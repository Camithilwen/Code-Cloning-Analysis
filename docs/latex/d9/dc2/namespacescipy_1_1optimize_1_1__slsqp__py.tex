\doxysection{scipy.\+optimize.\+\_\+slsqp\+\_\+py Namespace Reference}
\hypertarget{namespacescipy_1_1optimize_1_1__slsqp__py}{}\label{namespacescipy_1_1optimize_1_1__slsqp__py}\index{scipy.optimize.\_slsqp\_py@{scipy.optimize.\_slsqp\_py}}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__slsqp__py_ac0a6e1572b8d06543d043989d9918784}{approx\+\_\+jacobian}} (x, func, epsilon, \texorpdfstring{$\ast$}{*}args)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__slsqp__py_ae7d58c77d0d76879f12d53edc598f812}{fmin\+\_\+slsqp}} (func, x0, eqcons=(), f\+\_\+eqcons=None, ieqcons=(), f\+\_\+ieqcons=None, bounds=(), fprime=None, fprime\+\_\+eqcons=None, fprime\+\_\+ieqcons=None, args=(), iter=100, acc=1.\+0E-\/6, iprint=1, disp=None, full\+\_\+output=0, epsilon=\+\_\+epsilon, callback=None)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__slsqp__py_a5d1c67e62b8906dcf87875da8d7f1fae}{\+\_\+minimize\+\_\+slsqp}} (func, x0, args=(), jac=None, bounds=None, constraints=(), maxiter=100, ftol=1.\+0E-\/6, iprint=1, disp=False, eps=\+\_\+epsilon, callback=None, finite\+\_\+diff\+\_\+rel\+\_\+step=None, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}unknown\+\_\+options)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__slsqp__py_a92f13bb0a00d44922f362fd55873ba6a}{\+\_\+eval\+\_\+constraint}} (x, cons)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__slsqp__py_a6371fb433f2cf00121a6b6dc787a58c4}{\+\_\+eval\+\_\+con\+\_\+normals}} (x, cons, la, n, m, meq, mieq)
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
list \mbox{\hyperlink{namespacescipy_1_1optimize_1_1__slsqp__py_a402dd9750925637a548ca029a402d2d4}{\+\_\+\+\_\+all\+\_\+\+\_\+}} = \mbox{[}\textquotesingle{}\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__slsqp__py_ac0a6e1572b8d06543d043989d9918784}{approx\+\_\+jacobian}}\textquotesingle{}, \textquotesingle{}\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__slsqp__py_ae7d58c77d0d76879f12d53edc598f812}{fmin\+\_\+slsqp}}\textquotesingle{}\mbox{]}
\item 
str \mbox{\hyperlink{namespacescipy_1_1optimize_1_1__slsqp__py_ad07d1a32ec65aa7d3e90367d7b0b0d90}{\+\_\+\+\_\+docformat\+\_\+\+\_\+}} = "{}restructuredtext en"{}
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__slsqp__py_a424b5e0ec3553d15b51606f03a110743}{\+\_\+epsilon}} = sqrt(\mbox{\hyperlink{classnumpy_1_1core_1_1getlimits_1_1finfo}{finfo}}(float).eps)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\begin{DoxyVerb}This module implements the Sequential Least Squares Programming optimization
algorithm (SLSQP), originally developed by Dieter Kraft.
See http://www.netlib.org/toms/733

Functions
---------
.. autosummary::
   :toctree: generated/

    approx_jacobian
    fmin_slsqp
\end{DoxyVerb}
 

\doxysubsection{Function Documentation}
\Hypertarget{namespacescipy_1_1optimize_1_1__slsqp__py_a6371fb433f2cf00121a6b6dc787a58c4}\index{scipy.optimize.\_slsqp\_py@{scipy.optimize.\_slsqp\_py}!\_eval\_con\_normals@{\_eval\_con\_normals}}
\index{\_eval\_con\_normals@{\_eval\_con\_normals}!scipy.optimize.\_slsqp\_py@{scipy.optimize.\_slsqp\_py}}
\doxysubsubsection{\texorpdfstring{\_eval\_con\_normals()}{\_eval\_con\_normals()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__slsqp__py_a6371fb433f2cf00121a6b6dc787a58c4} 
scipy.\+optimize.\+\_\+slsqp\+\_\+py.\+\_\+eval\+\_\+con\+\_\+normals (\begin{DoxyParamCaption}\item[{}]{x}{, }\item[{}]{cons}{, }\item[{}]{la}{, }\item[{}]{n}{, }\item[{}]{m}{, }\item[{}]{meq}{, }\item[{}]{mieq}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{__slsqp__py_8py_source_l00483}{483}} of file \mbox{\hyperlink{__slsqp__py_8py_source}{\+\_\+slsqp\+\_\+py.\+py}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__slsqp__py_a92f13bb0a00d44922f362fd55873ba6a}\index{scipy.optimize.\_slsqp\_py@{scipy.optimize.\_slsqp\_py}!\_eval\_constraint@{\_eval\_constraint}}
\index{\_eval\_constraint@{\_eval\_constraint}!scipy.optimize.\_slsqp\_py@{scipy.optimize.\_slsqp\_py}}
\doxysubsubsection{\texorpdfstring{\_eval\_constraint()}{\_eval\_constraint()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__slsqp__py_a92f13bb0a00d44922f362fd55873ba6a} 
scipy.\+optimize.\+\_\+slsqp\+\_\+py.\+\_\+eval\+\_\+constraint (\begin{DoxyParamCaption}\item[{}]{x}{, }\item[{}]{cons}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{__slsqp__py_8py_source_l00464}{464}} of file \mbox{\hyperlink{__slsqp__py_8py_source}{\+\_\+slsqp\+\_\+py.\+py}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__slsqp__py_a5d1c67e62b8906dcf87875da8d7f1fae}\index{scipy.optimize.\_slsqp\_py@{scipy.optimize.\_slsqp\_py}!\_minimize\_slsqp@{\_minimize\_slsqp}}
\index{\_minimize\_slsqp@{\_minimize\_slsqp}!scipy.optimize.\_slsqp\_py@{scipy.optimize.\_slsqp\_py}}
\doxysubsubsection{\texorpdfstring{\_minimize\_slsqp()}{\_minimize\_slsqp()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__slsqp__py_a5d1c67e62b8906dcf87875da8d7f1fae} 
scipy.\+optimize.\+\_\+slsqp\+\_\+py.\+\_\+minimize\+\_\+slsqp (\begin{DoxyParamCaption}\item[{}]{func}{, }\item[{}]{x0}{, }\item[{}]{args}{ = {\ttfamily ()}, }\item[{}]{jac}{ = {\ttfamily None}, }\item[{}]{bounds}{ = {\ttfamily None}, }\item[{}]{constraints}{ = {\ttfamily ()}, }\item[{}]{maxiter}{ = {\ttfamily 100}, }\item[{}]{ftol}{ = {\ttfamily 1.0E-\/6}, }\item[{}]{iprint}{ = {\ttfamily 1}, }\item[{}]{disp}{ = {\ttfamily False}, }\item[{}]{eps}{ = {\ttfamily \+\_\+epsilon}, }\item[{}]{callback}{ = {\ttfamily None}, }\item[{}]{finite\+\_\+diff\+\_\+rel\+\_\+step}{ = {\ttfamily None}, }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{unknown\+\_\+options}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Minimize a scalar function of one or more variables using Sequential
Least Squares Programming (SLSQP).

Options
-------
ftol : float
    Precision goal for the value of f in the stopping criterion.
eps : float
    Step size used for numerical approximation of the Jacobian.
disp : bool
    Set to True to print convergence messages. If False,
    `verbosity` is ignored and set to 0.
maxiter : int
    Maximum number of iterations.
finite_diff_rel_step : None or array_like, optional
    If `jac in ['2-point', '3-point', 'cs']` the relative step size to
    use for numerical approximation of `jac`. The absolute step
    size is computed as ``h = rel_step * sign(x) * max(1, abs(x))``,
    possibly adjusted to fit into the bounds. For ``method='3-point'``
    the sign of `h` is ignored. If None (default) then step is selected
    automatically.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__slsqp__py_8py_source_l00214}{214}} of file \mbox{\hyperlink{__slsqp__py_8py_source}{\+\_\+slsqp\+\_\+py.\+py}}.



References \mbox{\hyperlink{__optimize_8py_source_l00297}{scipy.\+optimize.\+\_\+optimize.\+\_\+prepare\+\_\+scalar\+\_\+function()}}.



Referenced by \mbox{\hyperlink{__slsqp__py_8py_source_l00072}{fmin\+\_\+slsqp()}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__slsqp__py_ac0a6e1572b8d06543d043989d9918784}\index{scipy.optimize.\_slsqp\_py@{scipy.optimize.\_slsqp\_py}!approx\_jacobian@{approx\_jacobian}}
\index{approx\_jacobian@{approx\_jacobian}!scipy.optimize.\_slsqp\_py@{scipy.optimize.\_slsqp\_py}}
\doxysubsubsection{\texorpdfstring{approx\_jacobian()}{approx\_jacobian()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__slsqp__py_ac0a6e1572b8d06543d043989d9918784} 
scipy.\+optimize.\+\_\+slsqp\+\_\+py.\+approx\+\_\+jacobian (\begin{DoxyParamCaption}\item[{}]{x}{, }\item[{}]{func}{, }\item[{}]{epsilon}{, }\item[{\texorpdfstring{$\ast$}{*}}]{args}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Approximate the Jacobian matrix of a callable function.

Parameters
----------
x : array_like
    The state vector at which to compute the Jacobian matrix.
func : callable f(x,*args)
    The vector-valued function.
epsilon : float
    The perturbation used to determine the partial derivatives.
args : sequence
    Additional arguments passed to func.

Returns
-------
An array of dimensions ``(lenf, lenx)`` where ``lenf`` is the length
of the outputs of `func`, and ``lenx`` is the number of elements in
`x`.

Notes
-----
The approximation is done using forward differences.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__slsqp__py_8py_source_l00034}{34}} of file \mbox{\hyperlink{__slsqp__py_8py_source}{\+\_\+slsqp\+\_\+py.\+py}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__slsqp__py_ae7d58c77d0d76879f12d53edc598f812}\index{scipy.optimize.\_slsqp\_py@{scipy.optimize.\_slsqp\_py}!fmin\_slsqp@{fmin\_slsqp}}
\index{fmin\_slsqp@{fmin\_slsqp}!scipy.optimize.\_slsqp\_py@{scipy.optimize.\_slsqp\_py}}
\doxysubsubsection{\texorpdfstring{fmin\_slsqp()}{fmin\_slsqp()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__slsqp__py_ae7d58c77d0d76879f12d53edc598f812} 
scipy.\+optimize.\+\_\+slsqp\+\_\+py.\+fmin\+\_\+slsqp (\begin{DoxyParamCaption}\item[{}]{func}{, }\item[{}]{x0}{, }\item[{}]{eqcons}{ = {\ttfamily ()}, }\item[{}]{f\+\_\+eqcons}{ = {\ttfamily None}, }\item[{}]{ieqcons}{ = {\ttfamily ()}, }\item[{}]{f\+\_\+ieqcons}{ = {\ttfamily None}, }\item[{}]{bounds}{ = {\ttfamily ()}, }\item[{}]{fprime}{ = {\ttfamily None}, }\item[{}]{fprime\+\_\+eqcons}{ = {\ttfamily None}, }\item[{}]{fprime\+\_\+ieqcons}{ = {\ttfamily None}, }\item[{}]{args}{ = {\ttfamily ()}, }\item[{}]{iter}{ = {\ttfamily 100}, }\item[{}]{acc}{ = {\ttfamily 1.0E-\/6}, }\item[{}]{iprint}{ = {\ttfamily 1}, }\item[{}]{disp}{ = {\ttfamily None}, }\item[{}]{full\+\_\+output}{ = {\ttfamily 0}, }\item[{}]{epsilon}{ = {\ttfamily \+\_\+epsilon}, }\item[{}]{callback}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Minimize a function using Sequential Least Squares Programming

Python interface function for the SLSQP Optimization subroutine
originally implemented by Dieter Kraft.

Parameters
----------
func : callable f(x,*args)
    Objective function.  Must return a scalar.
x0 : 1-D ndarray of float
    Initial guess for the independent variable(s).
eqcons : list, optional
    A list of functions of length n such that
    eqcons[j](x,*args) == 0.0 in a successfully optimized
    problem.
f_eqcons : callable f(x,*args), optional
    Returns a 1-D array in which each element must equal 0.0 in a
    successfully optimized problem. If f_eqcons is specified,
    eqcons is ignored.
ieqcons : list, optional
    A list of functions of length n such that
    ieqcons[j](x,*args) >= 0.0 in a successfully optimized
    problem.
f_ieqcons : callable f(x,*args), optional
    Returns a 1-D ndarray in which each element must be greater or
    equal to 0.0 in a successfully optimized problem. If
    f_ieqcons is specified, ieqcons is ignored.
bounds : list, optional
    A list of tuples specifying the lower and upper bound
    for each independent variable [(xl0, xu0),(xl1, xu1),...]
    Infinite values will be interpreted as large floating values.
fprime : callable `f(x,*args)`, optional
    A function that evaluates the partial derivatives of func.
fprime_eqcons : callable `f(x,*args)`, optional
    A function of the form `f(x, *args)` that returns the m by n
    array of equality constraint normals. If not provided,
    the normals will be approximated. The array returned by
    fprime_eqcons should be sized as ( len(eqcons), len(x0) ).
fprime_ieqcons : callable `f(x,*args)`, optional
    A function of the form `f(x, *args)` that returns the m by n
    array of inequality constraint normals. If not provided,
    the normals will be approximated. The array returned by
    fprime_ieqcons should be sized as ( len(ieqcons), len(x0) ).
args : sequence, optional
    Additional arguments passed to func and fprime.
iter : int, optional
    The maximum number of iterations.
acc : float, optional
    Requested accuracy.
iprint : int, optional
    The verbosity of fmin_slsqp :

    * iprint <= 0 : Silent operation
    * iprint == 1 : Print summary upon completion (default)
    * iprint >= 2 : Print status of each iterate and summary
disp : int, optional
    Overrides the iprint interface (preferred).
full_output : bool, optional
    If False, return only the minimizer of func (default).
    Otherwise, output final objective function and summary
    information.
epsilon : float, optional
    The step size for finite-difference derivative estimates.
callback : callable, optional
    Called after each iteration, as ``callback(x)``, where ``x`` is the
    current parameter vector.

Returns
-------
out : ndarray of float
    The final minimizer of func.
fx : ndarray of float, if full_output is true
    The final value of the objective function.
its : int, if full_output is true
    The number of iterations.
imode : int, if full_output is true
    The exit mode from the optimizer (see below).
smode : string, if full_output is true
    Message describing the exit mode from the optimizer.

See also
--------
minimize: Interface to minimization algorithms for multivariate
    functions. See the 'SLSQP' `method` in particular.

Notes
-----
Exit modes are defined as follows ::

    -1 : Gradient evaluation required (g & a)
     0 : Optimization terminated successfully
     1 : Function evaluation required (f & c)
     2 : More equality constraints than independent variables
     3 : More than 3*n iterations in LSQ subproblem
     4 : Inequality constraints incompatible
     5 : Singular matrix E in LSQ subproblem
     6 : Singular matrix C in LSQ subproblem
     7 : Rank-deficient equality constraint subproblem HFTI
     8 : Positive directional derivative for linesearch
     9 : Iteration limit reached

Examples
--------
Examples are given :ref:`in the tutorial <tutorial-sqlsp>`.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__slsqp__py_8py_source_l00068}{68}} of file \mbox{\hyperlink{__slsqp__py_8py_source}{\+\_\+slsqp\+\_\+py.\+py}}.



References \mbox{\hyperlink{__slsqp__py_8py_source_l00218}{\+\_\+minimize\+\_\+slsqp()}}.



\doxysubsection{Variable Documentation}
\Hypertarget{namespacescipy_1_1optimize_1_1__slsqp__py_a402dd9750925637a548ca029a402d2d4}\index{scipy.optimize.\_slsqp\_py@{scipy.optimize.\_slsqp\_py}!\_\_all\_\_@{\_\_all\_\_}}
\index{\_\_all\_\_@{\_\_all\_\_}!scipy.optimize.\_slsqp\_py@{scipy.optimize.\_slsqp\_py}}
\doxysubsubsection{\texorpdfstring{\_\_all\_\_}{\_\_all\_\_}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__slsqp__py_a402dd9750925637a548ca029a402d2d4} 
list scipy.\+optimize.\+\_\+slsqp\+\_\+py.\+\_\+\+\_\+all\+\_\+\+\_\+ = \mbox{[}\textquotesingle{}\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__slsqp__py_ac0a6e1572b8d06543d043989d9918784}{approx\+\_\+jacobian}}\textquotesingle{}, \textquotesingle{}\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__slsqp__py_ae7d58c77d0d76879f12d53edc598f812}{fmin\+\_\+slsqp}}\textquotesingle{}\mbox{]}\hspace{0.3cm}{\ttfamily [private]}}



Definition at line \mbox{\hyperlink{__slsqp__py_8py_source_l00016}{16}} of file \mbox{\hyperlink{__slsqp__py_8py_source}{\+\_\+slsqp\+\_\+py.\+py}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__slsqp__py_ad07d1a32ec65aa7d3e90367d7b0b0d90}\index{scipy.optimize.\_slsqp\_py@{scipy.optimize.\_slsqp\_py}!\_\_docformat\_\_@{\_\_docformat\_\_}}
\index{\_\_docformat\_\_@{\_\_docformat\_\_}!scipy.optimize.\_slsqp\_py@{scipy.optimize.\_slsqp\_py}}
\doxysubsubsection{\texorpdfstring{\_\_docformat\_\_}{\_\_docformat\_\_}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__slsqp__py_ad07d1a32ec65aa7d3e90367d7b0b0d90} 
str scipy.\+optimize.\+\_\+slsqp\+\_\+py.\+\_\+\+\_\+docformat\+\_\+\+\_\+ = "{}restructuredtext en"{}\hspace{0.3cm}{\ttfamily [private]}}



Definition at line \mbox{\hyperlink{__slsqp__py_8py_source_l00029}{29}} of file \mbox{\hyperlink{__slsqp__py_8py_source}{\+\_\+slsqp\+\_\+py.\+py}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__slsqp__py_a424b5e0ec3553d15b51606f03a110743}\index{scipy.optimize.\_slsqp\_py@{scipy.optimize.\_slsqp\_py}!\_epsilon@{\_epsilon}}
\index{\_epsilon@{\_epsilon}!scipy.optimize.\_slsqp\_py@{scipy.optimize.\_slsqp\_py}}
\doxysubsubsection{\texorpdfstring{\_epsilon}{\_epsilon}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__slsqp__py_a424b5e0ec3553d15b51606f03a110743} 
scipy.\+optimize.\+\_\+slsqp\+\_\+py.\+\_\+epsilon = sqrt(\mbox{\hyperlink{classnumpy_1_1core_1_1getlimits_1_1finfo}{finfo}}(float).eps)\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{__slsqp__py_8py_source_l00031}{31}} of file \mbox{\hyperlink{__slsqp__py_8py_source}{\+\_\+slsqp\+\_\+py.\+py}}.

