\doxysection{scipy.\+interpolate.\+\_\+rgi Namespace Reference}
\hypertarget{namespacescipy_1_1interpolate_1_1__rgi}{}\label{namespacescipy_1_1interpolate_1_1__rgi}\index{scipy.interpolate.\_rgi@{scipy.interpolate.\_rgi}}
\doxysubsubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classscipy_1_1interpolate_1_1__rgi_1_1RegularGridInterpolator}{Regular\+Grid\+Interpolator}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacescipy_1_1interpolate_1_1__rgi_ad94dbdc1ad2bf7cc2c34bd54f13b38b5}{\+\_\+check\+\_\+points}} (points)
\item 
\mbox{\hyperlink{namespacescipy_1_1interpolate_1_1__rgi_a87b336f69b61630f2ebcaae2a8579477}{\+\_\+check\+\_\+dimensionality}} (points, values)
\item 
\mbox{\hyperlink{namespacescipy_1_1interpolate_1_1__rgi_a31c4a916c1a0a3b0e6b3453b3a15d4c8}{interpn}} (points, values, xi, method="{}linear"{}, bounds\+\_\+error=\mbox{\hyperlink{classTrue}{True}}, fill\+\_\+value=np.\+nan)
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
list \mbox{\hyperlink{namespacescipy_1_1interpolate_1_1__rgi_a0be4fc9c01a7c6d148140a720424a09d}{\+\_\+\+\_\+all\+\_\+\+\_\+}} = \mbox{[}\textquotesingle{}\mbox{\hyperlink{classscipy_1_1interpolate_1_1__rgi_1_1RegularGridInterpolator}{Regular\+Grid\+Interpolator}}\textquotesingle{}, \textquotesingle{}\mbox{\hyperlink{namespacescipy_1_1interpolate_1_1__rgi_a31c4a916c1a0a3b0e6b3453b3a15d4c8}{interpn}}\textquotesingle{}\mbox{]}
\end{DoxyCompactItemize}


\doxysubsection{Function Documentation}
\Hypertarget{namespacescipy_1_1interpolate_1_1__rgi_a87b336f69b61630f2ebcaae2a8579477}\index{scipy.interpolate.\_rgi@{scipy.interpolate.\_rgi}!\_check\_dimensionality@{\_check\_dimensionality}}
\index{\_check\_dimensionality@{\_check\_dimensionality}!scipy.interpolate.\_rgi@{scipy.interpolate.\_rgi}}
\doxysubsubsection{\texorpdfstring{\_check\_dimensionality()}{\_check\_dimensionality()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1interpolate_1_1__rgi_a87b336f69b61630f2ebcaae2a8579477} 
scipy.\+interpolate.\+\_\+rgi.\+\_\+check\+\_\+dimensionality (\begin{DoxyParamCaption}\item[{}]{points}{, }\item[{}]{values}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{__rgi_8py_source_l00036}{36}} of file \mbox{\hyperlink{__rgi_8py_source}{\+\_\+rgi.\+py}}.

\Hypertarget{namespacescipy_1_1interpolate_1_1__rgi_ad94dbdc1ad2bf7cc2c34bd54f13b38b5}\index{scipy.interpolate.\_rgi@{scipy.interpolate.\_rgi}!\_check\_points@{\_check\_points}}
\index{\_check\_points@{\_check\_points}!scipy.interpolate.\_rgi@{scipy.interpolate.\_rgi}}
\doxysubsubsection{\texorpdfstring{\_check\_points()}{\_check\_points()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1interpolate_1_1__rgi_ad94dbdc1ad2bf7cc2c34bd54f13b38b5} 
scipy.\+interpolate.\+\_\+rgi.\+\_\+check\+\_\+points (\begin{DoxyParamCaption}\item[{}]{points}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{__rgi_8py_source_l00014}{14}} of file \mbox{\hyperlink{__rgi_8py_source}{\+\_\+rgi.\+py}}.

\Hypertarget{namespacescipy_1_1interpolate_1_1__rgi_a31c4a916c1a0a3b0e6b3453b3a15d4c8}\index{scipy.interpolate.\_rgi@{scipy.interpolate.\_rgi}!interpn@{interpn}}
\index{interpn@{interpn}!scipy.interpolate.\_rgi@{scipy.interpolate.\_rgi}}
\doxysubsubsection{\texorpdfstring{interpn()}{interpn()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1interpolate_1_1__rgi_a31c4a916c1a0a3b0e6b3453b3a15d4c8} 
scipy.\+interpolate.\+\_\+rgi.\+interpn (\begin{DoxyParamCaption}\item[{}]{points}{, }\item[{}]{values}{, }\item[{}]{xi}{, }\item[{}]{method}{ = {\ttfamily "{}linear"{}}, }\item[{}]{bounds\+\_\+error}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}, }\item[{}]{fill\+\_\+value}{ = {\ttfamily np.nan}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Multidimensional interpolation on regular or rectilinear grids.

Strictly speaking, not all regular grids are supported - this function
works on *rectilinear* grids, that is, a rectangular grid with even or
uneven spacing.

Parameters
----------
points : tuple of ndarray of float, with shapes (m1, ), ..., (mn, )
    The points defining the regular grid in n dimensions. The points in
    each dimension (i.e. every elements of the points tuple) must be
    strictly ascending or descending.

values : array_like, shape (m1, ..., mn, ...)
    The data on the regular grid in n dimensions. Complex data can be
    acceptable.

xi : ndarray of shape (..., ndim)
    The coordinates to sample the gridded data at

method : str, optional
    The method of interpolation to perform. Supported are "linear",
    "nearest", "slinear", "cubic", "quintic", "pchip", and "splinef2d".
    "splinef2d" is only supported for 2-dimensional data.

bounds_error : bool, optional
    If True, when interpolated values are requested outside of the
    domain of the input data, a ValueError is raised.
    If False, then `fill_value` is used.

fill_value : number, optional
    If provided, the value to use for points outside of the
    interpolation domain. If None, values outside
    the domain are extrapolated.  Extrapolation is not supported by method
    "splinef2d".

Returns
-------
values_x : ndarray, shape xi.shape[:-1] + values.shape[ndim:]
    Interpolated values at `xi`. See notes for behaviour when
    ``xi.ndim == 1``.

See Also
--------
NearestNDInterpolator : Nearest neighbor interpolation on unstructured
                        data in N dimensions
LinearNDInterpolator : Piecewise linear interpolant on unstructured data
                       in N dimensions
RegularGridInterpolator : interpolation on a regular or rectilinear grid
                          in arbitrary dimensions (`interpn` wraps this
                          class).
RectBivariateSpline : Bivariate spline approximation over a rectangular mesh
scipy.ndimage.map_coordinates : interpolation on grids with equal spacing
                                (suitable for e.g., N-D image resampling)

Notes
-----

.. versionadded:: 0.14

In the case that ``xi.ndim == 1`` a new axis is inserted into
the 0 position of the returned array, values_x, so its shape is
instead ``(1,) + values.shape[ndim:]``.

If the input data is such that input dimensions have incommensurate
units and differ by many orders of magnitude, the interpolant may have
numerical artifacts. Consider rescaling the data before interpolation.

Examples
--------
Evaluate a simple example function on the points of a regular 3-D grid:

>>> import numpy as np
>>> from scipy.interpolate import interpn
>>> def value_func_3d(x, y, z):
...     return 2 * x + 3 * y - z
>>> x = np.linspace(0, 4, 5)
>>> y = np.linspace(0, 5, 6)
>>> z = np.linspace(0, 6, 7)
>>> points = (x, y, z)
>>> values = value_func_3d(*np.meshgrid(*points, indexing='ij'))

Evaluate the interpolating function at a point

>>> point = np.array([2.21, 3.12, 1.15])
>>> print(interpn(points, values, point))
[12.63]
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__rgi_8py_source_l00516}{516}} of file \mbox{\hyperlink{__rgi_8py_source}{\+\_\+rgi.\+py}}.



\doxysubsection{Variable Documentation}
\Hypertarget{namespacescipy_1_1interpolate_1_1__rgi_a0be4fc9c01a7c6d148140a720424a09d}\index{scipy.interpolate.\_rgi@{scipy.interpolate.\_rgi}!\_\_all\_\_@{\_\_all\_\_}}
\index{\_\_all\_\_@{\_\_all\_\_}!scipy.interpolate.\_rgi@{scipy.interpolate.\_rgi}}
\doxysubsubsection{\texorpdfstring{\_\_all\_\_}{\_\_all\_\_}}
{\footnotesize\ttfamily \label{namespacescipy_1_1interpolate_1_1__rgi_a0be4fc9c01a7c6d148140a720424a09d} 
list scipy.\+interpolate.\+\_\+rgi.\+\_\+\+\_\+all\+\_\+\+\_\+ = \mbox{[}\textquotesingle{}\mbox{\hyperlink{classscipy_1_1interpolate_1_1__rgi_1_1RegularGridInterpolator}{Regular\+Grid\+Interpolator}}\textquotesingle{}, \textquotesingle{}\mbox{\hyperlink{namespacescipy_1_1interpolate_1_1__rgi_a31c4a916c1a0a3b0e6b3453b3a15d4c8}{interpn}}\textquotesingle{}\mbox{]}\hspace{0.3cm}{\ttfamily [private]}}



Definition at line \mbox{\hyperlink{__rgi_8py_source_l00001}{1}} of file \mbox{\hyperlink{__rgi_8py_source}{\+\_\+rgi.\+py}}.

