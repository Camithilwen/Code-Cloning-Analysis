\doxysection{pandas.\+io.\+sql Namespace Reference}
\hypertarget{namespacepandas_1_1io_1_1sql}{}\label{namespacepandas_1_1io_1_1sql}\index{pandas.io.sql@{pandas.io.sql}}
\doxysubsubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classpandas_1_1io_1_1sql_1_1ADBCDatabase}{ADBCDatabase}}
\item 
class \mbox{\hyperlink{classpandas_1_1io_1_1sql_1_1BaseEngine}{Base\+Engine}}
\item 
class \mbox{\hyperlink{classpandas_1_1io_1_1sql_1_1PandasSQL}{Pandas\+SQL}}
\item 
class \mbox{\hyperlink{classpandas_1_1io_1_1sql_1_1SQLAlchemyEngine}{SQLAlchemy\+Engine}}
\item 
class \mbox{\hyperlink{classpandas_1_1io_1_1sql_1_1SQLDatabase}{SQLDatabase}}
\item 
class \mbox{\hyperlink{classpandas_1_1io_1_1sql_1_1SQLiteDatabase}{SQLite\+Database}}
\item 
class \mbox{\hyperlink{classpandas_1_1io_1_1sql_1_1SQLiteTable}{SQLite\+Table}}
\item 
class \mbox{\hyperlink{classpandas_1_1io_1_1sql_1_1SQLTable}{SQLTable}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacepandas_1_1io_1_1sql_aa43da01ce3b7a8e882bab2bf30f1e90e}{\+\_\+process\+\_\+parse\+\_\+dates\+\_\+argument}} (parse\+\_\+dates)
\item 
\mbox{\hyperlink{namespacepandas_1_1io_1_1sql_a9f6dca033621a3d44addce8dd8bbe532}{\+\_\+handle\+\_\+date\+\_\+column}} (col, bool utc=False, str\texorpdfstring{$\vert$}{|}dict\mbox{[}str, Any\mbox{]}\texorpdfstring{$\vert$}{|}None format=None)
\item 
\mbox{\hyperlink{namespacepandas_1_1io_1_1sql_a3cb6491889e8ad545988d2e392fcd5e8}{\+\_\+parse\+\_\+date\+\_\+columns}} (data\+\_\+frame, parse\+\_\+dates)
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1frame_1_1DataFrame}{Data\+Frame}} \mbox{\hyperlink{namespacepandas_1_1io_1_1sql_a18c1348c9c48a194e48a726b040cc277}{\+\_\+convert\+\_\+arrays\+\_\+to\+\_\+dataframe}} (data, columns, bool coerce\+\_\+float=\mbox{\hyperlink{classTrue}{True}}, Dtype\+Backend\texorpdfstring{$\vert$}{|}Literal\mbox{[}"{}numpy"{}\mbox{]} dtype\+\_\+backend="{}numpy"{})
\item 
\mbox{\hyperlink{namespacepandas_1_1io_1_1sql_a454ec3aabdebc044c2822f591dc4736b}{\+\_\+wrap\+\_\+result}} (data, columns, index\+\_\+col=None, bool coerce\+\_\+float=\mbox{\hyperlink{classTrue}{True}}, parse\+\_\+dates=None, Dtype\+Arg\texorpdfstring{$\vert$}{|}None dtype=None, Dtype\+Backend\texorpdfstring{$\vert$}{|}Literal\mbox{[}"{}numpy"{}\mbox{]} dtype\+\_\+backend="{}numpy"{})
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1frame_1_1DataFrame}{Data\+Frame}} \mbox{\hyperlink{namespacepandas_1_1io_1_1sql_a5dfd74a5fb48ffd2692108f350cccabf}{\+\_\+wrap\+\_\+result\+\_\+adbc}} (\mbox{\hyperlink{classpandas_1_1core_1_1frame_1_1DataFrame}{Data\+Frame}} df, \texorpdfstring{$\ast$}{*}, index\+\_\+col=None, parse\+\_\+dates=None, Dtype\+Arg\texorpdfstring{$\vert$}{|}None dtype=None, Dtype\+Backend\texorpdfstring{$\vert$}{|}Literal\mbox{[}"{}numpy"{}\mbox{]} dtype\+\_\+backend="{}numpy"{})
\item 
\mbox{\hyperlink{namespacepandas_1_1io_1_1sql_aeba42e94abda0c7396e30e5192e7d651}{execute}} (sql, con, params=None)
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1frame_1_1DataFrame}{Data\+Frame}} \mbox{\hyperlink{namespacepandas_1_1io_1_1sql_a734c0d227bd68ba064bf2f048e10a8f9}{read\+\_\+sql\+\_\+table}} (str table\+\_\+name, con, schema=..., str\texorpdfstring{$\vert$}{|}list\mbox{[}str\mbox{]}\texorpdfstring{$\vert$}{|}None index\+\_\+col=..., coerce\+\_\+float=..., list\mbox{[}str\mbox{]}\texorpdfstring{$\vert$}{|}dict\mbox{[}str, str\mbox{]}\texorpdfstring{$\vert$}{|}None parse\+\_\+dates=..., list\mbox{[}str\mbox{]}\texorpdfstring{$\vert$}{|}None columns=..., None chunksize=..., Dtype\+Backend\texorpdfstring{$\vert$}{|}lib.\+No\+Default dtype\+\_\+backend=...)
\item 
Iterator\mbox{[}\mbox{\hyperlink{classpandas_1_1core_1_1frame_1_1DataFrame}{Data\+Frame}}\mbox{]} \mbox{\hyperlink{namespacepandas_1_1io_1_1sql_a331746382c2a4f1a3fb2a9aa480c9956}{read\+\_\+sql\+\_\+table}} (str table\+\_\+name, con, schema=..., str\texorpdfstring{$\vert$}{|}list\mbox{[}str\mbox{]}\texorpdfstring{$\vert$}{|}None index\+\_\+col=..., coerce\+\_\+float=..., list\mbox{[}str\mbox{]}\texorpdfstring{$\vert$}{|}dict\mbox{[}str, str\mbox{]}\texorpdfstring{$\vert$}{|}None parse\+\_\+dates=..., list\mbox{[}str\mbox{]}\texorpdfstring{$\vert$}{|}None columns=..., int chunksize=..., Dtype\+Backend\texorpdfstring{$\vert$}{|}lib.\+No\+Default dtype\+\_\+backend=...)
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1frame_1_1DataFrame}{Data\+Frame}}\texorpdfstring{$\vert$}{|}Iterator\mbox{[}\mbox{\hyperlink{classpandas_1_1core_1_1frame_1_1DataFrame}{Data\+Frame}}\mbox{]} \mbox{\hyperlink{namespacepandas_1_1io_1_1sql_a97f645358aefa6bf91e644c5a38882b9}{read\+\_\+sql\+\_\+table}} (str table\+\_\+name, con, str\texorpdfstring{$\vert$}{|}None schema=None, str\texorpdfstring{$\vert$}{|}list\mbox{[}str\mbox{]}\texorpdfstring{$\vert$}{|}None index\+\_\+col=None, bool coerce\+\_\+float=\mbox{\hyperlink{classTrue}{True}}, list\mbox{[}str\mbox{]}\texorpdfstring{$\vert$}{|}dict\mbox{[}str, str\mbox{]}\texorpdfstring{$\vert$}{|}None parse\+\_\+dates=None, list\mbox{[}str\mbox{]}\texorpdfstring{$\vert$}{|}None columns=None, int\texorpdfstring{$\vert$}{|}None chunksize=None, Dtype\+Backend\texorpdfstring{$\vert$}{|}lib.\+No\+Default dtype\+\_\+backend=lib.\+no\+\_\+default)
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1frame_1_1DataFrame}{Data\+Frame}} \mbox{\hyperlink{namespacepandas_1_1io_1_1sql_a591da2cb6c8e6b1abf5d9a49361a019b}{read\+\_\+sql\+\_\+query}} (sql, con, str\texorpdfstring{$\vert$}{|}list\mbox{[}str\mbox{]}\texorpdfstring{$\vert$}{|}None index\+\_\+col=..., coerce\+\_\+float=..., list\mbox{[}Any\mbox{]}\texorpdfstring{$\vert$}{|}Mapping\mbox{[}str, Any\mbox{]}\texorpdfstring{$\vert$}{|}None params=..., list\mbox{[}str\mbox{]}\texorpdfstring{$\vert$}{|}dict\mbox{[}str, str\mbox{]}\texorpdfstring{$\vert$}{|}None parse\+\_\+dates=..., None chunksize=..., Dtype\+Arg\texorpdfstring{$\vert$}{|}None dtype=..., Dtype\+Backend\texorpdfstring{$\vert$}{|}lib.\+No\+Default dtype\+\_\+backend=...)
\item 
Iterator\mbox{[}\mbox{\hyperlink{classpandas_1_1core_1_1frame_1_1DataFrame}{Data\+Frame}}\mbox{]} \mbox{\hyperlink{namespacepandas_1_1io_1_1sql_a2f7467cc4cb1527b9261f0b415e5a7e6}{read\+\_\+sql\+\_\+query}} (sql, con, str\texorpdfstring{$\vert$}{|}list\mbox{[}str\mbox{]}\texorpdfstring{$\vert$}{|}None index\+\_\+col=..., coerce\+\_\+float=..., list\mbox{[}Any\mbox{]}\texorpdfstring{$\vert$}{|}Mapping\mbox{[}str, Any\mbox{]}\texorpdfstring{$\vert$}{|}None params=..., list\mbox{[}str\mbox{]}\texorpdfstring{$\vert$}{|}dict\mbox{[}str, str\mbox{]}\texorpdfstring{$\vert$}{|}None parse\+\_\+dates=..., int chunksize=..., Dtype\+Arg\texorpdfstring{$\vert$}{|}None dtype=..., Dtype\+Backend\texorpdfstring{$\vert$}{|}lib.\+No\+Default dtype\+\_\+backend=...)
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1frame_1_1DataFrame}{Data\+Frame}}\texorpdfstring{$\vert$}{|}Iterator\mbox{[}\mbox{\hyperlink{classpandas_1_1core_1_1frame_1_1DataFrame}{Data\+Frame}}\mbox{]} \mbox{\hyperlink{namespacepandas_1_1io_1_1sql_ade90c889afd215496f48f01f07c24132}{read\+\_\+sql\+\_\+query}} (sql, con, str\texorpdfstring{$\vert$}{|}list\mbox{[}str\mbox{]}\texorpdfstring{$\vert$}{|}None index\+\_\+col=None, bool coerce\+\_\+float=\mbox{\hyperlink{classTrue}{True}}, list\mbox{[}Any\mbox{]}\texorpdfstring{$\vert$}{|}Mapping\mbox{[}str, Any\mbox{]}\texorpdfstring{$\vert$}{|}None params=None, list\mbox{[}str\mbox{]}\texorpdfstring{$\vert$}{|}dict\mbox{[}str, str\mbox{]}\texorpdfstring{$\vert$}{|}None parse\+\_\+dates=None, int\texorpdfstring{$\vert$}{|}None chunksize=None, Dtype\+Arg\texorpdfstring{$\vert$}{|}None dtype=None, Dtype\+Backend\texorpdfstring{$\vert$}{|}lib.\+No\+Default dtype\+\_\+backend=lib.\+no\+\_\+default)
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1frame_1_1DataFrame}{Data\+Frame}} \mbox{\hyperlink{namespacepandas_1_1io_1_1sql_a585f91f9496e6e380efb1cd31e3eb7a9}{read\+\_\+sql}} (sql, con, str\texorpdfstring{$\vert$}{|}list\mbox{[}str\mbox{]}\texorpdfstring{$\vert$}{|}None index\+\_\+col=..., coerce\+\_\+float=..., params=..., parse\+\_\+dates=..., list\mbox{[}str\mbox{]} columns=..., None chunksize=..., Dtype\+Backend\texorpdfstring{$\vert$}{|}lib.\+No\+Default dtype\+\_\+backend=..., Dtype\+Arg\texorpdfstring{$\vert$}{|}None dtype=None)
\item 
Iterator\mbox{[}\mbox{\hyperlink{classpandas_1_1core_1_1frame_1_1DataFrame}{Data\+Frame}}\mbox{]} \mbox{\hyperlink{namespacepandas_1_1io_1_1sql_a1256ddc25ee6b14cd44e74ac3948949f}{read\+\_\+sql}} (sql, con, str\texorpdfstring{$\vert$}{|}list\mbox{[}str\mbox{]}\texorpdfstring{$\vert$}{|}None index\+\_\+col=..., coerce\+\_\+float=..., params=..., parse\+\_\+dates=..., list\mbox{[}str\mbox{]} columns=..., int chunksize=..., Dtype\+Backend\texorpdfstring{$\vert$}{|}lib.\+No\+Default dtype\+\_\+backend=..., Dtype\+Arg\texorpdfstring{$\vert$}{|}None dtype=None)
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1frame_1_1DataFrame}{Data\+Frame}}\texorpdfstring{$\vert$}{|}Iterator\mbox{[}\mbox{\hyperlink{classpandas_1_1core_1_1frame_1_1DataFrame}{Data\+Frame}}\mbox{]} \mbox{\hyperlink{namespacepandas_1_1io_1_1sql_a7f38cde8306cf4122aaa9f62adcd5cda}{read\+\_\+sql}} (sql, con, str\texorpdfstring{$\vert$}{|}list\mbox{[}str\mbox{]}\texorpdfstring{$\vert$}{|}None index\+\_\+col=None, bool coerce\+\_\+float=\mbox{\hyperlink{classTrue}{True}}, params=None, parse\+\_\+dates=None, list\mbox{[}str\mbox{]}\texorpdfstring{$\vert$}{|}None columns=None, int\texorpdfstring{$\vert$}{|}None chunksize=None, Dtype\+Backend\texorpdfstring{$\vert$}{|}lib.\+No\+Default dtype\+\_\+backend=lib.\+no\+\_\+default, Dtype\+Arg\texorpdfstring{$\vert$}{|}None dtype=None)
\item 
int\texorpdfstring{$\vert$}{|}None \mbox{\hyperlink{namespacepandas_1_1io_1_1sql_a84834f87b2fbd018a2e094944db67423}{to\+\_\+sql}} (frame, str name, con, str\texorpdfstring{$\vert$}{|}None schema=None, Literal\mbox{[}"{}fail"{}, "{}replace"{}, "{}append"{}\mbox{]} if\+\_\+exists="{}fail"{}, bool index=\mbox{\hyperlink{classTrue}{True}}, Index\+Label\texorpdfstring{$\vert$}{|}None index\+\_\+label=None, int\texorpdfstring{$\vert$}{|}None chunksize=None, Dtype\+Arg\texorpdfstring{$\vert$}{|}None dtype=None, Literal\mbox{[}"{}multi"{}\mbox{]}\texorpdfstring{$\vert$}{|}Callable\texorpdfstring{$\vert$}{|}None method=None, str engine="{}auto"{}, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}engine\+\_\+kwargs)
\item 
bool \mbox{\hyperlink{namespacepandas_1_1io_1_1sql_a481d992f90af2849fdc44ae80127e13f}{has\+\_\+table}} (str table\+\_\+name, con, str\texorpdfstring{$\vert$}{|}None schema=None)
\item 
\mbox{\hyperlink{classpandas_1_1io_1_1sql_1_1PandasSQL}{Pandas\+SQL}} \mbox{\hyperlink{namespacepandas_1_1io_1_1sql_a0978df25c1f15b46844773dc61ace4cf}{pandas\+SQL\+\_\+builder}} (con, str\texorpdfstring{$\vert$}{|}None schema=None, bool need\+\_\+transaction=False)
\item 
\mbox{\hyperlink{classpandas_1_1io_1_1sql_1_1BaseEngine}{Base\+Engine}} \mbox{\hyperlink{namespacepandas_1_1io_1_1sql_a215b5bf10d7ec240725cb0439f6d8ad0}{get\+\_\+engine}} (str engine)
\item 
\mbox{\hyperlink{namespacepandas_1_1io_1_1sql_ac7bdd2e4c3f192154cb9b65955cee795}{\+\_\+get\+\_\+unicode\+\_\+name}} (object name)
\item 
\mbox{\hyperlink{namespacepandas_1_1io_1_1sql_a2fcb9c26692320754f6991e1f2d54014}{\+\_\+get\+\_\+valid\+\_\+sqlite\+\_\+name}} (object name)
\item 
str \mbox{\hyperlink{namespacepandas_1_1io_1_1sql_a0244b565d56f904bc774fcd553cc9bf6}{get\+\_\+schema}} (frame, str name, keys=None, con=None, Dtype\+Arg\texorpdfstring{$\vert$}{|}None dtype=None, str\texorpdfstring{$\vert$}{|}None schema=None)
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
bool \mbox{\hyperlink{namespacepandas_1_1io_1_1sql_aa7cfd1d87ee3e84467f1437462970a29}{table\+\_\+exists}} = \mbox{\hyperlink{namespacepandas_1_1io_1_1sql_a481d992f90af2849fdc44ae80127e13f}{has\+\_\+table}}
\item 
dict \mbox{\hyperlink{namespacepandas_1_1io_1_1sql_a6fe412bc2640a94db1e0989b222767ed}{\+\_\+\+SQL\+\_\+\+TYPES}}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\begin{DoxyVerb}Collection of query wrappers / abstractions to both facilitate data
retrieval and to reduce dependency on DB-specific API.
\end{DoxyVerb}
 

\doxysubsection{Function Documentation}
\Hypertarget{namespacepandas_1_1io_1_1sql_a18c1348c9c48a194e48a726b040cc277}\index{pandas.io.sql@{pandas.io.sql}!\_convert\_arrays\_to\_dataframe@{\_convert\_arrays\_to\_dataframe}}
\index{\_convert\_arrays\_to\_dataframe@{\_convert\_arrays\_to\_dataframe}!pandas.io.sql@{pandas.io.sql}}
\doxysubsubsection{\texorpdfstring{\_convert\_arrays\_to\_dataframe()}{\_convert\_arrays\_to\_dataframe()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1io_1_1sql_a18c1348c9c48a194e48a726b040cc277} 
 \mbox{\hyperlink{classpandas_1_1core_1_1frame_1_1DataFrame}{Data\+Frame}} pandas.\+io.\+sql.\+\_\+convert\+\_\+arrays\+\_\+to\+\_\+dataframe (\begin{DoxyParamCaption}\item[{}]{data}{, }\item[{}]{columns}{, }\item[{bool }]{coerce\+\_\+float}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}, }\item[{Dtype\+Backend \texorpdfstring{$\vert$}{|} Literal\mbox{[}"{}numpy"{}\mbox{]} }]{dtype\+\_\+backend}{ = {\ttfamily "{}numpy"{}}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{sql_8py_source_l00162}{162}} of file \mbox{\hyperlink{sql_8py_source}{sql.\+py}}.

\Hypertarget{namespacepandas_1_1io_1_1sql_ac7bdd2e4c3f192154cb9b65955cee795}\index{pandas.io.sql@{pandas.io.sql}!\_get\_unicode\_name@{\_get\_unicode\_name}}
\index{\_get\_unicode\_name@{\_get\_unicode\_name}!pandas.io.sql@{pandas.io.sql}}
\doxysubsubsection{\texorpdfstring{\_get\_unicode\_name()}{\_get\_unicode\_name()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1io_1_1sql_ac7bdd2e4c3f192154cb9b65955cee795} 
pandas.\+io.\+sql.\+\_\+get\+\_\+unicode\+\_\+name (\begin{DoxyParamCaption}\item[{object}]{name}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{sql_8py_source_l02442}{2442}} of file \mbox{\hyperlink{sql_8py_source}{sql.\+py}}.

\Hypertarget{namespacepandas_1_1io_1_1sql_a2fcb9c26692320754f6991e1f2d54014}\index{pandas.io.sql@{pandas.io.sql}!\_get\_valid\_sqlite\_name@{\_get\_valid\_sqlite\_name}}
\index{\_get\_valid\_sqlite\_name@{\_get\_valid\_sqlite\_name}!pandas.io.sql@{pandas.io.sql}}
\doxysubsubsection{\texorpdfstring{\_get\_valid\_sqlite\_name()}{\_get\_valid\_sqlite\_name()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1io_1_1sql_a2fcb9c26692320754f6991e1f2d54014} 
pandas.\+io.\+sql.\+\_\+get\+\_\+valid\+\_\+sqlite\+\_\+name (\begin{DoxyParamCaption}\item[{object}]{name}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{sql_8py_source_l02450}{2450}} of file \mbox{\hyperlink{sql_8py_source}{sql.\+py}}.

\Hypertarget{namespacepandas_1_1io_1_1sql_a9f6dca033621a3d44addce8dd8bbe532}\index{pandas.io.sql@{pandas.io.sql}!\_handle\_date\_column@{\_handle\_date\_column}}
\index{\_handle\_date\_column@{\_handle\_date\_column}!pandas.io.sql@{pandas.io.sql}}
\doxysubsubsection{\texorpdfstring{\_handle\_date\_column()}{\_handle\_date\_column()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1io_1_1sql_a9f6dca033621a3d44addce8dd8bbe532} 
pandas.\+io.\+sql.\+\_\+handle\+\_\+date\+\_\+column (\begin{DoxyParamCaption}\item[{}]{col}{, }\item[{bool }]{utc}{ = {\ttfamily False}, }\item[{str \texorpdfstring{$\vert$}{|} dict\mbox{[}str, Any\mbox{]} \texorpdfstring{$\vert$}{|} None }]{format}{ = {\ttfamily None}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{sql_8py_source_l00107}{107}} of file \mbox{\hyperlink{sql_8py_source}{sql.\+py}}.

\Hypertarget{namespacepandas_1_1io_1_1sql_a3cb6491889e8ad545988d2e392fcd5e8}\index{pandas.io.sql@{pandas.io.sql}!\_parse\_date\_columns@{\_parse\_date\_columns}}
\index{\_parse\_date\_columns@{\_parse\_date\_columns}!pandas.io.sql@{pandas.io.sql}}
\doxysubsubsection{\texorpdfstring{\_parse\_date\_columns()}{\_parse\_date\_columns()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1io_1_1sql_a3cb6491889e8ad545988d2e392fcd5e8} 
pandas.\+io.\+sql.\+\_\+parse\+\_\+date\+\_\+columns (\begin{DoxyParamCaption}\item[{}]{data\+\_\+frame}{, }\item[{}]{parse\+\_\+dates}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Force non-datetime columns to be read as such.
Supports both string formatted and integer timestamp columns.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{sql_8py_source_l00141}{141}} of file \mbox{\hyperlink{sql_8py_source}{sql.\+py}}.



References \mbox{\hyperlink{sql_8py_source_l00096}{\+\_\+process\+\_\+parse\+\_\+dates\+\_\+argument()}}.



Referenced by \mbox{\hyperlink{sql_8py_source_l00204}{\+\_\+wrap\+\_\+result()}}, and \mbox{\hyperlink{sql_8py_source_l00226}{\+\_\+wrap\+\_\+result\+\_\+adbc()}}.

\Hypertarget{namespacepandas_1_1io_1_1sql_aa43da01ce3b7a8e882bab2bf30f1e90e}\index{pandas.io.sql@{pandas.io.sql}!\_process\_parse\_dates\_argument@{\_process\_parse\_dates\_argument}}
\index{\_process\_parse\_dates\_argument@{\_process\_parse\_dates\_argument}!pandas.io.sql@{pandas.io.sql}}
\doxysubsubsection{\texorpdfstring{\_process\_parse\_dates\_argument()}{\_process\_parse\_dates\_argument()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1io_1_1sql_aa43da01ce3b7a8e882bab2bf30f1e90e} 
pandas.\+io.\+sql.\+\_\+process\+\_\+parse\+\_\+dates\+\_\+argument (\begin{DoxyParamCaption}\item[{}]{parse\+\_\+dates}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Process parse_dates argument for read_sql functions\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{sql_8py_source_l00096}{96}} of file \mbox{\hyperlink{sql_8py_source}{sql.\+py}}.



Referenced by \mbox{\hyperlink{sql_8py_source_l01293}{pandas.\+io.\+sql.\+SQLTable.\+\_\+harmonize\+\_\+columns()}}, and \mbox{\hyperlink{sql_8py_source_l00141}{\+\_\+parse\+\_\+date\+\_\+columns()}}.

\Hypertarget{namespacepandas_1_1io_1_1sql_a454ec3aabdebc044c2822f591dc4736b}\index{pandas.io.sql@{pandas.io.sql}!\_wrap\_result@{\_wrap\_result}}
\index{\_wrap\_result@{\_wrap\_result}!pandas.io.sql@{pandas.io.sql}}
\doxysubsubsection{\texorpdfstring{\_wrap\_result()}{\_wrap\_result()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1io_1_1sql_a454ec3aabdebc044c2822f591dc4736b} 
pandas.\+io.\+sql.\+\_\+wrap\+\_\+result (\begin{DoxyParamCaption}\item[{}]{data}{, }\item[{}]{columns}{, }\item[{}]{index\+\_\+col}{ = {\ttfamily None}, }\item[{bool }]{coerce\+\_\+float}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}, }\item[{}]{parse\+\_\+dates}{ = {\ttfamily None}, }\item[{Dtype\+Arg \texorpdfstring{$\vert$}{|} None }]{dtype}{ = {\ttfamily None}, }\item[{Dtype\+Backend \texorpdfstring{$\vert$}{|} Literal\mbox{[}"{}numpy"{}\mbox{]} }]{dtype\+\_\+backend}{ = {\ttfamily "{}numpy"{}}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Wrap result set of a SQLAlchemy query in a DataFrame.\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{sql_8py_source_l00196}{196}} of file \mbox{\hyperlink{sql_8py_source}{sql.\+py}}.



References \mbox{\hyperlink{sql_8py_source_l00141}{\+\_\+parse\+\_\+date\+\_\+columns()}}.



Referenced by \mbox{\hyperlink{sql_8py_source_l01761}{pandas.\+io.\+sql.\+SQLDatabase.\+\_\+query\+\_\+iterator()}}, \mbox{\hyperlink{sql_8py_source_l02688}{pandas.\+io.\+sql.\+SQLite\+Database.\+\_\+query\+\_\+iterator()}}, and \mbox{\hyperlink{sql_8py_source_l01801}{pandas.\+io.\+sql.\+SQLDatabase.\+read\+\_\+query()}}.

\Hypertarget{namespacepandas_1_1io_1_1sql_a5dfd74a5fb48ffd2692108f350cccabf}\index{pandas.io.sql@{pandas.io.sql}!\_wrap\_result\_adbc@{\_wrap\_result\_adbc}}
\index{\_wrap\_result\_adbc@{\_wrap\_result\_adbc}!pandas.io.sql@{pandas.io.sql}}
\doxysubsubsection{\texorpdfstring{\_wrap\_result\_adbc()}{\_wrap\_result\_adbc()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1io_1_1sql_a5dfd74a5fb48ffd2692108f350cccabf} 
 \mbox{\hyperlink{classpandas_1_1core_1_1frame_1_1DataFrame}{Data\+Frame}} pandas.\+io.\+sql.\+\_\+wrap\+\_\+result\+\_\+adbc (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classpandas_1_1core_1_1frame_1_1DataFrame}{Data\+Frame}}}]{df}{, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{index\+\_\+col}{ = {\ttfamily None}, }\item[{}]{parse\+\_\+dates}{ = {\ttfamily None}, }\item[{Dtype\+Arg \texorpdfstring{$\vert$}{|} None }]{dtype}{ = {\ttfamily None}, }\item[{Dtype\+Backend \texorpdfstring{$\vert$}{|} Literal\mbox{[}"{}numpy"{}\mbox{]} }]{dtype\+\_\+backend}{ = {\ttfamily "{}numpy"{}}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Wrap result set of a SQLAlchemy query in a DataFrame.\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{sql_8py_source_l00219}{219}} of file \mbox{\hyperlink{sql_8py_source}{sql.\+py}}.



References \mbox{\hyperlink{sql_8py_source_l00141}{\+\_\+parse\+\_\+date\+\_\+columns()}}.



Referenced by \mbox{\hyperlink{sql_8py_source_l02244}{pandas.\+io.\+sql.\+ADBCDatabase.\+read\+\_\+query()}}, and \mbox{\hyperlink{sql_8py_source_l02154}{pandas.\+io.\+sql.\+ADBCDatabase.\+read\+\_\+table()}}.

\Hypertarget{namespacepandas_1_1io_1_1sql_aeba42e94abda0c7396e30e5192e7d651}\index{pandas.io.sql@{pandas.io.sql}!execute@{execute}}
\index{execute@{execute}!pandas.io.sql@{pandas.io.sql}}
\doxysubsubsection{\texorpdfstring{execute()}{execute()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1io_1_1sql_aeba42e94abda0c7396e30e5192e7d651} 
pandas.\+io.\+sql.\+execute (\begin{DoxyParamCaption}\item[{}]{sql}{, }\item[{}]{con}{, }\item[{}]{params}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Execute the given SQL query using the provided connection object.

Parameters
----------
sql : string
    SQL query to be executed.
con : SQLAlchemy connection or sqlite3 connection
    If a DBAPI2 object, only sqlite3 is supported.
params : list or tuple, optional, default: None
    List of parameters to pass to execute method.

Returns
-------
Results Iterable
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{sql_8py_source_l00239}{239}} of file \mbox{\hyperlink{sql_8py_source}{sql.\+py}}.



References \mbox{\hyperlink{sql_8py_source_l00891}{pandas\+SQL\+\_\+builder()}}.



Referenced by \mbox{\hyperlink{sql_8py_source_l01139}{pandas.\+io.\+sql.\+SQLTable.\+\_\+query\+\_\+iterator()}}.

\Hypertarget{namespacepandas_1_1io_1_1sql_a215b5bf10d7ec240725cb0439f6d8ad0}\index{pandas.io.sql@{pandas.io.sql}!get\_engine@{get\_engine}}
\index{get\_engine@{get\_engine}!pandas.io.sql@{pandas.io.sql}}
\doxysubsubsection{\texorpdfstring{get\_engine()}{get\_engine()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1io_1_1sql_a215b5bf10d7ec240725cb0439f6d8ad0} 
 \mbox{\hyperlink{classpandas_1_1io_1_1sql_1_1BaseEngine}{Base\+Engine}} pandas.\+io.\+sql.\+get\+\_\+engine (\begin{DoxyParamCaption}\item[{str}]{engine}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}return our implementation\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{sql_8py_source_l01582}{1582}} of file \mbox{\hyperlink{sql_8py_source}{sql.\+py}}.



Referenced by \mbox{\hyperlink{sql_8py_source_l01969}{pandas.\+io.\+sql.\+SQLDatabase.\+to\+\_\+sql()}}.

\Hypertarget{namespacepandas_1_1io_1_1sql_a0244b565d56f904bc774fcd553cc9bf6}\index{pandas.io.sql@{pandas.io.sql}!get\_schema@{get\_schema}}
\index{get\_schema@{get\_schema}!pandas.io.sql@{pandas.io.sql}}
\doxysubsubsection{\texorpdfstring{get\_schema()}{get\_schema()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1io_1_1sql_a0244b565d56f904bc774fcd553cc9bf6} 
 str pandas.\+io.\+sql.\+get\+\_\+schema (\begin{DoxyParamCaption}\item[{}]{frame}{, }\item[{str}]{name}{, }\item[{}]{keys}{ = {\ttfamily None}, }\item[{}]{con}{ = {\ttfamily None}, }\item[{Dtype\+Arg \texorpdfstring{$\vert$}{|} None }]{dtype}{ = {\ttfamily None}, }\item[{str \texorpdfstring{$\vert$}{|} None }]{schema}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Get the SQL db table schema for the given frame.

Parameters
----------
frame : DataFrame
name : str
    name of SQL table
keys : string or sequence, default: None
    columns to use a primary key
con: ADBC Connection, SQLAlchemy connectable, sqlite3 connection, default: None
    ADBC provides high performance I/O with native type support, where available.
    Using SQLAlchemy makes it possible to use any DB supported by that
    library
    If a DBAPI2 object, only sqlite3 is supported.
dtype : dict of column name to SQL type, default None
    Optional specifying the datatype for columns. The SQL type should
    be a SQLAlchemy type, or a string for sqlite3 fallback connection.
schema: str, default: None
    Optional specifying the schema to be used in creating the table.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{sql_8py_source_l02884}{2884}} of file \mbox{\hyperlink{sql_8py_source}{sql.\+py}}.



References \mbox{\hyperlink{sql_8py_source_l00891}{pandas\+SQL\+\_\+builder()}}.

\Hypertarget{namespacepandas_1_1io_1_1sql_a481d992f90af2849fdc44ae80127e13f}\index{pandas.io.sql@{pandas.io.sql}!has\_table@{has\_table}}
\index{has\_table@{has\_table}!pandas.io.sql@{pandas.io.sql}}
\doxysubsubsection{\texorpdfstring{has\_table()}{has\_table()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1io_1_1sql_a481d992f90af2849fdc44ae80127e13f} 
 bool pandas.\+io.\+sql.\+has\+\_\+table (\begin{DoxyParamCaption}\item[{str}]{table\+\_\+name}{, }\item[{}]{con}{, }\item[{str \texorpdfstring{$\vert$}{|} None }]{schema}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Check if DataBase has named table.

Parameters
----------
table_name: string
    Name of SQL table.
con: ADBC Connection, SQLAlchemy connectable, str, or sqlite3 connection
    ADBC provides high performance I/O with native type support, where available.
    Using SQLAlchemy makes it possible to use any DB supported by that
    library.
    If a DBAPI2 object, only sqlite3 is supported.
schema : string, default None
    Name of SQL schema in database to write to (if database flavor supports
    this). If None, use default schema (default).

Returns
-------
boolean
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{sql_8py_source_l00859}{859}} of file \mbox{\hyperlink{sql_8py_source}{sql.\+py}}.



References \mbox{\hyperlink{sql_8py_source_l00891}{pandas\+SQL\+\_\+builder()}}.

\Hypertarget{namespacepandas_1_1io_1_1sql_a0978df25c1f15b46844773dc61ace4cf}\index{pandas.io.sql@{pandas.io.sql}!pandasSQL\_builder@{pandasSQL\_builder}}
\index{pandasSQL\_builder@{pandasSQL\_builder}!pandas.io.sql@{pandas.io.sql}}
\doxysubsubsection{\texorpdfstring{pandasSQL\_builder()}{pandasSQL\_builder()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1io_1_1sql_a0978df25c1f15b46844773dc61ace4cf} 
 \mbox{\hyperlink{classpandas_1_1io_1_1sql_1_1PandasSQL}{Pandas\+SQL}} pandas.\+io.\+sql.\+pandas\+SQL\+\_\+builder (\begin{DoxyParamCaption}\item[{}]{con}{, }\item[{str \texorpdfstring{$\vert$}{|} None }]{schema}{ = {\ttfamily None}, }\item[{bool }]{need\+\_\+transaction}{ = {\ttfamily False}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Convenience function to return the correct PandasSQL subclass based on the
provided parameters.  Also creates a sqlalchemy connection and transaction
if necessary.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{sql_8py_source_l00887}{887}} of file \mbox{\hyperlink{sql_8py_source}{sql.\+py}}.



Referenced by \mbox{\hyperlink{sql_8py_source_l00239}{execute()}}, \mbox{\hyperlink{sql_8py_source_l02891}{get\+\_\+schema()}}, \mbox{\hyperlink{sql_8py_source_l00859}{has\+\_\+table()}}, \mbox{\hyperlink{sql_8py_source_l00583}{read\+\_\+sql()}}, \mbox{\hyperlink{sql_8py_source_l00446}{read\+\_\+sql\+\_\+query()}}, \mbox{\hyperlink{sql_8py_source_l00314}{read\+\_\+sql\+\_\+table()}}, and \mbox{\hyperlink{sql_8py_source_l00761}{to\+\_\+sql()}}.

\Hypertarget{namespacepandas_1_1io_1_1sql_a1256ddc25ee6b14cd44e74ac3948949f}\index{pandas.io.sql@{pandas.io.sql}!read\_sql@{read\_sql}}
\index{read\_sql@{read\_sql}!pandas.io.sql@{pandas.io.sql}}
\doxysubsubsection{\texorpdfstring{read\_sql()}{read\_sql()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily \label{namespacepandas_1_1io_1_1sql_a1256ddc25ee6b14cd44e74ac3948949f} 
 Iterator\mbox{[}\mbox{\hyperlink{classpandas_1_1core_1_1frame_1_1DataFrame}{Data\+Frame}}\mbox{]} pandas.\+io.\+sql.\+read\+\_\+sql (\begin{DoxyParamCaption}\item[{}]{sql}{, }\item[{}]{con}{, }\item[{str \texorpdfstring{$\vert$}{|} list\mbox{[}str\mbox{]} \texorpdfstring{$\vert$}{|} None }]{index\+\_\+col}{ = {\ttfamily ...}, }\item[{}]{coerce\+\_\+float}{ = {\ttfamily ...}, }\item[{}]{params}{ = {\ttfamily ...}, }\item[{}]{parse\+\_\+dates}{ = {\ttfamily ...}, }\item[{list\mbox{[}str\mbox{]} }]{columns}{ = {\ttfamily ...}, }\item[{int }]{chunksize}{ = {\ttfamily ...}, }\item[{Dtype\+Backend \texorpdfstring{$\vert$}{|} lib.\+No\+Default }]{dtype\+\_\+backend}{ = {\ttfamily ...}, }\item[{Dtype\+Arg \texorpdfstring{$\vert$}{|} None }]{dtype}{ = {\ttfamily None}}\end{DoxyParamCaption})}



Definition at line \mbox{\hyperlink{sql_8py_source_l00557}{557}} of file \mbox{\hyperlink{sql_8py_source}{sql.\+py}}.

\Hypertarget{namespacepandas_1_1io_1_1sql_a585f91f9496e6e380efb1cd31e3eb7a9}\index{pandas.io.sql@{pandas.io.sql}!read\_sql@{read\_sql}}
\index{read\_sql@{read\_sql}!pandas.io.sql@{pandas.io.sql}}
\doxysubsubsection{\texorpdfstring{read\_sql()}{read\_sql()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily \label{namespacepandas_1_1io_1_1sql_a585f91f9496e6e380efb1cd31e3eb7a9} 
 \mbox{\hyperlink{classpandas_1_1core_1_1frame_1_1DataFrame}{Data\+Frame}} pandas.\+io.\+sql.\+read\+\_\+sql (\begin{DoxyParamCaption}\item[{}]{sql}{, }\item[{}]{con}{, }\item[{str \texorpdfstring{$\vert$}{|} list\mbox{[}str\mbox{]} \texorpdfstring{$\vert$}{|} None }]{index\+\_\+col}{ = {\ttfamily ...}, }\item[{}]{coerce\+\_\+float}{ = {\ttfamily ...}, }\item[{}]{params}{ = {\ttfamily ...}, }\item[{}]{parse\+\_\+dates}{ = {\ttfamily ...}, }\item[{list\mbox{[}str\mbox{]} }]{columns}{ = {\ttfamily ...}, }\item[{None }]{chunksize}{ = {\ttfamily ...}, }\item[{Dtype\+Backend \texorpdfstring{$\vert$}{|} lib.\+No\+Default }]{dtype\+\_\+backend}{ = {\ttfamily ...}, }\item[{Dtype\+Arg \texorpdfstring{$\vert$}{|} None }]{dtype}{ = {\ttfamily None}}\end{DoxyParamCaption})}



Definition at line \mbox{\hyperlink{sql_8py_source_l00541}{541}} of file \mbox{\hyperlink{sql_8py_source}{sql.\+py}}.

\Hypertarget{namespacepandas_1_1io_1_1sql_a7f38cde8306cf4122aaa9f62adcd5cda}\index{pandas.io.sql@{pandas.io.sql}!read\_sql@{read\_sql}}
\index{read\_sql@{read\_sql}!pandas.io.sql@{pandas.io.sql}}
\doxysubsubsection{\texorpdfstring{read\_sql()}{read\_sql()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily \label{namespacepandas_1_1io_1_1sql_a7f38cde8306cf4122aaa9f62adcd5cda} 
 \mbox{\hyperlink{classpandas_1_1core_1_1frame_1_1DataFrame}{Data\+Frame}} \texorpdfstring{$\vert$}{|} Iterator\mbox{[}\mbox{\hyperlink{classpandas_1_1core_1_1frame_1_1DataFrame}{Data\+Frame}}\mbox{]} pandas.\+io.\+sql.\+read\+\_\+sql (\begin{DoxyParamCaption}\item[{}]{sql}{, }\item[{}]{con}{, }\item[{str \texorpdfstring{$\vert$}{|} list\mbox{[}str\mbox{]} \texorpdfstring{$\vert$}{|} None }]{index\+\_\+col}{ = {\ttfamily None}, }\item[{bool }]{coerce\+\_\+float}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}, }\item[{}]{params}{ = {\ttfamily None}, }\item[{}]{parse\+\_\+dates}{ = {\ttfamily None}, }\item[{list\mbox{[}str\mbox{]} \texorpdfstring{$\vert$}{|} None }]{columns}{ = {\ttfamily None}, }\item[{int \texorpdfstring{$\vert$}{|} None }]{chunksize}{ = {\ttfamily None}, }\item[{Dtype\+Backend \texorpdfstring{$\vert$}{|} lib.\+No\+Default }]{dtype\+\_\+backend}{ = {\ttfamily lib.no\+\_\+default}, }\item[{Dtype\+Arg \texorpdfstring{$\vert$}{|} None }]{dtype}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Read SQL query or database table into a DataFrame.

This function is a convenience wrapper around ``read_sql_table`` and
``read_sql_query`` (for backward compatibility). It will delegate
to the specific function depending on the provided input. A SQL query
will be routed to ``read_sql_query``, while a database table name will
be routed to ``read_sql_table``. Note that the delegated function might
have more specific notes about their functionality not listed here.

Parameters
----------
sql : str or SQLAlchemy Selectable (select or text object)
    SQL query to be executed or a table name.
con : ADBC Connection, SQLAlchemy connectable, str, or sqlite3 connection
    ADBC provides high performance I/O with native type support, where available.
    Using SQLAlchemy makes it possible to use any DB supported by that
    library. If a DBAPI2 object, only sqlite3 is supported. The user is responsible
    for engine disposal and connection closure for the ADBC connection and
    SQLAlchemy connectable; str connections are closed automatically. See
    `here <https://docs.sqlalchemy.org/en/20/core/connections.html>`_.
index_col : str or list of str, optional, default: None
    Column(s) to set as index(MultiIndex).
coerce_float : bool, default True
    Attempts to convert values of non-string, non-numeric objects (like
    decimal.Decimal) to floating point, useful for SQL result sets.
params : list, tuple or dict, optional, default: None
    List of parameters to pass to execute method.  The syntax used
    to pass parameters is database driver dependent. Check your
    database driver documentation for which of the five syntax styles,
    described in PEP 249's paramstyle, is supported.
    Eg. for psycopg2, uses %(name)s so use params={'name' : 'value'}.
parse_dates : list or dict, default: None
    - List of column names to parse as dates.
    - Dict of ``{column_name: format string}`` where format string is
      strftime compatible in case of parsing string times, or is one of
      (D, s, ns, ms, us) in case of parsing integer timestamps.
    - Dict of ``{column_name: arg dict}``, where the arg dict corresponds
      to the keyword arguments of :func:`pandas.to_datetime`
      Especially useful with databases without native Datetime support,
      such as SQLite.
columns : list, default: None
    List of column names to select from SQL table (only used when reading
    a table).
chunksize : int, default None
    If specified, return an iterator where `chunksize` is the
    number of rows to include in each chunk.
dtype_backend : {'numpy_nullable', 'pyarrow'}, default 'numpy_nullable'
    Back-end data type applied to the resultant :class:`DataFrame`
    (still experimental). Behaviour is as follows:

    * ``"numpy_nullable"``: returns nullable-dtype-backed :class:`DataFrame`
      (default).
    * ``"pyarrow"``: returns pyarrow-backed nullable :class:`ArrowDtype`
      DataFrame.

    .. versionadded:: 2.0
dtype : Type name or dict of columns
    Data type for data or columns. E.g. np.float64 or
    {'a': np.float64, 'b': np.int32, 'c': 'Int64'}.
    The argument is ignored if a table is passed instead of a query.

    .. versionadded:: 2.0.0

Returns
-------
DataFrame or Iterator[DataFrame]

See Also
--------
read_sql_table : Read SQL database table into a DataFrame.
read_sql_query : Read SQL query into a DataFrame.

Examples
--------
Read data from SQL via either a SQL query or a SQL tablename.
When using a SQLite database only SQL queries are accepted,
providing only the SQL tablename will result in an error.

>>> from sqlite3 import connect
>>> conn = connect(':memory:')
>>> df = pd.DataFrame(data=[[0, '10/11/12'], [1, '12/11/10']],
...                   columns=['int_column', 'date_column'])
>>> df.to_sql(name='test_data', con=conn)
2

>>> pd.read_sql('SELECT int_column, date_column FROM test_data', conn)
   int_column date_column
0           0    10/11/12
1           1    12/11/10

>>> pd.read_sql('test_data', 'postgres:///db_name')  # doctest:+SKIP

Apply date parsing to columns through the ``parse_dates`` argument
The ``parse_dates`` argument calls ``pd.to_datetime`` on the provided columns.
Custom argument values for applying ``pd.to_datetime`` on a column are specified
via a dictionary format:

>>> pd.read_sql('SELECT int_column, date_column FROM test_data',
...             conn,
...             parse_dates={"date_column": {"format": "%d/%m/%y"}})
   int_column date_column
0           0  2012-11-10
1           1  2010-11-12

.. versionadded:: 2.2.0

   pandas now supports reading via ADBC drivers

>>> from adbc_driver_postgresql import dbapi  # doctest:+SKIP
>>> with dbapi.connect('postgres:///db_name') as conn:  # doctest:+SKIP
...     pd.read_sql('SELECT int_column FROM test_data', conn)
   int_column
0           0
1           1
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{sql_8py_source_l00572}{572}} of file \mbox{\hyperlink{sql_8py_source}{sql.\+py}}.



References \mbox{\hyperlink{sql_8py_source_l00891}{pandas\+SQL\+\_\+builder()}}.

\Hypertarget{namespacepandas_1_1io_1_1sql_a2f7467cc4cb1527b9261f0b415e5a7e6}\index{pandas.io.sql@{pandas.io.sql}!read\_sql\_query@{read\_sql\_query}}
\index{read\_sql\_query@{read\_sql\_query}!pandas.io.sql@{pandas.io.sql}}
\doxysubsubsection{\texorpdfstring{read\_sql\_query()}{read\_sql\_query()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily \label{namespacepandas_1_1io_1_1sql_a2f7467cc4cb1527b9261f0b415e5a7e6} 
 Iterator\mbox{[}\mbox{\hyperlink{classpandas_1_1core_1_1frame_1_1DataFrame}{Data\+Frame}}\mbox{]} pandas.\+io.\+sql.\+read\+\_\+sql\+\_\+query (\begin{DoxyParamCaption}\item[{}]{sql}{, }\item[{}]{con}{, }\item[{str \texorpdfstring{$\vert$}{|} list\mbox{[}str\mbox{]} \texorpdfstring{$\vert$}{|} None }]{index\+\_\+col}{ = {\ttfamily ...}, }\item[{}]{coerce\+\_\+float}{ = {\ttfamily ...}, }\item[{list\mbox{[}Any\mbox{]} \texorpdfstring{$\vert$}{|} Mapping\mbox{[}str, Any\mbox{]} \texorpdfstring{$\vert$}{|} None }]{params}{ = {\ttfamily ...}, }\item[{list\mbox{[}str\mbox{]} \texorpdfstring{$\vert$}{|} dict\mbox{[}str, str\mbox{]} \texorpdfstring{$\vert$}{|} None }]{parse\+\_\+dates}{ = {\ttfamily ...}, }\item[{int }]{chunksize}{ = {\ttfamily ...}, }\item[{Dtype\+Arg \texorpdfstring{$\vert$}{|} None }]{dtype}{ = {\ttfamily ...}, }\item[{Dtype\+Backend \texorpdfstring{$\vert$}{|} lib.\+No\+Default }]{dtype\+\_\+backend}{ = {\ttfamily ...}}\end{DoxyParamCaption})}



Definition at line \mbox{\hyperlink{sql_8py_source_l00422}{422}} of file \mbox{\hyperlink{sql_8py_source}{sql.\+py}}.

\Hypertarget{namespacepandas_1_1io_1_1sql_a591da2cb6c8e6b1abf5d9a49361a019b}\index{pandas.io.sql@{pandas.io.sql}!read\_sql\_query@{read\_sql\_query}}
\index{read\_sql\_query@{read\_sql\_query}!pandas.io.sql@{pandas.io.sql}}
\doxysubsubsection{\texorpdfstring{read\_sql\_query()}{read\_sql\_query()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily \label{namespacepandas_1_1io_1_1sql_a591da2cb6c8e6b1abf5d9a49361a019b} 
 \mbox{\hyperlink{classpandas_1_1core_1_1frame_1_1DataFrame}{Data\+Frame}} pandas.\+io.\+sql.\+read\+\_\+sql\+\_\+query (\begin{DoxyParamCaption}\item[{}]{sql}{, }\item[{}]{con}{, }\item[{str \texorpdfstring{$\vert$}{|} list\mbox{[}str\mbox{]} \texorpdfstring{$\vert$}{|} None }]{index\+\_\+col}{ = {\ttfamily ...}, }\item[{}]{coerce\+\_\+float}{ = {\ttfamily ...}, }\item[{list\mbox{[}Any\mbox{]} \texorpdfstring{$\vert$}{|} Mapping\mbox{[}str, Any\mbox{]} \texorpdfstring{$\vert$}{|} None }]{params}{ = {\ttfamily ...}, }\item[{list\mbox{[}str\mbox{]} \texorpdfstring{$\vert$}{|} dict\mbox{[}str, str\mbox{]} \texorpdfstring{$\vert$}{|} None }]{parse\+\_\+dates}{ = {\ttfamily ...}, }\item[{None }]{chunksize}{ = {\ttfamily ...}, }\item[{Dtype\+Arg \texorpdfstring{$\vert$}{|} None }]{dtype}{ = {\ttfamily ...}, }\item[{Dtype\+Backend \texorpdfstring{$\vert$}{|} lib.\+No\+Default }]{dtype\+\_\+backend}{ = {\ttfamily ...}}\end{DoxyParamCaption})}



Definition at line \mbox{\hyperlink{sql_8py_source_l00407}{407}} of file \mbox{\hyperlink{sql_8py_source}{sql.\+py}}.

\Hypertarget{namespacepandas_1_1io_1_1sql_ade90c889afd215496f48f01f07c24132}\index{pandas.io.sql@{pandas.io.sql}!read\_sql\_query@{read\_sql\_query}}
\index{read\_sql\_query@{read\_sql\_query}!pandas.io.sql@{pandas.io.sql}}
\doxysubsubsection{\texorpdfstring{read\_sql\_query()}{read\_sql\_query()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily \label{namespacepandas_1_1io_1_1sql_ade90c889afd215496f48f01f07c24132} 
 \mbox{\hyperlink{classpandas_1_1core_1_1frame_1_1DataFrame}{Data\+Frame}} \texorpdfstring{$\vert$}{|} Iterator\mbox{[}\mbox{\hyperlink{classpandas_1_1core_1_1frame_1_1DataFrame}{Data\+Frame}}\mbox{]} pandas.\+io.\+sql.\+read\+\_\+sql\+\_\+query (\begin{DoxyParamCaption}\item[{}]{sql}{, }\item[{}]{con}{, }\item[{str \texorpdfstring{$\vert$}{|} list\mbox{[}str\mbox{]} \texorpdfstring{$\vert$}{|} None }]{index\+\_\+col}{ = {\ttfamily None}, }\item[{bool }]{coerce\+\_\+float}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}, }\item[{list\mbox{[}Any\mbox{]} \texorpdfstring{$\vert$}{|} Mapping\mbox{[}str, Any\mbox{]} \texorpdfstring{$\vert$}{|} None }]{params}{ = {\ttfamily None}, }\item[{list\mbox{[}str\mbox{]} \texorpdfstring{$\vert$}{|} dict\mbox{[}str, str\mbox{]} \texorpdfstring{$\vert$}{|} None }]{parse\+\_\+dates}{ = {\ttfamily None}, }\item[{int \texorpdfstring{$\vert$}{|} None }]{chunksize}{ = {\ttfamily None}, }\item[{Dtype\+Arg \texorpdfstring{$\vert$}{|} None }]{dtype}{ = {\ttfamily None}, }\item[{Dtype\+Backend \texorpdfstring{$\vert$}{|} lib.\+No\+Default }]{dtype\+\_\+backend}{ = {\ttfamily lib.no\+\_\+default}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Read SQL query into a DataFrame.

Returns a DataFrame corresponding to the result set of the query
string. Optionally provide an `index_col` parameter to use one of the
columns as the index, otherwise default integer index will be used.

Parameters
----------
sql : str SQL query or SQLAlchemy Selectable (select or text object)
    SQL query to be executed.
con : SQLAlchemy connectable, str, or sqlite3 connection
    Using SQLAlchemy makes it possible to use any DB supported by that
    library. If a DBAPI2 object, only sqlite3 is supported.
index_col : str or list of str, optional, default: None
    Column(s) to set as index(MultiIndex).
coerce_float : bool, default True
    Attempts to convert values of non-string, non-numeric objects (like
    decimal.Decimal) to floating point. Useful for SQL result sets.
params : list, tuple or mapping, optional, default: None
    List of parameters to pass to execute method.  The syntax used
    to pass parameters is database driver dependent. Check your
    database driver documentation for which of the five syntax styles,
    described in PEP 249's paramstyle, is supported.
    Eg. for psycopg2, uses %(name)s so use params={'name' : 'value'}.
parse_dates : list or dict, default: None
    - List of column names to parse as dates.
    - Dict of ``{column_name: format string}`` where format string is
      strftime compatible in case of parsing string times, or is one of
      (D, s, ns, ms, us) in case of parsing integer timestamps.
    - Dict of ``{column_name: arg dict}``, where the arg dict corresponds
      to the keyword arguments of :func:`pandas.to_datetime`
      Especially useful with databases without native Datetime support,
      such as SQLite.
chunksize : int, default None
    If specified, return an iterator where `chunksize` is the number of
    rows to include in each chunk.
dtype : Type name or dict of columns
    Data type for data or columns. E.g. np.float64 or
    {'a': np.float64, 'b': np.int32, 'c': 'Int64'}.

    .. versionadded:: 1.3.0
dtype_backend : {'numpy_nullable', 'pyarrow'}, default 'numpy_nullable'
    Back-end data type applied to the resultant :class:`DataFrame`
    (still experimental). Behaviour is as follows:

    * ``"numpy_nullable"``: returns nullable-dtype-backed :class:`DataFrame`
      (default).
    * ``"pyarrow"``: returns pyarrow-backed nullable :class:`ArrowDtype`
      DataFrame.

    .. versionadded:: 2.0

Returns
-------
DataFrame or Iterator[DataFrame]

See Also
--------
read_sql_table : Read SQL database table into a DataFrame.
read_sql : Read SQL query or database table into a DataFrame.

Notes
-----
Any datetime values with time zone information parsed via the `parse_dates`
parameter will be converted to UTC.

Examples
--------
>>> from sqlalchemy import create_engine  # doctest: +SKIP
>>> engine = create_engine("sqlite:///database.db")  # doctest: +SKIP
>>> with engine.connect() as conn, conn.begin():  # doctest: +SKIP
...     data = pd.read_sql_table("data", conn)  # doctest: +SKIP
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{sql_8py_source_l00436}{436}} of file \mbox{\hyperlink{sql_8py_source}{sql.\+py}}.



References \mbox{\hyperlink{sql_8py_source_l00891}{pandas\+SQL\+\_\+builder()}}.

\Hypertarget{namespacepandas_1_1io_1_1sql_a331746382c2a4f1a3fb2a9aa480c9956}\index{pandas.io.sql@{pandas.io.sql}!read\_sql\_table@{read\_sql\_table}}
\index{read\_sql\_table@{read\_sql\_table}!pandas.io.sql@{pandas.io.sql}}
\doxysubsubsection{\texorpdfstring{read\_sql\_table()}{read\_sql\_table()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily \label{namespacepandas_1_1io_1_1sql_a331746382c2a4f1a3fb2a9aa480c9956} 
 Iterator\mbox{[}\mbox{\hyperlink{classpandas_1_1core_1_1frame_1_1DataFrame}{Data\+Frame}}\mbox{]} pandas.\+io.\+sql.\+read\+\_\+sql\+\_\+table (\begin{DoxyParamCaption}\item[{str}]{table\+\_\+name}{, }\item[{}]{con}{, }\item[{}]{schema}{ = {\ttfamily ...}, }\item[{str \texorpdfstring{$\vert$}{|} list\mbox{[}str\mbox{]} \texorpdfstring{$\vert$}{|} None }]{index\+\_\+col}{ = {\ttfamily ...}, }\item[{}]{coerce\+\_\+float}{ = {\ttfamily ...}, }\item[{list\mbox{[}str\mbox{]} \texorpdfstring{$\vert$}{|} dict\mbox{[}str, str\mbox{]} \texorpdfstring{$\vert$}{|} None }]{parse\+\_\+dates}{ = {\ttfamily ...}, }\item[{list\mbox{[}str\mbox{]} \texorpdfstring{$\vert$}{|} None }]{columns}{ = {\ttfamily ...}, }\item[{int }]{chunksize}{ = {\ttfamily ...}, }\item[{Dtype\+Backend \texorpdfstring{$\vert$}{|} lib.\+No\+Default }]{dtype\+\_\+backend}{ = {\ttfamily ...}}\end{DoxyParamCaption})}



Definition at line \mbox{\hyperlink{sql_8py_source_l00290}{290}} of file \mbox{\hyperlink{sql_8py_source}{sql.\+py}}.

\Hypertarget{namespacepandas_1_1io_1_1sql_a734c0d227bd68ba064bf2f048e10a8f9}\index{pandas.io.sql@{pandas.io.sql}!read\_sql\_table@{read\_sql\_table}}
\index{read\_sql\_table@{read\_sql\_table}!pandas.io.sql@{pandas.io.sql}}
\doxysubsubsection{\texorpdfstring{read\_sql\_table()}{read\_sql\_table()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily \label{namespacepandas_1_1io_1_1sql_a734c0d227bd68ba064bf2f048e10a8f9} 
 \mbox{\hyperlink{classpandas_1_1core_1_1frame_1_1DataFrame}{Data\+Frame}} pandas.\+io.\+sql.\+read\+\_\+sql\+\_\+table (\begin{DoxyParamCaption}\item[{str}]{table\+\_\+name}{, }\item[{}]{con}{, }\item[{}]{schema}{ = {\ttfamily ...}, }\item[{str \texorpdfstring{$\vert$}{|} list\mbox{[}str\mbox{]} \texorpdfstring{$\vert$}{|} None }]{index\+\_\+col}{ = {\ttfamily ...}, }\item[{}]{coerce\+\_\+float}{ = {\ttfamily ...}, }\item[{list\mbox{[}str\mbox{]} \texorpdfstring{$\vert$}{|} dict\mbox{[}str, str\mbox{]} \texorpdfstring{$\vert$}{|} None }]{parse\+\_\+dates}{ = {\ttfamily ...}, }\item[{list\mbox{[}str\mbox{]} \texorpdfstring{$\vert$}{|} None }]{columns}{ = {\ttfamily ...}, }\item[{None }]{chunksize}{ = {\ttfamily ...}, }\item[{Dtype\+Backend \texorpdfstring{$\vert$}{|} lib.\+No\+Default }]{dtype\+\_\+backend}{ = {\ttfamily ...}}\end{DoxyParamCaption})}



Definition at line \mbox{\hyperlink{sql_8py_source_l00275}{275}} of file \mbox{\hyperlink{sql_8py_source}{sql.\+py}}.

\Hypertarget{namespacepandas_1_1io_1_1sql_a97f645358aefa6bf91e644c5a38882b9}\index{pandas.io.sql@{pandas.io.sql}!read\_sql\_table@{read\_sql\_table}}
\index{read\_sql\_table@{read\_sql\_table}!pandas.io.sql@{pandas.io.sql}}
\doxysubsubsection{\texorpdfstring{read\_sql\_table()}{read\_sql\_table()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily \label{namespacepandas_1_1io_1_1sql_a97f645358aefa6bf91e644c5a38882b9} 
 \mbox{\hyperlink{classpandas_1_1core_1_1frame_1_1DataFrame}{Data\+Frame}} \texorpdfstring{$\vert$}{|} Iterator\mbox{[}\mbox{\hyperlink{classpandas_1_1core_1_1frame_1_1DataFrame}{Data\+Frame}}\mbox{]} pandas.\+io.\+sql.\+read\+\_\+sql\+\_\+table (\begin{DoxyParamCaption}\item[{str}]{table\+\_\+name}{, }\item[{}]{con}{, }\item[{str \texorpdfstring{$\vert$}{|} None }]{schema}{ = {\ttfamily None}, }\item[{str \texorpdfstring{$\vert$}{|} list\mbox{[}str\mbox{]} \texorpdfstring{$\vert$}{|} None }]{index\+\_\+col}{ = {\ttfamily None}, }\item[{bool }]{coerce\+\_\+float}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}, }\item[{list\mbox{[}str\mbox{]} \texorpdfstring{$\vert$}{|} dict\mbox{[}str, str\mbox{]} \texorpdfstring{$\vert$}{|} None }]{parse\+\_\+dates}{ = {\ttfamily None}, }\item[{list\mbox{[}str\mbox{]} \texorpdfstring{$\vert$}{|} None }]{columns}{ = {\ttfamily None}, }\item[{int \texorpdfstring{$\vert$}{|} None }]{chunksize}{ = {\ttfamily None}, }\item[{Dtype\+Backend \texorpdfstring{$\vert$}{|} lib.\+No\+Default }]{dtype\+\_\+backend}{ = {\ttfamily lib.no\+\_\+default}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Read SQL database table into a DataFrame.

Given a table name and a SQLAlchemy connectable, returns a DataFrame.
This function does not support DBAPI connections.

Parameters
----------
table_name : str
    Name of SQL table in database.
con : SQLAlchemy connectable or str
    A database URI could be provided as str.
    SQLite DBAPI connection mode not supported.
schema : str, default None
    Name of SQL schema in database to query (if database flavor
    supports this). Uses default schema if None (default).
index_col : str or list of str, optional, default: None
    Column(s) to set as index(MultiIndex).
coerce_float : bool, default True
    Attempts to convert values of non-string, non-numeric objects (like
    decimal.Decimal) to floating point. Can result in loss of Precision.
parse_dates : list or dict, default None
    - List of column names to parse as dates.
    - Dict of ``{column_name: format string}`` where format string is
      strftime compatible in case of parsing string times or is one of
      (D, s, ns, ms, us) in case of parsing integer timestamps.
    - Dict of ``{column_name: arg dict}``, where the arg dict corresponds
      to the keyword arguments of :func:`pandas.to_datetime`
      Especially useful with databases without native Datetime support,
      such as SQLite.
columns : list, default None
    List of column names to select from SQL table.
chunksize : int, default None
    If specified, returns an iterator where `chunksize` is the number of
    rows to include in each chunk.
dtype_backend : {'numpy_nullable', 'pyarrow'}, default 'numpy_nullable'
    Back-end data type applied to the resultant :class:`DataFrame`
    (still experimental). Behaviour is as follows:

    * ``"numpy_nullable"``: returns nullable-dtype-backed :class:`DataFrame`
      (default).
    * ``"pyarrow"``: returns pyarrow-backed nullable :class:`ArrowDtype`
      DataFrame.

    .. versionadded:: 2.0

Returns
-------
DataFrame or Iterator[DataFrame]
    A SQL table is returned as two-dimensional data structure with labeled
    axes.

See Also
--------
read_sql_query : Read SQL query into a DataFrame.
read_sql : Read SQL query or database table into a DataFrame.

Notes
-----
Any datetime values with time zone information will be converted to UTC.

Examples
--------
>>> pd.read_sql_table('table_name', 'postgres:///db_name')  # doctest:+SKIP
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{sql_8py_source_l00304}{304}} of file \mbox{\hyperlink{sql_8py_source}{sql.\+py}}.



References \mbox{\hyperlink{sql_8py_source_l00891}{pandas\+SQL\+\_\+builder()}}.

\Hypertarget{namespacepandas_1_1io_1_1sql_a84834f87b2fbd018a2e094944db67423}\index{pandas.io.sql@{pandas.io.sql}!to\_sql@{to\_sql}}
\index{to\_sql@{to\_sql}!pandas.io.sql@{pandas.io.sql}}
\doxysubsubsection{\texorpdfstring{to\_sql()}{to\_sql()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1io_1_1sql_a84834f87b2fbd018a2e094944db67423} 
 int \texorpdfstring{$\vert$}{|} None pandas.\+io.\+sql.\+to\+\_\+sql (\begin{DoxyParamCaption}\item[{}]{frame}{, }\item[{str}]{name}{, }\item[{}]{con}{, }\item[{str \texorpdfstring{$\vert$}{|} None }]{schema}{ = {\ttfamily None}, }\item[{Literal\mbox{[}"{}fail"{}, "{}replace"{}, "{}append"{}\mbox{]} }]{if\+\_\+exists}{ = {\ttfamily "{}fail"{}}, }\item[{bool }]{index}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}, }\item[{Index\+Label \texorpdfstring{$\vert$}{|} None }]{index\+\_\+label}{ = {\ttfamily None}, }\item[{int \texorpdfstring{$\vert$}{|} None }]{chunksize}{ = {\ttfamily None}, }\item[{Dtype\+Arg \texorpdfstring{$\vert$}{|} None }]{dtype}{ = {\ttfamily None}, }\item[{Literal\mbox{[}"{}multi"{}\mbox{]} \texorpdfstring{$\vert$}{|} Callable \texorpdfstring{$\vert$}{|} None }]{method}{ = {\ttfamily None}, }\item[{str }]{engine}{ = {\ttfamily "{}auto"{}}, }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{engine\+\_\+kwargs}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Write records stored in a DataFrame to a SQL database.

Parameters
----------
frame : DataFrame, Series
name : str
    Name of SQL table.
con : ADBC Connection, SQLAlchemy connectable, str, or sqlite3 connection
    or sqlite3 DBAPI2 connection
    ADBC provides high performance I/O with native type support, where available.
    Using SQLAlchemy makes it possible to use any DB supported by that
    library.
    If a DBAPI2 object, only sqlite3 is supported.
schema : str, optional
    Name of SQL schema in database to write to (if database flavor
    supports this). If None, use default schema (default).
if_exists : {'fail', 'replace', 'append'}, default 'fail'
    - fail: If table exists, do nothing.
    - replace: If table exists, drop it, recreate it, and insert data.
    - append: If table exists, insert data. Create if does not exist.
index : bool, default True
    Write DataFrame index as a column.
index_label : str or sequence, optional
    Column label for index column(s). If None is given (default) and
    `index` is True, then the index names are used.
    A sequence should be given if the DataFrame uses MultiIndex.
chunksize : int, optional
    Specify the number of rows in each batch to be written at a time.
    By default, all rows will be written at once.
dtype : dict or scalar, optional
    Specifying the datatype for columns. If a dictionary is used, the
    keys should be the column names and the values should be the
    SQLAlchemy types or strings for the sqlite3 fallback mode. If a
    scalar is provided, it will be applied to all columns.
method : {None, 'multi', callable}, optional
    Controls the SQL insertion clause used:

    - None : Uses standard SQL ``INSERT`` clause (one per row).
    - ``'multi'``: Pass multiple values in a single ``INSERT`` clause.
    - callable with signature ``(pd_table, conn, keys, data_iter) -> int | None``.

    Details and a sample callable implementation can be found in the
    section :ref:`insert method <io.sql.method>`.
engine : {'auto', 'sqlalchemy'}, default 'auto'
    SQL engine library to use. If 'auto', then the option
    ``io.sql.engine`` is used. The default ``io.sql.engine``
    behavior is 'sqlalchemy'

    .. versionadded:: 1.3.0

**engine_kwargs
    Any additional kwargs are passed to the engine.

Returns
-------
None or int
    Number of rows affected by to_sql. None is returned if the callable
    passed into ``method`` does not return an integer number of rows.

    .. versionadded:: 1.4.0

Notes
-----
The returned rows affected is the sum of the ``rowcount`` attribute of ``sqlite3.Cursor``
or SQLAlchemy connectable. If using ADBC the returned rows are the result
of ``Cursor.adbc_ingest``. The returned value may not reflect the exact number of written
rows as stipulated in the
`sqlite3 <https://docs.python.org/3/library/sqlite3.html#sqlite3.Cursor.rowcount>`__ or
`SQLAlchemy <https://docs.sqlalchemy.org/en/14/core/connections.html#sqlalchemy.engine.BaseCursorResult.rowcount>`__
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{sql_8py_source_l00748}{748}} of file \mbox{\hyperlink{sql_8py_source}{sql.\+py}}.



References \mbox{\hyperlink{sql_8py_source_l00891}{pandas\+SQL\+\_\+builder()}}.



\doxysubsection{Variable Documentation}
\Hypertarget{namespacepandas_1_1io_1_1sql_a6fe412bc2640a94db1e0989b222767ed}\index{pandas.io.sql@{pandas.io.sql}!\_SQL\_TYPES@{\_SQL\_TYPES}}
\index{\_SQL\_TYPES@{\_SQL\_TYPES}!pandas.io.sql@{pandas.io.sql}}
\doxysubsubsection{\texorpdfstring{\_SQL\_TYPES}{\_SQL\_TYPES}}
{\footnotesize\ttfamily \label{namespacepandas_1_1io_1_1sql_a6fe412bc2640a94db1e0989b222767ed} 
dict pandas.\+io.\+sql.\+\_\+\+SQL\+\_\+\+TYPES\hspace{0.3cm}{\ttfamily [protected]}}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ \{}
\DoxyCodeLine{00002\ \ \ \ \ \textcolor{stringliteral}{"{}string"{}}:\ \textcolor{stringliteral}{"{}TEXT"{}},}
\DoxyCodeLine{00003\ \ \ \ \ \textcolor{stringliteral}{"{}floating"{}}:\ \textcolor{stringliteral}{"{}REAL"{}},}
\DoxyCodeLine{00004\ \ \ \ \ \textcolor{stringliteral}{"{}integer"{}}:\ \textcolor{stringliteral}{"{}INTEGER"{}},}
\DoxyCodeLine{00005\ \ \ \ \ \textcolor{stringliteral}{"{}datetime"{}}:\ \textcolor{stringliteral}{"{}TIMESTAMP"{}},}
\DoxyCodeLine{00006\ \ \ \ \ \textcolor{stringliteral}{"{}date"{}}:\ \textcolor{stringliteral}{"{}DATE"{}},}
\DoxyCodeLine{00007\ \ \ \ \ \textcolor{stringliteral}{"{}time"{}}:\ \textcolor{stringliteral}{"{}TIME"{}},}
\DoxyCodeLine{00008\ \ \ \ \ \textcolor{stringliteral}{"{}boolean"{}}:\ \textcolor{stringliteral}{"{}INTEGER"{}},}
\DoxyCodeLine{00009\ \}}

\end{DoxyCode}


Definition at line \mbox{\hyperlink{sql_8py_source_l02431}{2431}} of file \mbox{\hyperlink{sql_8py_source}{sql.\+py}}.

\Hypertarget{namespacepandas_1_1io_1_1sql_aa7cfd1d87ee3e84467f1437462970a29}\index{pandas.io.sql@{pandas.io.sql}!table\_exists@{table\_exists}}
\index{table\_exists@{table\_exists}!pandas.io.sql@{pandas.io.sql}}
\doxysubsubsection{\texorpdfstring{table\_exists}{table\_exists}}
{\footnotesize\ttfamily \label{namespacepandas_1_1io_1_1sql_aa7cfd1d87ee3e84467f1437462970a29} 
bool pandas.\+io.\+sql.\+table\+\_\+exists = \mbox{\hyperlink{namespacepandas_1_1io_1_1sql_a481d992f90af2849fdc44ae80127e13f}{has\+\_\+table}}}



Definition at line \mbox{\hyperlink{sql_8py_source_l00884}{884}} of file \mbox{\hyperlink{sql_8py_source}{sql.\+py}}.

