\doxysection{scipy.\+integrate.\+\_\+ivp.\+lsoda.\+LSODA Class Reference}
\hypertarget{classscipy_1_1integrate_1_1__ivp_1_1lsoda_1_1LSODA}{}\label{classscipy_1_1integrate_1_1__ivp_1_1lsoda_1_1LSODA}\index{scipy.integrate.\_ivp.lsoda.LSODA@{scipy.integrate.\_ivp.lsoda.LSODA}}


Inheritance diagram for scipy.\+integrate.\+\_\+ivp.\+lsoda.\+LSODA\+:
% FIG 0


Collaboration diagram for scipy.\+integrate.\+\_\+ivp.\+lsoda.\+LSODA\+:
% FIG 1
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classscipy_1_1integrate_1_1__ivp_1_1lsoda_1_1LSODA_a38a352e9d3d965d869297c30f47b91a5}{\+\_\+\+\_\+init\+\_\+\+\_\+}} (self, fun, t0, y0, t\+\_\+bound, first\+\_\+step=None, min\+\_\+step=0.\+0, max\+\_\+step=np.\+inf, rtol=1e-\/3, atol=1e-\/6, jac=None, lband=None, uband=None, vectorized=False, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}extraneous)
\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions inherited from \mbox{\hyperlink{classscipy_1_1integrate_1_1__ivp_1_1base_1_1OdeSolver}{scipy.\+integrate.\+\_\+ivp.\+base.\+Ode\+Solver}}}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classscipy_1_1integrate_1_1__ivp_1_1base_1_1OdeSolver_a9c4e9fd1fcf86df252245e3a690d2295}{\+\_\+\+\_\+init\+\_\+\+\_\+}} (self, fun, t0, y0, t\+\_\+bound, vectorized, support\+\_\+complex=False)
\item 
\mbox{\hyperlink{classscipy_1_1integrate_1_1__ivp_1_1base_1_1OdeSolver_a27d7a568d3ef586049546b3ba9e58197}{step\+\_\+size}} (self)
\item 
\mbox{\hyperlink{classscipy_1_1integrate_1_1__ivp_1_1base_1_1OdeSolver_ae3c5dcdf2ac714840b6f3634566341d3}{step}} (self)
\item 
\mbox{\hyperlink{classscipy_1_1integrate_1_1__ivp_1_1base_1_1OdeSolver_a195e15342b5a252a8134adb0ab59057e}{dense\+\_\+output}} (self)
\end{DoxyCompactItemize}
\doxysubsubsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classscipy_1_1integrate_1_1__ivp_1_1lsoda_1_1LSODA_ace3065acdd80d9d904668cf8383e9cb0}{\+\_\+step\+\_\+impl}} (self)
\item 
\mbox{\hyperlink{classscipy_1_1integrate_1_1__ivp_1_1lsoda_1_1LSODA_ac832c34a536e3964092b2187fe59e59f}{\+\_\+dense\+\_\+output\+\_\+impl}} (self)
\end{DoxyCompactItemize}
\doxysubsubsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classscipy_1_1integrate_1_1__ivp_1_1lsoda_1_1LSODA_a2b746e8fd24b8b6377035da4120d4b32}{\+\_\+lsoda\+\_\+solver}} = solver
\end{DoxyCompactItemize}
\doxysubsection*{Protected Attributes inherited from \mbox{\hyperlink{classscipy_1_1integrate_1_1__ivp_1_1base_1_1OdeSolver}{scipy.\+integrate.\+\_\+ivp.\+base.\+Ode\+Solver}}}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classscipy_1_1integrate_1_1__ivp_1_1base_1_1OdeSolver_aa11eb1c1824ef2b662e7700fcdedc497}{\+\_\+fun}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Additional Inherited Members}
\doxysubsection*{Public Attributes inherited from \mbox{\hyperlink{classscipy_1_1integrate_1_1__ivp_1_1base_1_1OdeSolver}{scipy.\+integrate.\+\_\+ivp.\+base.\+Ode\+Solver}}}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classscipy_1_1integrate_1_1__ivp_1_1base_1_1OdeSolver_a0093ec62c6c9dd41131f2d867bcf67c4}{t\+\_\+old}} = None
\item 
\mbox{\hyperlink{classscipy_1_1integrate_1_1__ivp_1_1base_1_1OdeSolver_a02ce7b1a63b6eacc3a0c086d333cd0db}{t}} = t0
\item 
\mbox{\hyperlink{classscipy_1_1integrate_1_1__ivp_1_1base_1_1OdeSolver_a81f6cc865069df46b578ecc69cd0bdb5}{y}} = \mbox{\hyperlink{namespacescipy_1_1integrate_1_1__ivp_1_1base_a44ad6e618ce8bf255180e9f010b1c478}{check\+\_\+arguments}}(fun, y0, support\+\_\+complex)
\item 
\mbox{\hyperlink{classscipy_1_1integrate_1_1__ivp_1_1base_1_1OdeSolver_adfc08e37d36be687b59ac3ac6bd441c1}{t\+\_\+bound}} = t\+\_\+bound
\item 
\mbox{\hyperlink{classscipy_1_1integrate_1_1__ivp_1_1base_1_1OdeSolver_a513360780da06cece588eb4be2992fed}{vectorized}} = vectorized
\item 
\mbox{\hyperlink{classscipy_1_1integrate_1_1__ivp_1_1base_1_1OdeSolver_a197e81c9751b393b77e31dd57a5414ea}{fun}} = fun
\item 
\mbox{\hyperlink{classscipy_1_1integrate_1_1__ivp_1_1base_1_1OdeSolver_a5c83912512fa07d5a92386cdcc117cb3}{fun\+\_\+single}} = fun\+\_\+single
\item 
\mbox{\hyperlink{classscipy_1_1integrate_1_1__ivp_1_1base_1_1OdeSolver_ad4d0167316cb50a9ed4e64245f34a2a3}{fun\+\_\+vectorized}} = fun\+\_\+vectorized
\item 
int \mbox{\hyperlink{classscipy_1_1integrate_1_1__ivp_1_1base_1_1OdeSolver_a2c02a611e2ee66d727085e4f3540e615}{direction}} = t0 else 1
\item 
int \mbox{\hyperlink{classscipy_1_1integrate_1_1__ivp_1_1base_1_1OdeSolver_a460d321a92662254b1865e733dc5ef41}{n}} = self.\+y.\+size
\item 
str \mbox{\hyperlink{classscipy_1_1integrate_1_1__ivp_1_1base_1_1OdeSolver_a8d24311a10738fd442820d956dc9263c}{status}} = \textquotesingle{}running\textquotesingle{}
\item 
int \mbox{\hyperlink{classscipy_1_1integrate_1_1__ivp_1_1base_1_1OdeSolver_a3fafa668f6a877260c69d91159843a34}{nfev}} = 0
\item 
int \mbox{\hyperlink{classscipy_1_1integrate_1_1__ivp_1_1base_1_1OdeSolver_a5c3b903f6455ff7918b690e751a843da}{njev}} = 0
\item 
int \mbox{\hyperlink{classscipy_1_1integrate_1_1__ivp_1_1base_1_1OdeSolver_af137ff8c30b6e54d9aed9483c22f4084}{nlu}} = 0
\end{DoxyCompactItemize}
\doxysubsection*{Static Public Attributes inherited from \mbox{\hyperlink{classscipy_1_1integrate_1_1__ivp_1_1base_1_1OdeSolver}{scipy.\+integrate.\+\_\+ivp.\+base.\+Ode\+Solver}}}
\begin{DoxyCompactItemize}
\item 
str \mbox{\hyperlink{classscipy_1_1integrate_1_1__ivp_1_1base_1_1OdeSolver_a7a9a9882986196f149c96085ea3dd708}{TOO\+\_\+\+SMALL\+\_\+\+STEP}} = "{}Required \mbox{\hyperlink{classscipy_1_1integrate_1_1__ivp_1_1base_1_1OdeSolver_ae3c5dcdf2ac714840b6f3634566341d3}{step}} size is less than spacing between numbers."{}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\begin{DoxyVerb}Adams/BDF method with automatic stiffness detection and switching.

This is a wrapper to the Fortran solver from ODEPACK [1]_. It switches
automatically between the nonstiff Adams method and the stiff BDF method.
The method was originally detailed in [2]_.

Parameters
----------
fun : callable
    Right-hand side of the system: the time derivative of the state ``y``
    at time ``t``. The calling signature is ``fun(t, y)``, where ``t`` is a
    scalar and ``y`` is an ndarray with ``len(y) = len(y0)``. ``fun`` must
    return an array of the same shape as ``y``. See `vectorized` for more
    information.
t0 : float
    Initial time.
y0 : array_like, shape (n,)
    Initial state.
t_bound : float
    Boundary time - the integration won't continue beyond it. It also
    determines the direction of the integration.
first_step : float or None, optional
    Initial step size. Default is ``None`` which means that the algorithm
    should choose.
min_step : float, optional
    Minimum allowed step size. Default is 0.0, i.e., the step size is not
    bounded and determined solely by the solver.
max_step : float, optional
    Maximum allowed step size. Default is np.inf, i.e., the step size is not
    bounded and determined solely by the solver.
rtol, atol : float and array_like, optional
    Relative and absolute tolerances. The solver keeps the local error
    estimates less than ``atol + rtol * abs(y)``. Here `rtol` controls a
    relative accuracy (number of correct digits), while `atol` controls
    absolute accuracy (number of correct decimal places). To achieve the
    desired `rtol`, set `atol` to be smaller than the smallest value that
    can be expected from ``rtol * abs(y)`` so that `rtol` dominates the
    allowable error. If `atol` is larger than ``rtol * abs(y)`` the
    number of correct digits is not guaranteed. Conversely, to achieve the
    desired `atol` set `rtol` such that ``rtol * abs(y)`` is always smaller
    than `atol`. If components of y have different scales, it might be
    beneficial to set different `atol` values for different components by
    passing array_like with shape (n,) for `atol`. Default values are
    1e-3 for `rtol` and 1e-6 for `atol`.
jac : None or callable, optional
    Jacobian matrix of the right-hand side of the system with respect to
    ``y``. The Jacobian matrix has shape (n, n) and its element (i, j) is
    equal to ``d f_i / d y_j``. The function will be called as
    ``jac(t, y)``. If None (default), the Jacobian will be
    approximated by finite differences. It is generally recommended to
    provide the Jacobian rather than relying on a finite-difference
    approximation.
lband, uband : int or None
    Parameters defining the bandwidth of the Jacobian,
    i.e., ``jac[i, j] != 0 only for i - lband <= j <= i + uband``. Setting
    these requires your jac routine to return the Jacobian in the packed format:
    the returned array must have ``n`` columns and ``uband + lband + 1``
    rows in which Jacobian diagonals are written. Specifically
    ``jac_packed[uband + i - j , j] = jac[i, j]``. The same format is used
    in `scipy.linalg.solve_banded` (check for an illustration).
    These parameters can be also used with ``jac=None`` to reduce the
    number of Jacobian elements estimated by finite differences.
vectorized : bool, optional
    Whether `fun` may be called in a vectorized fashion. False (default)
    is recommended for this solver.

    If ``vectorized`` is False, `fun` will always be called with ``y`` of
    shape ``(n,)``, where ``n = len(y0)``.

    If ``vectorized`` is True, `fun` may be called with ``y`` of shape
    ``(n, k)``, where ``k`` is an integer. In this case, `fun` must behave
    such that ``fun(t, y)[:, i] == fun(t, y[:, i])`` (i.e. each column of
    the returned array is the time derivative of the state corresponding
    with a column of ``y``).

    Setting ``vectorized=True`` allows for faster finite difference
    approximation of the Jacobian by methods 'Radau' and 'BDF', but
    will result in slower execution for this solver.

Attributes
----------
n : int
    Number of equations.
status : string
    Current status of the solver: 'running', 'finished' or 'failed'.
t_bound : float
    Boundary time.
direction : float
    Integration direction: +1 or -1.
t : float
    Current time.
y : ndarray
    Current state.
t_old : float
    Previous time. None if no steps were made yet.
nfev : int
    Number of evaluations of the right-hand side.
njev : int
    Number of evaluations of the Jacobian.

References
----------
.. [1] A. C. Hindmarsh, "ODEPACK, A Systematized Collection of ODE
       Solvers," IMACS Transactions on Scientific Computation, Vol 1.,
       pp. 55-64, 1983.
.. [2] L. Petzold, "Automatic selection of methods for solving stiff and
       nonstiff systems of ordinary differential equations", SIAM Journal
       on Scientific and Statistical Computing, Vol. 4, No. 1, pp. 136-148,
       1983.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__ivp_2lsoda_8py_source_l00007}{7}} of file \mbox{\hyperlink{__ivp_2lsoda_8py_source}{lsoda.\+py}}.



\doxysubsection{Constructor \& Destructor Documentation}
\Hypertarget{classscipy_1_1integrate_1_1__ivp_1_1lsoda_1_1LSODA_a38a352e9d3d965d869297c30f47b91a5}\index{scipy.integrate.\_ivp.lsoda.LSODA@{scipy.integrate.\_ivp.lsoda.LSODA}!\_\_init\_\_@{\_\_init\_\_}}
\index{\_\_init\_\_@{\_\_init\_\_}!scipy.integrate.\_ivp.lsoda.LSODA@{scipy.integrate.\_ivp.lsoda.LSODA}}
\doxysubsubsection{\texorpdfstring{\_\_init\_\_()}{\_\_init\_\_()}}
{\footnotesize\ttfamily \label{classscipy_1_1integrate_1_1__ivp_1_1lsoda_1_1LSODA_a38a352e9d3d965d869297c30f47b91a5} 
scipy.\+integrate.\+\_\+ivp.\+lsoda.\+LSODA.\+\_\+\+\_\+init\+\_\+\+\_\+ (\begin{DoxyParamCaption}\item[{}]{self}{, }\item[{}]{fun}{, }\item[{}]{t0}{, }\item[{}]{y0}{, }\item[{}]{t\+\_\+bound}{, }\item[{}]{first\+\_\+step}{ = {\ttfamily None}, }\item[{}]{min\+\_\+step}{ = {\ttfamily 0.0}, }\item[{}]{max\+\_\+step}{ = {\ttfamily np.inf}, }\item[{}]{rtol}{ = {\ttfamily 1e-\/3}, }\item[{}]{atol}{ = {\ttfamily 1e-\/6}, }\item[{}]{jac}{ = {\ttfamily None}, }\item[{}]{lband}{ = {\ttfamily None}, }\item[{}]{uband}{ = {\ttfamily None}, }\item[{}]{vectorized}{ = {\ttfamily False}, }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{extraneous}{}\end{DoxyParamCaption})}



Definition at line \mbox{\hyperlink{__ivp_2lsoda_8py_source_l00118}{118}} of file \mbox{\hyperlink{__ivp_2lsoda_8py_source}{lsoda.\+py}}.



Referenced by \mbox{\hyperlink{kernels_8py_source_l00178}{sklearn.\+gaussian\+\_\+process.\+kernels.\+Kernel.\+get\+\_\+params()}}, and \mbox{\hyperlink{__distn__infrastructure_8py_source_l00643}{scipy.\+stats.\+\_\+distn\+\_\+infrastructure.\+rv\+\_\+generic.\+random\+\_\+state()}}.



\doxysubsection{Member Function Documentation}
\Hypertarget{classscipy_1_1integrate_1_1__ivp_1_1lsoda_1_1LSODA_ac832c34a536e3964092b2187fe59e59f}\index{scipy.integrate.\_ivp.lsoda.LSODA@{scipy.integrate.\_ivp.lsoda.LSODA}!\_dense\_output\_impl@{\_dense\_output\_impl}}
\index{\_dense\_output\_impl@{\_dense\_output\_impl}!scipy.integrate.\_ivp.lsoda.LSODA@{scipy.integrate.\_ivp.lsoda.LSODA}}
\doxysubsubsection{\texorpdfstring{\_dense\_output\_impl()}{\_dense\_output\_impl()}}
{\footnotesize\ttfamily \label{classscipy_1_1integrate_1_1__ivp_1_1lsoda_1_1LSODA_ac832c34a536e3964092b2187fe59e59f} 
scipy.\+integrate.\+\_\+ivp.\+lsoda.\+LSODA.\+\_\+dense\+\_\+output\+\_\+impl (\begin{DoxyParamCaption}\item[{}]{self}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Reimplemented from \mbox{\hyperlink{classscipy_1_1integrate_1_1__ivp_1_1base_1_1OdeSolver}{scipy.\+integrate.\+\_\+ivp.\+base.\+Ode\+Solver}}.



Definition at line \mbox{\hyperlink{__ivp_2lsoda_8py_source_l00176}{176}} of file \mbox{\hyperlink{__ivp_2lsoda_8py_source}{lsoda.\+py}}.

\Hypertarget{classscipy_1_1integrate_1_1__ivp_1_1lsoda_1_1LSODA_ace3065acdd80d9d904668cf8383e9cb0}\index{scipy.integrate.\_ivp.lsoda.LSODA@{scipy.integrate.\_ivp.lsoda.LSODA}!\_step\_impl@{\_step\_impl}}
\index{\_step\_impl@{\_step\_impl}!scipy.integrate.\_ivp.lsoda.LSODA@{scipy.integrate.\_ivp.lsoda.LSODA}}
\doxysubsubsection{\texorpdfstring{\_step\_impl()}{\_step\_impl()}}
{\footnotesize\ttfamily \label{classscipy_1_1integrate_1_1__ivp_1_1lsoda_1_1LSODA_ace3065acdd80d9d904668cf8383e9cb0} 
scipy.\+integrate.\+\_\+ivp.\+lsoda.\+LSODA.\+\_\+step\+\_\+impl (\begin{DoxyParamCaption}\item[{}]{self}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Reimplemented from \mbox{\hyperlink{classscipy_1_1integrate_1_1__ivp_1_1base_1_1OdeSolver}{scipy.\+integrate.\+\_\+ivp.\+base.\+Ode\+Solver}}.



Definition at line \mbox{\hyperlink{__ivp_2lsoda_8py_source_l00153}{153}} of file \mbox{\hyperlink{__ivp_2lsoda_8py_source}{lsoda.\+py}}.



\doxysubsection{Member Data Documentation}
\Hypertarget{classscipy_1_1integrate_1_1__ivp_1_1lsoda_1_1LSODA_a2b746e8fd24b8b6377035da4120d4b32}\index{scipy.integrate.\_ivp.lsoda.LSODA@{scipy.integrate.\_ivp.lsoda.LSODA}!\_lsoda\_solver@{\_lsoda\_solver}}
\index{\_lsoda\_solver@{\_lsoda\_solver}!scipy.integrate.\_ivp.lsoda.LSODA@{scipy.integrate.\_ivp.lsoda.LSODA}}
\doxysubsubsection{\texorpdfstring{\_lsoda\_solver}{\_lsoda\_solver}}
{\footnotesize\ttfamily \label{classscipy_1_1integrate_1_1__ivp_1_1lsoda_1_1LSODA_a2b746e8fd24b8b6377035da4120d4b32} 
scipy.\+integrate.\+\_\+ivp.\+lsoda.\+LSODA.\+\_\+lsoda\+\_\+solver = solver\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{__ivp_2lsoda_8py_source_l00151}{151}} of file \mbox{\hyperlink{__ivp_2lsoda_8py_source}{lsoda.\+py}}.



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/home/jam/\+Research/\+IRES-\/2025/dev/src/llm-\/scripts/testing/hypothesis-\/testing/hyp-\/env/lib/python3.\+12/site-\/packages/scipy/integrate/\+\_\+ivp/lsoda.\+py\end{DoxyCompactItemize}
