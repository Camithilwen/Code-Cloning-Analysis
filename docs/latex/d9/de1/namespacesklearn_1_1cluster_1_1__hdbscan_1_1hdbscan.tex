\doxysection{sklearn.\+cluster.\+\_\+hdbscan.\+hdbscan Namespace Reference}
\hypertarget{namespacesklearn_1_1cluster_1_1__hdbscan_1_1hdbscan}{}\label{namespacesklearn_1_1cluster_1_1__hdbscan_1_1hdbscan}\index{sklearn.cluster.\_hdbscan.hdbscan@{sklearn.cluster.\_hdbscan.hdbscan}}
\doxysubsubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classsklearn_1_1cluster_1_1__hdbscan_1_1hdbscan_1_1HDBSCAN}{HDBSCAN}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacesklearn_1_1cluster_1_1__hdbscan_1_1hdbscan_a8505635b7da6b2dabed894fc218ffe71}{\+\_\+brute\+\_\+mst}} (mutual\+\_\+reachability, min\+\_\+samples)
\item 
\mbox{\hyperlink{namespacesklearn_1_1cluster_1_1__hdbscan_1_1hdbscan_a0056a1701999c446d8369026cd9a2851}{\+\_\+process\+\_\+mst}} (min\+\_\+spanning\+\_\+tree)
\item 
\mbox{\hyperlink{namespacesklearn_1_1cluster_1_1__hdbscan_1_1hdbscan_ac364b710659efc2155e93e0fce61bfb7}{\+\_\+hdbscan\+\_\+brute}} (X, min\+\_\+samples=5, alpha=None, metric="{}euclidean"{}, n\+\_\+jobs=None, copy=False, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}metric\+\_\+params)
\item 
\mbox{\hyperlink{namespacesklearn_1_1cluster_1_1__hdbscan_1_1hdbscan_aacbb27fca6d5752f869888582ff5a960}{\+\_\+hdbscan\+\_\+prims}} (X, algo, min\+\_\+samples=5, alpha=1.\+0, metric="{}euclidean"{}, leaf\+\_\+size=40, n\+\_\+jobs=None, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}metric\+\_\+params)
\item 
\mbox{\hyperlink{namespacesklearn_1_1cluster_1_1__hdbscan_1_1hdbscan_a55e7ac2d3d9e0421d3da0507ef76f6ec}{remap\+\_\+single\+\_\+linkage\+\_\+tree}} (tree, internal\+\_\+to\+\_\+raw, non\+\_\+finite)
\item 
\mbox{\hyperlink{namespacesklearn_1_1cluster_1_1__hdbscan_1_1hdbscan_aa280d83af6a0dd2c0d068a48d8e7597a}{\+\_\+get\+\_\+finite\+\_\+row\+\_\+indices}} (matrix)
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacesklearn_1_1cluster_1_1__hdbscan_1_1hdbscan_ac3ef0a067b4887b0dfe6d0bf6e1767d4}{FAST\+\_\+\+METRICS}} = set(KDTree.\+valid\+\_\+metrics + Ball\+Tree.\+valid\+\_\+metrics)
\item 
dict \mbox{\hyperlink{namespacesklearn_1_1cluster_1_1__hdbscan_1_1hdbscan_a0056d42bb60dbe1f7573aeb4152635ba}{\+\_\+\+OUTLIER\+\_\+\+ENCODING}}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\begin{DoxyVerb}HDBSCAN: Hierarchical Density-Based Spatial Clustering
         of Applications with Noise
\end{DoxyVerb}
 

\doxysubsection{Function Documentation}
\Hypertarget{namespacesklearn_1_1cluster_1_1__hdbscan_1_1hdbscan_a8505635b7da6b2dabed894fc218ffe71}\index{sklearn.cluster.\_hdbscan.hdbscan@{sklearn.cluster.\_hdbscan.hdbscan}!\_brute\_mst@{\_brute\_mst}}
\index{\_brute\_mst@{\_brute\_mst}!sklearn.cluster.\_hdbscan.hdbscan@{sklearn.cluster.\_hdbscan.hdbscan}}
\doxysubsubsection{\texorpdfstring{\_brute\_mst()}{\_brute\_mst()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1cluster_1_1__hdbscan_1_1hdbscan_a8505635b7da6b2dabed894fc218ffe71} 
sklearn.\+cluster.\+\_\+hdbscan.\+hdbscan.\+\_\+brute\+\_\+mst (\begin{DoxyParamCaption}\item[{}]{mutual\+\_\+reachability}{, }\item[{}]{min\+\_\+samples}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Builds a minimum spanning tree (MST) from the provided mutual-reachability
values. This function dispatches to a custom Cython implementation for
dense arrays, and `scipy.sparse.csgraph.minimum_spanning_tree` for sparse
arrays/matrices.

Parameters
----------
mututal_reachability_graph: {ndarray, sparse matrix} of shape \
        (n_samples, n_samples)
    Weighted adjacency matrix of the mutual reachability graph.

min_samples : int, default=None
    The number of samples in a neighborhood for a point
    to be considered as a core point. This includes the point itself.

Returns
-------
mst : ndarray of shape (n_samples - 1,), dtype=MST_edge_dtype
    The MST representation of the mutual-reachability graph. The MST is
    represented as a collection of edges.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{hdbscan_8py_source_l00083}{83}} of file \mbox{\hyperlink{hdbscan_8py_source}{hdbscan.\+py}}.



Referenced by \mbox{\hyperlink{hdbscan_8py_source_l00175}{\+\_\+hdbscan\+\_\+brute()}}.

\Hypertarget{namespacesklearn_1_1cluster_1_1__hdbscan_1_1hdbscan_aa280d83af6a0dd2c0d068a48d8e7597a}\index{sklearn.cluster.\_hdbscan.hdbscan@{sklearn.cluster.\_hdbscan.hdbscan}!\_get\_finite\_row\_indices@{\_get\_finite\_row\_indices}}
\index{\_get\_finite\_row\_indices@{\_get\_finite\_row\_indices}!sklearn.cluster.\_hdbscan.hdbscan@{sklearn.cluster.\_hdbscan.hdbscan}}
\doxysubsubsection{\texorpdfstring{\_get\_finite\_row\_indices()}{\_get\_finite\_row\_indices()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1cluster_1_1__hdbscan_1_1hdbscan_aa280d83af6a0dd2c0d068a48d8e7597a} 
sklearn.\+cluster.\+\_\+hdbscan.\+hdbscan.\+\_\+get\+\_\+finite\+\_\+row\+\_\+indices (\begin{DoxyParamCaption}\item[{}]{matrix}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Returns the indices of the purely finite rows of a
sparse matrix or dense ndarray
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{hdbscan_8py_source_l00405}{405}} of file \mbox{\hyperlink{hdbscan_8py_source}{hdbscan.\+py}}.



Referenced by \mbox{\hyperlink{hdbscan_8py_source_l00693}{sklearn.\+cluster.\+\_\+hdbscan.\+hdbscan.\+HDBSCAN.\+fit()}}.

\Hypertarget{namespacesklearn_1_1cluster_1_1__hdbscan_1_1hdbscan_ac364b710659efc2155e93e0fce61bfb7}\index{sklearn.cluster.\_hdbscan.hdbscan@{sklearn.cluster.\_hdbscan.hdbscan}!\_hdbscan\_brute@{\_hdbscan\_brute}}
\index{\_hdbscan\_brute@{\_hdbscan\_brute}!sklearn.cluster.\_hdbscan.hdbscan@{sklearn.cluster.\_hdbscan.hdbscan}}
\doxysubsubsection{\texorpdfstring{\_hdbscan\_brute()}{\_hdbscan\_brute()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1cluster_1_1__hdbscan_1_1hdbscan_ac364b710659efc2155e93e0fce61bfb7} 
sklearn.\+cluster.\+\_\+hdbscan.\+hdbscan.\+\_\+hdbscan\+\_\+brute (\begin{DoxyParamCaption}\item[{}]{X}{, }\item[{}]{min\+\_\+samples}{ = {\ttfamily 5}, }\item[{}]{alpha}{ = {\ttfamily None}, }\item[{}]{metric}{ = {\ttfamily "{}euclidean"{}}, }\item[{}]{n\+\_\+jobs}{ = {\ttfamily None}, }\item[{}]{copy}{ = {\ttfamily False}, }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{metric\+\_\+params}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Builds a single-linkage tree (SLT) from the input data `X`. If
`metric="precomputed"` then `X` must be a symmetric array of distances.
Otherwise, the pairwise distances are calculated directly and passed to
`mutual_reachability_graph`.

Parameters
----------
X : ndarray of shape (n_samples, n_features) or (n_samples, n_samples)
    Either the raw data from which to compute the pairwise distances,
    or the precomputed distances.

min_samples : int, default=None
    The number of samples in a neighborhood for a point
    to be considered as a core point. This includes the point itself.

alpha : float, default=1.0
    A distance scaling parameter as used in robust single linkage.

metric : str or callable, default='euclidean'
    The metric to use when calculating distance between instances in a
    feature array.

    - If metric is a string or callable, it must be one of
      the options allowed by :func:`~sklearn.metrics.pairwise_distances`
      for its metric parameter.

    - If metric is "precomputed", X is assumed to be a distance matrix and
      must be square.

n_jobs : int, default=None
    The number of jobs to use for computing the pairwise distances. This
    works by breaking down the pairwise matrix into n_jobs even slices and
    computing them in parallel. This parameter is passed directly to
    :func:`~sklearn.metrics.pairwise_distances`.

    ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.
    ``-1`` means using all processors. See :term:`Glossary <n_jobs>`
    for more details.

copy : bool, default=False
    If `copy=True` then any time an in-place modifications would be made
    that would overwrite `X`, a copy will first be made, guaranteeing that
    the original data will be unchanged. Currently, it only applies when
    `metric="precomputed"`, when passing a dense array or a CSR sparse
    array/matrix.

metric_params : dict, default=None
    Arguments passed to the distance metric.

Returns
-------
single_linkage : ndarray of shape (n_samples - 1,), dtype=HIERARCHY_dtype
    The single-linkage tree tree (dendrogram) built from the MST.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{hdbscan_8py_source_l00167}{167}} of file \mbox{\hyperlink{hdbscan_8py_source}{hdbscan.\+py}}.



References \mbox{\hyperlink{hdbscan_8py_source_l00083}{\+\_\+brute\+\_\+mst()}}, and \mbox{\hyperlink{hdbscan_8py_source_l00144}{\+\_\+process\+\_\+mst()}}.

\Hypertarget{namespacesklearn_1_1cluster_1_1__hdbscan_1_1hdbscan_aacbb27fca6d5752f869888582ff5a960}\index{sklearn.cluster.\_hdbscan.hdbscan@{sklearn.cluster.\_hdbscan.hdbscan}!\_hdbscan\_prims@{\_hdbscan\_prims}}
\index{\_hdbscan\_prims@{\_hdbscan\_prims}!sklearn.cluster.\_hdbscan.hdbscan@{sklearn.cluster.\_hdbscan.hdbscan}}
\doxysubsubsection{\texorpdfstring{\_hdbscan\_prims()}{\_hdbscan\_prims()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1cluster_1_1__hdbscan_1_1hdbscan_aacbb27fca6d5752f869888582ff5a960} 
sklearn.\+cluster.\+\_\+hdbscan.\+hdbscan.\+\_\+hdbscan\+\_\+prims (\begin{DoxyParamCaption}\item[{}]{X}{, }\item[{}]{algo}{, }\item[{}]{min\+\_\+samples}{ = {\ttfamily 5}, }\item[{}]{alpha}{ = {\ttfamily 1.0}, }\item[{}]{metric}{ = {\ttfamily "{}euclidean"{}}, }\item[{}]{leaf\+\_\+size}{ = {\ttfamily 40}, }\item[{}]{n\+\_\+jobs}{ = {\ttfamily None}, }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{metric\+\_\+params}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Builds a single-linkage tree (SLT) from the input data `X`. If
`metric="precomputed"` then `X` must be a symmetric array of distances.
Otherwise, the pairwise distances are calculated directly and passed to
`mutual_reachability_graph`.

Parameters
----------
X : ndarray of shape (n_samples, n_features)
    The raw data.

min_samples : int, default=None
    The number of samples in a neighborhood for a point
    to be considered as a core point. This includes the point itself.

alpha : float, default=1.0
    A distance scaling parameter as used in robust single linkage.

metric : str or callable, default='euclidean'
    The metric to use when calculating distance between instances in a
    feature array. `metric` must be one of the options allowed by
    :func:`~sklearn.metrics.pairwise_distances` for its metric
    parameter.

n_jobs : int, default=None
    The number of jobs to use for computing the pairwise distances. This
    works by breaking down the pairwise matrix into n_jobs even slices and
    computing them in parallel. This parameter is passed directly to
    :func:`~sklearn.metrics.pairwise_distances`.

    ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.
    ``-1`` means using all processors. See :term:`Glossary <n_jobs>`
    for more details.

copy : bool, default=False
    If `copy=True` then any time an in-place modifications would be made
    that would overwrite `X`, a copy will first be made, guaranteeing that
    the original data will be unchanged. Currently, it only applies when
    `metric="precomputed"`, when passing a dense array or a CSR sparse
    array/matrix.

metric_params : dict, default=None
    Arguments passed to the distance metric.

Returns
-------
single_linkage : ndarray of shape (n_samples - 1,), dtype=HIERARCHY_dtype
    The single-linkage tree tree (dendrogram) built from the MST.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{hdbscan_8py_source_l00278}{278}} of file \mbox{\hyperlink{hdbscan_8py_source}{hdbscan.\+py}}.



References \mbox{\hyperlink{hdbscan_8py_source_l00144}{\+\_\+process\+\_\+mst()}}.

\Hypertarget{namespacesklearn_1_1cluster_1_1__hdbscan_1_1hdbscan_a0056a1701999c446d8369026cd9a2851}\index{sklearn.cluster.\_hdbscan.hdbscan@{sklearn.cluster.\_hdbscan.hdbscan}!\_process\_mst@{\_process\_mst}}
\index{\_process\_mst@{\_process\_mst}!sklearn.cluster.\_hdbscan.hdbscan@{sklearn.cluster.\_hdbscan.hdbscan}}
\doxysubsubsection{\texorpdfstring{\_process\_mst()}{\_process\_mst()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1cluster_1_1__hdbscan_1_1hdbscan_a0056a1701999c446d8369026cd9a2851} 
sklearn.\+cluster.\+\_\+hdbscan.\+hdbscan.\+\_\+process\+\_\+mst (\begin{DoxyParamCaption}\item[{}]{min\+\_\+spanning\+\_\+tree}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Builds a single-linkage tree (SLT) from the provided minimum spanning tree
(MST). The MST is first sorted then processed by a custom Cython routine.

Parameters
----------
min_spanning_tree : ndarray of shape (n_samples - 1,), dtype=MST_edge_dtype
    The MST representation of the mutual-reachability graph. The MST is
    represented as a collection of edges.

Returns
-------
single_linkage : ndarray of shape (n_samples - 1,), dtype=HIERARCHY_dtype
    The single-linkage tree tree (dendrogram) built from the MST.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{hdbscan_8py_source_l00144}{144}} of file \mbox{\hyperlink{hdbscan_8py_source}{hdbscan.\+py}}.



Referenced by \mbox{\hyperlink{hdbscan_8py_source_l00175}{\+\_\+hdbscan\+\_\+brute()}}, and \mbox{\hyperlink{hdbscan_8py_source_l00287}{\+\_\+hdbscan\+\_\+prims()}}.

\Hypertarget{namespacesklearn_1_1cluster_1_1__hdbscan_1_1hdbscan_a55e7ac2d3d9e0421d3da0507ef76f6ec}\index{sklearn.cluster.\_hdbscan.hdbscan@{sklearn.cluster.\_hdbscan.hdbscan}!remap\_single\_linkage\_tree@{remap\_single\_linkage\_tree}}
\index{remap\_single\_linkage\_tree@{remap\_single\_linkage\_tree}!sklearn.cluster.\_hdbscan.hdbscan@{sklearn.cluster.\_hdbscan.hdbscan}}
\doxysubsubsection{\texorpdfstring{remap\_single\_linkage\_tree()}{remap\_single\_linkage\_tree()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1cluster_1_1__hdbscan_1_1hdbscan_a55e7ac2d3d9e0421d3da0507ef76f6ec} 
sklearn.\+cluster.\+\_\+hdbscan.\+hdbscan.\+remap\+\_\+single\+\_\+linkage\+\_\+tree (\begin{DoxyParamCaption}\item[{}]{tree}{, }\item[{}]{internal\+\_\+to\+\_\+raw}{, }\item[{}]{non\+\_\+finite}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Takes an internal single_linkage_tree structure and adds back in a set of points
that were initially detected as non-finite and returns that new tree.
These points will all be merged into the final node at np.inf distance and
considered noise points.

Parameters
----------
tree : ndarray of shape (n_samples - 1,), dtype=HIERARCHY_dtype
    The single-linkage tree tree (dendrogram) built from the MST.
internal_to_raw: dict
    A mapping from internal integer index to the raw integer index
non_finite : ndarray
    Boolean array of which entries in the raw data are non-finite
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{hdbscan_8py_source_l00360}{360}} of file \mbox{\hyperlink{hdbscan_8py_source}{hdbscan.\+py}}.



Referenced by \mbox{\hyperlink{hdbscan_8py_source_l00693}{sklearn.\+cluster.\+\_\+hdbscan.\+hdbscan.\+HDBSCAN.\+fit()}}.



\doxysubsection{Variable Documentation}
\Hypertarget{namespacesklearn_1_1cluster_1_1__hdbscan_1_1hdbscan_a0056d42bb60dbe1f7573aeb4152635ba}\index{sklearn.cluster.\_hdbscan.hdbscan@{sklearn.cluster.\_hdbscan.hdbscan}!\_OUTLIER\_ENCODING@{\_OUTLIER\_ENCODING}}
\index{\_OUTLIER\_ENCODING@{\_OUTLIER\_ENCODING}!sklearn.cluster.\_hdbscan.hdbscan@{sklearn.cluster.\_hdbscan.hdbscan}}
\doxysubsubsection{\texorpdfstring{\_OUTLIER\_ENCODING}{\_OUTLIER\_ENCODING}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1cluster_1_1__hdbscan_1_1hdbscan_a0056d42bb60dbe1f7573aeb4152635ba} 
dict sklearn.\+cluster.\+\_\+hdbscan.\+hdbscan.\+\_\+\+OUTLIER\+\_\+\+ENCODING\hspace{0.3cm}{\ttfamily [protected]}}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ \{}
\DoxyCodeLine{00002\ \ \ \ \ \textcolor{stringliteral}{"{}infinite"{}}:\ \{}
\DoxyCodeLine{00003\ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}label"{}}:\ -\/2,}
\DoxyCodeLine{00004\ \ \ \ \ \ \ \ \ \textcolor{comment}{\#\ The\ probability\ could\ also\ be\ 1,\ since\ infinite\ points\ are\ certainly}}
\DoxyCodeLine{00005\ \ \ \ \ \ \ \ \ \textcolor{comment}{\#\ infinite\ outliers,\ however\ 0\ is\ convention\ from\ the\ HDBSCAN\ library}}
\DoxyCodeLine{00006\ \ \ \ \ \ \ \ \ \textcolor{comment}{\#\ implementation.}}
\DoxyCodeLine{00007\ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}prob"{}}:\ 0,}
\DoxyCodeLine{00008\ \ \ \ \ \},}
\DoxyCodeLine{00009\ \ \ \ \ \textcolor{stringliteral}{"{}missing"{}}:\ \{}
\DoxyCodeLine{00010\ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}label"{}}:\ -\/3,}
\DoxyCodeLine{00011\ \ \ \ \ \ \ \ \ \textcolor{comment}{\#\ A\ nan\ probability\ is\ chosen\ to\ emphasize\ the\ fact\ that\ the}}
\DoxyCodeLine{00012\ \ \ \ \ \ \ \ \ \textcolor{comment}{\#\ corresponding\ data\ was\ not\ considered\ in\ the\ clustering\ problem.}}
\DoxyCodeLine{00013\ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}prob"{}}:\ np.nan,}
\DoxyCodeLine{00014\ \ \ \ \ \},}
\DoxyCodeLine{00015\ \}}

\end{DoxyCode}


Definition at line \mbox{\hyperlink{hdbscan_8py_source_l00066}{66}} of file \mbox{\hyperlink{hdbscan_8py_source}{hdbscan.\+py}}.

\Hypertarget{namespacesklearn_1_1cluster_1_1__hdbscan_1_1hdbscan_ac3ef0a067b4887b0dfe6d0bf6e1767d4}\index{sklearn.cluster.\_hdbscan.hdbscan@{sklearn.cluster.\_hdbscan.hdbscan}!FAST\_METRICS@{FAST\_METRICS}}
\index{FAST\_METRICS@{FAST\_METRICS}!sklearn.cluster.\_hdbscan.hdbscan@{sklearn.cluster.\_hdbscan.hdbscan}}
\doxysubsubsection{\texorpdfstring{FAST\_METRICS}{FAST\_METRICS}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1cluster_1_1__hdbscan_1_1hdbscan_ac3ef0a067b4887b0dfe6d0bf6e1767d4} 
sklearn.\+cluster.\+\_\+hdbscan.\+hdbscan.\+FAST\+\_\+\+METRICS = set(KDTree.\+valid\+\_\+metrics + Ball\+Tree.\+valid\+\_\+metrics)}



Definition at line \mbox{\hyperlink{hdbscan_8py_source_l00061}{61}} of file \mbox{\hyperlink{hdbscan_8py_source}{hdbscan.\+py}}.

