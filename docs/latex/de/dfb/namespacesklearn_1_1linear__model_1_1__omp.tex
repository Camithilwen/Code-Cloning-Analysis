\doxysection{sklearn.\+linear\+\_\+model.\+\_\+omp Namespace Reference}
\hypertarget{namespacesklearn_1_1linear__model_1_1__omp}{}\label{namespacesklearn_1_1linear__model_1_1__omp}\index{sklearn.linear\_model.\_omp@{sklearn.linear\_model.\_omp}}
\doxysubsubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classsklearn_1_1linear__model_1_1__omp_1_1OrthogonalMatchingPursuit}{Orthogonal\+Matching\+Pursuit}}
\item 
class \mbox{\hyperlink{classsklearn_1_1linear__model_1_1__omp_1_1OrthogonalMatchingPursuitCV}{Orthogonal\+Matching\+Pursuit\+CV}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacesklearn_1_1linear__model_1_1__omp_af5c3386d2b91c7a872f9621e2ff78433}{\+\_\+cholesky\+\_\+omp}} (X, y, n\+\_\+nonzero\+\_\+coefs, tol=None, copy\+\_\+X=\mbox{\hyperlink{classTrue}{True}}, return\+\_\+path=False)
\item 
\mbox{\hyperlink{namespacesklearn_1_1linear__model_1_1__omp_a60447e23f1104fa0f9d0832e1a0ba1d4}{\+\_\+gram\+\_\+omp}} (Gram, Xy, n\+\_\+nonzero\+\_\+coefs, tol\+\_\+0=None, tol=None, copy\+\_\+\+Gram=\mbox{\hyperlink{classTrue}{True}}, copy\+\_\+\+Xy=\mbox{\hyperlink{classTrue}{True}}, return\+\_\+path=False)
\item 
\mbox{\hyperlink{namespacesklearn_1_1linear__model_1_1__omp_a6c86a716a91aca07dd2613cba5c337f7}{orthogonal\+\_\+mp}} (X, y, \texorpdfstring{$\ast$}{*}, n\+\_\+nonzero\+\_\+coefs=None, tol=None, precompute=False, copy\+\_\+X=\mbox{\hyperlink{classTrue}{True}}, return\+\_\+path=False, return\+\_\+n\+\_\+iter=False)
\item 
\mbox{\hyperlink{namespacesklearn_1_1linear__model_1_1__omp_a5b21e89a09f4a87d34c6376e8f2e1301}{orthogonal\+\_\+mp\+\_\+gram}} (Gram, Xy, \texorpdfstring{$\ast$}{*}, n\+\_\+nonzero\+\_\+coefs=None, tol=None, norms\+\_\+squared=None, copy\+\_\+\+Gram=\mbox{\hyperlink{classTrue}{True}}, copy\+\_\+\+Xy=\mbox{\hyperlink{classTrue}{True}}, return\+\_\+path=False, return\+\_\+n\+\_\+iter=False)
\item 
\mbox{\hyperlink{namespacesklearn_1_1linear__model_1_1__omp_a396525b2cecfcb1ab5aa7b7733f46a11}{\+\_\+omp\+\_\+path\+\_\+residues}} (X\+\_\+train, y\+\_\+train, X\+\_\+test, y\+\_\+test, copy=\mbox{\hyperlink{classTrue}{True}}, fit\+\_\+intercept=\mbox{\hyperlink{classTrue}{True}}, max\+\_\+iter=100)
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
tuple \mbox{\hyperlink{namespacesklearn_1_1linear__model_1_1__omp_ad6545a9caaa88dd6611d8287bd5d5032}{premature}}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\begin{DoxyVerb}Orthogonal matching pursuit algorithms\end{DoxyVerb}
 

\doxysubsection{Function Documentation}
\Hypertarget{namespacesklearn_1_1linear__model_1_1__omp_af5c3386d2b91c7a872f9621e2ff78433}\index{sklearn.linear\_model.\_omp@{sklearn.linear\_model.\_omp}!\_cholesky\_omp@{\_cholesky\_omp}}
\index{\_cholesky\_omp@{\_cholesky\_omp}!sklearn.linear\_model.\_omp@{sklearn.linear\_model.\_omp}}
\doxysubsubsection{\texorpdfstring{\_cholesky\_omp()}{\_cholesky\_omp()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1linear__model_1_1__omp_af5c3386d2b91c7a872f9621e2ff78433} 
sklearn.\+linear\+\_\+model.\+\_\+omp.\+\_\+cholesky\+\_\+omp (\begin{DoxyParamCaption}\item[{}]{X}{, }\item[{}]{y}{, }\item[{}]{n\+\_\+nonzero\+\_\+coefs}{, }\item[{}]{tol}{ = {\ttfamily None}, }\item[{}]{copy\+\_\+X}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}, }\item[{}]{return\+\_\+path}{ = {\ttfamily False}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Orthogonal Matching Pursuit step using the Cholesky decomposition.

Parameters
----------
X : ndarray of shape (n_samples, n_features)
    Input dictionary. Columns are assumed to have unit norm.

y : ndarray of shape (n_samples,)
    Input targets.

n_nonzero_coefs : int
    Targeted number of non-zero elements.

tol : float, default=None
    Targeted squared error, if not None overrides n_nonzero_coefs.

copy_X : bool, default=True
    Whether the design matrix X must be copied by the algorithm. A false
    value is only helpful if X is already Fortran-ordered, otherwise a
    copy is made anyway.

return_path : bool, default=False
    Whether to return every value of the nonzero coefficients along the
    forward path. Useful for cross-validation.

Returns
-------
gamma : ndarray of shape (n_nonzero_coefs,)
    Non-zero elements of the solution.

idx : ndarray of shape (n_nonzero_coefs,)
    Indices of the positions of the elements in gamma within the solution
    vector.

coef : ndarray of shape (n_features, n_nonzero_coefs)
    The first k values of column k correspond to the coefficient value
    for the active features at that step. The lower left triangle contains
    garbage. Only returned if ``return_path=True``.

n_active : int
    Number of active features at convergence.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__omp_8py_source_l00036}{36}} of file \mbox{\hyperlink{__omp_8py_source}{\+\_\+omp.\+py}}.



Referenced by \mbox{\hyperlink{__omp_8py_source_l00313}{orthogonal\+\_\+mp()}}.

\Hypertarget{namespacesklearn_1_1linear__model_1_1__omp_a60447e23f1104fa0f9d0832e1a0ba1d4}\index{sklearn.linear\_model.\_omp@{sklearn.linear\_model.\_omp}!\_gram\_omp@{\_gram\_omp}}
\index{\_gram\_omp@{\_gram\_omp}!sklearn.linear\_model.\_omp@{sklearn.linear\_model.\_omp}}
\doxysubsubsection{\texorpdfstring{\_gram\_omp()}{\_gram\_omp()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1linear__model_1_1__omp_a60447e23f1104fa0f9d0832e1a0ba1d4} 
sklearn.\+linear\+\_\+model.\+\_\+omp.\+\_\+gram\+\_\+omp (\begin{DoxyParamCaption}\item[{}]{Gram}{, }\item[{}]{Xy}{, }\item[{}]{n\+\_\+nonzero\+\_\+coefs}{, }\item[{}]{tol\+\_\+0}{ = {\ttfamily None}, }\item[{}]{tol}{ = {\ttfamily None}, }\item[{}]{copy\+\_\+\+Gram}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}, }\item[{}]{copy\+\_\+\+Xy}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}, }\item[{}]{return\+\_\+path}{ = {\ttfamily False}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Orthogonal Matching Pursuit step on a precomputed Gram matrix.

This function uses the Cholesky decomposition method.

Parameters
----------
Gram : ndarray of shape (n_features, n_features)
    Gram matrix of the input data matrix.

Xy : ndarray of shape (n_features,)
    Input targets.

n_nonzero_coefs : int
    Targeted number of non-zero elements.

tol_0 : float, default=None
    Squared norm of y, required if tol is not None.

tol : float, default=None
    Targeted squared error, if not None overrides n_nonzero_coefs.

copy_Gram : bool, default=True
    Whether the gram matrix must be copied by the algorithm. A false
    value is only helpful if it is already Fortran-ordered, otherwise a
    copy is made anyway.

copy_Xy : bool, default=True
    Whether the covariance vector Xy must be copied by the algorithm.
    If False, it may be overwritten.

return_path : bool, default=False
    Whether to return every value of the nonzero coefficients along the
    forward path. Useful for cross-validation.

Returns
-------
gamma : ndarray of shape (n_nonzero_coefs,)
    Non-zero elements of the solution.

idx : ndarray of shape (n_nonzero_coefs,)
    Indices of the positions of the elements in gamma within the solution
    vector.

coefs : ndarray of shape (n_features, n_nonzero_coefs)
    The first k values of column k correspond to the coefficient value
    for the active features at that step. The lower left triangle contains
    garbage. Only returned if ``return_path=True``.

n_active : int
    Number of active features at convergence.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__omp_8py_source_l00152}{152}} of file \mbox{\hyperlink{__omp_8py_source}{\+\_\+omp.\+py}}.



Referenced by \mbox{\hyperlink{__omp_8py_source_l00492}{orthogonal\+\_\+mp\+\_\+gram()}}.

\Hypertarget{namespacesklearn_1_1linear__model_1_1__omp_a396525b2cecfcb1ab5aa7b7733f46a11}\index{sklearn.linear\_model.\_omp@{sklearn.linear\_model.\_omp}!\_omp\_path\_residues@{\_omp\_path\_residues}}
\index{\_omp\_path\_residues@{\_omp\_path\_residues}!sklearn.linear\_model.\_omp@{sklearn.linear\_model.\_omp}}
\doxysubsubsection{\texorpdfstring{\_omp\_path\_residues()}{\_omp\_path\_residues()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1linear__model_1_1__omp_a396525b2cecfcb1ab5aa7b7733f46a11} 
sklearn.\+linear\+\_\+model.\+\_\+omp.\+\_\+omp\+\_\+path\+\_\+residues (\begin{DoxyParamCaption}\item[{}]{X\+\_\+train}{, }\item[{}]{y\+\_\+train}{, }\item[{}]{X\+\_\+test}{, }\item[{}]{y\+\_\+test}{, }\item[{}]{copy}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}, }\item[{}]{fit\+\_\+intercept}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}, }\item[{}]{max\+\_\+iter}{ = {\ttfamily 100}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Compute the residues on left-out data for a full LARS path.

Parameters
----------
X_train : ndarray of shape (n_samples, n_features)
    The data to fit the LARS on.

y_train : ndarray of shape (n_samples)
    The target variable to fit LARS on.

X_test : ndarray of shape (n_samples, n_features)
    The data to compute the residues on.

y_test : ndarray of shape (n_samples)
    The target variable to compute the residues on.

copy : bool, default=True
    Whether X_train, X_test, y_train and y_test should be copied.  If
    False, they may be overwritten.

fit_intercept : bool, default=True
    Whether to calculate the intercept for this model. If set
    to false, no intercept will be used in calculations
    (i.e. data is expected to be centered).

max_iter : int, default=100
    Maximum numbers of iterations to perform, therefore maximum features
    to include. 100 by default.

Returns
-------
residues : ndarray of shape (n_samples, max_features)
    Residues of the prediction on the test data.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__omp_8py_source_l00819}{819}} of file \mbox{\hyperlink{__omp_8py_source}{\+\_\+omp.\+py}}.



References \mbox{\hyperlink{__omp_8py_source_l00313}{orthogonal\+\_\+mp()}}.

\Hypertarget{namespacesklearn_1_1linear__model_1_1__omp_a6c86a716a91aca07dd2613cba5c337f7}\index{sklearn.linear\_model.\_omp@{sklearn.linear\_model.\_omp}!orthogonal\_mp@{orthogonal\_mp}}
\index{orthogonal\_mp@{orthogonal\_mp}!sklearn.linear\_model.\_omp@{sklearn.linear\_model.\_omp}}
\doxysubsubsection{\texorpdfstring{orthogonal\_mp()}{orthogonal\_mp()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1linear__model_1_1__omp_a6c86a716a91aca07dd2613cba5c337f7} 
sklearn.\+linear\+\_\+model.\+\_\+omp.\+orthogonal\+\_\+mp (\begin{DoxyParamCaption}\item[{}]{X}{, }\item[{}]{y}{, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{n\+\_\+nonzero\+\_\+coefs}{ = {\ttfamily None}, }\item[{}]{tol}{ = {\ttfamily None}, }\item[{}]{precompute}{ = {\ttfamily False}, }\item[{}]{copy\+\_\+X}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}, }\item[{}]{return\+\_\+path}{ = {\ttfamily False}, }\item[{}]{return\+\_\+n\+\_\+iter}{ = {\ttfamily False}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Orthogonal Matching Pursuit (OMP).

Solves n_targets Orthogonal Matching Pursuit problems.
An instance of the problem has the form:

When parametrized by the number of non-zero coefficients using
`n_nonzero_coefs`:
argmin ||y - X\gamma||^2 subject to ||\gamma||_0 <= n_{nonzero coefs}

When parametrized by error using the parameter `tol`:
argmin ||\gamma||_0 subject to ||y - X\gamma||^2 <= tol

Read more in the :ref:`User Guide <omp>`.

Parameters
----------
X : array-like of shape (n_samples, n_features)
    Input data. Columns are assumed to have unit norm.

y : ndarray of shape (n_samples,) or (n_samples, n_targets)
    Input targets.

n_nonzero_coefs : int, default=None
    Desired number of non-zero entries in the solution. If None (by
    default) this value is set to 10% of n_features.

tol : float, default=None
    Maximum squared norm of the residual. If not None, overrides n_nonzero_coefs.

precompute : 'auto' or bool, default=False
    Whether to perform precomputations. Improves performance when n_targets
    or n_samples is very large.

copy_X : bool, default=True
    Whether the design matrix X must be copied by the algorithm. A false
    value is only helpful if X is already Fortran-ordered, otherwise a
    copy is made anyway.

return_path : bool, default=False
    Whether to return every value of the nonzero coefficients along the
    forward path. Useful for cross-validation.

return_n_iter : bool, default=False
    Whether or not to return the number of iterations.

Returns
-------
coef : ndarray of shape (n_features,) or (n_features, n_targets)
    Coefficients of the OMP solution. If `return_path=True`, this contains
    the whole coefficient path. In this case its shape is
    (n_features, n_features) or (n_features, n_targets, n_features) and
    iterating over the last axis generates coefficients in increasing order
    of active features.

n_iters : array-like or int
    Number of active features across every target. Returned only if
    `return_n_iter` is set to True.

See Also
--------
OrthogonalMatchingPursuit : Orthogonal Matching Pursuit model.
orthogonal_mp_gram : Solve OMP problems using Gram matrix and the product X.T * y.
lars_path : Compute Least Angle Regression or Lasso path using LARS algorithm.
sklearn.decomposition.sparse_encode : Sparse coding.

Notes
-----
Orthogonal matching pursuit was introduced in S. Mallat, Z. Zhang,
Matching pursuits with time-frequency dictionaries, IEEE Transactions on
Signal Processing, Vol. 41, No. 12. (December 1993), pp. 3397-3415.
(https://www.di.ens.fr/~mallat/papiers/MallatPursuit93.pdf)

This implementation is based on Rubinstein, R., Zibulevsky, M. and Elad,
M., Efficient Implementation of the K-SVD Algorithm using Batch Orthogonal
Matching Pursuit Technical Report - CS Technion, April 2008.
https://www.cs.technion.ac.il/~ronrubin/Publications/KSVD-OMP-v2.pdf

Examples
--------
>>> from sklearn.datasets import make_regression
>>> from sklearn.linear_model import orthogonal_mp
>>> X, y = make_regression(noise=4, random_state=0)
>>> coef = orthogonal_mp(X, y)
>>> coef.shape
(100,)
>>> X[:1,] @ coef
array([-78.68])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__omp_8py_source_l00303}{303}} of file \mbox{\hyperlink{__omp_8py_source}{\+\_\+omp.\+py}}.



References \mbox{\hyperlink{__omp_8py_source_l00036}{\+\_\+cholesky\+\_\+omp()}}, and \mbox{\hyperlink{__omp_8py_source_l00492}{orthogonal\+\_\+mp\+\_\+gram()}}.



Referenced by \mbox{\hyperlink{__omp_8py_source_l00827}{\+\_\+omp\+\_\+path\+\_\+residues()}}, and \mbox{\hyperlink{__omp_8py_source_l00756}{sklearn.\+linear\+\_\+model.\+\_\+omp.\+Orthogonal\+Matching\+Pursuit.\+fit()}}.

\Hypertarget{namespacesklearn_1_1linear__model_1_1__omp_a5b21e89a09f4a87d34c6376e8f2e1301}\index{sklearn.linear\_model.\_omp@{sklearn.linear\_model.\_omp}!orthogonal\_mp\_gram@{orthogonal\_mp\_gram}}
\index{orthogonal\_mp\_gram@{orthogonal\_mp\_gram}!sklearn.linear\_model.\_omp@{sklearn.linear\_model.\_omp}}
\doxysubsubsection{\texorpdfstring{orthogonal\_mp\_gram()}{orthogonal\_mp\_gram()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1linear__model_1_1__omp_a5b21e89a09f4a87d34c6376e8f2e1301} 
sklearn.\+linear\+\_\+model.\+\_\+omp.\+orthogonal\+\_\+mp\+\_\+gram (\begin{DoxyParamCaption}\item[{}]{Gram}{, }\item[{}]{Xy}{, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{n\+\_\+nonzero\+\_\+coefs}{ = {\ttfamily None}, }\item[{}]{tol}{ = {\ttfamily None}, }\item[{}]{norms\+\_\+squared}{ = {\ttfamily None}, }\item[{}]{copy\+\_\+\+Gram}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}, }\item[{}]{copy\+\_\+\+Xy}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}, }\item[{}]{return\+\_\+path}{ = {\ttfamily False}, }\item[{}]{return\+\_\+n\+\_\+iter}{ = {\ttfamily False}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Gram Orthogonal Matching Pursuit (OMP).

Solves n_targets Orthogonal Matching Pursuit problems using only
the Gram matrix X.T * X and the product X.T * y.

Read more in the :ref:`User Guide <omp>`.

Parameters
----------
Gram : array-like of shape (n_features, n_features)
    Gram matrix of the input data: `X.T * X`.

Xy : array-like of shape (n_features,) or (n_features, n_targets)
    Input targets multiplied by `X`: `X.T * y`.

n_nonzero_coefs : int, default=None
    Desired number of non-zero entries in the solution. If `None` (by
    default) this value is set to 10% of n_features.

tol : float, default=None
    Maximum squared norm of the residual. If not `None`,
    overrides `n_nonzero_coefs`.

norms_squared : array-like of shape (n_targets,), default=None
    Squared L2 norms of the lines of `y`. Required if `tol` is not None.

copy_Gram : bool, default=True
    Whether the gram matrix must be copied by the algorithm. A `False`
    value is only helpful if it is already Fortran-ordered, otherwise a
    copy is made anyway.

copy_Xy : bool, default=True
    Whether the covariance vector `Xy` must be copied by the algorithm.
    If `False`, it may be overwritten.

return_path : bool, default=False
    Whether to return every value of the nonzero coefficients along the
    forward path. Useful for cross-validation.

return_n_iter : bool, default=False
    Whether or not to return the number of iterations.

Returns
-------
coef : ndarray of shape (n_features,) or (n_features, n_targets)
    Coefficients of the OMP solution. If `return_path=True`, this contains
    the whole coefficient path. In this case its shape is
    `(n_features, n_features)` or `(n_features, n_targets, n_features)` and
    iterating over the last axis yields coefficients in increasing order
    of active features.

n_iters : list or int
    Number of active features across every target. Returned only if
    `return_n_iter` is set to True.

See Also
--------
OrthogonalMatchingPursuit : Orthogonal Matching Pursuit model (OMP).
orthogonal_mp : Solves n_targets Orthogonal Matching Pursuit problems.
lars_path : Compute Least Angle Regression or Lasso path using
    LARS algorithm.
sklearn.decomposition.sparse_encode : Generic sparse coding.
    Each column of the result is the solution to a Lasso problem.

Notes
-----
Orthogonal matching pursuit was introduced in G. Mallat, Z. Zhang,
Matching pursuits with time-frequency dictionaries, IEEE Transactions on
Signal Processing, Vol. 41, No. 12. (December 1993), pp. 3397-3415.
(https://www.di.ens.fr/~mallat/papiers/MallatPursuit93.pdf)

This implementation is based on Rubinstein, R., Zibulevsky, M. and Elad,
M., Efficient Implementation of the K-SVD Algorithm using Batch Orthogonal
Matching Pursuit Technical Report - CS Technion, April 2008.
https://www.cs.technion.ac.il/~ronrubin/Publications/KSVD-OMP-v2.pdf

Examples
--------
>>> from sklearn.datasets import make_regression
>>> from sklearn.linear_model import orthogonal_mp_gram
>>> X, y = make_regression(noise=4, random_state=0)
>>> coef = orthogonal_mp_gram(X.T @ X, X.T @ y)
>>> coef.shape
(100,)
>>> X[:1,] @ coef
array([-78.68])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__omp_8py_source_l00481}{481}} of file \mbox{\hyperlink{__omp_8py_source}{\+\_\+omp.\+py}}.



References \mbox{\hyperlink{__omp_8py_source_l00161}{\+\_\+gram\+\_\+omp()}}.



Referenced by \mbox{\hyperlink{__omp_8py_source_l00756}{sklearn.\+linear\+\_\+model.\+\_\+omp.\+Orthogonal\+Matching\+Pursuit.\+fit()}}, and \mbox{\hyperlink{__omp_8py_source_l00313}{orthogonal\+\_\+mp()}}.



\doxysubsection{Variable Documentation}
\Hypertarget{namespacesklearn_1_1linear__model_1_1__omp_ad6545a9caaa88dd6611d8287bd5d5032}\index{sklearn.linear\_model.\_omp@{sklearn.linear\_model.\_omp}!premature@{premature}}
\index{premature@{premature}!sklearn.linear\_model.\_omp@{sklearn.linear\_model.\_omp}}
\doxysubsubsection{\texorpdfstring{premature}{premature}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1linear__model_1_1__omp_ad6545a9caaa88dd6611d8287bd5d5032} 
tuple sklearn.\+linear\+\_\+model.\+\_\+omp.\+premature}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ (}
\DoxyCodeLine{00002\ \ \ \ \ \textcolor{stringliteral}{"{}Orthogonal\ matching\ pursuit\ ended\ prematurely\ due\ to\ linear"{}}}
\DoxyCodeLine{00003\ \ \ \ \ \textcolor{stringliteral}{"{}\ dependence\ in\ the\ dictionary.\ The\ requested\ precision\ might"{}}}
\DoxyCodeLine{00004\ \ \ \ \ \textcolor{stringliteral}{"{}\ not\ have\ been\ met."{}}}
\DoxyCodeLine{00005\ )}

\end{DoxyCode}


Definition at line \mbox{\hyperlink{__omp_8py_source_l00029}{29}} of file \mbox{\hyperlink{__omp_8py_source}{\+\_\+omp.\+py}}.

