\doxysection{scipy.\+linalg.\+\_\+solvers Namespace Reference}
\hypertarget{namespacescipy_1_1linalg_1_1__solvers}{}\label{namespacescipy_1_1linalg_1_1__solvers}\index{scipy.linalg.\_solvers@{scipy.linalg.\_solvers}}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacescipy_1_1linalg_1_1__solvers_a3998015d397914b80c35bc7d05d51a87}{solve\+\_\+sylvester}} (a, b, q)
\item 
\mbox{\hyperlink{namespacescipy_1_1linalg_1_1__solvers_ad7c0774545127a1e4f46eb3fac815dc9}{solve\+\_\+continuous\+\_\+lyapunov}} (a, q)
\item 
\mbox{\hyperlink{namespacescipy_1_1linalg_1_1__solvers_ad5b508c50219bea8dff25c55223ef298}{\+\_\+solve\+\_\+discrete\+\_\+lyapunov\+\_\+direct}} (a, q)
\item 
\mbox{\hyperlink{namespacescipy_1_1linalg_1_1__solvers_aa8f4f41f8966738e4a985320a2c25553}{\+\_\+solve\+\_\+discrete\+\_\+lyapunov\+\_\+bilinear}} (a, q)
\item 
\mbox{\hyperlink{namespacescipy_1_1linalg_1_1__solvers_a69e3106f77513c66be82cc205a378763}{solve\+\_\+discrete\+\_\+lyapunov}} (a, q, method=None)
\item 
\mbox{\hyperlink{namespacescipy_1_1linalg_1_1__solvers_ae6dc294d2a4d07e61a77477c8107bc00}{solve\+\_\+continuous\+\_\+are}} (a, b, q, r, e=None, s=None, balanced=\mbox{\hyperlink{classTrue}{True}})
\item 
\mbox{\hyperlink{namespacescipy_1_1linalg_1_1__solvers_add5d1844118d8a79aae4a71660894ab8}{solve\+\_\+discrete\+\_\+are}} (a, b, q, r, e=None, s=None, balanced=\mbox{\hyperlink{classTrue}{True}})
\item 
\mbox{\hyperlink{namespacescipy_1_1linalg_1_1__solvers_aa6825788563b9a2e2b62176d2c46b06c}{\+\_\+are\+\_\+validate\+\_\+args}} (a, b, q, r, e, s, eq\+\_\+type=\textquotesingle{}care\textquotesingle{})
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
list \mbox{\hyperlink{namespacescipy_1_1linalg_1_1__solvers_ae47545360ff6e70df51361aee24589d3}{\+\_\+\+\_\+all\+\_\+\+\_\+}}
\item 
\mbox{\hyperlink{namespacescipy_1_1linalg_1_1__solvers_ae887ddd4ca47310dc4cc334f1e07d9ca}{solve\+\_\+lyapunov}} = \mbox{\hyperlink{namespacescipy_1_1linalg_1_1__solvers_ad7c0774545127a1e4f46eb3fac815dc9}{solve\+\_\+continuous\+\_\+lyapunov}}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\begin{DoxyVerb}Matrix equation solver routines\end{DoxyVerb}
 

\doxysubsection{Function Documentation}
\Hypertarget{namespacescipy_1_1linalg_1_1__solvers_aa6825788563b9a2e2b62176d2c46b06c}\index{scipy.linalg.\_solvers@{scipy.linalg.\_solvers}!\_are\_validate\_args@{\_are\_validate\_args}}
\index{\_are\_validate\_args@{\_are\_validate\_args}!scipy.linalg.\_solvers@{scipy.linalg.\_solvers}}
\doxysubsubsection{\texorpdfstring{\_are\_validate\_args()}{\_are\_validate\_args()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1linalg_1_1__solvers_aa6825788563b9a2e2b62176d2c46b06c} 
scipy.\+linalg.\+\_\+solvers.\+\_\+are\+\_\+validate\+\_\+args (\begin{DoxyParamCaption}\item[{}]{a}{, }\item[{}]{b}{, }\item[{}]{q}{, }\item[{}]{r}{, }\item[{}]{e}{, }\item[{}]{s}{, }\item[{}]{eq\+\_\+type}{ = {\ttfamily \textquotesingle{}care\textquotesingle{}}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}A helper function to validate the arguments supplied to the
Riccati equation solvers. Any discrepancy found in the input
matrices leads to a ``ValueError`` exception.

Essentially, it performs:

    - a check whether the input is free of NaN and Infs
    - a pass for the data through ``numpy.atleast_2d()``
    - squareness check of the relevant arrays
    - shape consistency check of the arrays
    - singularity check of the relevant arrays
    - symmetricity check of the relevant matrices
    - a check whether the regular or the generalized version is asked.

This function is used by ``solve_continuous_are`` and
``solve_discrete_are``.

Parameters
----------
a, b, q, r, e, s : array_like
    Input data
eq_type : str
    Accepted arguments are 'care' and 'dare'.

Returns
-------
a, b, q, r, e, s : ndarray
    Regularized input data
m, n : int
    shape of the problem
r_or_c : type
    Data type of the problem, returns float or complex
gen_or_not : bool
    Type of the equation, True for generalized and False for regular ARE.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__solvers_8py_source_l00742}{742}} of file \mbox{\hyperlink{__solvers_8py_source}{\+\_\+solvers.\+py}}.



References \mbox{\hyperlink{__decomp__svd_8py_source_l00014}{scipy.\+linalg.\+\_\+decomp\+\_\+svd.\+svd()}}.



Referenced by \mbox{\hyperlink{__solvers_8py_source_l00328}{solve\+\_\+continuous\+\_\+are()}}, and \mbox{\hyperlink{__solvers_8py_source_l00533}{solve\+\_\+discrete\+\_\+are()}}.

\Hypertarget{namespacescipy_1_1linalg_1_1__solvers_aa8f4f41f8966738e4a985320a2c25553}\index{scipy.linalg.\_solvers@{scipy.linalg.\_solvers}!\_solve\_discrete\_lyapunov\_bilinear@{\_solve\_discrete\_lyapunov\_bilinear}}
\index{\_solve\_discrete\_lyapunov\_bilinear@{\_solve\_discrete\_lyapunov\_bilinear}!scipy.linalg.\_solvers@{scipy.linalg.\_solvers}}
\doxysubsubsection{\texorpdfstring{\_solve\_discrete\_lyapunov\_bilinear()}{\_solve\_discrete\_lyapunov\_bilinear()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1linalg_1_1__solvers_aa8f4f41f8966738e4a985320a2c25553} 
scipy.\+linalg.\+\_\+solvers.\+\_\+solve\+\_\+discrete\+\_\+lyapunov\+\_\+bilinear (\begin{DoxyParamCaption}\item[{}]{a}{, }\item[{}]{q}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Solves the discrete Lyapunov equation using a bilinear transformation.

This function is called by the `solve_discrete_lyapunov` function with
`method=bilinear`. It is not supposed to be called directly.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__solvers_8py_source_l00221}{221}} of file \mbox{\hyperlink{__solvers_8py_source}{\+\_\+solvers.\+py}}.



References \mbox{\hyperlink{linalg_2__basic_8py_source_l00903}{scipy.\+linalg.\+\_\+basic.\+inv()}}.



Referenced by \mbox{\hyperlink{__solvers_8py_source_l00236}{solve\+\_\+discrete\+\_\+lyapunov()}}.

\Hypertarget{namespacescipy_1_1linalg_1_1__solvers_ad5b508c50219bea8dff25c55223ef298}\index{scipy.linalg.\_solvers@{scipy.linalg.\_solvers}!\_solve\_discrete\_lyapunov\_direct@{\_solve\_discrete\_lyapunov\_direct}}
\index{\_solve\_discrete\_lyapunov\_direct@{\_solve\_discrete\_lyapunov\_direct}!scipy.linalg.\_solvers@{scipy.linalg.\_solvers}}
\doxysubsubsection{\texorpdfstring{\_solve\_discrete\_lyapunov\_direct()}{\_solve\_discrete\_lyapunov\_direct()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1linalg_1_1__solvers_ad5b508c50219bea8dff25c55223ef298} 
scipy.\+linalg.\+\_\+solvers.\+\_\+solve\+\_\+discrete\+\_\+lyapunov\+\_\+direct (\begin{DoxyParamCaption}\item[{}]{a}{, }\item[{}]{q}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Solves the discrete Lyapunov equation directly.

This function is called by the `solve_discrete_lyapunov` function with
`method=direct`. It is not supposed to be called directly.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__solvers_8py_source_l00206}{206}} of file \mbox{\hyperlink{__solvers_8py_source}{\+\_\+solvers.\+py}}.



References \mbox{\hyperlink{__special__matrices_8py_source_l00448}{scipy.\+linalg.\+\_\+special\+\_\+matrices.\+kron()}}, and \mbox{\hyperlink{linalg_2__basic_8py_source_l00054}{scipy.\+linalg.\+\_\+basic.\+solve()}}.



Referenced by \mbox{\hyperlink{__solvers_8py_source_l00236}{solve\+\_\+discrete\+\_\+lyapunov()}}.

\Hypertarget{namespacescipy_1_1linalg_1_1__solvers_ae6dc294d2a4d07e61a77477c8107bc00}\index{scipy.linalg.\_solvers@{scipy.linalg.\_solvers}!solve\_continuous\_are@{solve\_continuous\_are}}
\index{solve\_continuous\_are@{solve\_continuous\_are}!scipy.linalg.\_solvers@{scipy.linalg.\_solvers}}
\doxysubsubsection{\texorpdfstring{solve\_continuous\_are()}{solve\_continuous\_are()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1linalg_1_1__solvers_ae6dc294d2a4d07e61a77477c8107bc00} 
scipy.\+linalg.\+\_\+solvers.\+solve\+\_\+continuous\+\_\+are (\begin{DoxyParamCaption}\item[{}]{a}{, }\item[{}]{b}{, }\item[{}]{q}{, }\item[{}]{r}{, }\item[{}]{e}{ = {\ttfamily None}, }\item[{}]{s}{ = {\ttfamily None}, }\item[{}]{balanced}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Solves the continuous-time algebraic Riccati equation (CARE).

The CARE is defined as

.. math::

  X A + A^H X - X B R^{-1} B^H X + Q = 0

The limitations for a solution to exist are :

* All eigenvalues of :math:`A` on the right half plane, should be
  controllable.

* The associated hamiltonian pencil (See Notes), should have
  eigenvalues sufficiently away from the imaginary axis.

Moreover, if ``e`` or ``s`` is not precisely ``None``, then the
generalized version of CARE

.. math::

  E^HXA + A^HXE - (E^HXB + S) R^{-1} (B^HXE + S^H) + Q = 0

is solved. When omitted, ``e`` is assumed to be the identity and ``s``
is assumed to be the zero matrix with sizes compatible with ``a`` and
``b``, respectively.

Parameters
----------
a : (M, M) array_like
Square matrix
b : (M, N) array_like
Input
q : (M, M) array_like
Input
r : (N, N) array_like
Nonsingular square matrix
e : (M, M) array_like, optional
Nonsingular square matrix
s : (M, N) array_like, optional
Input
balanced : bool, optional
The boolean that indicates whether a balancing step is performed
on the data. The default is set to True.

Returns
-------
x : (M, M) ndarray
Solution to the continuous-time algebraic Riccati equation.

Raises
------
LinAlgError
For cases where the stable subspace of the pencil could not be
isolated. See Notes section and the references for details.

See Also
--------
solve_discrete_are : Solves the discrete-time algebraic Riccati equation

Notes
-----
The equation is solved by forming the extended hamiltonian matrix pencil,
as described in [1]_, :math:`H - \lambda J` given by the block matrices ::

[ A    0    B ]             [ E   0    0 ]
[-Q  -A^H  -S ] - \lambda * [ 0  E^H   0 ]
[ S^H B^H   R ]             [ 0   0    0 ]

and using a QZ decomposition method.

In this algorithm, the fail conditions are linked to the symmetry
of the product :math:`U_2 U_1^{-1}` and condition number of
:math:`U_1`. Here, :math:`U` is the 2m-by-m matrix that holds the
eigenvectors spanning the stable subspace with 2-m rows and partitioned
into two m-row matrices. See [1]_ and [2]_ for more details.

In order to improve the QZ decomposition accuracy, the pencil goes
through a balancing step where the sum of absolute values of
:math:`H` and :math:`J` entries (after removing the diagonal entries of
the sum) is balanced following the recipe given in [3]_.

.. versionadded:: 0.11.0

References
----------
.. [1]  P. van Dooren , "A Generalized Eigenvalue Approach For Solving
Riccati Equations.", SIAM Journal on Scientific and Statistical
Computing, Vol.2(2), :doi:`10.1137/0902010`

.. [2] A.J. Laub, "A Schur Method for Solving Algebraic Riccati
Equations.", Massachusetts Institute of Technology. Laboratory for
Information and Decision Systems. LIDS-R ; 859. Available online :
http://hdl.handle.net/1721.1/1301

.. [3] P. Benner, "Symplectic Balancing of Hamiltonian Matrices", 2001,
SIAM J. Sci. Comput., 2001, Vol.22(5), :doi:`10.1137/S1064827500367993`

Examples
--------
Given `a`, `b`, `q`, and `r` solve for `x`:

>>> import numpy as np
>>> from scipy import linalg
>>> a = np.array([[4, 3], [-4.5, -3.5]])
>>> b = np.array([[1], [-1]])
>>> q = np.array([[9, 6], [6, 4.]])
>>> r = 1
>>> x = linalg.solve_continuous_are(a, b, q, r)
>>> x
array([[ 21.72792206,  14.48528137],
   [ 14.48528137,   9.65685425]])
>>> np.allclose(a.T.dot(x) + x.dot(a)-x.dot(b).dot(b.T).dot(x), -q)
True
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__solvers_8py_source_l00328}{328}} of file \mbox{\hyperlink{__solvers_8py_source}{\+\_\+solvers.\+py}}.



References \mbox{\hyperlink{__solvers_8py_source_l00742}{\+\_\+are\+\_\+validate\+\_\+args()}}, \mbox{\hyperlink{__special__matrices_8py_source_l00489}{scipy.\+linalg.\+\_\+special\+\_\+matrices.\+block\+\_\+diag()}}, \mbox{\hyperlink{__decomp__lu_8py_source_l00160}{scipy.\+linalg.\+\_\+decomp\+\_\+lu.\+lu()}}, \mbox{\hyperlink{linalg_2__basic_8py_source_l01561}{scipy.\+linalg.\+\_\+basic.\+matrix\+\_\+balance()}}, \mbox{\hyperlink{__decomp__qz_8py_source_l00321}{scipy.\+linalg.\+\_\+decomp\+\_\+qz.\+ordqz()}}, \mbox{\hyperlink{__decomp__qr_8py_source_l00027}{scipy.\+linalg.\+\_\+decomp\+\_\+qr.\+qr()}}, and \mbox{\hyperlink{linalg_2__basic_8py_source_l00266}{scipy.\+linalg.\+\_\+basic.\+solve\+\_\+triangular()}}.

\Hypertarget{namespacescipy_1_1linalg_1_1__solvers_ad7c0774545127a1e4f46eb3fac815dc9}\index{scipy.linalg.\_solvers@{scipy.linalg.\_solvers}!solve\_continuous\_lyapunov@{solve\_continuous\_lyapunov}}
\index{solve\_continuous\_lyapunov@{solve\_continuous\_lyapunov}!scipy.linalg.\_solvers@{scipy.linalg.\_solvers}}
\doxysubsubsection{\texorpdfstring{solve\_continuous\_lyapunov()}{solve\_continuous\_lyapunov()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1linalg_1_1__solvers_ad7c0774545127a1e4f46eb3fac815dc9} 
scipy.\+linalg.\+\_\+solvers.\+solve\+\_\+continuous\+\_\+lyapunov (\begin{DoxyParamCaption}\item[{}]{a}{, }\item[{}]{q}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Solves the continuous Lyapunov equation :math:`AX + XA^H = Q`.

Uses the Bartels-Stewart algorithm to find :math:`X`.

Parameters
----------
a : array_like
    A square matrix

q : array_like
    Right-hand side square matrix

Returns
-------
x : ndarray
    Solution to the continuous Lyapunov equation

See Also
--------
solve_discrete_lyapunov : computes the solution to the discrete-time
    Lyapunov equation
solve_sylvester : computes the solution to the Sylvester equation

Notes
-----
The continuous Lyapunov equation is a special form of the Sylvester
equation, hence this solver relies on LAPACK routine ?TRSYL.

.. versionadded:: 0.11.0

Examples
--------
Given `a` and `q` solve for `x`:

>>> import numpy as np
>>> from scipy import linalg
>>> a = np.array([[-3, -2, 0], [-1, -1, 0], [0, -5, -1]])
>>> b = np.array([2, 4, -1])
>>> q = np.eye(3)
>>> x = linalg.solve_continuous_lyapunov(a, q)
>>> x
array([[ -0.75  ,   0.875 ,  -3.75  ],
       [  0.875 ,  -1.375 ,   5.3125],
       [ -3.75  ,   5.3125, -27.0625]])
>>> np.allclose(a.dot(x) + x.dot(a.T), q)
True
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__solvers_8py_source_l00109}{109}} of file \mbox{\hyperlink{__solvers_8py_source}{\+\_\+solvers.\+py}}.



References \mbox{\hyperlink{lapack_8py_source_l00882}{scipy.\+linalg.\+lapack.\+get\+\_\+lapack\+\_\+funcs()}}, and \mbox{\hyperlink{__decomp__schur_8py_source_l00018}{scipy.\+linalg.\+\_\+decomp\+\_\+schur.\+schur()}}.

\Hypertarget{namespacescipy_1_1linalg_1_1__solvers_add5d1844118d8a79aae4a71660894ab8}\index{scipy.linalg.\_solvers@{scipy.linalg.\_solvers}!solve\_discrete\_are@{solve\_discrete\_are}}
\index{solve\_discrete\_are@{solve\_discrete\_are}!scipy.linalg.\_solvers@{scipy.linalg.\_solvers}}
\doxysubsubsection{\texorpdfstring{solve\_discrete\_are()}{solve\_discrete\_are()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1linalg_1_1__solvers_add5d1844118d8a79aae4a71660894ab8} 
scipy.\+linalg.\+\_\+solvers.\+solve\+\_\+discrete\+\_\+are (\begin{DoxyParamCaption}\item[{}]{a}{, }\item[{}]{b}{, }\item[{}]{q}{, }\item[{}]{r}{, }\item[{}]{e}{ = {\ttfamily None}, }\item[{}]{s}{ = {\ttfamily None}, }\item[{}]{balanced}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Solves the discrete-time algebraic Riccati equation (DARE).

The DARE is defined as

.. math::

A^HXA - X - (A^HXB) (R + B^HXB)^{-1} (B^HXA) + Q = 0

The limitations for a solution to exist are :

* All eigenvalues of :math:`A` outside the unit disc, should be
controllable.

* The associated symplectic pencil (See Notes), should have
eigenvalues sufficiently away from the unit circle.

Moreover, if ``e`` and ``s`` are not both precisely ``None``, then the
generalized version of DARE

.. math::

A^HXA - E^HXE - (A^HXB+S) (R+B^HXB)^{-1} (B^HXA+S^H) + Q = 0

is solved. When omitted, ``e`` is assumed to be the identity and ``s``
is assumed to be the zero matrix.

Parameters
----------
a : (M, M) array_like
Square matrix
b : (M, N) array_like
Input
q : (M, M) array_like
Input
r : (N, N) array_like
Square matrix
e : (M, M) array_like, optional
Nonsingular square matrix
s : (M, N) array_like, optional
Input
balanced : bool
The boolean that indicates whether a balancing step is performed
on the data. The default is set to True.

Returns
-------
x : (M, M) ndarray
Solution to the discrete algebraic Riccati equation.

Raises
------
LinAlgError
For cases where the stable subspace of the pencil could not be
isolated. See Notes section and the references for details.

See Also
--------
solve_continuous_are : Solves the continuous algebraic Riccati equation

Notes
-----
The equation is solved by forming the extended symplectic matrix pencil,
as described in [1]_, :math:`H - \lambda J` given by the block matrices ::

[  A   0   B ]             [ E   0   B ]
[ -Q  E^H -S ] - \lambda * [ 0  A^H  0 ]
[ S^H  0   R ]             [ 0 -B^H  0 ]

and using a QZ decomposition method.

In this algorithm, the fail conditions are linked to the symmetry
of the product :math:`U_2 U_1^{-1}` and condition number of
:math:`U_1`. Here, :math:`U` is the 2m-by-m matrix that holds the
eigenvectors spanning the stable subspace with 2-m rows and partitioned
into two m-row matrices. See [1]_ and [2]_ for more details.

In order to improve the QZ decomposition accuracy, the pencil goes
through a balancing step where the sum of absolute values of
:math:`H` and :math:`J` rows/cols (after removing the diagonal entries)
is balanced following the recipe given in [3]_. If the data has small
numerical noise, balancing may amplify their effects and some clean up
is required.

.. versionadded:: 0.11.0

References
----------
.. [1]  P. van Dooren , "A Generalized Eigenvalue Approach For Solving
Riccati Equations.", SIAM Journal on Scientific and Statistical
Computing, Vol.2(2), :doi:`10.1137/0902010`

.. [2] A.J. Laub, "A Schur Method for Solving Algebraic Riccati
Equations.", Massachusetts Institute of Technology. Laboratory for
Information and Decision Systems. LIDS-R ; 859. Available online :
http://hdl.handle.net/1721.1/1301

.. [3] P. Benner, "Symplectic Balancing of Hamiltonian Matrices", 2001,
SIAM J. Sci. Comput., 2001, Vol.22(5), :doi:`10.1137/S1064827500367993`

Examples
--------
Given `a`, `b`, `q`, and `r` solve for `x`:

>>> import numpy as np
>>> from scipy import linalg as la
>>> a = np.array([[0, 1], [0, -1]])
>>> b = np.array([[1, 0], [2, 1]])
>>> q = np.array([[-4, -4], [-4, 7]])
>>> r = np.array([[9, 3], [3, 1]])
>>> x = la.solve_discrete_are(a, b, q, r)
>>> x
array([[-4., -4.],
[-4.,  7.]])
>>> R = la.solve(r + b.T.dot(x).dot(b), b.T.dot(x).dot(a))
>>> np.allclose(a.T.dot(x).dot(a) - x - a.T.dot(x).dot(b).dot(R), -q)
True
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__solvers_8py_source_l00533}{533}} of file \mbox{\hyperlink{__solvers_8py_source}{\+\_\+solvers.\+py}}.



References \mbox{\hyperlink{__solvers_8py_source_l00742}{\+\_\+are\+\_\+validate\+\_\+args()}}, \mbox{\hyperlink{__decomp__lu_8py_source_l00160}{scipy.\+linalg.\+\_\+decomp\+\_\+lu.\+lu()}}, \mbox{\hyperlink{linalg_2__basic_8py_source_l01561}{scipy.\+linalg.\+\_\+basic.\+matrix\+\_\+balance()}}, \mbox{\hyperlink{__decomp__qz_8py_source_l00321}{scipy.\+linalg.\+\_\+decomp\+\_\+qz.\+ordqz()}}, \mbox{\hyperlink{__decomp__qr_8py_source_l00027}{scipy.\+linalg.\+\_\+decomp\+\_\+qr.\+qr()}}, and \mbox{\hyperlink{linalg_2__basic_8py_source_l00266}{scipy.\+linalg.\+\_\+basic.\+solve\+\_\+triangular()}}.

\Hypertarget{namespacescipy_1_1linalg_1_1__solvers_a69e3106f77513c66be82cc205a378763}\index{scipy.linalg.\_solvers@{scipy.linalg.\_solvers}!solve\_discrete\_lyapunov@{solve\_discrete\_lyapunov}}
\index{solve\_discrete\_lyapunov@{solve\_discrete\_lyapunov}!scipy.linalg.\_solvers@{scipy.linalg.\_solvers}}
\doxysubsubsection{\texorpdfstring{solve\_discrete\_lyapunov()}{solve\_discrete\_lyapunov()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1linalg_1_1__solvers_a69e3106f77513c66be82cc205a378763} 
scipy.\+linalg.\+\_\+solvers.\+solve\+\_\+discrete\+\_\+lyapunov (\begin{DoxyParamCaption}\item[{}]{a}{, }\item[{}]{q}{, }\item[{}]{method}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Solves the discrete Lyapunov equation :math:`AXA^H - X + Q = 0`.

Parameters
----------
a, q : (M, M) array_like
    Square matrices corresponding to A and Q in the equation
    above respectively. Must have the same shape.

method : {'direct', 'bilinear'}, optional
    Type of solver.

    If not given, chosen to be ``direct`` if ``M`` is less than 10 and
    ``bilinear`` otherwise.

Returns
-------
x : ndarray
    Solution to the discrete Lyapunov equation

See Also
--------
solve_continuous_lyapunov : computes the solution to the continuous-time
    Lyapunov equation

Notes
-----
This section describes the available solvers that can be selected by the
'method' parameter. The default method is *direct* if ``M`` is less than 10
and ``bilinear`` otherwise.

Method *direct* uses a direct analytical solution to the discrete Lyapunov
equation. The algorithm is given in, for example, [1]_. However, it requires
the linear solution of a system with dimension :math:`M^2` so that
performance degrades rapidly for even moderately sized matrices.

Method *bilinear* uses a bilinear transformation to convert the discrete
Lyapunov equation to a continuous Lyapunov equation :math:`(BX+XB'=-C)`
where :math:`B=(A-I)(A+I)^{-1}` and
:math:`C=2(A' + I)^{-1} Q (A + I)^{-1}`. The continuous equation can be
efficiently solved since it is a special case of a Sylvester equation.
The transformation algorithm is from Popov (1964) as described in [2]_.

.. versionadded:: 0.11.0

References
----------
.. [1] Hamilton, James D. Time Series Analysis, Princeton: Princeton
   University Press, 1994.  265.  Print.
   http://doc1.lbfl.li/aca/FLMF037168.pdf
.. [2] Gajic, Z., and M.T.J. Qureshi. 2008.
   Lyapunov Matrix Equation in System Stability and Control.
   Dover Books on Engineering Series. Dover Publications.

Examples
--------
Given `a` and `q` solve for `x`:

>>> import numpy as np
>>> from scipy import linalg
>>> a = np.array([[0.2, 0.5],[0.7, -0.9]])
>>> q = np.eye(2)
>>> x = linalg.solve_discrete_lyapunov(a, q)
>>> x
array([[ 0.70872893,  1.43518822],
       [ 1.43518822, -2.4266315 ]])
>>> np.allclose(a.dot(x).dot(a.T)-x, -q)
True
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__solvers_8py_source_l00236}{236}} of file \mbox{\hyperlink{__solvers_8py_source}{\+\_\+solvers.\+py}}.



References \mbox{\hyperlink{__solvers_8py_source_l00221}{\+\_\+solve\+\_\+discrete\+\_\+lyapunov\+\_\+bilinear()}}, and \mbox{\hyperlink{__solvers_8py_source_l00206}{\+\_\+solve\+\_\+discrete\+\_\+lyapunov\+\_\+direct()}}.

\Hypertarget{namespacescipy_1_1linalg_1_1__solvers_a3998015d397914b80c35bc7d05d51a87}\index{scipy.linalg.\_solvers@{scipy.linalg.\_solvers}!solve\_sylvester@{solve\_sylvester}}
\index{solve\_sylvester@{solve\_sylvester}!scipy.linalg.\_solvers@{scipy.linalg.\_solvers}}
\doxysubsubsection{\texorpdfstring{solve\_sylvester()}{solve\_sylvester()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1linalg_1_1__solvers_a3998015d397914b80c35bc7d05d51a87} 
scipy.\+linalg.\+\_\+solvers.\+solve\+\_\+sylvester (\begin{DoxyParamCaption}\item[{}]{a}{, }\item[{}]{b}{, }\item[{}]{q}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Computes a solution (X) to the Sylvester equation :math:`AX + XB = Q`.

Parameters
----------
a : (M, M) array_like
    Leading matrix of the Sylvester equation
b : (N, N) array_like
    Trailing matrix of the Sylvester equation
q : (M, N) array_like
    Right-hand side

Returns
-------
x : (M, N) ndarray
    The solution to the Sylvester equation.

Raises
------
LinAlgError
    If solution was not found

Notes
-----
Computes a solution to the Sylvester matrix equation via the Bartels-
Stewart algorithm. The A and B matrices first undergo Schur
decompositions. The resulting matrices are used to construct an
alternative Sylvester equation (``RY + YS^T = F``) where the R and S
matrices are in quasi-triangular form (or, when R, S or F are complex,
triangular form). The simplified equation is then solved using
``*TRSYL`` from LAPACK directly.

.. versionadded:: 0.11.0

Examples
--------
Given `a`, `b`, and `q` solve for `x`:

>>> import numpy as np
>>> from scipy import linalg
>>> a = np.array([[-3, -2, 0], [-1, -1, 3], [3, -5, -1]])
>>> b = np.array([[1]])
>>> q = np.array([[1],[2],[3]])
>>> x = linalg.solve_sylvester(a, b, q)
>>> x
array([[ 0.0625],
       [-0.5625],
       [ 0.6875]])
>>> np.allclose(a.dot(x) + x.dot(b), q)
True
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__solvers_8py_source_l00030}{30}} of file \mbox{\hyperlink{__solvers_8py_source}{\+\_\+solvers.\+py}}.



References \mbox{\hyperlink{lapack_8py_source_l00882}{scipy.\+linalg.\+lapack.\+get\+\_\+lapack\+\_\+funcs()}}, and \mbox{\hyperlink{__decomp__schur_8py_source_l00018}{scipy.\+linalg.\+\_\+decomp\+\_\+schur.\+schur()}}.



\doxysubsection{Variable Documentation}
\Hypertarget{namespacescipy_1_1linalg_1_1__solvers_ae47545360ff6e70df51361aee24589d3}\index{scipy.linalg.\_solvers@{scipy.linalg.\_solvers}!\_\_all\_\_@{\_\_all\_\_}}
\index{\_\_all\_\_@{\_\_all\_\_}!scipy.linalg.\_solvers@{scipy.linalg.\_solvers}}
\doxysubsubsection{\texorpdfstring{\_\_all\_\_}{\_\_all\_\_}}
{\footnotesize\ttfamily \label{namespacescipy_1_1linalg_1_1__solvers_ae47545360ff6e70df51361aee24589d3} 
list scipy.\+linalg.\+\_\+solvers.\+\_\+\+\_\+all\+\_\+\+\_\+\hspace{0.3cm}{\ttfamily [private]}}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ [\textcolor{stringliteral}{'solve\_sylvester'},}
\DoxyCodeLine{00002\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'solve\_continuous\_lyapunov'},\ \textcolor{stringliteral}{'solve\_discrete\_lyapunov'},}
\DoxyCodeLine{00003\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'solve\_lyapunov'},}
\DoxyCodeLine{00004\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'solve\_continuous\_are'},\ \textcolor{stringliteral}{'solve\_discrete\_are'}]}

\end{DoxyCode}


Definition at line \mbox{\hyperlink{__solvers_8py_source_l00024}{24}} of file \mbox{\hyperlink{__solvers_8py_source}{\+\_\+solvers.\+py}}.

\Hypertarget{namespacescipy_1_1linalg_1_1__solvers_ae887ddd4ca47310dc4cc334f1e07d9ca}\index{scipy.linalg.\_solvers@{scipy.linalg.\_solvers}!solve\_lyapunov@{solve\_lyapunov}}
\index{solve\_lyapunov@{solve\_lyapunov}!scipy.linalg.\_solvers@{scipy.linalg.\_solvers}}
\doxysubsubsection{\texorpdfstring{solve\_lyapunov}{solve\_lyapunov}}
{\footnotesize\ttfamily \label{namespacescipy_1_1linalg_1_1__solvers_ae887ddd4ca47310dc4cc334f1e07d9ca} 
scipy.\+linalg.\+\_\+solvers.\+solve\+\_\+lyapunov = \mbox{\hyperlink{namespacescipy_1_1linalg_1_1__solvers_ad7c0774545127a1e4f46eb3fac815dc9}{solve\+\_\+continuous\+\_\+lyapunov}}}



Definition at line \mbox{\hyperlink{__solvers_8py_source_l00203}{203}} of file \mbox{\hyperlink{__solvers_8py_source}{\+\_\+solvers.\+py}}.

