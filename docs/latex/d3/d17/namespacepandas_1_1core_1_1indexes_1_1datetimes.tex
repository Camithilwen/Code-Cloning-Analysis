\doxysection{pandas.\+core.\+indexes.\+datetimes Namespace Reference}
\hypertarget{namespacepandas_1_1core_1_1indexes_1_1datetimes}{}\label{namespacepandas_1_1core_1_1indexes_1_1datetimes}\index{pandas.core.indexes.datetimes@{pandas.core.indexes.datetimes}}
\doxysubsubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classpandas_1_1core_1_1indexes_1_1datetimes_1_1DatetimeIndex}{Datetime\+Index}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacepandas_1_1core_1_1indexes_1_1datetimes_a1629d8a299d4d9756ba87ec14e79bb6e}{\+\_\+new\+\_\+\+Datetime\+Index}} (cls, d)
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1indexes_1_1datetimes_1_1DatetimeIndex}{Datetime\+Index}} \mbox{\hyperlink{namespacepandas_1_1core_1_1indexes_1_1datetimes_ad5b9126d202e3f7335cc47e21c4a3264}{date\+\_\+range}} (start=None, end=None, periods=None, freq=None, tz=None, bool normalize=False, Hashable\texorpdfstring{$\vert$}{|}None name=None, Interval\+Closed\+Type inclusive="{}both"{}, \texorpdfstring{$\ast$}{*}, str\texorpdfstring{$\vert$}{|}None unit=None, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}kwargs)
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1indexes_1_1datetimes_1_1DatetimeIndex}{Datetime\+Index}} \mbox{\hyperlink{namespacepandas_1_1core_1_1indexes_1_1datetimes_a5b1d78b5b5ae30cfdb8155d92613d663}{bdate\+\_\+range}} (start=None, end=None, int\texorpdfstring{$\vert$}{|}None periods=None, Frequency\texorpdfstring{$\vert$}{|}dt.\+timedelta freq="{}B"{}, tz=None, bool normalize=\mbox{\hyperlink{classTrue}{True}}, Hashable\texorpdfstring{$\vert$}{|}None name=None, weekmask=None, holidays=None, Interval\+Closed\+Type inclusive="{}both"{}, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}kwargs)
\item 
int \mbox{\hyperlink{namespacepandas_1_1core_1_1indexes_1_1datetimes_a22081396a18a00750e51feddb317700e}{\+\_\+time\+\_\+to\+\_\+micros}} (dt.\+time time\+\_\+obj)
\end{DoxyCompactItemize}


\doxysubsection{Function Documentation}
\Hypertarget{namespacepandas_1_1core_1_1indexes_1_1datetimes_a1629d8a299d4d9756ba87ec14e79bb6e}\index{pandas.core.indexes.datetimes@{pandas.core.indexes.datetimes}!\_new\_DatetimeIndex@{\_new\_DatetimeIndex}}
\index{\_new\_DatetimeIndex@{\_new\_DatetimeIndex}!pandas.core.indexes.datetimes@{pandas.core.indexes.datetimes}}
\doxysubsubsection{\texorpdfstring{\_new\_DatetimeIndex()}{\_new\_DatetimeIndex()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1core_1_1indexes_1_1datetimes_a1629d8a299d4d9756ba87ec14e79bb6e} 
pandas.\+core.\+indexes.\+datetimes.\+\_\+new\+\_\+\+Datetime\+Index (\begin{DoxyParamCaption}\item[{}]{cls}{, }\item[{}]{d}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}This is called upon unpickling, rather than the default which doesn't
have arguments and breaks __new__
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{indexes_2datetimes_8py_source_l00073}{73}} of file \mbox{\hyperlink{indexes_2datetimes_8py_source}{datetimes.\+py}}.

\Hypertarget{namespacepandas_1_1core_1_1indexes_1_1datetimes_a22081396a18a00750e51feddb317700e}\index{pandas.core.indexes.datetimes@{pandas.core.indexes.datetimes}!\_time\_to\_micros@{\_time\_to\_micros}}
\index{\_time\_to\_micros@{\_time\_to\_micros}!pandas.core.indexes.datetimes@{pandas.core.indexes.datetimes}}
\doxysubsubsection{\texorpdfstring{\_time\_to\_micros()}{\_time\_to\_micros()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1core_1_1indexes_1_1datetimes_a22081396a18a00750e51feddb317700e} 
 int pandas.\+core.\+indexes.\+datetimes.\+\_\+time\+\_\+to\+\_\+micros (\begin{DoxyParamCaption}\item[{dt.\+time}]{time\+\_\+obj}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{indexes_2datetimes_8py_source_l01125}{1125}} of file \mbox{\hyperlink{indexes_2datetimes_8py_source}{datetimes.\+py}}.

\Hypertarget{namespacepandas_1_1core_1_1indexes_1_1datetimes_a5b1d78b5b5ae30cfdb8155d92613d663}\index{pandas.core.indexes.datetimes@{pandas.core.indexes.datetimes}!bdate\_range@{bdate\_range}}
\index{bdate\_range@{bdate\_range}!pandas.core.indexes.datetimes@{pandas.core.indexes.datetimes}}
\doxysubsubsection{\texorpdfstring{bdate\_range()}{bdate\_range()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1core_1_1indexes_1_1datetimes_a5b1d78b5b5ae30cfdb8155d92613d663} 
 \mbox{\hyperlink{classpandas_1_1core_1_1indexes_1_1datetimes_1_1DatetimeIndex}{Datetime\+Index}} pandas.\+core.\+indexes.\+datetimes.\+bdate\+\_\+range (\begin{DoxyParamCaption}\item[{}]{start}{ = {\ttfamily None}, }\item[{}]{end}{ = {\ttfamily None}, }\item[{int \texorpdfstring{$\vert$}{|} None }]{periods}{ = {\ttfamily None}, }\item[{Frequency \texorpdfstring{$\vert$}{|} dt.\+timedelta }]{freq}{ = {\ttfamily "{}B"{}}, }\item[{}]{tz}{ = {\ttfamily None}, }\item[{bool }]{normalize}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}, }\item[{Hashable \texorpdfstring{$\vert$}{|} None }]{name}{ = {\ttfamily None}, }\item[{}]{weekmask}{ = {\ttfamily None}, }\item[{}]{holidays}{ = {\ttfamily None}, }\item[{Interval\+Closed\+Type }]{inclusive}{ = {\ttfamily "{}both"{}}, }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{kwargs}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Return a fixed frequency DatetimeIndex with business day as the default.

Parameters
----------
start : str or datetime-like, default None
    Left bound for generating dates.
end : str or datetime-like, default None
    Right bound for generating dates.
periods : int, default None
    Number of periods to generate.
freq : str, Timedelta, datetime.timedelta, or DateOffset, default 'B'
    Frequency strings can have multiples, e.g. '5h'. The default is
    business daily ('B').
tz : str or None
    Time zone name for returning localized DatetimeIndex, for example
    Asia/Beijing.
normalize : bool, default False
    Normalize start/end dates to midnight before generating date range.
name : str, default None
    Name of the resulting DatetimeIndex.
weekmask : str or None, default None
    Weekmask of valid business days, passed to ``numpy.busdaycalendar``,
    only used when custom frequency strings are passed.  The default
    value None is equivalent to 'Mon Tue Wed Thu Fri'.
holidays : list-like or None, default None
    Dates to exclude from the set of valid business days, passed to
    ``numpy.busdaycalendar``, only used when custom frequency strings
    are passed.
inclusive : {"both", "neither", "left", "right"}, default "both"
    Include boundaries; Whether to set each bound as closed or open.

    .. versionadded:: 1.4.0
**kwargs
    For compatibility. Has no effect on the result.

Returns
-------
DatetimeIndex

Notes
-----
Of the four parameters: ``start``, ``end``, ``periods``, and ``freq``,
exactly three must be specified.  Specifying ``freq`` is a requirement
for ``bdate_range``.  Use ``date_range`` if specifying ``freq`` is not
desired.

To learn more about the frequency strings, please see `this link
<https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.

Examples
--------
Note how the two weekend days are skipped in the result.

>>> pd.bdate_range(start='1/1/2018', end='1/08/2018')
DatetimeIndex(['2018-01-01', '2018-01-02', '2018-01-03', '2018-01-04',
           '2018-01-05', '2018-01-08'],
          dtype='datetime64[ns]', freq='B')
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{indexes_2datetimes_8py_source_l01022}{1022}} of file \mbox{\hyperlink{indexes_2datetimes_8py_source}{datetimes.\+py}}.



References \mbox{\hyperlink{indexes_2datetimes_8py_source_l00833}{date\+\_\+range()}}.

\Hypertarget{namespacepandas_1_1core_1_1indexes_1_1datetimes_ad5b9126d202e3f7335cc47e21c4a3264}\index{pandas.core.indexes.datetimes@{pandas.core.indexes.datetimes}!date\_range@{date\_range}}
\index{date\_range@{date\_range}!pandas.core.indexes.datetimes@{pandas.core.indexes.datetimes}}
\doxysubsubsection{\texorpdfstring{date\_range()}{date\_range()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1core_1_1indexes_1_1datetimes_ad5b9126d202e3f7335cc47e21c4a3264} 
 \mbox{\hyperlink{classpandas_1_1core_1_1indexes_1_1datetimes_1_1DatetimeIndex}{Datetime\+Index}} pandas.\+core.\+indexes.\+datetimes.\+date\+\_\+range (\begin{DoxyParamCaption}\item[{}]{start}{ = {\ttfamily None}, }\item[{}]{end}{ = {\ttfamily None}, }\item[{}]{periods}{ = {\ttfamily None}, }\item[{}]{freq}{ = {\ttfamily None}, }\item[{}]{tz}{ = {\ttfamily None}, }\item[{bool }]{normalize}{ = {\ttfamily False}, }\item[{Hashable \texorpdfstring{$\vert$}{|} None }]{name}{ = {\ttfamily None}, }\item[{Interval\+Closed\+Type }]{inclusive}{ = {\ttfamily "{}both"{}}, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{str \texorpdfstring{$\vert$}{|} None }]{unit}{ = {\ttfamily None}, }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{kwargs}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Return a fixed frequency DatetimeIndex.

Returns the range of equally spaced time points (where the difference between any
two adjacent points is specified by the given frequency) such that they all
satisfy `start <[=] x <[=] end`, where the first one and the last one are, resp.,
the first and last time points in that range that fall on the boundary of ``freq``
(if given as a frequency string) or that are valid for ``freq`` (if given as a
:class:`pandas.tseries.offsets.DateOffset`). (If exactly one of ``start``,
``end``, or ``freq`` is *not* specified, this missing parameter can be computed
given ``periods``, the number of timesteps in the range. See the note below.)

Parameters
----------
start : str or datetime-like, optional
    Left bound for generating dates.
end : str or datetime-like, optional
    Right bound for generating dates.
periods : int, optional
    Number of periods to generate.
freq : str, Timedelta, datetime.timedelta, or DateOffset, default 'D'
    Frequency strings can have multiples, e.g. '5h'. See
    :ref:`here <timeseries.offset_aliases>` for a list of
    frequency aliases.
tz : str or tzinfo, optional
    Time zone name for returning localized DatetimeIndex, for example
    'Asia/Hong_Kong'. By default, the resulting DatetimeIndex is
    timezone-naive unless timezone-aware datetime-likes are passed.
normalize : bool, default False
    Normalize start/end dates to midnight before generating date range.
name : str, default None
    Name of the resulting DatetimeIndex.
inclusive : {"both", "neither", "left", "right"}, default "both"
    Include boundaries; Whether to set each bound as closed or open.

    .. versionadded:: 1.4.0
unit : str, default None
    Specify the desired resolution of the result.

    .. versionadded:: 2.0.0
**kwargs
    For compatibility. Has no effect on the result.

Returns
-------
DatetimeIndex

See Also
--------
DatetimeIndex : An immutable container for datetimes.
timedelta_range : Return a fixed frequency TimedeltaIndex.
period_range : Return a fixed frequency PeriodIndex.
interval_range : Return a fixed frequency IntervalIndex.

Notes
-----
Of the four parameters ``start``, ``end``, ``periods``, and ``freq``,
exactly three must be specified. If ``freq`` is omitted, the resulting
``DatetimeIndex`` will have ``periods`` linearly spaced elements between
``start`` and ``end`` (closed on both sides).

To learn more about the frequency strings, please see `this link
<https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.

Examples
--------
**Specifying the values**

The next four examples generate the same `DatetimeIndex`, but vary
the combination of `start`, `end` and `periods`.

Specify `start` and `end`, with the default daily frequency.

>>> pd.date_range(start='1/1/2018', end='1/08/2018')
DatetimeIndex(['2018-01-01', '2018-01-02', '2018-01-03', '2018-01-04',
               '2018-01-05', '2018-01-06', '2018-01-07', '2018-01-08'],
              dtype='datetime64[ns]', freq='D')

Specify timezone-aware `start` and `end`, with the default daily frequency.

>>> pd.date_range(
...     start=pd.to_datetime("1/1/2018").tz_localize("Europe/Berlin"),
...     end=pd.to_datetime("1/08/2018").tz_localize("Europe/Berlin"),
... )
DatetimeIndex(['2018-01-01 00:00:00+01:00', '2018-01-02 00:00:00+01:00',
               '2018-01-03 00:00:00+01:00', '2018-01-04 00:00:00+01:00',
               '2018-01-05 00:00:00+01:00', '2018-01-06 00:00:00+01:00',
               '2018-01-07 00:00:00+01:00', '2018-01-08 00:00:00+01:00'],
              dtype='datetime64[ns, Europe/Berlin]', freq='D')

Specify `start` and `periods`, the number of periods (days).

>>> pd.date_range(start='1/1/2018', periods=8)
DatetimeIndex(['2018-01-01', '2018-01-02', '2018-01-03', '2018-01-04',
               '2018-01-05', '2018-01-06', '2018-01-07', '2018-01-08'],
              dtype='datetime64[ns]', freq='D')

Specify `end` and `periods`, the number of periods (days).

>>> pd.date_range(end='1/1/2018', periods=8)
DatetimeIndex(['2017-12-25', '2017-12-26', '2017-12-27', '2017-12-28',
               '2017-12-29', '2017-12-30', '2017-12-31', '2018-01-01'],
              dtype='datetime64[ns]', freq='D')

Specify `start`, `end`, and `periods`; the frequency is generated
automatically (linearly spaced).

>>> pd.date_range(start='2018-04-24', end='2018-04-27', periods=3)
DatetimeIndex(['2018-04-24 00:00:00', '2018-04-25 12:00:00',
               '2018-04-27 00:00:00'],
              dtype='datetime64[ns]', freq=None)

**Other Parameters**

Changed the `freq` (frequency) to ``'ME'`` (month end frequency).

>>> pd.date_range(start='1/1/2018', periods=5, freq='ME')
DatetimeIndex(['2018-01-31', '2018-02-28', '2018-03-31', '2018-04-30',
               '2018-05-31'],
              dtype='datetime64[ns]', freq='ME')

Multiples are allowed

>>> pd.date_range(start='1/1/2018', periods=5, freq='3ME')
DatetimeIndex(['2018-01-31', '2018-04-30', '2018-07-31', '2018-10-31',
               '2019-01-31'],
              dtype='datetime64[ns]', freq='3ME')

`freq` can also be specified as an Offset object.

>>> pd.date_range(start='1/1/2018', periods=5, freq=pd.offsets.MonthEnd(3))
DatetimeIndex(['2018-01-31', '2018-04-30', '2018-07-31', '2018-10-31',
               '2019-01-31'],
              dtype='datetime64[ns]', freq='3ME')

Specify `tz` to set the timezone.

>>> pd.date_range(start='1/1/2018', periods=5, tz='Asia/Tokyo')
DatetimeIndex(['2018-01-01 00:00:00+09:00', '2018-01-02 00:00:00+09:00',
               '2018-01-03 00:00:00+09:00', '2018-01-04 00:00:00+09:00',
               '2018-01-05 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='D')

`inclusive` controls whether to include `start` and `end` that are on the
boundary. The default, "both", includes boundary points on either end.

>>> pd.date_range(start='2017-01-01', end='2017-01-04', inclusive="both")
DatetimeIndex(['2017-01-01', '2017-01-02', '2017-01-03', '2017-01-04'],
              dtype='datetime64[ns]', freq='D')

Use ``inclusive='left'`` to exclude `end` if it falls on the boundary.

>>> pd.date_range(start='2017-01-01', end='2017-01-04', inclusive='left')
DatetimeIndex(['2017-01-01', '2017-01-02', '2017-01-03'],
              dtype='datetime64[ns]', freq='D')

Use ``inclusive='right'`` to exclude `start` if it falls on the boundary, and
similarly ``inclusive='neither'`` will exclude both `start` and `end`.

>>> pd.date_range(start='2017-01-01', end='2017-01-04', inclusive='right')
DatetimeIndex(['2017-01-02', '2017-01-03', '2017-01-04'],
              dtype='datetime64[ns]', freq='D')

**Specify a unit**

>>> pd.date_range(start="2017-01-01", periods=10, freq="100YS", unit="s")
DatetimeIndex(['2017-01-01', '2117-01-01', '2217-01-01', '2317-01-01',
               '2417-01-01', '2517-01-01', '2617-01-01', '2717-01-01',
               '2817-01-01', '2917-01-01'],
              dtype='datetime64[s]', freq='100YS-JAN')
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{indexes_2datetimes_8py_source_l00821}{821}} of file \mbox{\hyperlink{indexes_2datetimes_8py_source}{datetimes.\+py}}.



Referenced by \mbox{\hyperlink{indexes_2datetimes_8py_source_l01034}{bdate\+\_\+range()}}.

