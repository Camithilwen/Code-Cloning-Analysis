\doxysection{scipy.\+interpolate.\+\_\+bsplines Namespace Reference}
\hypertarget{namespacescipy_1_1interpolate_1_1__bsplines}{}\label{namespacescipy_1_1interpolate_1_1__bsplines}\index{scipy.interpolate.\_bsplines@{scipy.interpolate.\_bsplines}}
\doxysubsubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classscipy_1_1interpolate_1_1__bsplines_1_1BSpline}{BSpline}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacescipy_1_1interpolate_1_1__bsplines_a12eff94cc3957733a4b568f78ce9944c}{\+\_\+get\+\_\+dtype}} (dtype)
\item 
\mbox{\hyperlink{namespacescipy_1_1interpolate_1_1__bsplines_a1c22a61aaf927f68ee7310b03fa254d5}{\+\_\+as\+\_\+float\+\_\+array}} (x, check\+\_\+finite=False)
\item 
\mbox{\hyperlink{namespacescipy_1_1interpolate_1_1__bsplines_a82a41bd7ade0ce03532cab4aa64b1f44}{\+\_\+dual\+\_\+poly}} (j, k, t, y)
\item 
\mbox{\hyperlink{namespacescipy_1_1interpolate_1_1__bsplines_a3d533ffccb59f0e2f79d612cca9d87eb}{\+\_\+diff\+\_\+dual\+\_\+poly}} (j, k, y, d, t)
\item 
\mbox{\hyperlink{namespacescipy_1_1interpolate_1_1__bsplines_a3b2cef211b422bf7cb0a21b9b6bfa0ad}{\+\_\+not\+\_\+a\+\_\+knot}} (x, k)
\item 
\mbox{\hyperlink{namespacescipy_1_1interpolate_1_1__bsplines_ab22ff51a45adb9b9fde8780085c3b444}{\+\_\+augknt}} (x, k)
\item 
\mbox{\hyperlink{namespacescipy_1_1interpolate_1_1__bsplines_a6a7ff6b252a21c5e1d7eba6a1d7e2530}{\+\_\+convert\+\_\+string\+\_\+aliases}} (deriv, target\+\_\+shape)
\item 
\mbox{\hyperlink{namespacescipy_1_1interpolate_1_1__bsplines_aa1b1dd8dd949ff5e64b32bdac71a07d8}{\+\_\+process\+\_\+deriv\+\_\+spec}} (deriv)
\item 
\mbox{\hyperlink{namespacescipy_1_1interpolate_1_1__bsplines_a4f44f2b8ccda26c4ae46a52495cd49b9}{\+\_\+woodbury\+\_\+algorithm}} (A, ur, ll, b, k)
\item 
\mbox{\hyperlink{namespacescipy_1_1interpolate_1_1__bsplines_ac4ec44936026d4ec7a34f6d40246e0b3}{\+\_\+periodic\+\_\+knots}} (x, k)
\item 
\mbox{\hyperlink{namespacescipy_1_1interpolate_1_1__bsplines_aa9d039e8899fe9c0fa0afeec009c017e}{\+\_\+make\+\_\+interp\+\_\+per\+\_\+full\+\_\+matr}} (x, y, t, k)
\item 
\mbox{\hyperlink{namespacescipy_1_1interpolate_1_1__bsplines_acefc19be1f6d49573ea1cc8d02a770a7}{\+\_\+make\+\_\+periodic\+\_\+spline}} (x, y, t, k, axis)
\item 
\mbox{\hyperlink{namespacescipy_1_1interpolate_1_1__bsplines_a301d5b15ab29ed96dd4caed6f3f83be6}{make\+\_\+interp\+\_\+spline}} (x, y, k=3, t=None, bc\+\_\+type=None, axis=0, check\+\_\+finite=\mbox{\hyperlink{classTrue}{True}})
\item 
\mbox{\hyperlink{namespacescipy_1_1interpolate_1_1__bsplines_aa247d650f5cb3bd24ecd13a9d349cebe}{make\+\_\+lsq\+\_\+spline}} (x, y, t, k=3, w=None, axis=0, check\+\_\+finite=\mbox{\hyperlink{classTrue}{True}})
\item 
\mbox{\hyperlink{namespacescipy_1_1interpolate_1_1__bsplines_a33ba021331ebd3348199709f4179e69c}{\+\_\+compute\+\_\+optimal\+\_\+gcv\+\_\+parameter}} (X, wE, y, w)
\begin{DoxyCompactList}\small\item\em Smoothing spline helpers \#. \end{DoxyCompactList}\item 
\mbox{\hyperlink{namespacescipy_1_1interpolate_1_1__bsplines_ab2417b9036c8b95b420affafc0c538c6}{\+\_\+coeff\+\_\+of\+\_\+divided\+\_\+diff}} (x)
\item 
\mbox{\hyperlink{namespacescipy_1_1interpolate_1_1__bsplines_a1d4bd5660f11261a2f46ae9adc271397}{make\+\_\+smoothing\+\_\+spline}} (x, y, w=None, lam=None)
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
list \mbox{\hyperlink{namespacescipy_1_1interpolate_1_1__bsplines_ae9009074145445a93d1790c809ed7085}{\+\_\+\+\_\+all\+\_\+\+\_\+}}
\end{DoxyCompactItemize}


\doxysubsection{Function Documentation}
\Hypertarget{namespacescipy_1_1interpolate_1_1__bsplines_a1c22a61aaf927f68ee7310b03fa254d5}\index{scipy.interpolate.\_bsplines@{scipy.interpolate.\_bsplines}!\_as\_float\_array@{\_as\_float\_array}}
\index{\_as\_float\_array@{\_as\_float\_array}!scipy.interpolate.\_bsplines@{scipy.interpolate.\_bsplines}}
\doxysubsubsection{\texorpdfstring{\_as\_float\_array()}{\_as\_float\_array()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1interpolate_1_1__bsplines_a1c22a61aaf927f68ee7310b03fa254d5} 
scipy.\+interpolate.\+\_\+bsplines.\+\_\+as\+\_\+float\+\_\+array (\begin{DoxyParamCaption}\item[{}]{x}{, }\item[{}]{check\+\_\+finite}{ = {\ttfamily False}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Convert the input into a C contiguous float array.

NB: Upcasts half- and single-precision floats to double precision.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{interpolate_2__bsplines_8py_source_l00028}{28}} of file \mbox{\hyperlink{interpolate_2__bsplines_8py_source}{\+\_\+bsplines.\+py}}.



References \mbox{\hyperlink{interpolate_2__bsplines_8py_source_l00020}{\+\_\+get\+\_\+dtype()}}.



Referenced by \mbox{\hyperlink{interpolate_2__bsplines_8py_source_l00274}{scipy.\+interpolate.\+\_\+bsplines.\+BSpline.\+basis\+\_\+element()}}, \mbox{\hyperlink{interpolate_2__bsplines_8py_source_l00338}{scipy.\+interpolate.\+\_\+bsplines.\+BSpline.\+design\+\_\+matrix()}}, \mbox{\hyperlink{interpolate_2__bsplines_8py_source_l01139}{make\+\_\+interp\+\_\+spline()}}, and \mbox{\hyperlink{interpolate_2__bsplines_8py_source_l01416}{make\+\_\+lsq\+\_\+spline()}}.

\Hypertarget{namespacescipy_1_1interpolate_1_1__bsplines_ab22ff51a45adb9b9fde8780085c3b444}\index{scipy.interpolate.\_bsplines@{scipy.interpolate.\_bsplines}!\_augknt@{\_augknt}}
\index{\_augknt@{\_augknt}!scipy.interpolate.\_bsplines@{scipy.interpolate.\_bsplines}}
\doxysubsubsection{\texorpdfstring{\_augknt()}{\_augknt()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1interpolate_1_1__bsplines_ab22ff51a45adb9b9fde8780085c3b444} 
scipy.\+interpolate.\+\_\+bsplines.\+\_\+augknt (\begin{DoxyParamCaption}\item[{}]{x}{, }\item[{}]{k}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Construct a knot vector appropriate for the order-k interpolation.\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{interpolate_2__bsplines_8py_source_l00851}{851}} of file \mbox{\hyperlink{interpolate_2__bsplines_8py_source}{\+\_\+bsplines.\+py}}.



Referenced by \mbox{\hyperlink{interpolate_2__bsplines_8py_source_l00727}{scipy.\+interpolate.\+\_\+bsplines.\+BSpline.\+from\+\_\+power\+\_\+basis()}}, and \mbox{\hyperlink{interpolate_2__bsplines_8py_source_l01139}{make\+\_\+interp\+\_\+spline()}}.

\Hypertarget{namespacescipy_1_1interpolate_1_1__bsplines_ab2417b9036c8b95b420affafc0c538c6}\index{scipy.interpolate.\_bsplines@{scipy.interpolate.\_bsplines}!\_coeff\_of\_divided\_diff@{\_coeff\_of\_divided\_diff}}
\index{\_coeff\_of\_divided\_diff@{\_coeff\_of\_divided\_diff}!scipy.interpolate.\_bsplines@{scipy.interpolate.\_bsplines}}
\doxysubsubsection{\texorpdfstring{\_coeff\_of\_divided\_diff()}{\_coeff\_of\_divided\_diff()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1interpolate_1_1__bsplines_ab2417b9036c8b95b420affafc0c538c6} 
scipy.\+interpolate.\+\_\+bsplines.\+\_\+coeff\+\_\+of\+\_\+divided\+\_\+diff (\begin{DoxyParamCaption}\item[{}]{x}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Returns the coefficients of the divided difference.

Parameters
----------
x : array, shape (n,)
    Array which is used for the computation of divided difference.

Returns
-------
res : array_like, shape (n,)
    Coefficients of the divided difference.

Notes
-----
Vector ``x`` should have unique elements, otherwise an error division by
zero might be raised.

No checks are performed.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{interpolate_2__bsplines_8py_source_l01820}{1820}} of file \mbox{\hyperlink{interpolate_2__bsplines_8py_source}{\+\_\+bsplines.\+py}}.



Referenced by \mbox{\hyperlink{interpolate_2__bsplines_8py_source_l01853}{make\+\_\+smoothing\+\_\+spline()}}.

\Hypertarget{namespacescipy_1_1interpolate_1_1__bsplines_a33ba021331ebd3348199709f4179e69c}\index{scipy.interpolate.\_bsplines@{scipy.interpolate.\_bsplines}!\_compute\_optimal\_gcv\_parameter@{\_compute\_optimal\_gcv\_parameter}}
\index{\_compute\_optimal\_gcv\_parameter@{\_compute\_optimal\_gcv\_parameter}!scipy.interpolate.\_bsplines@{scipy.interpolate.\_bsplines}}
\doxysubsubsection{\texorpdfstring{\_compute\_optimal\_gcv\_parameter()}{\_compute\_optimal\_gcv\_parameter()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1interpolate_1_1__bsplines_a33ba021331ebd3348199709f4179e69c} 
scipy.\+interpolate.\+\_\+bsplines.\+\_\+compute\+\_\+optimal\+\_\+gcv\+\_\+parameter (\begin{DoxyParamCaption}\item[{}]{X}{, }\item[{}]{wE}{, }\item[{}]{y}{, }\item[{}]{w}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Smoothing spline helpers \#. 

\begin{DoxyVerb}Returns an optimal regularization parameter from the GCV criteria [1].

Parameters
----------
X : array, shape (5, n)
    5 bands of the design matrix ``X`` stored in LAPACK banded storage.
wE : array, shape (5, n)
    5 bands of the penalty matrix :math:`W^{-1} E` stored in LAPACK banded
    storage.
y : array, shape (n,)
    Ordinates.
w : array, shape (n,)
    Vector of weights.

Returns
-------
lam : float
    An optimal from the GCV criteria point of view regularization
    parameter.

Notes
-----
No checks are performed.

References
----------
.. [1] G. Wahba, "Estimating the smoothing parameter" in Spline models
    for observational data, Philadelphia, Pennsylvania: Society for
    Industrial and Applied Mathematics, 1990, pp. 45-65.
    :doi:`10.1137/1.9781611970128`
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{interpolate_2__bsplines_8py_source_l01582}{1582}} of file \mbox{\hyperlink{interpolate_2__bsplines_8py_source}{\+\_\+bsplines.\+py}}.



Referenced by \mbox{\hyperlink{interpolate_2__bsplines_8py_source_l01853}{make\+\_\+smoothing\+\_\+spline()}}.

\Hypertarget{namespacescipy_1_1interpolate_1_1__bsplines_a6a7ff6b252a21c5e1d7eba6a1d7e2530}\index{scipy.interpolate.\_bsplines@{scipy.interpolate.\_bsplines}!\_convert\_string\_aliases@{\_convert\_string\_aliases}}
\index{\_convert\_string\_aliases@{\_convert\_string\_aliases}!scipy.interpolate.\_bsplines@{scipy.interpolate.\_bsplines}}
\doxysubsubsection{\texorpdfstring{\_convert\_string\_aliases()}{\_convert\_string\_aliases()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1interpolate_1_1__bsplines_a6a7ff6b252a21c5e1d7eba6a1d7e2530} 
scipy.\+interpolate.\+\_\+bsplines.\+\_\+convert\+\_\+string\+\_\+aliases (\begin{DoxyParamCaption}\item[{}]{deriv}{, }\item[{}]{target\+\_\+shape}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{interpolate_2__bsplines_8py_source_l00856}{856}} of file \mbox{\hyperlink{interpolate_2__bsplines_8py_source}{\+\_\+bsplines.\+py}}.

\Hypertarget{namespacescipy_1_1interpolate_1_1__bsplines_a3d533ffccb59f0e2f79d612cca9d87eb}\index{scipy.interpolate.\_bsplines@{scipy.interpolate.\_bsplines}!\_diff\_dual\_poly@{\_diff\_dual\_poly}}
\index{\_diff\_dual\_poly@{\_diff\_dual\_poly}!scipy.interpolate.\_bsplines@{scipy.interpolate.\_bsplines}}
\doxysubsubsection{\texorpdfstring{\_diff\_dual\_poly()}{\_diff\_dual\_poly()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1interpolate_1_1__bsplines_a3d533ffccb59f0e2f79d612cca9d87eb} 
scipy.\+interpolate.\+\_\+bsplines.\+\_\+diff\+\_\+dual\+\_\+poly (\begin{DoxyParamCaption}\item[{}]{j}{, }\item[{}]{k}{, }\item[{}]{y}{, }\item[{}]{d}{, }\item[{}]{t}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}d-th derivative of the dual polynomial $p_{j,k}(y)$
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{interpolate_2__bsplines_8py_source_l00052}{52}} of file \mbox{\hyperlink{interpolate_2__bsplines_8py_source}{\+\_\+bsplines.\+py}}.



References \mbox{\hyperlink{interpolate_2__bsplines_8py_source_l00041}{\+\_\+dual\+\_\+poly()}}.



Referenced by \mbox{\hyperlink{interpolate_2__bsplines_8py_source_l00727}{scipy.\+interpolate.\+\_\+bsplines.\+BSpline.\+from\+\_\+power\+\_\+basis()}}.

\Hypertarget{namespacescipy_1_1interpolate_1_1__bsplines_a82a41bd7ade0ce03532cab4aa64b1f44}\index{scipy.interpolate.\_bsplines@{scipy.interpolate.\_bsplines}!\_dual\_poly@{\_dual\_poly}}
\index{\_dual\_poly@{\_dual\_poly}!scipy.interpolate.\_bsplines@{scipy.interpolate.\_bsplines}}
\doxysubsubsection{\texorpdfstring{\_dual\_poly()}{\_dual\_poly()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1interpolate_1_1__bsplines_a82a41bd7ade0ce03532cab4aa64b1f44} 
scipy.\+interpolate.\+\_\+bsplines.\+\_\+dual\+\_\+poly (\begin{DoxyParamCaption}\item[{}]{j}{, }\item[{}]{k}{, }\item[{}]{t}{, }\item[{}]{y}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Dual polynomial of the B-spline B_{j,k,t} -
polynomial which is associated with B_{j,k,t}:
$p_{j,k}(y) = (y - t_{j+1})(y - t_{j+2})...(y - t_{j+k})$
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{interpolate_2__bsplines_8py_source_l00041}{41}} of file \mbox{\hyperlink{interpolate_2__bsplines_8py_source}{\+\_\+bsplines.\+py}}.



Referenced by \mbox{\hyperlink{interpolate_2__bsplines_8py_source_l00052}{\+\_\+diff\+\_\+dual\+\_\+poly()}}.

\Hypertarget{namespacescipy_1_1interpolate_1_1__bsplines_a12eff94cc3957733a4b568f78ce9944c}\index{scipy.interpolate.\_bsplines@{scipy.interpolate.\_bsplines}!\_get\_dtype@{\_get\_dtype}}
\index{\_get\_dtype@{\_get\_dtype}!scipy.interpolate.\_bsplines@{scipy.interpolate.\_bsplines}}
\doxysubsubsection{\texorpdfstring{\_get\_dtype()}{\_get\_dtype()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1interpolate_1_1__bsplines_a12eff94cc3957733a4b568f78ce9944c} 
scipy.\+interpolate.\+\_\+bsplines.\+\_\+get\+\_\+dtype (\begin{DoxyParamCaption}\item[{}]{dtype}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Return np.complex128 for complex dtypes, np.float64 otherwise.\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{interpolate_2__bsplines_8py_source_l00020}{20}} of file \mbox{\hyperlink{interpolate_2__bsplines_8py_source}{\+\_\+bsplines.\+py}}.



Referenced by \mbox{\hyperlink{interpolate_2__bsplines_8py_source_l00028}{\+\_\+as\+\_\+float\+\_\+array()}}, and \mbox{\hyperlink{interpolate_2__bsplines_8py_source_l01139}{make\+\_\+interp\+\_\+spline()}}.

\Hypertarget{namespacescipy_1_1interpolate_1_1__bsplines_aa9d039e8899fe9c0fa0afeec009c017e}\index{scipy.interpolate.\_bsplines@{scipy.interpolate.\_bsplines}!\_make\_interp\_per\_full\_matr@{\_make\_interp\_per\_full\_matr}}
\index{\_make\_interp\_per\_full\_matr@{\_make\_interp\_per\_full\_matr}!scipy.interpolate.\_bsplines@{scipy.interpolate.\_bsplines}}
\doxysubsubsection{\texorpdfstring{\_make\_interp\_per\_full\_matr()}{\_make\_interp\_per\_full\_matr()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1interpolate_1_1__bsplines_aa9d039e8899fe9c0fa0afeec009c017e} 
scipy.\+interpolate.\+\_\+bsplines.\+\_\+make\+\_\+interp\+\_\+per\+\_\+full\+\_\+matr (\begin{DoxyParamCaption}\item[{}]{x}{, }\item[{}]{y}{, }\item[{}]{t}{, }\item[{}]{k}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Returns a solution of a system for B-spline interpolation with periodic
boundary conditions. First ``k - 1`` rows of matrix are condtions of
periodicity (continuity of ``k - 1`` derivatives at the boundary points).
Last ``n`` rows are interpolation conditions.
RHS is ``k - 1`` zeros and ``n`` ordinates in this case.

Parameters
----------
x : 1-D array, shape (n,)
    Values of x - coordinate of a given set of points.
y : 1-D array, shape (n,)
    Values of y - coordinate of a given set of points.
t : 1-D array, shape(n+2*k,)
    Vector of knots.
k : int
    The maximum degree of spline

Returns
-------
c : 1-D array, shape (n+k-1,)
    B-spline coefficients

Notes
-----
``t`` is supposed to be taken on circle.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{interpolate_2__bsplines_8py_source_l00986}{986}} of file \mbox{\hyperlink{interpolate_2__bsplines_8py_source}{\+\_\+bsplines.\+py}}.



Referenced by \mbox{\hyperlink{interpolate_2__bsplines_8py_source_l01049}{\+\_\+make\+\_\+periodic\+\_\+spline()}}.

\Hypertarget{namespacescipy_1_1interpolate_1_1__bsplines_acefc19be1f6d49573ea1cc8d02a770a7}\index{scipy.interpolate.\_bsplines@{scipy.interpolate.\_bsplines}!\_make\_periodic\_spline@{\_make\_periodic\_spline}}
\index{\_make\_periodic\_spline@{\_make\_periodic\_spline}!scipy.interpolate.\_bsplines@{scipy.interpolate.\_bsplines}}
\doxysubsubsection{\texorpdfstring{\_make\_periodic\_spline()}{\_make\_periodic\_spline()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1interpolate_1_1__bsplines_acefc19be1f6d49573ea1cc8d02a770a7} 
scipy.\+interpolate.\+\_\+bsplines.\+\_\+make\+\_\+periodic\+\_\+spline (\begin{DoxyParamCaption}\item[{}]{x}{, }\item[{}]{y}{, }\item[{}]{t}{, }\item[{}]{k}{, }\item[{}]{axis}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Compute the (coefficients of) interpolating B-spline with periodic
boundary conditions.

Parameters
----------
x : array_like, shape (n,)
    Abscissas.
y : array_like, shape (n,)
    Ordinates.
k : int
    B-spline degree.
t : array_like, shape (n + 2 * k,).
    Knots taken on a circle, ``k`` on the left and ``k`` on the right
    of the vector ``x``.

Returns
-------
b : a BSpline object of the degree ``k`` and with knots ``t``.

Notes
-----
The original system is formed by ``n + k - 1`` equations where the first
``k - 1`` of them stand for the ``k - 1`` derivatives continuity on the
edges while the other equations correspond to an interpolating case
(matching all the input points). Due to a special form of knot vector, it
can be proved that in the original system the first and last ``k``
coefficients of a spline function are the same, respectively. It follows
from the fact that all ``k - 1`` derivatives are equal term by term at ends
and that the matrix of the original system of linear equations is
non-degenerate. So, we can reduce the number of equations to ``n - 1``
(first ``k - 1`` equations could be reduced). Another trick of this
implementation is cyclic shift of values of B-splines due to equality of
``k`` unknown coefficients. With this we can receive matrix of the system
with upper right and lower left blocks, and ``k`` diagonals.  It allows
to use Woodbury formula to optimize the computations.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{interpolate_2__bsplines_8py_source_l01049}{1049}} of file \mbox{\hyperlink{interpolate_2__bsplines_8py_source}{\+\_\+bsplines.\+py}}.



References \mbox{\hyperlink{interpolate_2__bsplines_8py_source_l00986}{\+\_\+make\+\_\+interp\+\_\+per\+\_\+full\+\_\+matr()}}, and \mbox{\hyperlink{interpolate_2__bsplines_8py_source_l00880}{\+\_\+woodbury\+\_\+algorithm()}}.



Referenced by \mbox{\hyperlink{interpolate_2__bsplines_8py_source_l01139}{make\+\_\+interp\+\_\+spline()}}.

\Hypertarget{namespacescipy_1_1interpolate_1_1__bsplines_a3b2cef211b422bf7cb0a21b9b6bfa0ad}\index{scipy.interpolate.\_bsplines@{scipy.interpolate.\_bsplines}!\_not\_a\_knot@{\_not\_a\_knot}}
\index{\_not\_a\_knot@{\_not\_a\_knot}!scipy.interpolate.\_bsplines@{scipy.interpolate.\_bsplines}}
\doxysubsubsection{\texorpdfstring{\_not\_a\_knot()}{\_not\_a\_knot()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1interpolate_1_1__bsplines_a3b2cef211b422bf7cb0a21b9b6bfa0ad} 
scipy.\+interpolate.\+\_\+bsplines.\+\_\+not\+\_\+a\+\_\+knot (\begin{DoxyParamCaption}\item[{}]{x}{, }\item[{}]{k}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Given data x, construct the knot vector w/ not-a-knot BC.
cf de Boor, XIII(12).\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{interpolate_2__bsplines_8py_source_l00838}{838}} of file \mbox{\hyperlink{interpolate_2__bsplines_8py_source}{\+\_\+bsplines.\+py}}.



Referenced by \mbox{\hyperlink{interpolate_2__bsplines_8py_source_l00727}{scipy.\+interpolate.\+\_\+bsplines.\+BSpline.\+from\+\_\+power\+\_\+basis()}}, and \mbox{\hyperlink{interpolate_2__bsplines_8py_source_l01139}{make\+\_\+interp\+\_\+spline()}}.

\Hypertarget{namespacescipy_1_1interpolate_1_1__bsplines_ac4ec44936026d4ec7a34f6d40246e0b3}\index{scipy.interpolate.\_bsplines@{scipy.interpolate.\_bsplines}!\_periodic\_knots@{\_periodic\_knots}}
\index{\_periodic\_knots@{\_periodic\_knots}!scipy.interpolate.\_bsplines@{scipy.interpolate.\_bsplines}}
\doxysubsubsection{\texorpdfstring{\_periodic\_knots()}{\_periodic\_knots()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1interpolate_1_1__bsplines_ac4ec44936026d4ec7a34f6d40246e0b3} 
scipy.\+interpolate.\+\_\+bsplines.\+\_\+periodic\+\_\+knots (\begin{DoxyParamCaption}\item[{}]{x}{, }\item[{}]{k}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}returns vector of nodes on circle
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{interpolate_2__bsplines_8py_source_l00966}{966}} of file \mbox{\hyperlink{interpolate_2__bsplines_8py_source}{\+\_\+bsplines.\+py}}.



Referenced by \mbox{\hyperlink{interpolate_2__bsplines_8py_source_l00727}{scipy.\+interpolate.\+\_\+bsplines.\+BSpline.\+from\+\_\+power\+\_\+basis()}}, and \mbox{\hyperlink{interpolate_2__bsplines_8py_source_l01139}{make\+\_\+interp\+\_\+spline()}}.

\Hypertarget{namespacescipy_1_1interpolate_1_1__bsplines_aa1b1dd8dd949ff5e64b32bdac71a07d8}\index{scipy.interpolate.\_bsplines@{scipy.interpolate.\_bsplines}!\_process\_deriv\_spec@{\_process\_deriv\_spec}}
\index{\_process\_deriv\_spec@{\_process\_deriv\_spec}!scipy.interpolate.\_bsplines@{scipy.interpolate.\_bsplines}}
\doxysubsubsection{\texorpdfstring{\_process\_deriv\_spec()}{\_process\_deriv\_spec()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1interpolate_1_1__bsplines_aa1b1dd8dd949ff5e64b32bdac71a07d8} 
scipy.\+interpolate.\+\_\+bsplines.\+\_\+process\+\_\+deriv\+\_\+spec (\begin{DoxyParamCaption}\item[{}]{deriv}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{interpolate_2__bsplines_8py_source_l00867}{867}} of file \mbox{\hyperlink{interpolate_2__bsplines_8py_source}{\+\_\+bsplines.\+py}}.

\Hypertarget{namespacescipy_1_1interpolate_1_1__bsplines_a4f44f2b8ccda26c4ae46a52495cd49b9}\index{scipy.interpolate.\_bsplines@{scipy.interpolate.\_bsplines}!\_woodbury\_algorithm@{\_woodbury\_algorithm}}
\index{\_woodbury\_algorithm@{\_woodbury\_algorithm}!scipy.interpolate.\_bsplines@{scipy.interpolate.\_bsplines}}
\doxysubsubsection{\texorpdfstring{\_woodbury\_algorithm()}{\_woodbury\_algorithm()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1interpolate_1_1__bsplines_a4f44f2b8ccda26c4ae46a52495cd49b9} 
scipy.\+interpolate.\+\_\+bsplines.\+\_\+woodbury\+\_\+algorithm (\begin{DoxyParamCaption}\item[{}]{A}{, }\item[{}]{ur}{, }\item[{}]{ll}{, }\item[{}]{b}{, }\item[{}]{k}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Solve a cyclic banded linear system with upper right
and lower blocks of size ``(k-1) / 2`` using
the Woodbury formula

Parameters
----------
A : 2-D array, shape(k, n)
    Matrix of diagonals of original matrix (see
    ``solve_banded`` documentation).
ur : 2-D array, shape(bs, bs)
    Upper right block matrix.
ll : 2-D array, shape(bs, bs)
    Lower left block matrix.
b : 1-D array, shape(n,)
    Vector of constant terms of the system of linear equations.
k : int
    B-spline degree.

Returns
-------
c : 1-D array, shape(n,)
    Solution of the original system of linear equations.

Notes
-----
This algorithm works only for systems with banded matrix A plus
a correction term U @ V.T, where the matrix U @ V.T gives upper right
and lower left block of A
The system is solved with the following steps:
    1.  New systems of linear equations are constructed:
        A @ z_i = u_i,
        u_i - columnn vector of U,
        i = 1, ..., k - 1
    2.  Matrix Z is formed from vectors z_i:
        Z = [ z_1 | z_2 | ... | z_{k - 1} ]
    3.  Matrix H = (1 + V.T @ Z)^{-1}
    4.  The system A' @ y = b is solved
    5.  x = y - Z @ (H @ V.T @ y)
Also, ``n`` should be greater than ``k``, otherwise corner block
elements will intersect with diagonals.

Examples
--------
Consider the case of n = 8, k = 5 (size of blocks - 2 x 2).
The matrix of a system:       U:          V:
  x  x  x  *  *  a  b         a b 0 0     0 0 1 0
  x  x  x  x  *  *  c         0 c 0 0     0 0 0 1
  x  x  x  x  x  *  *         0 0 0 0     0 0 0 0
  *  x  x  x  x  x  *         0 0 0 0     0 0 0 0
  *  *  x  x  x  x  x         0 0 0 0     0 0 0 0
  d  *  *  x  x  x  x         0 0 d 0     1 0 0 0
  e  f  *  *  x  x  x         0 0 e f     0 1 0 0

References
----------
.. [1] William H. Press, Saul A. Teukolsky, William T. Vetterling
       and Brian P. Flannery, Numerical Recipes, 2007, Section 2.7.3
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{interpolate_2__bsplines_8py_source_l00880}{880}} of file \mbox{\hyperlink{interpolate_2__bsplines_8py_source}{\+\_\+bsplines.\+py}}.



Referenced by \mbox{\hyperlink{interpolate_2__bsplines_8py_source_l01049}{\+\_\+make\+\_\+periodic\+\_\+spline()}}, and \mbox{\hyperlink{interpolate_2tests_2test__bsplines_8py_source_l01356}{scipy.\+interpolate.\+tests.\+test\+\_\+bsplines.\+Test\+Interp.\+test\+\_\+woodbury()}}.

\Hypertarget{namespacescipy_1_1interpolate_1_1__bsplines_a301d5b15ab29ed96dd4caed6f3f83be6}\index{scipy.interpolate.\_bsplines@{scipy.interpolate.\_bsplines}!make\_interp\_spline@{make\_interp\_spline}}
\index{make\_interp\_spline@{make\_interp\_spline}!scipy.interpolate.\_bsplines@{scipy.interpolate.\_bsplines}}
\doxysubsubsection{\texorpdfstring{make\_interp\_spline()}{make\_interp\_spline()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1interpolate_1_1__bsplines_a301d5b15ab29ed96dd4caed6f3f83be6} 
scipy.\+interpolate.\+\_\+bsplines.\+make\+\_\+interp\+\_\+spline (\begin{DoxyParamCaption}\item[{}]{x}{, }\item[{}]{y}{, }\item[{}]{k}{ = {\ttfamily 3}, }\item[{}]{t}{ = {\ttfamily None}, }\item[{}]{bc\+\_\+type}{ = {\ttfamily None}, }\item[{}]{axis}{ = {\ttfamily 0}, }\item[{}]{check\+\_\+finite}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute the (coefficients of) interpolating B-spline.

Parameters
----------
x : array_like, shape (n,)
    Abscissas.
y : array_like, shape (n, ...)
    Ordinates.
k : int, optional
    B-spline degree. Default is cubic, ``k = 3``.
t : array_like, shape (nt + k + 1,), optional.
    Knots.
    The number of knots needs to agree with the number of data points and
    the number of derivatives at the edges. Specifically, ``nt - n`` must
    equal ``len(deriv_l) + len(deriv_r)``.
bc_type : 2-tuple or None
    Boundary conditions.
    Default is None, which means choosing the boundary conditions
    automatically. Otherwise, it must be a length-two tuple where the first
    element (``deriv_l``) sets the boundary conditions at ``x[0]`` and
    the second element (``deriv_r``) sets the boundary conditions at
    ``x[-1]``. Each of these must be an iterable of pairs
    ``(order, value)`` which gives the values of derivatives of specified
    orders at the given edge of the interpolation interval.
    Alternatively, the following string aliases are recognized:

    * ``"clamped"``: The first derivatives at the ends are zero. This is
       equivalent to ``bc_type=([(1, 0.0)], [(1, 0.0)])``.
    * ``"natural"``: The second derivatives at ends are zero. This is
      equivalent to ``bc_type=([(2, 0.0)], [(2, 0.0)])``.
    * ``"not-a-knot"`` (default): The first and second segments are the
      same polynomial. This is equivalent to having ``bc_type=None``.
    * ``"periodic"``: The values and the first ``k-1`` derivatives at the
      ends are equivalent.

axis : int, optional
    Interpolation axis. Default is 0.
check_finite : bool, optional
    Whether to check that the input arrays contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.
    Default is True.

Returns
-------
b : a BSpline object of the degree ``k`` and with knots ``t``.

See Also
--------
BSpline : base class representing the B-spline objects
CubicSpline : a cubic spline in the polynomial basis
make_lsq_spline : a similar factory function for spline fitting
UnivariateSpline : a wrapper over FITPACK spline fitting routines
splrep : a wrapper over FITPACK spline fitting routines

Examples
--------

Use cubic interpolation on Chebyshev nodes:

>>> import numpy as np
>>> import matplotlib.pyplot as plt
>>> def cheb_nodes(N):
...     jj = 2.*np.arange(N) + 1
...     x = np.cos(np.pi * jj / 2 / N)[::-1]
...     return x

>>> x = cheb_nodes(20)
>>> y = np.sqrt(1 - x**2)

>>> from scipy.interpolate import BSpline, make_interp_spline
>>> b = make_interp_spline(x, y)
>>> np.allclose(b(x), y)
True

Note that the default is a cubic spline with a not-a-knot boundary condition

>>> b.k
3

Here we use a 'natural' spline, with zero 2nd derivatives at edges:

>>> l, r = [(2, 0.0)], [(2, 0.0)]
>>> b_n = make_interp_spline(x, y, bc_type=(l, r))  # or, bc_type="natural"
>>> np.allclose(b_n(x), y)
True
>>> x0, x1 = x[0], x[-1]
>>> np.allclose([b_n(x0, 2), b_n(x1, 2)], [0, 0])
True

Interpolation of parametric curves is also supported. As an example, we
compute a discretization of a snail curve in polar coordinates

>>> phi = np.linspace(0, 2.*np.pi, 40)
>>> r = 0.3 + np.cos(phi)
>>> x, y = r*np.cos(phi), r*np.sin(phi)  # convert to Cartesian coordinates

Build an interpolating curve, parameterizing it by the angle

>>> spl = make_interp_spline(phi, np.c_[x, y])

Evaluate the interpolant on a finer grid (note that we transpose the result
to unpack it into a pair of x- and y-arrays)

>>> phi_new = np.linspace(0, 2.*np.pi, 100)
>>> x_new, y_new = spl(phi_new).T

Plot the result

>>> plt.plot(x, y, 'o')
>>> plt.plot(x_new, y_new, '-')
>>> plt.show()

Build a B-spline curve with 2 dimensional y

>>> x = np.linspace(0, 2*np.pi, 10)
>>> y = np.array([np.sin(x), np.cos(x)])

Periodic condition is satisfied because y coordinates of points on the ends
are equivalent

>>> ax = plt.axes(projection='3d')
>>> xx = np.linspace(0, 2*np.pi, 100)
>>> bspl = make_interp_spline(x, y, k=5, bc_type='periodic', axis=1)
>>> ax.plot3D(xx, *bspl(xx))
>>> ax.scatter3D(x, *y, color='red')
>>> plt.show()
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{interpolate_2__bsplines_8py_source_l01138}{1138}} of file \mbox{\hyperlink{interpolate_2__bsplines_8py_source}{\+\_\+bsplines.\+py}}.



References \mbox{\hyperlink{interpolate_2__bsplines_8py_source_l00028}{\+\_\+as\+\_\+float\+\_\+array()}}, \mbox{\hyperlink{interpolate_2__bsplines_8py_source_l00851}{\+\_\+augknt()}}, \mbox{\hyperlink{interpolate_2__bsplines_8py_source_l00020}{\+\_\+get\+\_\+dtype()}}, \mbox{\hyperlink{interpolate_2__bsplines_8py_source_l01049}{\+\_\+make\+\_\+periodic\+\_\+spline()}}, \mbox{\hyperlink{interpolate_2__bsplines_8py_source_l00838}{\+\_\+not\+\_\+a\+\_\+knot()}}, and \mbox{\hyperlink{interpolate_2__bsplines_8py_source_l00966}{\+\_\+periodic\+\_\+knots()}}.



Referenced by \mbox{\hyperlink{__rgi_8py_source_l00274}{scipy.\+interpolate.\+\_\+rgi.\+Regular\+Grid\+Interpolator.\+\_\+\+\_\+call\+\_\+\+\_\+()}}, \mbox{\hyperlink{__interpolate_8py_source_l00492}{scipy.\+interpolate.\+\_\+interpolate.\+interp1d.\+\_\+\+\_\+init\+\_\+\+\_\+()}}, \mbox{\hyperlink{interpolate_2tests_2test__bsplines_8py_source_l00431}{scipy.\+interpolate.\+tests.\+test\+\_\+bsplines.\+Test\+BSpline.\+test\+\_\+design\+\_\+matrix\+\_\+bc\+\_\+types()}}, \mbox{\hyperlink{interpolate_2tests_2test__bsplines_8py_source_l00475}{scipy.\+interpolate.\+tests.\+test\+\_\+bsplines.\+Test\+BSpline.\+test\+\_\+design\+\_\+matrix\+\_\+same\+\_\+as\+\_\+\+BSpline\+\_\+call()}}, and \mbox{\hyperlink{interpolate_2tests_2test__bsplines_8py_source_l01624}{scipy.\+interpolate.\+tests.\+test\+\_\+bsplines.\+Test\+Smoothing\+Spline.\+test\+\_\+non\+\_\+regularized\+\_\+case()}}.

\Hypertarget{namespacescipy_1_1interpolate_1_1__bsplines_aa247d650f5cb3bd24ecd13a9d349cebe}\index{scipy.interpolate.\_bsplines@{scipy.interpolate.\_bsplines}!make\_lsq\_spline@{make\_lsq\_spline}}
\index{make\_lsq\_spline@{make\_lsq\_spline}!scipy.interpolate.\_bsplines@{scipy.interpolate.\_bsplines}}
\doxysubsubsection{\texorpdfstring{make\_lsq\_spline()}{make\_lsq\_spline()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1interpolate_1_1__bsplines_aa247d650f5cb3bd24ecd13a9d349cebe} 
scipy.\+interpolate.\+\_\+bsplines.\+make\+\_\+lsq\+\_\+spline (\begin{DoxyParamCaption}\item[{}]{x}{, }\item[{}]{y}{, }\item[{}]{t}{, }\item[{}]{k}{ = {\ttfamily 3}, }\item[{}]{w}{ = {\ttfamily None}, }\item[{}]{axis}{ = {\ttfamily 0}, }\item[{}]{check\+\_\+finite}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute the (coefficients of) an LSQ (Least SQuared) based
fitting B-spline.

The result is a linear combination

.. math::

        S(x) = \sum_j c_j B_j(x; t)

of the B-spline basis elements, :math:`B_j(x; t)`, which minimizes

.. math::

    \sum_{j} \left( w_j \times (S(x_j) - y_j) \right)^2

Parameters
----------
x : array_like, shape (m,)
    Abscissas.
y : array_like, shape (m, ...)
    Ordinates.
t : array_like, shape (n + k + 1,).
    Knots.
    Knots and data points must satisfy Schoenberg-Whitney conditions.
k : int, optional
    B-spline degree. Default is cubic, ``k = 3``.
w : array_like, shape (m,), optional
    Weights for spline fitting. Must be positive. If ``None``,
    then weights are all equal.
    Default is ``None``.
axis : int, optional
    Interpolation axis. Default is zero.
check_finite : bool, optional
    Whether to check that the input arrays contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.
    Default is True.

Returns
-------
b : a BSpline object of the degree ``k`` with knots ``t``.

See Also
--------
BSpline : base class representing the B-spline objects
make_interp_spline : a similar factory function for interpolating splines
LSQUnivariateSpline : a FITPACK-based spline fitting routine
splrep : a FITPACK-based fitting routine

Notes
-----
The number of data points must be larger than the spline degree ``k``.

Knots ``t`` must satisfy the Schoenberg-Whitney conditions,
i.e., there must be a subset of data points ``x[j]`` such that
``t[j] < x[j] < t[j+k+1]``, for ``j=0, 1,...,n-k-2``.

Examples
--------
Generate some noisy data:

>>> import numpy as np
>>> import matplotlib.pyplot as plt
>>> rng = np.random.default_rng()
>>> x = np.linspace(-3, 3, 50)
>>> y = np.exp(-x**2) + 0.1 * rng.standard_normal(50)

Now fit a smoothing cubic spline with a pre-defined internal knots.
Here we make the knot vector (k+1)-regular by adding boundary knots:

>>> from scipy.interpolate import make_lsq_spline, BSpline
>>> t = [-1, 0, 1]
>>> k = 3
>>> t = np.r_[(x[0],)*(k+1),
...           t,
...           (x[-1],)*(k+1)]
>>> spl = make_lsq_spline(x, y, t, k)

For comparison, we also construct an interpolating spline for the same
set of data:

>>> from scipy.interpolate import make_interp_spline
>>> spl_i = make_interp_spline(x, y)

Plot both:

>>> xs = np.linspace(-3, 3, 100)
>>> plt.plot(x, y, 'ro', ms=5)
>>> plt.plot(xs, spl(xs), 'g-', lw=3, label='LSQ spline')
>>> plt.plot(xs, spl_i(xs), 'b-', lw=3, alpha=0.7, label='interp spline')
>>> plt.legend(loc='best')
>>> plt.show()

**NaN handling**: If the input arrays contain ``nan`` values, the result is
not useful since the underlying spline fitting routines cannot deal with
``nan``. A workaround is to use zero weights for not-a-number data points:

>>> y[8] = np.nan
>>> w = np.isnan(y)
>>> y[w] = 0.
>>> tck = make_lsq_spline(x, y, t, w=~w)

Notice the need to replace a ``nan`` by a numerical value (precise value
does not matter as long as the corresponding weight is zero.)
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{interpolate_2__bsplines_8py_source_l01416}{1416}} of file \mbox{\hyperlink{interpolate_2__bsplines_8py_source}{\+\_\+bsplines.\+py}}.



References \mbox{\hyperlink{interpolate_2__bsplines_8py_source_l00028}{\+\_\+as\+\_\+float\+\_\+array()}}.

\Hypertarget{namespacescipy_1_1interpolate_1_1__bsplines_a1d4bd5660f11261a2f46ae9adc271397}\index{scipy.interpolate.\_bsplines@{scipy.interpolate.\_bsplines}!make\_smoothing\_spline@{make\_smoothing\_spline}}
\index{make\_smoothing\_spline@{make\_smoothing\_spline}!scipy.interpolate.\_bsplines@{scipy.interpolate.\_bsplines}}
\doxysubsubsection{\texorpdfstring{make\_smoothing\_spline()}{make\_smoothing\_spline()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1interpolate_1_1__bsplines_a1d4bd5660f11261a2f46ae9adc271397} 
scipy.\+interpolate.\+\_\+bsplines.\+make\+\_\+smoothing\+\_\+spline (\begin{DoxyParamCaption}\item[{}]{x}{, }\item[{}]{y}{, }\item[{}]{w}{ = {\ttfamily None}, }\item[{}]{lam}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute the (coefficients of) smoothing cubic spline function using
``lam`` to control the tradeoff between the amount of smoothness of the
curve and its proximity to the data. In case ``lam`` is None, using the
GCV criteria [1] to find it.

A smoothing spline is found as a solution to the regularized weighted
linear regression problem:

.. math::

    \sum\limits_{i=1}^n w_i\lvert y_i - f(x_i) \rvert^2 +
    \lambda\int\limits_{x_1}^{x_n} (f^{(2)}(u))^2 d u

where :math:`f` is a spline function, :math:`w` is a vector of weights and
:math:`\lambda` is a regularization parameter.

If ``lam`` is None, we use the GCV criteria to find an optimal
regularization parameter, otherwise we solve the regularized weighted
linear regression problem with given parameter. The parameter controls
the tradeoff in the following way: the larger the parameter becomes, the
smoother the function gets.

Parameters
----------
x : array_like, shape (n,)
    Abscissas. `n` must be larger than 5.
y : array_like, shape (n,)
    Ordinates. `n` must be larger than 5.
w : array_like, shape (n,), optional
    Vector of weights. Default is ``np.ones_like(x)``.
lam : float, (:math:`\lambda \geq 0`), optional
    Regularization parameter. If ``lam`` is None, then it is found from
    the GCV criteria. Default is None.

Returns
-------
func : a BSpline object.
    A callable representing a spline in the B-spline basis
    as a solution of the problem of smoothing splines using
    the GCV criteria [1] in case ``lam`` is None, otherwise using the
    given parameter ``lam``.

Notes
-----
This algorithm is a clean room reimplementation of the algorithm
introduced by Woltring in FORTRAN [2]. The original version cannot be used
in SciPy source code because of the license issues. The details of the
reimplementation are discussed here (available only in Russian) [4].

If the vector of weights ``w`` is None, we assume that all the points are
equal in terms of weights, and vector of weights is vector of ones.

Note that in weighted residual sum of squares, weights are not squared:
:math:`\sum\limits_{i=1}^n w_i\lvert y_i - f(x_i) \rvert^2` while in
``splrep`` the sum is built from the squared weights.

In cases when the initial problem is ill-posed (for example, the product
:math:`X^T W X` where :math:`X` is a design matrix is not a positive
defined matrix) a ValueError is raised.

References
----------
.. [1] G. Wahba, "Estimating the smoothing parameter" in Spline models for
    observational data, Philadelphia, Pennsylvania: Society for Industrial
    and Applied Mathematics, 1990, pp. 45-65.
    :doi:`10.1137/1.9781611970128`
.. [2] H. J. Woltring, A Fortran package for generalized, cross-validatory
    spline smoothing and differentiation, Advances in Engineering
    Software, vol. 8, no. 2, pp. 104-113, 1986.
    :doi:`10.1016/0141-1195(86)90098-7`
.. [3] T. Hastie, J. Friedman, and R. Tisbshirani, "Smoothing Splines" in
    The elements of Statistical Learning: Data Mining, Inference, and
    prediction, New York: Springer, 2017, pp. 241-249.
    :doi:`10.1007/978-0-387-84858-7`
.. [4] E. Zemlyanoy, "Generalized cross-validation smoothing splines",
    BSc thesis, 2022.
    `<https://www.hse.ru/ba/am/students/diplomas/620910604>`_ (in
    Russian)

Examples
--------
Generate some noisy data

>>> import numpy as np
>>> np.random.seed(1234)
>>> n = 200
>>> def func(x):
...    return x**3 + x**2 * np.sin(4 * x)
>>> x = np.sort(np.random.random_sample(n) * 4 - 2)
>>> y = func(x) + np.random.normal(scale=1.5, size=n)

Make a smoothing spline function

>>> from scipy.interpolate import make_smoothing_spline
>>> spl = make_smoothing_spline(x, y)

Plot both

>>> import matplotlib.pyplot as plt
>>> grid = np.linspace(x[0], x[-1], 400)
>>> plt.plot(grid, spl(grid), label='Spline')
>>> plt.plot(grid, func(grid), label='Original function')
>>> plt.scatter(x, y, marker='.')
>>> plt.legend(loc='best')
>>> plt.show()
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{interpolate_2__bsplines_8py_source_l01853}{1853}} of file \mbox{\hyperlink{interpolate_2__bsplines_8py_source}{\+\_\+bsplines.\+py}}.



References \mbox{\hyperlink{interpolate_2__bsplines_8py_source_l01820}{\+\_\+coeff\+\_\+of\+\_\+divided\+\_\+diff()}}, and \mbox{\hyperlink{interpolate_2__bsplines_8py_source_l01582}{\+\_\+compute\+\_\+optimal\+\_\+gcv\+\_\+parameter()}}.



Referenced by \mbox{\hyperlink{interpolate_2tests_2test__bsplines_8py_source_l01570}{scipy.\+interpolate.\+tests.\+test\+\_\+bsplines.\+Test\+Smoothing\+Spline.\+test\+\_\+compare\+\_\+with\+\_\+\+GCVSPL()}}, and \mbox{\hyperlink{interpolate_2tests_2test__bsplines_8py_source_l01624}{scipy.\+interpolate.\+tests.\+test\+\_\+bsplines.\+Test\+Smoothing\+Spline.\+test\+\_\+non\+\_\+regularized\+\_\+case()}}.



\doxysubsection{Variable Documentation}
\Hypertarget{namespacescipy_1_1interpolate_1_1__bsplines_ae9009074145445a93d1790c809ed7085}\index{scipy.interpolate.\_bsplines@{scipy.interpolate.\_bsplines}!\_\_all\_\_@{\_\_all\_\_}}
\index{\_\_all\_\_@{\_\_all\_\_}!scipy.interpolate.\_bsplines@{scipy.interpolate.\_bsplines}}
\doxysubsubsection{\texorpdfstring{\_\_all\_\_}{\_\_all\_\_}}
{\footnotesize\ttfamily \label{namespacescipy_1_1interpolate_1_1__bsplines_ae9009074145445a93d1790c809ed7085} 
list scipy.\+interpolate.\+\_\+bsplines.\+\_\+\+\_\+all\+\_\+\+\_\+\hspace{0.3cm}{\ttfamily [private]}}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ [\textcolor{stringliteral}{"{}BSpline"{}},\ \textcolor{stringliteral}{"{}make\_interp\_spline"{}},\ \textcolor{stringliteral}{"{}make\_lsq\_spline"{}},}
\DoxyCodeLine{00002\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}make\_smoothing\_spline"{}}]}

\end{DoxyCode}


Definition at line \mbox{\hyperlink{interpolate_2__bsplines_8py_source_l00016}{16}} of file \mbox{\hyperlink{interpolate_2__bsplines_8py_source}{\+\_\+bsplines.\+py}}.

