\doxysection{scipy.\+linalg.\+\_\+decomp\+\_\+lu Namespace Reference}
\hypertarget{namespacescipy_1_1linalg_1_1__decomp__lu}{}\label{namespacescipy_1_1linalg_1_1__decomp__lu}\index{scipy.linalg.\_decomp\_lu@{scipy.linalg.\_decomp\_lu}}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacescipy_1_1linalg_1_1__decomp__lu_a8675c7a06ce605453735ea37804a81a5}{lu\+\_\+factor}} (a, overwrite\+\_\+a=False, check\+\_\+finite=\mbox{\hyperlink{classTrue}{True}})
\item 
\mbox{\hyperlink{namespacescipy_1_1linalg_1_1__decomp__lu_a4bf8c553bca299b245135fa3fc408a72}{lu\+\_\+solve}} (lu\+\_\+and\+\_\+piv, b, trans=0, overwrite\+\_\+b=False, check\+\_\+finite=\mbox{\hyperlink{classTrue}{True}})
\item 
\mbox{\hyperlink{namespacescipy_1_1linalg_1_1__decomp__lu_a92e75e2c660e16f852d8ff9687126851}{lu}} (a, permute\+\_\+l=False, overwrite\+\_\+a=False, check\+\_\+finite=\mbox{\hyperlink{classTrue}{True}}, p\+\_\+indices=False)
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
dict \mbox{\hyperlink{namespacescipy_1_1linalg_1_1__decomp__lu_a7e8a68890b45adfd645ccc360a82730c}{lapack\+\_\+cast\+\_\+dict}}
\item 
list \mbox{\hyperlink{namespacescipy_1_1linalg_1_1__decomp__lu_a46efb5245af2df8994db340b7f96e8bd}{\+\_\+\+\_\+all\+\_\+\+\_\+}} = \mbox{[}\textquotesingle{}\mbox{\hyperlink{namespacescipy_1_1linalg_1_1__decomp__lu_a92e75e2c660e16f852d8ff9687126851}{lu}}\textquotesingle{}, \textquotesingle{}\mbox{\hyperlink{namespacescipy_1_1linalg_1_1__decomp__lu_a4bf8c553bca299b245135fa3fc408a72}{lu\+\_\+solve}}\textquotesingle{}, \textquotesingle{}\mbox{\hyperlink{namespacescipy_1_1linalg_1_1__decomp__lu_a8675c7a06ce605453735ea37804a81a5}{lu\+\_\+factor}}\textquotesingle{}\mbox{]}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\begin{DoxyVerb}LU decomposition functions.\end{DoxyVerb}
 

\doxysubsection{Function Documentation}
\Hypertarget{namespacescipy_1_1linalg_1_1__decomp__lu_a92e75e2c660e16f852d8ff9687126851}\index{scipy.linalg.\_decomp\_lu@{scipy.linalg.\_decomp\_lu}!lu@{lu}}
\index{lu@{lu}!scipy.linalg.\_decomp\_lu@{scipy.linalg.\_decomp\_lu}}
\doxysubsubsection{\texorpdfstring{lu()}{lu()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1linalg_1_1__decomp__lu_a92e75e2c660e16f852d8ff9687126851} 
scipy.\+linalg.\+\_\+decomp\+\_\+lu.\+lu (\begin{DoxyParamCaption}\item[{}]{a}{, }\item[{}]{permute\+\_\+l}{ = {\ttfamily False}, }\item[{}]{overwrite\+\_\+a}{ = {\ttfamily False}, }\item[{}]{check\+\_\+finite}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}, }\item[{}]{p\+\_\+indices}{ = {\ttfamily False}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute LU decomposition of a matrix with partial pivoting.

The decomposition satisfies::

    A = P @ L @ U

where ``P`` is a permutation matrix, ``L`` lower triangular with unit
diagonal elements, and ``U`` upper triangular. If `permute_l` is set to
``True`` then ``L`` is returned already permuted and hence satisfying
``A = L @ U``.

Parameters
----------
a : (M, N) array_like
    Array to decompose
permute_l : bool, optional
    Perform the multiplication P*L (Default: do not permute)
overwrite_a : bool, optional
    Whether to overwrite data in a (may improve performance)
check_finite : bool, optional
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.
p_indices : bool, optional
    If ``True`` the permutation information is returned as row indices.
    The default is ``False`` for backwards-compatibility reasons.

Returns
-------
**(If `permute_l` is ``False``)**

p : (..., M, M) ndarray
    Permutation arrays or vectors depending on `p_indices`
l : (..., M, K) ndarray
    Lower triangular or trapezoidal array with unit diagonal.
    ``K = min(M, N)``
u : (..., K, N) ndarray
    Upper triangular or trapezoidal array

**(If `permute_l` is ``True``)**

pl : (..., M, K) ndarray
    Permuted L matrix.
    ``K = min(M, N)``
u : (..., K, N) ndarray
    Upper triangular or trapezoidal array

Notes
-----
Permutation matrices are costly since they are nothing but row reorder of
``L`` and hence indices are strongly recommended to be used instead if the
permutation is required. The relation in the 2D case then becomes simply
``A = L[P, :] @ U``. In higher dimensions, it is better to use `permute_l`
to avoid complicated indexing tricks.

In 2D case, if one has the indices however, for some reason, the
permutation matrix is still needed then it can be constructed by
``np.eye(M)[P, :]``.

Examples
--------

>>> import numpy as np
>>> from scipy.linalg import lu
>>> A = np.array([[2, 5, 8, 7], [5, 2, 2, 8], [7, 5, 6, 6], [5, 4, 4, 8]])
>>> p, l, u = lu(A)
>>> np.allclose(A, p @ l @ u)
True
>>> p  # Permutation matrix
array([[0., 1., 0., 0.],  # Row index 1
       [0., 0., 0., 1.],  # Row index 3
       [1., 0., 0., 0.],  # Row index 0
       [0., 0., 1., 0.]]) # Row index 2
>>> p, _, _ = lu(A, p_indices=True)
>>> p
array([1, 3, 0, 2])  # as given by row indices above
>>> np.allclose(A, l[p, :] @ u)
True

We can also use nd-arrays, for example, a demonstration with 4D array:

>>> rng = np.random.default_rng()
>>> A = rng.uniform(low=-4, high=4, size=[3, 2, 4, 8])
>>> p, l, u = lu(A)
>>> p.shape, l.shape, u.shape
((3, 2, 4, 4), (3, 2, 4, 4), (3, 2, 4, 8))
>>> np.allclose(A, p @ l @ u)
True
>>> PL, U = lu(A, permute_l=True)
>>> np.allclose(A, PL @ U)
True
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__decomp__lu_8py_source_l00159}{159}} of file \mbox{\hyperlink{__decomp__lu_8py_source}{\+\_\+decomp\+\_\+lu.\+py}}.



References \mbox{\hyperlink{scipy_2linalg_2__misc_8py_source_l00181}{scipy.\+linalg.\+\_\+misc.\+\_\+datacopied()}}.



Referenced by \mbox{\hyperlink{__solvers_8py_source_l00328}{scipy.\+linalg.\+\_\+solvers.\+solve\+\_\+continuous\+\_\+are()}}, \mbox{\hyperlink{__solvers_8py_source_l00533}{scipy.\+linalg.\+\_\+solvers.\+solve\+\_\+discrete\+\_\+are()}}, and \mbox{\hyperlink{test__decomp__lu_8py_source_l00229}{scipy.\+linalg.\+tests.\+test\+\_\+decomp\+\_\+lu.\+Test\+LUFactor.\+test\+\_\+medium1\+\_\+complex()}}.

\Hypertarget{namespacescipy_1_1linalg_1_1__decomp__lu_a8675c7a06ce605453735ea37804a81a5}\index{scipy.linalg.\_decomp\_lu@{scipy.linalg.\_decomp\_lu}!lu\_factor@{lu\_factor}}
\index{lu\_factor@{lu\_factor}!scipy.linalg.\_decomp\_lu@{scipy.linalg.\_decomp\_lu}}
\doxysubsubsection{\texorpdfstring{lu\_factor()}{lu\_factor()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1linalg_1_1__decomp__lu_a8675c7a06ce605453735ea37804a81a5} 
scipy.\+linalg.\+\_\+decomp\+\_\+lu.\+lu\+\_\+factor (\begin{DoxyParamCaption}\item[{}]{a}{, }\item[{}]{overwrite\+\_\+a}{ = {\ttfamily False}, }\item[{}]{check\+\_\+finite}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute pivoted LU decomposition of a matrix.

The decomposition is::

    A = P L U

where P is a permutation matrix, L lower triangular with unit
diagonal elements, and U upper triangular.

Parameters
----------
a : (M, N) array_like
    Matrix to decompose
overwrite_a : bool, optional
    Whether to overwrite data in A (may increase performance)
check_finite : bool, optional
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
lu : (M, N) ndarray
    Matrix containing U in its upper triangle, and L in its lower triangle.
    The unit diagonal elements of L are not stored.
piv : (N,) ndarray
    Pivot indices representing the permutation matrix P:
    row i of matrix was interchanged with row piv[i].

See Also
--------
lu : gives lu factorization in more user-friendly format
lu_solve : solve an equation system using the LU factorization of a matrix

Notes
-----
This is a wrapper to the ``*GETRF`` routines from LAPACK. Unlike
:func:`lu`, it outputs the L and U factors into a single array
and returns pivot indices instead of a permutation matrix.

Examples
--------
>>> import numpy as np
>>> from scipy.linalg import lu_factor
>>> A = np.array([[2, 5, 8, 7], [5, 2, 2, 8], [7, 5, 6, 6], [5, 4, 4, 8]])
>>> lu, piv = lu_factor(A)
>>> piv
array([2, 2, 3, 3], dtype=int32)

Convert LAPACK's ``piv`` array to NumPy index and test the permutation

>>> piv_py = [2, 0, 3, 1]
>>> L, U = np.tril(lu, k=-1) + np.eye(4), np.triu(lu)
>>> np.allclose(A[piv_py] - L @ U, np.zeros((4, 4)))
True
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__decomp__lu_8py_source_l00020}{20}} of file \mbox{\hyperlink{__decomp__lu_8py_source}{\+\_\+decomp\+\_\+lu.\+py}}.



References \mbox{\hyperlink{scipy_2linalg_2__misc_8py_source_l00181}{scipy.\+linalg.\+\_\+misc.\+\_\+datacopied()}}, and \mbox{\hyperlink{lapack_8py_source_l00882}{scipy.\+linalg.\+lapack.\+get\+\_\+lapack\+\_\+funcs()}}.



Referenced by \mbox{\hyperlink{test__decomp__lu_8py_source_l00229}{scipy.\+linalg.\+tests.\+test\+\_\+decomp\+\_\+lu.\+Test\+LUFactor.\+test\+\_\+medium1\+\_\+complex()}}.

\Hypertarget{namespacescipy_1_1linalg_1_1__decomp__lu_a4bf8c553bca299b245135fa3fc408a72}\index{scipy.linalg.\_decomp\_lu@{scipy.linalg.\_decomp\_lu}!lu\_solve@{lu\_solve}}
\index{lu\_solve@{lu\_solve}!scipy.linalg.\_decomp\_lu@{scipy.linalg.\_decomp\_lu}}
\doxysubsubsection{\texorpdfstring{lu\_solve()}{lu\_solve()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1linalg_1_1__decomp__lu_a4bf8c553bca299b245135fa3fc408a72} 
scipy.\+linalg.\+\_\+decomp\+\_\+lu.\+lu\+\_\+solve (\begin{DoxyParamCaption}\item[{}]{lu\+\_\+and\+\_\+piv}{, }\item[{}]{b}{, }\item[{}]{trans}{ = {\ttfamily 0}, }\item[{}]{overwrite\+\_\+b}{ = {\ttfamily False}, }\item[{}]{check\+\_\+finite}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Solve an equation system, a x = b, given the LU factorization of a

Parameters
----------
(lu, piv)
    Factorization of the coefficient matrix a, as given by lu_factor
b : array
    Right-hand side
trans : {0, 1, 2}, optional
    Type of system to solve:

    =====  =========
    trans  system
    =====  =========
    0      a x   = b
    1      a^T x = b
    2      a^H x = b
    =====  =========
overwrite_b : bool, optional
    Whether to overwrite data in b (may increase performance)
check_finite : bool, optional
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
x : array
    Solution to the system

See Also
--------
lu_factor : LU factorize a matrix

Examples
--------
>>> import numpy as np
>>> from scipy.linalg import lu_factor, lu_solve
>>> A = np.array([[2, 5, 8, 7], [5, 2, 2, 8], [7, 5, 6, 6], [5, 4, 4, 8]])
>>> b = np.array([1, 1, 1, 1])
>>> lu, piv = lu_factor(A)
>>> x = lu_solve((lu, piv), b)
>>> np.allclose(A @ x - b, np.zeros((4,)))
True
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__decomp__lu_8py_source_l00094}{94}} of file \mbox{\hyperlink{__decomp__lu_8py_source}{\+\_\+decomp\+\_\+lu.\+py}}.



References \mbox{\hyperlink{scipy_2linalg_2__misc_8py_source_l00181}{scipy.\+linalg.\+\_\+misc.\+\_\+datacopied()}}, and \mbox{\hyperlink{lapack_8py_source_l00882}{scipy.\+linalg.\+lapack.\+get\+\_\+lapack\+\_\+funcs()}}.



\doxysubsection{Variable Documentation}
\Hypertarget{namespacescipy_1_1linalg_1_1__decomp__lu_a46efb5245af2df8994db340b7f96e8bd}\index{scipy.linalg.\_decomp\_lu@{scipy.linalg.\_decomp\_lu}!\_\_all\_\_@{\_\_all\_\_}}
\index{\_\_all\_\_@{\_\_all\_\_}!scipy.linalg.\_decomp\_lu@{scipy.linalg.\_decomp\_lu}}
\doxysubsubsection{\texorpdfstring{\_\_all\_\_}{\_\_all\_\_}}
{\footnotesize\ttfamily \label{namespacescipy_1_1linalg_1_1__decomp__lu_a46efb5245af2df8994db340b7f96e8bd} 
list scipy.\+linalg.\+\_\+decomp\+\_\+lu.\+\_\+\+\_\+all\+\_\+\+\_\+ = \mbox{[}\textquotesingle{}\mbox{\hyperlink{namespacescipy_1_1linalg_1_1__decomp__lu_a92e75e2c660e16f852d8ff9687126851}{lu}}\textquotesingle{}, \textquotesingle{}\mbox{\hyperlink{namespacescipy_1_1linalg_1_1__decomp__lu_a4bf8c553bca299b245135fa3fc408a72}{lu\+\_\+solve}}\textquotesingle{}, \textquotesingle{}\mbox{\hyperlink{namespacescipy_1_1linalg_1_1__decomp__lu_a8675c7a06ce605453735ea37804a81a5}{lu\+\_\+factor}}\textquotesingle{}\mbox{]}\hspace{0.3cm}{\ttfamily [private]}}



Definition at line \mbox{\hyperlink{__decomp__lu_8py_source_l00017}{17}} of file \mbox{\hyperlink{__decomp__lu_8py_source}{\+\_\+decomp\+\_\+lu.\+py}}.

\Hypertarget{namespacescipy_1_1linalg_1_1__decomp__lu_a7e8a68890b45adfd645ccc360a82730c}\index{scipy.linalg.\_decomp\_lu@{scipy.linalg.\_decomp\_lu}!lapack\_cast\_dict@{lapack\_cast\_dict}}
\index{lapack\_cast\_dict@{lapack\_cast\_dict}!scipy.linalg.\_decomp\_lu@{scipy.linalg.\_decomp\_lu}}
\doxysubsubsection{\texorpdfstring{lapack\_cast\_dict}{lapack\_cast\_dict}}
{\footnotesize\ttfamily \label{namespacescipy_1_1linalg_1_1__decomp__lu_a7e8a68890b45adfd645ccc360a82730c} 
dict scipy.\+linalg.\+\_\+decomp\+\_\+lu.\+lapack\+\_\+cast\+\_\+dict}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ \{x:\ \textcolor{stringliteral}{''}.join([y\ \textcolor{keywordflow}{for}\ y\ \textcolor{keywordflow}{in}\ \textcolor{stringliteral}{'fdFD'}\ \textcolor{keywordflow}{if}\ np.can\_cast(x,\ y)])}
\DoxyCodeLine{00002\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ x\ \textcolor{keywordflow}{in}\ np.typecodes[\textcolor{stringliteral}{'All'}]\}}

\end{DoxyCode}


Definition at line \mbox{\hyperlink{__decomp__lu_8py_source_l00014}{14}} of file \mbox{\hyperlink{__decomp__lu_8py_source}{\+\_\+decomp\+\_\+lu.\+py}}.

