\doxysection{numpy.\+core.\+einsumfunc Namespace Reference}
\hypertarget{namespacenumpy_1_1core_1_1einsumfunc}{}\label{namespacenumpy_1_1core_1_1einsumfunc}\index{numpy.core.einsumfunc@{numpy.core.einsumfunc}}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1einsumfunc_ae0534658b323271137dcf34b25aa9fd9}{\+\_\+flop\+\_\+count}} (idx\+\_\+contraction, inner, num\+\_\+terms, size\+\_\+dictionary)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1einsumfunc_ac1a7ae66dbf87e0c7458651c801a55be}{\+\_\+compute\+\_\+size\+\_\+by\+\_\+dict}} (\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_a9b57e299af9537cd1030c654e4be8abb}{indices}}, idx\+\_\+dict)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1einsumfunc_ae3420e845da6cf5b8182f741c364b6e2}{\+\_\+find\+\_\+contraction}} (positions, input\+\_\+sets, output\+\_\+set)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1einsumfunc_a9dff852d6519fc0dcb632d7bb51818ca}{\+\_\+optimal\+\_\+path}} (input\+\_\+sets, output\+\_\+set, idx\+\_\+dict, memory\+\_\+limit)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1einsumfunc_a335083a29f87822424e8ac7e3bfb5060}{\+\_\+parse\+\_\+possible\+\_\+contraction}} (positions, input\+\_\+sets, output\+\_\+set, idx\+\_\+dict, memory\+\_\+limit, path\+\_\+cost, naive\+\_\+cost)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1einsumfunc_a67a948887a56e53d34d275ed795464d2}{\+\_\+update\+\_\+other\+\_\+results}} (results, best)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1einsumfunc_a1b1140adb40e3e09e6a4b291e3c9ddd8}{\+\_\+greedy\+\_\+path}} (input\+\_\+sets, output\+\_\+set, idx\+\_\+dict, memory\+\_\+limit)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1einsumfunc_ac5cd5849b0abe9fa455f46cf212c4ec7}{\+\_\+can\+\_\+dot}} (inputs, result, idx\+\_\+removed)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1einsumfunc_ad3a2d270997c04b34faf92b0b9d1291e}{\+\_\+parse\+\_\+einsum\+\_\+input}} (operands)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1einsumfunc_a73fd339ad847f48ff8f68063597791d9}{\+\_\+einsum\+\_\+path\+\_\+dispatcher}} (\texorpdfstring{$\ast$}{*}operands, optimize=None, einsum\+\_\+call=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1einsumfunc_a8df65e48c50e2ec96f2e23ea69249a32}{einsum\+\_\+path}} (\texorpdfstring{$\ast$}{*}operands, optimize=\textquotesingle{}greedy\textquotesingle{}, einsum\+\_\+call=False)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1einsumfunc_a2e25c66a9ca3c319c62b9a171dd6e66c}{\+\_\+einsum\+\_\+dispatcher}} (\texorpdfstring{$\ast$}{*}operands, out=None, optimize=None, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}kwargs)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1einsumfunc_af40e071d1855e1ffe8dcb31e705fc095}{einsum}} (\texorpdfstring{$\ast$}{*}operands, out=None, optimize=False, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}kwargs)
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
list \mbox{\hyperlink{namespacenumpy_1_1core_1_1einsumfunc_a166d635e475ff86e685961c3b7c60b73}{\+\_\+\+\_\+all\+\_\+\+\_\+}} = \mbox{[}\textquotesingle{}\mbox{\hyperlink{namespacenumpy_1_1core_1_1einsumfunc_af40e071d1855e1ffe8dcb31e705fc095}{einsum}}\textquotesingle{}, \textquotesingle{}\mbox{\hyperlink{namespacenumpy_1_1core_1_1einsumfunc_a8df65e48c50e2ec96f2e23ea69249a32}{einsum\+\_\+path}}\textquotesingle{}\mbox{]}
\item 
str \mbox{\hyperlink{namespacenumpy_1_1core_1_1einsumfunc_a18a08d7e10c94d25799a8e1a57922e23}{einsum\+\_\+symbols}} = \textquotesingle{}abcdefghijklmnopqrstuvwxyz\+ABCDEFGHIJKLMNOPQRSTUVWXYZ\textquotesingle{}
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1einsumfunc_ae9434bd5793781fc806f488c58228d32}{einsum\+\_\+symbols\+\_\+set}} = set(einsum\+\_\+symbols)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\begin{DoxyVerb}Implementation of optimized einsum.
\end{DoxyVerb}
 

\doxysubsection{Function Documentation}
\Hypertarget{namespacenumpy_1_1core_1_1einsumfunc_ac5cd5849b0abe9fa455f46cf212c4ec7}\index{numpy.core.einsumfunc@{numpy.core.einsumfunc}!\_can\_dot@{\_can\_dot}}
\index{\_can\_dot@{\_can\_dot}!numpy.core.einsumfunc@{numpy.core.einsumfunc}}
\doxysubsubsection{\texorpdfstring{\_can\_dot()}{\_can\_dot()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1core_1_1einsumfunc_ac5cd5849b0abe9fa455f46cf212c4ec7} 
numpy.\+core.\+einsumfunc.\+\_\+can\+\_\+dot (\begin{DoxyParamCaption}\item[{}]{inputs}{, }\item[{}]{result}{, }\item[{}]{idx\+\_\+removed}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Checks if we can use BLAS (np.tensordot) call and its beneficial to do so.

Parameters
----------
inputs : list of str
    Specifies the subscripts for summation.
result : str
    Resulting summation.
idx_removed : set
    Indices that are removed in the summation


Returns
-------
type : bool
    Returns true if BLAS should and can be used, else False

Notes
-----
If the operations is BLAS level 1 or 2 and is not already aligned
we default back to einsum as the memory movement to copy is more
costly than the operation itself.


Examples
--------

# Standard GEMM operation
>>> _can_dot(['ij', 'jk'], 'ik', set('j'))
True

# Can use the standard BLAS, but requires odd data movement
>>> _can_dot(['ijj', 'jk'], 'ik', set('j'))
False

# DDOT where the memory is not aligned
>>> _can_dot(['ijk', 'ikj'], '', set('ijk'))
False
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{core_2einsumfunc_8py_source_l00413}{413}} of file \mbox{\hyperlink{core_2einsumfunc_8py_source}{einsumfunc.\+py}}.



Referenced by \mbox{\hyperlink{core_2einsumfunc_8py_source_l00707}{einsum\+\_\+path()}}.

\Hypertarget{namespacenumpy_1_1core_1_1einsumfunc_ac1a7ae66dbf87e0c7458651c801a55be}\index{numpy.core.einsumfunc@{numpy.core.einsumfunc}!\_compute\_size\_by\_dict@{\_compute\_size\_by\_dict}}
\index{\_compute\_size\_by\_dict@{\_compute\_size\_by\_dict}!numpy.core.einsumfunc@{numpy.core.einsumfunc}}
\doxysubsubsection{\texorpdfstring{\_compute\_size\_by\_dict()}{\_compute\_size\_by\_dict()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1core_1_1einsumfunc_ac1a7ae66dbf87e0c7458651c801a55be} 
numpy.\+core.\+einsumfunc.\+\_\+compute\+\_\+size\+\_\+by\+\_\+dict (\begin{DoxyParamCaption}\item[{}]{indices}{, }\item[{}]{idx\+\_\+dict}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Computes the product of the elements in indices based on the dictionary
idx_dict.

Parameters
----------
indices : iterable
    Indices to base the product on.
idx_dict : dictionary
    Dictionary of index sizes

Returns
-------
ret : int
    The resulting product.

Examples
--------
>>> _compute_size_by_dict('abbc', {'a': 2, 'b':3, 'c':5})
90
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{core_2einsumfunc_8py_source_l00056}{56}} of file \mbox{\hyperlink{core_2einsumfunc_8py_source}{einsumfunc.\+py}}.



Referenced by \mbox{\hyperlink{core_2einsumfunc_8py_source_l00018}{\+\_\+flop\+\_\+count()}}, \mbox{\hyperlink{core_2einsumfunc_8py_source_l00145}{\+\_\+optimal\+\_\+path()}}, \mbox{\hyperlink{core_2einsumfunc_8py_source_l00215}{\+\_\+parse\+\_\+possible\+\_\+contraction()}}, and \mbox{\hyperlink{core_2einsumfunc_8py_source_l00707}{einsum\+\_\+path()}}.

\Hypertarget{namespacenumpy_1_1core_1_1einsumfunc_a2e25c66a9ca3c319c62b9a171dd6e66c}\index{numpy.core.einsumfunc@{numpy.core.einsumfunc}!\_einsum\_dispatcher@{\_einsum\_dispatcher}}
\index{\_einsum\_dispatcher@{\_einsum\_dispatcher}!numpy.core.einsumfunc@{numpy.core.einsumfunc}}
\doxysubsubsection{\texorpdfstring{\_einsum\_dispatcher()}{\_einsum\_dispatcher()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1core_1_1einsumfunc_a2e25c66a9ca3c319c62b9a171dd6e66c} 
numpy.\+core.\+einsumfunc.\+\_\+einsum\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{\texorpdfstring{$\ast$}{*}}]{operands}{, }\item[{}]{out}{ = {\ttfamily None}, }\item[{}]{optimize}{ = {\ttfamily None}, }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{kwargs}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{core_2einsumfunc_8py_source_l01001}{1001}} of file \mbox{\hyperlink{core_2einsumfunc_8py_source}{einsumfunc.\+py}}.

\Hypertarget{namespacenumpy_1_1core_1_1einsumfunc_a73fd339ad847f48ff8f68063597791d9}\index{numpy.core.einsumfunc@{numpy.core.einsumfunc}!\_einsum\_path\_dispatcher@{\_einsum\_path\_dispatcher}}
\index{\_einsum\_path\_dispatcher@{\_einsum\_path\_dispatcher}!numpy.core.einsumfunc@{numpy.core.einsumfunc}}
\doxysubsubsection{\texorpdfstring{\_einsum\_path\_dispatcher()}{\_einsum\_path\_dispatcher()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1core_1_1einsumfunc_a73fd339ad847f48ff8f68063597791d9} 
numpy.\+core.\+einsumfunc.\+\_\+einsum\+\_\+path\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{\texorpdfstring{$\ast$}{*}}]{operands}{, }\item[{}]{optimize}{ = {\ttfamily None}, }\item[{}]{einsum\+\_\+call}{ = {\ttfamily None}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{core_2einsumfunc_8py_source_l00696}{696}} of file \mbox{\hyperlink{core_2einsumfunc_8py_source}{einsumfunc.\+py}}.

\Hypertarget{namespacenumpy_1_1core_1_1einsumfunc_ae3420e845da6cf5b8182f741c364b6e2}\index{numpy.core.einsumfunc@{numpy.core.einsumfunc}!\_find\_contraction@{\_find\_contraction}}
\index{\_find\_contraction@{\_find\_contraction}!numpy.core.einsumfunc@{numpy.core.einsumfunc}}
\doxysubsubsection{\texorpdfstring{\_find\_contraction()}{\_find\_contraction()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1core_1_1einsumfunc_ae3420e845da6cf5b8182f741c364b6e2} 
numpy.\+core.\+einsumfunc.\+\_\+find\+\_\+contraction (\begin{DoxyParamCaption}\item[{}]{positions}{, }\item[{}]{input\+\_\+sets}{, }\item[{}]{output\+\_\+set}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Finds the contraction for a given set of input and output sets.

Parameters
----------
positions : iterable
    Integer positions of terms used in the contraction.
input_sets : list
    List of sets that represent the lhs side of the einsum subscript
output_set : set
    Set that represents the rhs side of the overall einsum subscript

Returns
-------
new_result : set
    The indices of the resulting contraction
remaining : list
    List of sets that have not been contracted, the new set is appended to
    the end of this list
idx_removed : set
    Indices removed from the entire contraction
idx_contraction : set
    The indices used in the current contraction

Examples
--------

# A simple dot product test case
>>> pos = (0, 1)
>>> isets = [set('ab'), set('bc')]
>>> oset = set('ac')
>>> _find_contraction(pos, isets, oset)
({'a', 'c'}, [{'a', 'c'}], {'b'}, {'a', 'b', 'c'})

# A more complex case with additional terms in the contraction
>>> pos = (0, 2)
>>> isets = [set('abd'), set('ac'), set('bdc')]
>>> oset = set('ac')
>>> _find_contraction(pos, isets, oset)
({'a', 'c'}, [{'a', 'c'}, {'a', 'c'}], {'b', 'd'}, {'a', 'b', 'c', 'd'})
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{core_2einsumfunc_8py_source_l00085}{85}} of file \mbox{\hyperlink{core_2einsumfunc_8py_source}{einsumfunc.\+py}}.



Referenced by \mbox{\hyperlink{core_2einsumfunc_8py_source_l00312}{\+\_\+greedy\+\_\+path()}}, \mbox{\hyperlink{core_2einsumfunc_8py_source_l00145}{\+\_\+optimal\+\_\+path()}}, \mbox{\hyperlink{core_2einsumfunc_8py_source_l00215}{\+\_\+parse\+\_\+possible\+\_\+contraction()}}, and \mbox{\hyperlink{core_2einsumfunc_8py_source_l00707}{einsum\+\_\+path()}}.

\Hypertarget{namespacenumpy_1_1core_1_1einsumfunc_ae0534658b323271137dcf34b25aa9fd9}\index{numpy.core.einsumfunc@{numpy.core.einsumfunc}!\_flop\_count@{\_flop\_count}}
\index{\_flop\_count@{\_flop\_count}!numpy.core.einsumfunc@{numpy.core.einsumfunc}}
\doxysubsubsection{\texorpdfstring{\_flop\_count()}{\_flop\_count()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1core_1_1einsumfunc_ae0534658b323271137dcf34b25aa9fd9} 
numpy.\+core.\+einsumfunc.\+\_\+flop\+\_\+count (\begin{DoxyParamCaption}\item[{}]{idx\+\_\+contraction}{, }\item[{}]{inner}{, }\item[{}]{num\+\_\+terms}{, }\item[{}]{size\+\_\+dictionary}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Computes the number of FLOPS in the contraction.

Parameters
----------
idx_contraction : iterable
    The indices involved in the contraction
inner : bool
    Does this contraction require an inner product?
num_terms : int
    The number of terms in a contraction
size_dictionary : dict
    The size of each of the indices in idx_contraction

Returns
-------
flop_count : int
    The total number of FLOPS required for the contraction.

Examples
--------

>>> _flop_count('abc', False, 1, {'a': 2, 'b':3, 'c':5})
30

>>> _flop_count('abc', True, 2, {'a': 2, 'b':3, 'c':5})
60
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{core_2einsumfunc_8py_source_l00018}{18}} of file \mbox{\hyperlink{core_2einsumfunc_8py_source}{einsumfunc.\+py}}.



References \mbox{\hyperlink{core_2einsumfunc_8py_source_l00056}{\+\_\+compute\+\_\+size\+\_\+by\+\_\+dict()}}, and \mbox{\hyperlink{core_2fromnumeric_8py_source_l02695}{numpy.\+core.\+fromnumeric.\+max()}}.



Referenced by \mbox{\hyperlink{core_2einsumfunc_8py_source_l00312}{\+\_\+greedy\+\_\+path()}}, \mbox{\hyperlink{core_2einsumfunc_8py_source_l00145}{\+\_\+optimal\+\_\+path()}}, \mbox{\hyperlink{core_2einsumfunc_8py_source_l00215}{\+\_\+parse\+\_\+possible\+\_\+contraction()}}, and \mbox{\hyperlink{core_2einsumfunc_8py_source_l00707}{einsum\+\_\+path()}}.

\Hypertarget{namespacenumpy_1_1core_1_1einsumfunc_a1b1140adb40e3e09e6a4b291e3c9ddd8}\index{numpy.core.einsumfunc@{numpy.core.einsumfunc}!\_greedy\_path@{\_greedy\_path}}
\index{\_greedy\_path@{\_greedy\_path}!numpy.core.einsumfunc@{numpy.core.einsumfunc}}
\doxysubsubsection{\texorpdfstring{\_greedy\_path()}{\_greedy\_path()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1core_1_1einsumfunc_a1b1140adb40e3e09e6a4b291e3c9ddd8} 
numpy.\+core.\+einsumfunc.\+\_\+greedy\+\_\+path (\begin{DoxyParamCaption}\item[{}]{input\+\_\+sets}{, }\item[{}]{output\+\_\+set}{, }\item[{}]{idx\+\_\+dict}{, }\item[{}]{memory\+\_\+limit}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Finds the path by contracting the best pair until the input list is
exhausted. The best pair is found by minimizing the tuple
``(-prod(indices_removed), cost)``.  What this amounts to is prioritizing
matrix multiplication or inner product operations, then Hadamard like
operations, and finally outer operations. Outer products are limited by
``memory_limit``. This algorithm scales cubically with respect to the
number of elements in the list ``input_sets``.

Parameters
----------
input_sets : list
    List of sets that represent the lhs side of the einsum subscript
output_set : set
    Set that represents the rhs side of the overall einsum subscript
idx_dict : dictionary
    Dictionary of index sizes
memory_limit : int
    The maximum number of elements in a temporary array

Returns
-------
path : list
    The greedy contraction order within the memory limit constraint.

Examples
--------
>>> isets = [set('abd'), set('ac'), set('bdc')]
>>> oset = set()
>>> idx_sizes = {'a': 1, 'b':2, 'c':3, 'd':4}
>>> _greedy_path(isets, oset, idx_sizes, 5000)
[(0, 2), (0, 1)]
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{core_2einsumfunc_8py_source_l00312}{312}} of file \mbox{\hyperlink{core_2einsumfunc_8py_source}{einsumfunc.\+py}}.



References \mbox{\hyperlink{core_2einsumfunc_8py_source_l00085}{\+\_\+find\+\_\+contraction()}}, \mbox{\hyperlink{core_2einsumfunc_8py_source_l00018}{\+\_\+flop\+\_\+count()}}, \mbox{\hyperlink{core_2einsumfunc_8py_source_l00215}{\+\_\+parse\+\_\+possible\+\_\+contraction()}}, \mbox{\hyperlink{core_2einsumfunc_8py_source_l00273}{\+\_\+update\+\_\+other\+\_\+results()}}, and \mbox{\hyperlink{core_2fromnumeric_8py_source_l02838}{numpy.\+core.\+fromnumeric.\+min()}}.



Referenced by \mbox{\hyperlink{core_2einsumfunc_8py_source_l00707}{einsum\+\_\+path()}}.

\Hypertarget{namespacenumpy_1_1core_1_1einsumfunc_a9dff852d6519fc0dcb632d7bb51818ca}\index{numpy.core.einsumfunc@{numpy.core.einsumfunc}!\_optimal\_path@{\_optimal\_path}}
\index{\_optimal\_path@{\_optimal\_path}!numpy.core.einsumfunc@{numpy.core.einsumfunc}}
\doxysubsubsection{\texorpdfstring{\_optimal\_path()}{\_optimal\_path()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1core_1_1einsumfunc_a9dff852d6519fc0dcb632d7bb51818ca} 
numpy.\+core.\+einsumfunc.\+\_\+optimal\+\_\+path (\begin{DoxyParamCaption}\item[{}]{input\+\_\+sets}{, }\item[{}]{output\+\_\+set}{, }\item[{}]{idx\+\_\+dict}{, }\item[{}]{memory\+\_\+limit}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Computes all possible pair contractions, sieves the results based
on ``memory_limit`` and returns the lowest cost path. This algorithm
scales factorial with respect to the elements in the list ``input_sets``.

Parameters
----------
input_sets : list
    List of sets that represent the lhs side of the einsum subscript
output_set : set
    Set that represents the rhs side of the overall einsum subscript
idx_dict : dictionary
    Dictionary of index sizes
memory_limit : int
    The maximum number of elements in a temporary array

Returns
-------
path : list
    The optimal contraction order within the memory limit constraint.

Examples
--------
>>> isets = [set('abd'), set('ac'), set('bdc')]
>>> oset = set()
>>> idx_sizes = {'a': 1, 'b':2, 'c':3, 'd':4}
>>> _optimal_path(isets, oset, idx_sizes, 5000)
[(0, 2), (0, 1)]
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{core_2einsumfunc_8py_source_l00145}{145}} of file \mbox{\hyperlink{core_2einsumfunc_8py_source}{einsumfunc.\+py}}.



References \mbox{\hyperlink{core_2einsumfunc_8py_source_l00056}{\+\_\+compute\+\_\+size\+\_\+by\+\_\+dict()}}, \mbox{\hyperlink{core_2einsumfunc_8py_source_l00085}{\+\_\+find\+\_\+contraction()}}, \mbox{\hyperlink{core_2einsumfunc_8py_source_l00018}{\+\_\+flop\+\_\+count()}}, and \mbox{\hyperlink{core_2fromnumeric_8py_source_l02838}{numpy.\+core.\+fromnumeric.\+min()}}.



Referenced by \mbox{\hyperlink{core_2einsumfunc_8py_source_l00707}{einsum\+\_\+path()}}.

\Hypertarget{namespacenumpy_1_1core_1_1einsumfunc_ad3a2d270997c04b34faf92b0b9d1291e}\index{numpy.core.einsumfunc@{numpy.core.einsumfunc}!\_parse\_einsum\_input@{\_parse\_einsum\_input}}
\index{\_parse\_einsum\_input@{\_parse\_einsum\_input}!numpy.core.einsumfunc@{numpy.core.einsumfunc}}
\doxysubsubsection{\texorpdfstring{\_parse\_einsum\_input()}{\_parse\_einsum\_input()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1core_1_1einsumfunc_ad3a2d270997c04b34faf92b0b9d1291e} 
numpy.\+core.\+einsumfunc.\+\_\+parse\+\_\+einsum\+\_\+input (\begin{DoxyParamCaption}\item[{}]{operands}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}A reproduction of einsum c side einsum parsing in python.

Returns
-------
input_strings : str
    Parsed input strings
output_string : str
    Parsed output string
operands : list of array_like
    The operands to use in the numpy contraction

Examples
--------
The operand list is simplified to reduce printing:

>>> np.random.seed(123)
>>> a = np.random.rand(4, 4)
>>> b = np.random.rand(4, 4, 4)
>>> _parse_einsum_input(('...a,...a->...', a, b))
('za,xza', 'xz', [a, b]) # may vary

>>> _parse_einsum_input((a, [Ellipsis, 0], b, [Ellipsis, 0]))
('za,xza', 'xz', [a, b]) # may vary
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{core_2einsumfunc_8py_source_l00523}{523}} of file \mbox{\hyperlink{core_2einsumfunc_8py_source}{einsumfunc.\+py}}.



References \mbox{\hyperlink{core_2fromnumeric_8py_source_l02695}{numpy.\+core.\+fromnumeric.\+max()}}.



Referenced by \mbox{\hyperlink{core_2einsumfunc_8py_source_l00707}{einsum\+\_\+path()}}.

\Hypertarget{namespacenumpy_1_1core_1_1einsumfunc_a335083a29f87822424e8ac7e3bfb5060}\index{numpy.core.einsumfunc@{numpy.core.einsumfunc}!\_parse\_possible\_contraction@{\_parse\_possible\_contraction}}
\index{\_parse\_possible\_contraction@{\_parse\_possible\_contraction}!numpy.core.einsumfunc@{numpy.core.einsumfunc}}
\doxysubsubsection{\texorpdfstring{\_parse\_possible\_contraction()}{\_parse\_possible\_contraction()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1core_1_1einsumfunc_a335083a29f87822424e8ac7e3bfb5060} 
numpy.\+core.\+einsumfunc.\+\_\+parse\+\_\+possible\+\_\+contraction (\begin{DoxyParamCaption}\item[{}]{positions}{, }\item[{}]{input\+\_\+sets}{, }\item[{}]{output\+\_\+set}{, }\item[{}]{idx\+\_\+dict}{, }\item[{}]{memory\+\_\+limit}{, }\item[{}]{path\+\_\+cost}{, }\item[{}]{naive\+\_\+cost}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Compute the cost (removed size + flops) and resultant indices for
performing the contraction specified by ``positions``.

Parameters
----------
positions : tuple of int
    The locations of the proposed tensors to contract.
input_sets : list of sets
    The indices found on each tensors.
output_set : set
    The output indices of the expression.
idx_dict : dict
    Mapping of each index to its size.
memory_limit : int
    The total allowed size for an intermediary tensor.
path_cost : int
    The contraction cost so far.
naive_cost : int
    The cost of the unoptimized expression.

Returns
-------
cost : (int, int)
    A tuple containing the size of any indices removed, and the flop cost.
positions : tuple of int
    The locations of the proposed tensors to contract.
new_input_sets : list of sets
    The resulting new list of indices if this proposed contraction is performed.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{core_2einsumfunc_8py_source_l00215}{215}} of file \mbox{\hyperlink{core_2einsumfunc_8py_source}{einsumfunc.\+py}}.



References \mbox{\hyperlink{core_2einsumfunc_8py_source_l00056}{\+\_\+compute\+\_\+size\+\_\+by\+\_\+dict()}}, \mbox{\hyperlink{core_2einsumfunc_8py_source_l00085}{\+\_\+find\+\_\+contraction()}}, \mbox{\hyperlink{core_2einsumfunc_8py_source_l00018}{\+\_\+flop\+\_\+count()}}, and \mbox{\hyperlink{core_2fromnumeric_8py_source_l02179}{numpy.\+core.\+fromnumeric.\+sum()}}.



Referenced by \mbox{\hyperlink{core_2einsumfunc_8py_source_l00312}{\+\_\+greedy\+\_\+path()}}.

\Hypertarget{namespacenumpy_1_1core_1_1einsumfunc_a67a948887a56e53d34d275ed795464d2}\index{numpy.core.einsumfunc@{numpy.core.einsumfunc}!\_update\_other\_results@{\_update\_other\_results}}
\index{\_update\_other\_results@{\_update\_other\_results}!numpy.core.einsumfunc@{numpy.core.einsumfunc}}
\doxysubsubsection{\texorpdfstring{\_update\_other\_results()}{\_update\_other\_results()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1core_1_1einsumfunc_a67a948887a56e53d34d275ed795464d2} 
numpy.\+core.\+einsumfunc.\+\_\+update\+\_\+other\+\_\+results (\begin{DoxyParamCaption}\item[{}]{results}{, }\item[{}]{best}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Update the positions and provisional input_sets of ``results`` based on
performing the contraction result ``best``. Remove any involving the tensors
contracted.

Parameters
----------
results : list
    List of contraction results produced by ``_parse_possible_contraction``.
best : list
    The best contraction of ``results`` i.e. the one that will be performed.

Returns
-------
mod_results : list
    The list of modified results, updated with outcome of ``best`` contraction.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{core_2einsumfunc_8py_source_l00273}{273}} of file \mbox{\hyperlink{core_2einsumfunc_8py_source}{einsumfunc.\+py}}.



Referenced by \mbox{\hyperlink{core_2einsumfunc_8py_source_l00312}{\+\_\+greedy\+\_\+path()}}.

\Hypertarget{namespacenumpy_1_1core_1_1einsumfunc_af40e071d1855e1ffe8dcb31e705fc095}\index{numpy.core.einsumfunc@{numpy.core.einsumfunc}!einsum@{einsum}}
\index{einsum@{einsum}!numpy.core.einsumfunc@{numpy.core.einsumfunc}}
\doxysubsubsection{\texorpdfstring{einsum()}{einsum()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1core_1_1einsumfunc_af40e071d1855e1ffe8dcb31e705fc095} 
numpy.\+core.\+einsumfunc.\+einsum (\begin{DoxyParamCaption}\item[{\texorpdfstring{$\ast$}{*}}]{operands}{, }\item[{}]{out}{ = {\ttfamily None}, }\item[{}]{optimize}{ = {\ttfamily False}, }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{kwargs}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}einsum(subscripts, *operands, out=None, dtype=None, order='K',
       casting='safe', optimize=False)

Evaluates the Einstein summation convention on the operands.

Using the Einstein summation convention, many common multi-dimensional,
linear algebraic array operations can be represented in a simple fashion.
In *implicit* mode `einsum` computes these values.

In *explicit* mode, `einsum` provides further flexibility to compute
other array operations that might not be considered classical Einstein
summation operations, by disabling, or forcing summation over specified
subscript labels.

See the notes and examples for clarification.

Parameters
----------
subscripts : str
    Specifies the subscripts for summation as comma separated list of
    subscript labels. An implicit (classical Einstein summation)
    calculation is performed unless the explicit indicator '->' is
    included as well as subscript labels of the precise output form.
operands : list of array_like
    These are the arrays for the operation.
out : ndarray, optional
    If provided, the calculation is done into this array.
dtype : {data-type, None}, optional
    If provided, forces the calculation to use the data type specified.
    Note that you may have to also give a more liberal `casting`
    parameter to allow the conversions. Default is None.
order : {'C', 'F', 'A', 'K'}, optional
    Controls the memory layout of the output. 'C' means it should
    be C contiguous. 'F' means it should be Fortran contiguous,
    'A' means it should be 'F' if the inputs are all 'F', 'C' otherwise.
    'K' means it should be as close to the layout as the inputs as
    is possible, including arbitrarily permuted axes.
    Default is 'K'.
casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional
    Controls what kind of data casting may occur.  Setting this to
    'unsafe' is not recommended, as it can adversely affect accumulations.

      * 'no' means the data types should not be cast at all.
      * 'equiv' means only byte-order changes are allowed.
      * 'safe' means only casts which can preserve values are allowed.
      * 'same_kind' means only safe casts or casts within a kind,
        like float64 to float32, are allowed.
      * 'unsafe' means any data conversions may be done.

    Default is 'safe'.
optimize : {False, True, 'greedy', 'optimal'}, optional
    Controls if intermediate optimization should occur. No optimization
    will occur if False and True will default to the 'greedy' algorithm.
    Also accepts an explicit contraction list from the ``np.einsum_path``
    function. See ``np.einsum_path`` for more details. Defaults to False.

Returns
-------
output : ndarray
    The calculation based on the Einstein summation convention.

See Also
--------
einsum_path, dot, inner, outer, tensordot, linalg.multi_dot
einops :
    similar verbose interface is provided by
    `einops <https://github.com/arogozhnikov/einops>`_ package to cover
    additional operations: transpose, reshape/flatten, repeat/tile,
    squeeze/unsqueeze and reductions.
opt_einsum :
    `opt_einsum <https://optimized-einsum.readthedocs.io/en/stable/>`_
    optimizes contraction order for einsum-like expressions
    in backend-agnostic manner.

Notes
-----
.. versionadded:: 1.6.0

The Einstein summation convention can be used to compute
many multi-dimensional, linear algebraic array operations. `einsum`
provides a succinct way of representing these.

A non-exhaustive list of these operations,
which can be computed by `einsum`, is shown below along with examples:

* Trace of an array, :py:func:`numpy.trace`.
* Return a diagonal, :py:func:`numpy.diag`.
* Array axis summations, :py:func:`numpy.sum`.
* Transpositions and permutations, :py:func:`numpy.transpose`.
* Matrix multiplication and dot product, :py:func:`numpy.matmul` :py:func:`numpy.dot`.
* Vector inner and outer products, :py:func:`numpy.inner` :py:func:`numpy.outer`.
* Broadcasting, element-wise and scalar multiplication, :py:func:`numpy.multiply`.
* Tensor contractions, :py:func:`numpy.tensordot`.
* Chained array operations, in efficient calculation order, :py:func:`numpy.einsum_path`.

The subscripts string is a comma-separated list of subscript labels,
where each label refers to a dimension of the corresponding operand.
Whenever a label is repeated it is summed, so ``np.einsum('i,i', a, b)``
is equivalent to :py:func:`np.inner(a,b) <numpy.inner>`. If a label
appears only once, it is not summed, so ``np.einsum('i', a)`` produces a
view of ``a`` with no changes. A further example ``np.einsum('ij,jk', a, b)``
describes traditional matrix multiplication and is equivalent to
:py:func:`np.matmul(a,b) <numpy.matmul>`. Repeated subscript labels in one
operand take the diagonal. For example, ``np.einsum('ii', a)`` is equivalent
to :py:func:`np.trace(a) <numpy.trace>`.

In *implicit mode*, the chosen subscripts are important
since the axes of the output are reordered alphabetically.  This
means that ``np.einsum('ij', a)`` doesn't affect a 2D array, while
``np.einsum('ji', a)`` takes its transpose. Additionally,
``np.einsum('ij,jk', a, b)`` returns a matrix multiplication, while,
``np.einsum('ij,jh', a, b)`` returns the transpose of the
multiplication since subscript 'h' precedes subscript 'i'.

In *explicit mode* the output can be directly controlled by
specifying output subscript labels.  This requires the
identifier '->' as well as the list of output subscript labels.
This feature increases the flexibility of the function since
summing can be disabled or forced when required. The call
``np.einsum('i->', a)`` is like :py:func:`np.sum(a, axis=-1) <numpy.sum>`,
and ``np.einsum('ii->i', a)`` is like :py:func:`np.diag(a) <numpy.diag>`.
The difference is that `einsum` does not allow broadcasting by default.
Additionally ``np.einsum('ij,jh->ih', a, b)`` directly specifies the
order of the output subscript labels and therefore returns matrix
multiplication, unlike the example above in implicit mode.

To enable and control broadcasting, use an ellipsis.  Default
NumPy-style broadcasting is done by adding an ellipsis
to the left of each term, like ``np.einsum('...ii->...i', a)``.
To take the trace along the first and last axes,
you can do ``np.einsum('i...i', a)``, or to do a matrix-matrix
product with the left-most indices instead of rightmost, one can do
``np.einsum('ij...,jk...->ik...', a, b)``.

When there is only one operand, no axes are summed, and no output
parameter is provided, a view into the operand is returned instead
of a new array.  Thus, taking the diagonal as ``np.einsum('ii->i', a)``
produces a view (changed in version 1.10.0).

`einsum` also provides an alternative way to provide the subscripts
and operands as ``einsum(op0, sublist0, op1, sublist1, ..., [sublistout])``.
If the output shape is not provided in this format `einsum` will be
calculated in implicit mode, otherwise it will be performed explicitly.
The examples below have corresponding `einsum` calls with the two
parameter methods.

.. versionadded:: 1.10.0

Views returned from einsum are now writeable whenever the input array
is writeable. For example, ``np.einsum('ijk...->kji...', a)`` will now
have the same effect as :py:func:`np.swapaxes(a, 0, 2) <numpy.swapaxes>`
and ``np.einsum('ii->i', a)`` will return a writeable view of the diagonal
of a 2D array.

.. versionadded:: 1.12.0

Added the ``optimize`` argument which will optimize the contraction order
of an einsum expression. For a contraction with three or more operands this
can greatly increase the computational efficiency at the cost of a larger
memory footprint during computation.

Typically a 'greedy' algorithm is applied which empirical tests have shown
returns the optimal path in the majority of cases. In some cases 'optimal'
will return the superlative path through a more expensive, exhaustive search.
For iterative calculations it may be advisable to calculate the optimal path
once and reuse that path by supplying it as an argument. An example is given
below.

See :py:func:`numpy.einsum_path` for more details.

Examples
--------
>>> a = np.arange(25).reshape(5,5)
>>> b = np.arange(5)
>>> c = np.arange(6).reshape(2,3)

Trace of a matrix:

>>> np.einsum('ii', a)
60
>>> np.einsum(a, [0,0])
60
>>> np.trace(a)
60

Extract the diagonal (requires explicit form):

>>> np.einsum('ii->i', a)
array([ 0,  6, 12, 18, 24])
>>> np.einsum(a, [0,0], [0])
array([ 0,  6, 12, 18, 24])
>>> np.diag(a)
array([ 0,  6, 12, 18, 24])

Sum over an axis (requires explicit form):

>>> np.einsum('ij->i', a)
array([ 10,  35,  60,  85, 110])
>>> np.einsum(a, [0,1], [0])
array([ 10,  35,  60,  85, 110])
>>> np.sum(a, axis=1)
array([ 10,  35,  60,  85, 110])

For higher dimensional arrays summing a single axis can be done with ellipsis:

>>> np.einsum('...j->...', a)
array([ 10,  35,  60,  85, 110])
>>> np.einsum(a, [Ellipsis,1], [Ellipsis])
array([ 10,  35,  60,  85, 110])

Compute a matrix transpose, or reorder any number of axes:

>>> np.einsum('ji', c)
array([[0, 3],
       [1, 4],
       [2, 5]])
>>> np.einsum('ij->ji', c)
array([[0, 3],
       [1, 4],
       [2, 5]])
>>> np.einsum(c, [1,0])
array([[0, 3],
       [1, 4],
       [2, 5]])
>>> np.transpose(c)
array([[0, 3],
       [1, 4],
       [2, 5]])

Vector inner products:

>>> np.einsum('i,i', b, b)
30
>>> np.einsum(b, [0], b, [0])
30
>>> np.inner(b,b)
30

Matrix vector multiplication:

>>> np.einsum('ij,j', a, b)
array([ 30,  80, 130, 180, 230])
>>> np.einsum(a, [0,1], b, [1])
array([ 30,  80, 130, 180, 230])
>>> np.dot(a, b)
array([ 30,  80, 130, 180, 230])
>>> np.einsum('...j,j', a, b)
array([ 30,  80, 130, 180, 230])

Broadcasting and scalar multiplication:

>>> np.einsum('..., ...', 3, c)
array([[ 0,  3,  6],
       [ 9, 12, 15]])
>>> np.einsum(',ij', 3, c)
array([[ 0,  3,  6],
       [ 9, 12, 15]])
>>> np.einsum(3, [Ellipsis], c, [Ellipsis])
array([[ 0,  3,  6],
       [ 9, 12, 15]])
>>> np.multiply(3, c)
array([[ 0,  3,  6],
       [ 9, 12, 15]])

Vector outer product:

>>> np.einsum('i,j', np.arange(2)+1, b)
array([[0, 1, 2, 3, 4],
       [0, 2, 4, 6, 8]])
>>> np.einsum(np.arange(2)+1, [0], b, [1])
array([[0, 1, 2, 3, 4],
       [0, 2, 4, 6, 8]])
>>> np.outer(np.arange(2)+1, b)
array([[0, 1, 2, 3, 4],
       [0, 2, 4, 6, 8]])

Tensor contraction:

>>> a = np.arange(60.).reshape(3,4,5)
>>> b = np.arange(24.).reshape(4,3,2)
>>> np.einsum('ijk,jil->kl', a, b)
array([[4400., 4730.],
       [4532., 4874.],
       [4664., 5018.],
       [4796., 5162.],
       [4928., 5306.]])
>>> np.einsum(a, [0,1,2], b, [1,0,3], [2,3])
array([[4400., 4730.],
       [4532., 4874.],
       [4664., 5018.],
       [4796., 5162.],
       [4928., 5306.]])
>>> np.tensordot(a,b, axes=([1,0],[0,1]))
array([[4400., 4730.],
       [4532., 4874.],
       [4664., 5018.],
       [4796., 5162.],
       [4928., 5306.]])

Writeable returned arrays (since version 1.10.0):

>>> a = np.zeros((3, 3))
>>> np.einsum('ii->i', a)[:] = 1
>>> a
array([[1., 0., 0.],
       [0., 1., 0.],
       [0., 0., 1.]])

Example of ellipsis use:

>>> a = np.arange(6).reshape((3,2))
>>> b = np.arange(12).reshape((4,3))
>>> np.einsum('ki,jk->ij', a, b)
array([[10, 28, 46, 64],
       [13, 40, 67, 94]])
>>> np.einsum('ki,...k->i...', a, b)
array([[10, 28, 46, 64],
       [13, 40, 67, 94]])
>>> np.einsum('k...,jk', a, b)
array([[10, 28, 46, 64],
       [13, 40, 67, 94]])

Chained array operations. For more complicated contractions, speed ups
might be achieved by repeatedly computing a 'greedy' path or pre-computing the
'optimal' path and repeatedly applying it, using an
`einsum_path` insertion (since version 1.12.0). Performance improvements can be
particularly significant with larger arrays:

>>> a = np.ones(64).reshape(2,4,8)

Basic `einsum`: ~1520ms  (benchmarked on 3.1GHz Intel i5.)

>>> for iteration in range(500):
...     _ = np.einsum('ijk,ilm,njm,nlk,abc->',a,a,a,a,a)

Sub-optimal `einsum` (due to repeated path calculation time): ~330ms

>>> for iteration in range(500):
...     _ = np.einsum('ijk,ilm,njm,nlk,abc->',a,a,a,a,a, optimize='optimal')

Greedy `einsum` (faster optimal path approximation): ~160ms

>>> for iteration in range(500):
...     _ = np.einsum('ijk,ilm,njm,nlk,abc->',a,a,a,a,a, optimize='greedy')

Optimal `einsum` (best usage pattern in some use cases): ~110ms

>>> path = np.einsum_path('ijk,ilm,njm,nlk,abc->',a,a,a,a,a, optimize='optimal')[0]
>>> for iteration in range(500):
...     _ = np.einsum('ijk,ilm,njm,nlk,abc->',a,a,a,a,a, optimize=path)
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{core_2einsumfunc_8py_source_l01010}{1010}} of file \mbox{\hyperlink{core_2einsumfunc_8py_source}{einsumfunc.\+py}}.



References \mbox{\hyperlink{core_2fromnumeric_8py_source_l02422}{numpy.\+core.\+fromnumeric.\+all()}}, \mbox{\hyperlink{core_2einsumfunc_8py_source_l00707}{einsum\+\_\+path()}}, and \mbox{\hyperlink{numpy_2core_2numeric_8py_source_l00933}{numpy.\+core.\+numeric.\+tensordot()}}.

\Hypertarget{namespacenumpy_1_1core_1_1einsumfunc_a8df65e48c50e2ec96f2e23ea69249a32}\index{numpy.core.einsumfunc@{numpy.core.einsumfunc}!einsum\_path@{einsum\_path}}
\index{einsum\_path@{einsum\_path}!numpy.core.einsumfunc@{numpy.core.einsumfunc}}
\doxysubsubsection{\texorpdfstring{einsum\_path()}{einsum\_path()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1core_1_1einsumfunc_a8df65e48c50e2ec96f2e23ea69249a32} 
numpy.\+core.\+einsumfunc.\+einsum\+\_\+path (\begin{DoxyParamCaption}\item[{\texorpdfstring{$\ast$}{*}}]{operands}{, }\item[{}]{optimize}{ = {\ttfamily \textquotesingle{}greedy\textquotesingle{}}, }\item[{}]{einsum\+\_\+call}{ = {\ttfamily False}}\end{DoxyParamCaption})}

\begin{DoxyVerb}einsum_path(subscripts, *operands, optimize='greedy')

Evaluates the lowest cost contraction order for an einsum expression by
considering the creation of intermediate arrays.

Parameters
----------
subscripts : str
    Specifies the subscripts for summation.
*operands : list of array_like
    These are the arrays for the operation.
optimize : {bool, list, tuple, 'greedy', 'optimal'}
    Choose the type of path. If a tuple is provided, the second argument is
    assumed to be the maximum intermediate size created. If only a single
    argument is provided the largest input or output array size is used
    as a maximum intermediate size.

    * if a list is given that starts with ``einsum_path``, uses this as the
      contraction path
    * if False no optimization is taken
    * if True defaults to the 'greedy' algorithm
    * 'optimal' An algorithm that combinatorially explores all possible
      ways of contracting the listed tensors and chooses the least costly
      path. Scales exponentially with the number of terms in the
      contraction.
    * 'greedy' An algorithm that chooses the best pair contraction
      at each step. Effectively, this algorithm searches the largest inner,
      Hadamard, and then outer products at each step. Scales cubically with
      the number of terms in the contraction. Equivalent to the 'optimal'
      path for most contractions.

    Default is 'greedy'.

Returns
-------
path : list of tuples
    A list representation of the einsum path.
string_repr : str
    A printable representation of the einsum path.

Notes
-----
The resulting path indicates which terms of the input contraction should be
contracted first, the result of this contraction is then appended to the
end of the contraction list. This list can then be iterated over until all
intermediate contractions are complete.

See Also
--------
einsum, linalg.multi_dot

Examples
--------

We can begin with a chain dot example. In this case, it is optimal to
contract the ``b`` and ``c`` tensors first as represented by the first
element of the path ``(1, 2)``. The resulting tensor is added to the end
of the contraction and the remaining contraction ``(0, 1)`` is then
completed.

>>> np.random.seed(123)
>>> a = np.random.rand(2, 2)
>>> b = np.random.rand(2, 5)
>>> c = np.random.rand(5, 2)
>>> path_info = np.einsum_path('ij,jk,kl->il', a, b, c, optimize='greedy')
>>> print(path_info[0])
['einsum_path', (1, 2), (0, 1)]
>>> print(path_info[1])
  Complete contraction:  ij,jk,kl->il # may vary
         Naive scaling:  4
     Optimized scaling:  3
      Naive FLOP count:  1.600e+02
  Optimized FLOP count:  5.600e+01
   Theoretical speedup:  2.857
  Largest intermediate:  4.000e+00 elements
-------------------------------------------------------------------------
scaling                  current                                remaining
-------------------------------------------------------------------------
   3                   kl,jk->jl                                ij,jl->il
   3                   jl,ij->il                                   il->il


A more complex index transformation example.

>>> I = np.random.rand(10, 10, 10, 10)
>>> C = np.random.rand(10, 10)
>>> path_info = np.einsum_path('ea,fb,abcd,gc,hd->efgh', C, C, I, C, C,
...                            optimize='greedy')

>>> print(path_info[0])
['einsum_path', (0, 2), (0, 3), (0, 2), (0, 1)]
>>> print(path_info[1]) 
  Complete contraction:  ea,fb,abcd,gc,hd->efgh # may vary
         Naive scaling:  8
     Optimized scaling:  5
      Naive FLOP count:  8.000e+08
  Optimized FLOP count:  8.000e+05
   Theoretical speedup:  1000.000
  Largest intermediate:  1.000e+04 elements
--------------------------------------------------------------------------
scaling                  current                                remaining
--------------------------------------------------------------------------
   5               abcd,ea->bcde                      fb,gc,hd,bcde->efgh
   5               bcde,fb->cdef                         gc,hd,cdef->efgh
   5               cdef,gc->defg                            hd,defg->efgh
   5               defg,hd->efgh                               efgh->efgh
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{core_2einsumfunc_8py_source_l00707}{707}} of file \mbox{\hyperlink{core_2einsumfunc_8py_source}{einsumfunc.\+py}}.



References \mbox{\hyperlink{core_2einsumfunc_8py_source_l00413}{\+\_\+can\+\_\+dot()}}, \mbox{\hyperlink{core_2einsumfunc_8py_source_l00056}{\+\_\+compute\+\_\+size\+\_\+by\+\_\+dict()}}, \mbox{\hyperlink{core_2einsumfunc_8py_source_l00085}{\+\_\+find\+\_\+contraction()}}, \mbox{\hyperlink{core_2einsumfunc_8py_source_l00018}{\+\_\+flop\+\_\+count()}}, \mbox{\hyperlink{core_2einsumfunc_8py_source_l00312}{\+\_\+greedy\+\_\+path()}}, \mbox{\hyperlink{core_2einsumfunc_8py_source_l00145}{\+\_\+optimal\+\_\+path()}}, \mbox{\hyperlink{core_2einsumfunc_8py_source_l00523}{\+\_\+parse\+\_\+einsum\+\_\+input()}}, \mbox{\hyperlink{lib_2function__base_8py_source_l05564}{numpy.\+lib.\+function\+\_\+base.\+append()}}, \mbox{\hyperlink{core_2fromnumeric_8py_source_l02695}{numpy.\+core.\+fromnumeric.\+max()}}, and \mbox{\hyperlink{core_2fromnumeric_8py_source_l02179}{numpy.\+core.\+fromnumeric.\+sum()}}.



Referenced by \mbox{\hyperlink{core_2einsumfunc_8py_source_l01010}{einsum()}}.



\doxysubsection{Variable Documentation}
\Hypertarget{namespacenumpy_1_1core_1_1einsumfunc_a166d635e475ff86e685961c3b7c60b73}\index{numpy.core.einsumfunc@{numpy.core.einsumfunc}!\_\_all\_\_@{\_\_all\_\_}}
\index{\_\_all\_\_@{\_\_all\_\_}!numpy.core.einsumfunc@{numpy.core.einsumfunc}}
\doxysubsubsection{\texorpdfstring{\_\_all\_\_}{\_\_all\_\_}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1core_1_1einsumfunc_a166d635e475ff86e685961c3b7c60b73} 
list numpy.\+core.\+einsumfunc.\+\_\+\+\_\+all\+\_\+\+\_\+ = \mbox{[}\textquotesingle{}\mbox{\hyperlink{namespacenumpy_1_1core_1_1einsumfunc_af40e071d1855e1ffe8dcb31e705fc095}{einsum}}\textquotesingle{}, \textquotesingle{}\mbox{\hyperlink{namespacenumpy_1_1core_1_1einsumfunc_a8df65e48c50e2ec96f2e23ea69249a32}{einsum\+\_\+path}}\textquotesingle{}\mbox{]}\hspace{0.3cm}{\ttfamily [private]}}



Definition at line \mbox{\hyperlink{core_2einsumfunc_8py_source_l00012}{12}} of file \mbox{\hyperlink{core_2einsumfunc_8py_source}{einsumfunc.\+py}}.

\Hypertarget{namespacenumpy_1_1core_1_1einsumfunc_a18a08d7e10c94d25799a8e1a57922e23}\index{numpy.core.einsumfunc@{numpy.core.einsumfunc}!einsum\_symbols@{einsum\_symbols}}
\index{einsum\_symbols@{einsum\_symbols}!numpy.core.einsumfunc@{numpy.core.einsumfunc}}
\doxysubsubsection{\texorpdfstring{einsum\_symbols}{einsum\_symbols}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1core_1_1einsumfunc_a18a08d7e10c94d25799a8e1a57922e23} 
str numpy.\+core.\+einsumfunc.\+einsum\+\_\+symbols = \textquotesingle{}abcdefghijklmnopqrstuvwxyz\+ABCDEFGHIJKLMNOPQRSTUVWXYZ\textquotesingle{}}



Definition at line \mbox{\hyperlink{core_2einsumfunc_8py_source_l00014}{14}} of file \mbox{\hyperlink{core_2einsumfunc_8py_source}{einsumfunc.\+py}}.

\Hypertarget{namespacenumpy_1_1core_1_1einsumfunc_ae9434bd5793781fc806f488c58228d32}\index{numpy.core.einsumfunc@{numpy.core.einsumfunc}!einsum\_symbols\_set@{einsum\_symbols\_set}}
\index{einsum\_symbols\_set@{einsum\_symbols\_set}!numpy.core.einsumfunc@{numpy.core.einsumfunc}}
\doxysubsubsection{\texorpdfstring{einsum\_symbols\_set}{einsum\_symbols\_set}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1core_1_1einsumfunc_ae9434bd5793781fc806f488c58228d32} 
numpy.\+core.\+einsumfunc.\+einsum\+\_\+symbols\+\_\+set = set(einsum\+\_\+symbols)}



Definition at line \mbox{\hyperlink{core_2einsumfunc_8py_source_l00015}{15}} of file \mbox{\hyperlink{core_2einsumfunc_8py_source}{einsumfunc.\+py}}.

