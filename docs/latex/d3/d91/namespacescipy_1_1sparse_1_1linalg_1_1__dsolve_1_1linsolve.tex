\doxysection{scipy.\+sparse.\+linalg.\+\_\+dsolve.\+linsolve Namespace Reference}
\hypertarget{namespacescipy_1_1sparse_1_1linalg_1_1__dsolve_1_1linsolve}{}\label{namespacescipy_1_1sparse_1_1linalg_1_1__dsolve_1_1linsolve}\index{scipy.sparse.linalg.\_dsolve.linsolve@{scipy.sparse.linalg.\_dsolve.linsolve}}
\doxysubsubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classscipy_1_1sparse_1_1linalg_1_1__dsolve_1_1linsolve_1_1MatrixRankWarning}{Matrix\+Rank\+Warning}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacescipy_1_1sparse_1_1linalg_1_1__dsolve_1_1linsolve_a3562221f172ffbb4cb828800634b39e8}{use\+\_\+solver}} (\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}kwargs)
\item 
\mbox{\hyperlink{namespacescipy_1_1sparse_1_1linalg_1_1__dsolve_1_1linsolve_ad50bb5ae7e5f5024370aa56772ec704a}{\+\_\+get\+\_\+umf\+\_\+family}} (A)
\item 
\mbox{\hyperlink{namespacescipy_1_1sparse_1_1linalg_1_1__dsolve_1_1linsolve_a947db68cc3950a1a4c92431136b770ea}{\+\_\+safe\+\_\+downcast\+\_\+indices}} (A)
\item 
\mbox{\hyperlink{namespacescipy_1_1sparse_1_1linalg_1_1__dsolve_1_1linsolve_a77d4460d0a53d429a7fa4ca0583b2306}{spsolve}} (A, b, permc\+\_\+spec=None, use\+\_\+umfpack=\mbox{\hyperlink{classTrue}{True}})
\item 
\mbox{\hyperlink{namespacescipy_1_1sparse_1_1linalg_1_1__dsolve_1_1linsolve_a8c07190f8e51626f2ed4e71b14c46b35}{splu}} (A, permc\+\_\+spec=None, diag\+\_\+pivot\+\_\+thresh=None, relax=None, panel\+\_\+size=None, options=dict())
\item 
\mbox{\hyperlink{namespacescipy_1_1sparse_1_1linalg_1_1__dsolve_1_1linsolve_aa95183b2d7d8f42d73801705fa43d4d9}{spilu}} (A, drop\+\_\+tol=None, fill\+\_\+factor=None, drop\+\_\+rule=None, permc\+\_\+spec=None, diag\+\_\+pivot\+\_\+thresh=None, relax=None, panel\+\_\+size=None, options=None)
\item 
\mbox{\hyperlink{namespacescipy_1_1sparse_1_1linalg_1_1__dsolve_1_1linsolve_a446adbb91392729bee9b76650a2f18ef}{factorized}} (A)
\item 
\mbox{\hyperlink{namespacescipy_1_1sparse_1_1linalg_1_1__dsolve_1_1linsolve_af719c053e767659bcae22880fcffe6dd}{spsolve\+\_\+triangular}} (A, b, lower=\mbox{\hyperlink{classTrue}{True}}, overwrite\+\_\+A=False, overwrite\+\_\+b=False, unit\+\_\+diagonal=False)
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
bool \mbox{\hyperlink{namespacescipy_1_1sparse_1_1linalg_1_1__dsolve_1_1linsolve_a90f9c9e70d541f570a0fb7046ae3be39}{no\+Scikit}} = False
\item 
bool \mbox{\hyperlink{namespacescipy_1_1sparse_1_1linalg_1_1__dsolve_1_1linsolve_a707a01b322b97cfb84efdf9e67a80a78}{use\+Umfpack}} = not no\+Scikit
\item 
list \mbox{\hyperlink{namespacescipy_1_1sparse_1_1linalg_1_1__dsolve_1_1linsolve_ab99290eb4dfa8064405ebcc3f97a22be}{\+\_\+\+\_\+all\+\_\+\+\_\+}}
\end{DoxyCompactItemize}


\doxysubsection{Function Documentation}
\Hypertarget{namespacescipy_1_1sparse_1_1linalg_1_1__dsolve_1_1linsolve_ad50bb5ae7e5f5024370aa56772ec704a}\index{scipy.sparse.linalg.\_dsolve.linsolve@{scipy.sparse.linalg.\_dsolve.linsolve}!\_get\_umf\_family@{\_get\_umf\_family}}
\index{\_get\_umf\_family@{\_get\_umf\_family}!scipy.sparse.linalg.\_dsolve.linsolve@{scipy.sparse.linalg.\_dsolve.linsolve}}
\doxysubsubsection{\texorpdfstring{\_get\_umf\_family()}{\_get\_umf\_family()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1sparse_1_1linalg_1_1__dsolve_1_1linsolve_ad50bb5ae7e5f5024370aa56772ec704a} 
scipy.\+sparse.\+linalg.\+\_\+dsolve.\+linsolve.\+\_\+get\+\_\+umf\+\_\+family (\begin{DoxyParamCaption}\item[{}]{A}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Get umfpack family string given the sparse matrix dtype.\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{linsolve_8py_source_l00095}{95}} of file \mbox{\hyperlink{linsolve_8py_source}{linsolve.\+py}}.



Referenced by \mbox{\hyperlink{linsolve_8py_source_l00535}{factorized()}}, and \mbox{\hyperlink{linsolve_8py_source_l00141}{spsolve()}}.

\Hypertarget{namespacescipy_1_1sparse_1_1linalg_1_1__dsolve_1_1linsolve_a947db68cc3950a1a4c92431136b770ea}\index{scipy.sparse.linalg.\_dsolve.linsolve@{scipy.sparse.linalg.\_dsolve.linsolve}!\_safe\_downcast\_indices@{\_safe\_downcast\_indices}}
\index{\_safe\_downcast\_indices@{\_safe\_downcast\_indices}!scipy.sparse.linalg.\_dsolve.linsolve@{scipy.sparse.linalg.\_dsolve.linsolve}}
\doxysubsubsection{\texorpdfstring{\_safe\_downcast\_indices()}{\_safe\_downcast\_indices()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1sparse_1_1linalg_1_1__dsolve_1_1linsolve_a947db68cc3950a1a4c92431136b770ea} 
scipy.\+sparse.\+linalg.\+\_\+dsolve.\+linsolve.\+\_\+safe\+\_\+downcast\+\_\+indices (\begin{DoxyParamCaption}\item[{}]{A}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{linsolve_8py_source_l00126}{126}} of file \mbox{\hyperlink{linsolve_8py_source}{linsolve.\+py}}.

\Hypertarget{namespacescipy_1_1sparse_1_1linalg_1_1__dsolve_1_1linsolve_a446adbb91392729bee9b76650a2f18ef}\index{scipy.sparse.linalg.\_dsolve.linsolve@{scipy.sparse.linalg.\_dsolve.linsolve}!factorized@{factorized}}
\index{factorized@{factorized}!scipy.sparse.linalg.\_dsolve.linsolve@{scipy.sparse.linalg.\_dsolve.linsolve}}
\doxysubsubsection{\texorpdfstring{factorized()}{factorized()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1sparse_1_1linalg_1_1__dsolve_1_1linsolve_a446adbb91392729bee9b76650a2f18ef} 
scipy.\+sparse.\+linalg.\+\_\+dsolve.\+linsolve.\+factorized (\begin{DoxyParamCaption}\item[{}]{A}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Return a function for solving a sparse linear system, with A pre-factorized.

Parameters
----------
A : (N, N) array_like
    Input. A in CSC format is most efficient. A CSR format matrix will
    be converted to CSC before factorization.

Returns
-------
solve : callable
    To solve the linear system of equations given in `A`, the `solve`
    callable should be passed an ndarray of shape (N,).

Examples
--------
>>> import numpy as np
>>> from scipy.sparse.linalg import factorized
>>> A = np.array([[ 3. ,  2. , -1. ],
...               [ 2. , -2. ,  4. ],
...               [-1. ,  0.5, -1. ]])
>>> solve = factorized(A) # Makes LU decomposition.
>>> rhs1 = np.array([1, -2, 0])
>>> solve(rhs1) # Uses the LU factors.
array([ 1., -2., -2.])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{linsolve_8py_source_l00535}{535}} of file \mbox{\hyperlink{linsolve_8py_source}{linsolve.\+py}}.



References \mbox{\hyperlink{linsolve_8py_source_l00095}{\+\_\+get\+\_\+umf\+\_\+family()}}, \mbox{\hyperlink{scipy_2sparse_2__base_8py_source_l01461}{scipy.\+sparse.\+\_\+base.\+issparse()}}, and \mbox{\hyperlink{linsolve_8py_source_l00336}{splu()}}.



Referenced by \mbox{\hyperlink{linsolve_8py_source_l00141}{spsolve()}}.

\Hypertarget{namespacescipy_1_1sparse_1_1linalg_1_1__dsolve_1_1linsolve_aa95183b2d7d8f42d73801705fa43d4d9}\index{scipy.sparse.linalg.\_dsolve.linsolve@{scipy.sparse.linalg.\_dsolve.linsolve}!spilu@{spilu}}
\index{spilu@{spilu}!scipy.sparse.linalg.\_dsolve.linsolve@{scipy.sparse.linalg.\_dsolve.linsolve}}
\doxysubsubsection{\texorpdfstring{spilu()}{spilu()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1sparse_1_1linalg_1_1__dsolve_1_1linsolve_aa95183b2d7d8f42d73801705fa43d4d9} 
scipy.\+sparse.\+linalg.\+\_\+dsolve.\+linsolve.\+spilu (\begin{DoxyParamCaption}\item[{}]{A}{, }\item[{}]{drop\+\_\+tol}{ = {\ttfamily None}, }\item[{}]{fill\+\_\+factor}{ = {\ttfamily None}, }\item[{}]{drop\+\_\+rule}{ = {\ttfamily None}, }\item[{}]{permc\+\_\+spec}{ = {\ttfamily None}, }\item[{}]{diag\+\_\+pivot\+\_\+thresh}{ = {\ttfamily None}, }\item[{}]{relax}{ = {\ttfamily None}, }\item[{}]{panel\+\_\+size}{ = {\ttfamily None}, }\item[{}]{options}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute an incomplete LU decomposition for a sparse, square matrix.

The resulting object is an approximation to the inverse of `A`.

Parameters
----------
A : (N, N) array_like
    Sparse matrix to factorize. Most efficient when provided in CSC format.
    Other formats will be converted to CSC before factorization.
drop_tol : float, optional
    Drop tolerance (0 <= tol <= 1) for an incomplete LU decomposition.
    (default: 1e-4)
fill_factor : float, optional
    Specifies the fill ratio upper bound (>= 1.0) for ILU. (default: 10)
drop_rule : str, optional
    Comma-separated string of drop rules to use.
    Available rules: ``basic``, ``prows``, ``column``, ``area``,
    ``secondary``, ``dynamic``, ``interp``. (Default: ``basic,area``)

    See SuperLU documentation for details.

Remaining other options
    Same as for `splu`

Returns
-------
invA_approx : scipy.sparse.linalg.SuperLU
    Object, which has a ``solve`` method.

See also
--------
splu : complete LU decomposition

Notes
-----
To improve the better approximation to the inverse, you may need to
increase `fill_factor` AND decrease `drop_tol`.

This function uses the SuperLU library.

Examples
--------
>>> import numpy as np
>>> from scipy.sparse import csc_matrix
>>> from scipy.sparse.linalg import spilu
>>> A = csc_matrix([[1., 0., 0.], [5., 0., 2.], [0., -1., 0.]], dtype=float)
>>> B = spilu(A)
>>> x = np.array([1., 2., 3.], dtype=float)
>>> B.solve(x)
array([ 1. , -3. , -1.5])
>>> A.dot(B.solve(x))
array([ 1.,  2.,  3.])
>>> B.solve(A.dot(x))
array([ 1.,  2.,  3.])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{linsolve_8py_source_l00438}{438}} of file \mbox{\hyperlink{linsolve_8py_source}{linsolve.\+py}}.



References \mbox{\hyperlink{scipy_2sparse_2__base_8py_source_l01461}{scipy.\+sparse.\+\_\+base.\+issparse()}}.

\Hypertarget{namespacescipy_1_1sparse_1_1linalg_1_1__dsolve_1_1linsolve_a8c07190f8e51626f2ed4e71b14c46b35}\index{scipy.sparse.linalg.\_dsolve.linsolve@{scipy.sparse.linalg.\_dsolve.linsolve}!splu@{splu}}
\index{splu@{splu}!scipy.sparse.linalg.\_dsolve.linsolve@{scipy.sparse.linalg.\_dsolve.linsolve}}
\doxysubsubsection{\texorpdfstring{splu()}{splu()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1sparse_1_1linalg_1_1__dsolve_1_1linsolve_a8c07190f8e51626f2ed4e71b14c46b35} 
scipy.\+sparse.\+linalg.\+\_\+dsolve.\+linsolve.\+splu (\begin{DoxyParamCaption}\item[{}]{A}{, }\item[{}]{permc\+\_\+spec}{ = {\ttfamily None}, }\item[{}]{diag\+\_\+pivot\+\_\+thresh}{ = {\ttfamily None}, }\item[{}]{relax}{ = {\ttfamily None}, }\item[{}]{panel\+\_\+size}{ = {\ttfamily None}, }\item[{}]{options}{ = {\ttfamily dict()}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute the LU decomposition of a sparse, square matrix.

Parameters
----------
A : sparse matrix
    Sparse matrix to factorize. Most efficient when provided in CSC
    format. Other formats will be converted to CSC before factorization.
permc_spec : str, optional
    How to permute the columns of the matrix for sparsity preservation.
    (default: 'COLAMD')

    - ``NATURAL``: natural ordering.
    - ``MMD_ATA``: minimum degree ordering on the structure of A^T A.
    - ``MMD_AT_PLUS_A``: minimum degree ordering on the structure of A^T+A.
    - ``COLAMD``: approximate minimum degree column ordering

diag_pivot_thresh : float, optional
    Threshold used for a diagonal entry to be an acceptable pivot.
    See SuperLU user's guide for details [1]_
relax : int, optional
    Expert option for customizing the degree of relaxing supernodes.
    See SuperLU user's guide for details [1]_
panel_size : int, optional
    Expert option for customizing the panel size.
    See SuperLU user's guide for details [1]_
options : dict, optional
    Dictionary containing additional expert options to SuperLU.
    See SuperLU user guide [1]_ (section 2.4 on the 'Options' argument)
    for more details. For example, you can specify
    ``options=dict(Equil=False, IterRefine='SINGLE'))``
    to turn equilibration off and perform a single iterative refinement.

Returns
-------
invA : scipy.sparse.linalg.SuperLU
    Object, which has a ``solve`` method.

See also
--------
spilu : incomplete LU decomposition

Notes
-----
This function uses the SuperLU library.

References
----------
.. [1] SuperLU https://portal.nersc.gov/project/sparse/superlu/

Examples
--------
>>> import numpy as np
>>> from scipy.sparse import csc_matrix
>>> from scipy.sparse.linalg import splu
>>> A = csc_matrix([[1., 0., 0.], [5., 0., 2.], [0., -1., 0.]], dtype=float)
>>> B = splu(A)
>>> x = np.array([1., 2., 3.], dtype=float)
>>> B.solve(x)
array([ 1. , -3. , -1.5])
>>> A.dot(B.solve(x))
array([ 1.,  2.,  3.])
>>> B.solve(A.dot(x))
array([ 1.,  2.,  3.])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{linsolve_8py_source_l00335}{335}} of file \mbox{\hyperlink{linsolve_8py_source}{linsolve.\+py}}.



References \mbox{\hyperlink{scipy_2sparse_2__base_8py_source_l01461}{scipy.\+sparse.\+\_\+base.\+issparse()}}.



Referenced by \mbox{\hyperlink{linsolve_8py_source_l00535}{factorized()}}.

\Hypertarget{namespacescipy_1_1sparse_1_1linalg_1_1__dsolve_1_1linsolve_a77d4460d0a53d429a7fa4ca0583b2306}\index{scipy.sparse.linalg.\_dsolve.linsolve@{scipy.sparse.linalg.\_dsolve.linsolve}!spsolve@{spsolve}}
\index{spsolve@{spsolve}!scipy.sparse.linalg.\_dsolve.linsolve@{scipy.sparse.linalg.\_dsolve.linsolve}}
\doxysubsubsection{\texorpdfstring{spsolve()}{spsolve()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1sparse_1_1linalg_1_1__dsolve_1_1linsolve_a77d4460d0a53d429a7fa4ca0583b2306} 
scipy.\+sparse.\+linalg.\+\_\+dsolve.\+linsolve.\+spsolve (\begin{DoxyParamCaption}\item[{}]{A}{, }\item[{}]{b}{, }\item[{}]{permc\+\_\+spec}{ = {\ttfamily None}, }\item[{}]{use\+\_\+umfpack}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Solve the sparse linear system Ax=b, where b may be a vector or a matrix.

Parameters
----------
A : ndarray or sparse matrix
    The square matrix A will be converted into CSC or CSR form
b : ndarray or sparse matrix
    The matrix or vector representing the right hand side of the equation.
    If a vector, b.shape must be (n,) or (n, 1).
permc_spec : str, optional
    How to permute the columns of the matrix for sparsity preservation.
    (default: 'COLAMD')

    - ``NATURAL``: natural ordering.
    - ``MMD_ATA``: minimum degree ordering on the structure of A^T A.
    - ``MMD_AT_PLUS_A``: minimum degree ordering on the structure of A^T+A.
    - ``COLAMD``: approximate minimum degree column ordering [1]_, [2]_.

use_umfpack : bool, optional
    if True (default) then use UMFPACK for the solution [3]_, [4]_, [5]_,
    [6]_ . This is only referenced if b is a vector and
    ``scikits.umfpack`` is installed.

Returns
-------
x : ndarray or sparse matrix
    the solution of the sparse linear equation.
    If b is a vector, then x is a vector of size A.shape[1]
    If b is a matrix, then x is a matrix of size (A.shape[1], b.shape[1])

Notes
-----
For solving the matrix expression AX = B, this solver assumes the resulting
matrix X is sparse, as is often the case for very sparse inputs.  If the
resulting X is dense, the construction of this sparse result will be
relatively expensive.  In that case, consider converting A to a dense
matrix and using scipy.linalg.solve or its variants.

References
----------
.. [1] T. A. Davis, J. R. Gilbert, S. Larimore, E. Ng, Algorithm 836:
       COLAMD, an approximate column minimum degree ordering algorithm,
       ACM Trans. on Mathematical Software, 30(3), 2004, pp. 377--380.
       :doi:`10.1145/1024074.1024080`

.. [2] T. A. Davis, J. R. Gilbert, S. Larimore, E. Ng, A column approximate
       minimum degree ordering algorithm, ACM Trans. on Mathematical
       Software, 30(3), 2004, pp. 353--376. :doi:`10.1145/1024074.1024079`

.. [3] T. A. Davis, Algorithm 832:  UMFPACK - an unsymmetric-pattern
       multifrontal method with a column pre-ordering strategy, ACM
       Trans. on Mathematical Software, 30(2), 2004, pp. 196--199.
       https://dl.acm.org/doi/abs/10.1145/992200.992206

.. [4] T. A. Davis, A column pre-ordering strategy for the
       unsymmetric-pattern multifrontal method, ACM Trans.
       on Mathematical Software, 30(2), 2004, pp. 165--195.
       https://dl.acm.org/doi/abs/10.1145/992200.992205

.. [5] T. A. Davis and I. S. Duff, A combined unifrontal/multifrontal
       method for unsymmetric sparse matrices, ACM Trans. on
       Mathematical Software, 25(1), 1999, pp. 1--19.
       https://doi.org/10.1145/305658.287640

.. [6] T. A. Davis and I. S. Duff, An unsymmetric-pattern multifrontal
       method for sparse LU factorization, SIAM J. Matrix Analysis and
       Computations, 18(1), 1997, pp. 140--158.
       https://doi.org/10.1137/S0895479894246905T.


Examples
--------
>>> import numpy as np
>>> from scipy.sparse import csc_matrix
>>> from scipy.sparse.linalg import spsolve
>>> A = csc_matrix([[3, 2, 0], [1, -1, 0], [0, 5, 1]], dtype=float)
>>> B = csc_matrix([[2, 0], [-1, 0], [2, 0]], dtype=float)
>>> x = spsolve(A, B)
>>> np.allclose(A.dot(x).toarray(), B.toarray())
True
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{linsolve_8py_source_l00141}{141}} of file \mbox{\hyperlink{linsolve_8py_source}{linsolve.\+py}}.



References \mbox{\hyperlink{linsolve_8py_source_l00095}{\+\_\+get\+\_\+umf\+\_\+family()}}, \mbox{\hyperlink{linsolve_8py_source_l00535}{factorized()}}, and \mbox{\hyperlink{scipy_2sparse_2__base_8py_source_l01461}{scipy.\+sparse.\+\_\+base.\+issparse()}}.



Referenced by \mbox{\hyperlink{sparse_2linalg_2__matfuncs_8py_source_l00683}{scipy.\+sparse.\+linalg.\+\_\+matfuncs.\+\_\+solve\+\_\+\+P\+\_\+\+Q()}}, and \mbox{\hyperlink{sparse_2linalg_2__matfuncs_8py_source_l00030}{scipy.\+sparse.\+linalg.\+\_\+matfuncs.\+inv()}}.

\Hypertarget{namespacescipy_1_1sparse_1_1linalg_1_1__dsolve_1_1linsolve_af719c053e767659bcae22880fcffe6dd}\index{scipy.sparse.linalg.\_dsolve.linsolve@{scipy.sparse.linalg.\_dsolve.linsolve}!spsolve\_triangular@{spsolve\_triangular}}
\index{spsolve\_triangular@{spsolve\_triangular}!scipy.sparse.linalg.\_dsolve.linsolve@{scipy.sparse.linalg.\_dsolve.linsolve}}
\doxysubsubsection{\texorpdfstring{spsolve\_triangular()}{spsolve\_triangular()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1sparse_1_1linalg_1_1__dsolve_1_1linsolve_af719c053e767659bcae22880fcffe6dd} 
scipy.\+sparse.\+linalg.\+\_\+dsolve.\+linsolve.\+spsolve\+\_\+triangular (\begin{DoxyParamCaption}\item[{}]{A}{, }\item[{}]{b}{, }\item[{}]{lower}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}, }\item[{}]{overwrite\+\_\+A}{ = {\ttfamily False}, }\item[{}]{overwrite\+\_\+b}{ = {\ttfamily False}, }\item[{}]{unit\+\_\+diagonal}{ = {\ttfamily False}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Solve the equation ``A x = b`` for `x`, assuming A is a triangular matrix.

Parameters
----------
A : (M, M) sparse matrix
    A sparse square triangular matrix. Should be in CSR format.
b : (M,) or (M, N) array_like
    Right-hand side matrix in ``A x = b``
lower : bool, optional
    Whether `A` is a lower or upper triangular matrix.
    Default is lower triangular matrix.
overwrite_A : bool, optional
    Allow changing `A`. The indices of `A` are going to be sorted and zero
    entries are going to be removed.
    Enabling gives a performance gain. Default is False.
overwrite_b : bool, optional
    Allow overwriting data in `b`.
    Enabling gives a performance gain. Default is False.
    If `overwrite_b` is True, it should be ensured that
    `b` has an appropriate dtype to be able to store the result.
unit_diagonal : bool, optional
    If True, diagonal elements of `a` are assumed to be 1 and will not be
    referenced.

    .. versionadded:: 1.4.0

Returns
-------
x : (M,) or (M, N) ndarray
    Solution to the system ``A x = b``. Shape of return matches shape
    of `b`.

Raises
------
LinAlgError
    If `A` is singular or not triangular.
ValueError
    If shape of `A` or shape of `b` do not match the requirements.

Notes
-----
.. versionadded:: 0.19.0

Examples
--------
>>> import numpy as np
>>> from scipy.sparse import csr_matrix
>>> from scipy.sparse.linalg import spsolve_triangular
>>> A = csr_matrix([[3, 0, 0], [1, -1, 0], [2, 0, 1]], dtype=float)
>>> B = np.array([[2, 0], [-1, 0], [2, 0]], dtype=float)
>>> x = spsolve_triangular(A, B)
>>> np.allclose(A.dot(x), B)
True
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{linsolve_8py_source_l00600}{600}} of file \mbox{\hyperlink{linsolve_8py_source}{linsolve.\+py}}.



References \mbox{\hyperlink{scipy_2sparse_2__base_8py_source_l01461}{scipy.\+sparse.\+\_\+base.\+issparse()}}.

\Hypertarget{namespacescipy_1_1sparse_1_1linalg_1_1__dsolve_1_1linsolve_a3562221f172ffbb4cb828800634b39e8}\index{scipy.sparse.linalg.\_dsolve.linsolve@{scipy.sparse.linalg.\_dsolve.linsolve}!use\_solver@{use\_solver}}
\index{use\_solver@{use\_solver}!scipy.sparse.linalg.\_dsolve.linsolve@{scipy.sparse.linalg.\_dsolve.linsolve}}
\doxysubsubsection{\texorpdfstring{use\_solver()}{use\_solver()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1sparse_1_1linalg_1_1__dsolve_1_1linsolve_a3562221f172ffbb4cb828800634b39e8} 
scipy.\+sparse.\+linalg.\+\_\+dsolve.\+linsolve.\+use\+\_\+solver (\begin{DoxyParamCaption}\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{kwargs}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Select default sparse direct solver to be used.

Parameters
----------
useUmfpack : bool, optional
    Use UMFPACK [1]_, [2]_, [3]_, [4]_. over SuperLU. Has effect only
    if ``scikits.umfpack`` is installed. Default: True
assumeSortedIndices : bool, optional
    Allow UMFPACK to skip the step of sorting indices for a CSR/CSC matrix.
    Has effect only if useUmfpack is True and ``scikits.umfpack`` is
    installed. Default: False

Notes
-----
The default sparse solver is UMFPACK when available
(``scikits.umfpack`` is installed). This can be changed by passing
useUmfpack = False, which then causes the always present SuperLU
based solver to be used.

UMFPACK requires a CSR/CSC matrix to have sorted column/row indices. If
sure that the matrix fulfills this, pass ``assumeSortedIndices=True``
to gain some speed.

References
----------
.. [1] T. A. Davis, Algorithm 832:  UMFPACK - an unsymmetric-pattern
       multifrontal method with a column pre-ordering strategy, ACM
       Trans. on Mathematical Software, 30(2), 2004, pp. 196--199.
       https://dl.acm.org/doi/abs/10.1145/992200.992206

.. [2] T. A. Davis, A column pre-ordering strategy for the
       unsymmetric-pattern multifrontal method, ACM Trans.
       on Mathematical Software, 30(2), 2004, pp. 165--195.
       https://dl.acm.org/doi/abs/10.1145/992200.992205

.. [3] T. A. Davis and I. S. Duff, A combined unifrontal/multifrontal
       method for unsymmetric sparse matrices, ACM Trans. on
       Mathematical Software, 25(1), 1999, pp. 1--19.
       https://doi.org/10.1145/305658.287640

.. [4] T. A. Davis and I. S. Duff, An unsymmetric-pattern multifrontal
       method for sparse LU factorization, SIAM J. Matrix Analysis and
       Computations, 18(1), 1997, pp. 140--158.
       https://doi.org/10.1137/S0895479894246905T.

Examples
--------
>>> import numpy as np
>>> from scipy.sparse.linalg import use_solver, spsolve
>>> from scipy.sparse import csc_matrix
>>> R = np.random.randn(5, 5)
>>> A = csc_matrix(R)
>>> b = np.random.randn(5)
>>> use_solver(useUmfpack=False) # enforce superLU over UMFPACK
>>> x = spsolve(A, b)
>>> np.allclose(A.dot(x), b)
True
>>> use_solver(useUmfpack=True) # reset umfPack usage to default
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{linsolve_8py_source_l00029}{29}} of file \mbox{\hyperlink{linsolve_8py_source}{linsolve.\+py}}.



\doxysubsection{Variable Documentation}
\Hypertarget{namespacescipy_1_1sparse_1_1linalg_1_1__dsolve_1_1linsolve_ab99290eb4dfa8064405ebcc3f97a22be}\index{scipy.sparse.linalg.\_dsolve.linsolve@{scipy.sparse.linalg.\_dsolve.linsolve}!\_\_all\_\_@{\_\_all\_\_}}
\index{\_\_all\_\_@{\_\_all\_\_}!scipy.sparse.linalg.\_dsolve.linsolve@{scipy.sparse.linalg.\_dsolve.linsolve}}
\doxysubsubsection{\texorpdfstring{\_\_all\_\_}{\_\_all\_\_}}
{\footnotesize\ttfamily \label{namespacescipy_1_1sparse_1_1linalg_1_1__dsolve_1_1linsolve_ab99290eb4dfa8064405ebcc3f97a22be} 
list scipy.\+sparse.\+linalg.\+\_\+dsolve.\+linsolve.\+\_\+\+\_\+all\+\_\+\+\_\+\hspace{0.3cm}{\ttfamily [private]}}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ [\textcolor{stringliteral}{'use\_solver'},\ \textcolor{stringliteral}{'spsolve'},\ \textcolor{stringliteral}{'splu'},\ \textcolor{stringliteral}{'spilu'},\ \textcolor{stringliteral}{'factorized'},}
\DoxyCodeLine{00002\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'MatrixRankWarning'},\ \textcolor{stringliteral}{'spsolve\_triangular'}]}

\end{DoxyCode}


Definition at line \mbox{\hyperlink{linsolve_8py_source_l00021}{21}} of file \mbox{\hyperlink{linsolve_8py_source}{linsolve.\+py}}.

\Hypertarget{namespacescipy_1_1sparse_1_1linalg_1_1__dsolve_1_1linsolve_a90f9c9e70d541f570a0fb7046ae3be39}\index{scipy.sparse.linalg.\_dsolve.linsolve@{scipy.sparse.linalg.\_dsolve.linsolve}!noScikit@{noScikit}}
\index{noScikit@{noScikit}!scipy.sparse.linalg.\_dsolve.linsolve@{scipy.sparse.linalg.\_dsolve.linsolve}}
\doxysubsubsection{\texorpdfstring{noScikit}{noScikit}}
{\footnotesize\ttfamily \label{namespacescipy_1_1sparse_1_1linalg_1_1__dsolve_1_1linsolve_a90f9c9e70d541f570a0fb7046ae3be39} 
bool scipy.\+sparse.\+linalg.\+\_\+dsolve.\+linsolve.\+no\+Scikit = False}



Definition at line \mbox{\hyperlink{linsolve_8py_source_l00013}{13}} of file \mbox{\hyperlink{linsolve_8py_source}{linsolve.\+py}}.

\Hypertarget{namespacescipy_1_1sparse_1_1linalg_1_1__dsolve_1_1linsolve_a707a01b322b97cfb84efdf9e67a80a78}\index{scipy.sparse.linalg.\_dsolve.linsolve@{scipy.sparse.linalg.\_dsolve.linsolve}!useUmfpack@{useUmfpack}}
\index{useUmfpack@{useUmfpack}!scipy.sparse.linalg.\_dsolve.linsolve@{scipy.sparse.linalg.\_dsolve.linsolve}}
\doxysubsubsection{\texorpdfstring{useUmfpack}{useUmfpack}}
{\footnotesize\ttfamily \label{namespacescipy_1_1sparse_1_1linalg_1_1__dsolve_1_1linsolve_a707a01b322b97cfb84efdf9e67a80a78} 
bool scipy.\+sparse.\+linalg.\+\_\+dsolve.\+linsolve.\+use\+Umfpack = not no\+Scikit}



Definition at line \mbox{\hyperlink{linsolve_8py_source_l00019}{19}} of file \mbox{\hyperlink{linsolve_8py_source}{linsolve.\+py}}.

