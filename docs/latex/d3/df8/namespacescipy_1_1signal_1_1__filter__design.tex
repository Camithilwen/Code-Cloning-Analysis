\doxysection{scipy.\+signal.\+\_\+filter\+\_\+design Namespace Reference}
\hypertarget{namespacescipy_1_1signal_1_1__filter__design}{}\label{namespacescipy_1_1signal_1_1__filter__design}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classscipy_1_1signal_1_1__filter__design_1_1BadCoefficients}{Bad\+Coefficients}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_a5e0ed4ba7b94312ec66b13bf06bf8f74}{\+\_\+is\+\_\+int\+\_\+type}} (x)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_a121c7e536c227088450930f0b93805ad}{findfreqs}} (num, den, N, kind=\textquotesingle{}ba\textquotesingle{})
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_a9575c4eb7f36f5e534309051f96a8bb7}{freqs}} (b, a, worN=200, plot=None)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_a8d1dbc48cfac5f3492922f226c4cd817}{freqs\+\_\+zpk}} (z, p, k, worN=200)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_a57ecfa32b9c147c7075a33d24edd5c74}{freqz}} (b, a=1, worN=512, whole=False, plot=None, fs=2 \texorpdfstring{$\ast$}{*}pi, include\+\_\+nyquist=False)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_a054b88d412ab15682d43c45663270868}{freqz\+\_\+zpk}} (z, p, k, worN=512, whole=False, fs=2 \texorpdfstring{$\ast$}{*}pi)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_a625d835512a209cd19d7dafe141ef33a}{group\+\_\+delay}} (system, w=512, whole=False, fs=2 \texorpdfstring{$\ast$}{*}pi)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_ad2dec7b3a76879ba708edb9f7d00c00c}{\+\_\+validate\+\_\+sos}} (sos)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_aea4c4ed52a5437a54057fd7a094d1936}{sosfreqz}} (sos, worN=512, whole=False, fs=2 \texorpdfstring{$\ast$}{*}pi)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_a39cb8fff9a90d19a81ee134d1ee37ed4}{\+\_\+cplxreal}} (z, tol=None)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_a2aed3d7c4622770e66245baa67139fbe}{\+\_\+cplxpair}} (z, tol=None)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_afd8e35038fae8873d10b7f7be6b8ca8f}{tf2zpk}} (b, a)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_a3bf4baf8dc505f8b2ef88845ec55d645}{zpk2tf}} (z, p, k)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_a91eaf3cecda0b1314ae9abe837e7a074}{tf2sos}} (b, a, pairing=None, \texorpdfstring{$\ast$}{*}, analog=False)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_ab4b170e32f7fa6684c6c75c54fd0520d}{sos2tf}} (sos)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_aa268051778baf0e9f10a285f6cfd412f}{sos2zpk}} (sos)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_ac0dd1dd0be3996b739e2a4af5d8a2d0a}{\+\_\+nearest\+\_\+real\+\_\+complex\+\_\+idx}} (fro, to, which)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_a5c2c25900a53f28740007fa4ed1445a7}{\+\_\+single\+\_\+zpksos}} (z, p, k)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_a0815bb39a494870b6e7a09e38ac2d417}{zpk2sos}} (z, p, k, pairing=None, \texorpdfstring{$\ast$}{*}, analog=False)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_a2f786c9911a15f0727e21552a6d027e1}{\+\_\+align\+\_\+nums}} (nums)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_a403f599e6854656425d2a6c393be2504}{normalize}} (b, a)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_acdb73944d070b0526aea89119ebcd64a}{lp2lp}} (b, a, wo=1.\+0)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_acf80f2294b9a61970f9af0785977ac7d}{lp2hp}} (b, a, wo=1.\+0)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_aaef8478cb2d3a2d9df568f00047d2931}{lp2bp}} (b, a, wo=1.\+0, bw=1.\+0)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_ad3bb750049c7af67e7751863c24c1652}{lp2bs}} (b, a, wo=1.\+0, bw=1.\+0)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_a6fe7b079ffdda28a189c255cbe9fb1d2}{bilinear}} (b, a, fs=1.\+0)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_aec666fcd802c4b7014526c80cbee6ed0}{\+\_\+validate\+\_\+gpass\+\_\+gstop}} (gpass, gstop)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_ae4d58f87f7cfea7d8b63e0809aba1c20}{iirdesign}} (wp, ws, gpass, gstop, analog=False, ftype=\textquotesingle{}\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_a61a842f3ea1494216b2d32708a8ae665}{ellip}}\textquotesingle{}, output=\textquotesingle{}ba\textquotesingle{}, fs=None)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_a937343d2df9040beea4d31c3efe33481}{iirfilter}} (N, Wn, rp=None, rs=None, btype=\textquotesingle{}band\textquotesingle{}, analog=False, ftype=\textquotesingle{}\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_a4568219d096c6e4e5a091c63dbde4bb8}{butter}}\textquotesingle{}, output=\textquotesingle{}ba\textquotesingle{}, fs=None)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_a719d7c3c96122501b193e7e67a6cc19b}{\+\_\+relative\+\_\+degree}} (z, p)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_a9da0a444f05972f5eca9cb9035d71261}{bilinear\+\_\+zpk}} (z, p, k, fs)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_afbc60fe8e91d4d924a667655144f7b3d}{lp2lp\+\_\+zpk}} (z, p, k, wo=1.\+0)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_a7d904ad8d1239d1f5408d1ed46d6b87c}{lp2hp\+\_\+zpk}} (z, p, k, wo=1.\+0)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_add44de70076884fad1e24280565faa71}{lp2bp\+\_\+zpk}} (z, p, k, wo=1.\+0, bw=1.\+0)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_ab0030f63a715bfb905de22b463bb2005}{lp2bs\+\_\+zpk}} (z, p, k, wo=1.\+0, bw=1.\+0)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_a4568219d096c6e4e5a091c63dbde4bb8}{butter}} (N, Wn, btype=\textquotesingle{}low\textquotesingle{}, analog=False, output=\textquotesingle{}ba\textquotesingle{}, fs=None)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_a0e77ed88eb55f4b49a99f4d8844e61b7}{cheby1}} (N, rp, Wn, btype=\textquotesingle{}low\textquotesingle{}, analog=False, output=\textquotesingle{}ba\textquotesingle{}, fs=None)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_a7ded91bfef2a44d329c94a19f884a2e9}{cheby2}} (N, rs, Wn, btype=\textquotesingle{}low\textquotesingle{}, analog=False, output=\textquotesingle{}ba\textquotesingle{}, fs=None)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_a61a842f3ea1494216b2d32708a8ae665}{ellip}} (N, rp, rs, Wn, btype=\textquotesingle{}low\textquotesingle{}, analog=False, output=\textquotesingle{}ba\textquotesingle{}, fs=None)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_ad432d51b3c6588aad365b569f4fd73fc}{bessel}} (N, Wn, btype=\textquotesingle{}low\textquotesingle{}, analog=False, output=\textquotesingle{}ba\textquotesingle{}, norm=\textquotesingle{}phase\textquotesingle{}, fs=None)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_a4e93da165795ed541dd2fa129b781a35}{maxflat}} ()
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_a63c5cc73d85694103d8943b59e3c3fe4}{yulewalk}} ()
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_a258bb5e560cf7595cda3c4906daa5f01}{band\+\_\+stop\+\_\+obj}} (wp, ind, passb, stopb, gpass, gstop, type)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_a91da99d4aea5955bfa7a499a8e815bf4}{buttord}} (wp, ws, gpass, gstop, analog=False, fs=None)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_a7faa130bd1b19c1b14542e764b6fe3c8}{cheb1ord}} (wp, ws, gpass, gstop, analog=False, fs=None)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_afa28a525115653cfbb7fa47769345631}{cheb2ord}} (wp, ws, gpass, gstop, analog=False, fs=None)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_a29fbb90ffea114a412f2f43b81f4a00c}{\+\_\+pow10m1}} (x)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_a6ef9f4f8f06e8223d397899d35ee6772}{ellipord}} (wp, ws, gpass, gstop, analog=False, fs=None)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_accb3d2394285c25575e31ab79e78633c}{buttap}} (N)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_a8bff6c7f370bc3d69ca665c99c72b991}{cheb1ap}} (N, rp)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_a85604d994461d93b66688f46e2274e01}{cheb2ap}} (N, rs)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_adea1a91e31a980a583aea106301c3af7}{\+\_\+ellipdeg}} (n, m1)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_a79130ea20d907c20de2133fa36a8b2b4}{\+\_\+arc\+\_\+jac\+\_\+sn}} (w, m)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_adc92d81e1dcd3827ea2a5a35dd9d9dbd}{\+\_\+arc\+\_\+jac\+\_\+sc1}} (w, m)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_a23f21ad85d8274746e8029345a2d6dd2}{ellipap}} (N, rp, rs)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_a430d6e30bd79c1ac8415b1b3a86920ca}{\+\_\+falling\+\_\+factorial}} (x, n)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_ac558291278a8e0c181a04544633535e9}{\+\_\+bessel\+\_\+poly}} (n, reverse=False)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_a1f4c3649aa3f992a5fce219262b6b86b}{\+\_\+campos\+\_\+zeros}} (n)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_a7b3e35a28f953cc535b8338a3d16e42b}{\+\_\+aberth}} (f, fp, x0, tol=1e-\/15, maxiter=50)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_a437956b9572826ca331e4c0145f478b3}{\+\_\+bessel\+\_\+zeros}} (N)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_af24f2b004da00e3d84426d2f1b70507c}{\+\_\+norm\+\_\+factor}} (p, k)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_a9494ea841106ba6e20f525f6782efb38}{besselap}} (N, norm=\textquotesingle{}phase\textquotesingle{})
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_ad597e2eb48ee608991d13e408bf5873e}{iirnotch}} (w0, Q, fs=2.\+0)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_af928a310a30876eb852f6ef0ee25ac02}{iirpeak}} (w0, Q, fs=2.\+0)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_a5ac21026656dadfc0ee99dc0ff88d716}{\+\_\+design\+\_\+notch\+\_\+peak\+\_\+filter}} (w0, Q, ftype, fs=2.\+0)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_a2aa21ab1bccbcf879a749367fa1abdfa}{iircomb}} (w0, Q, ftype=\textquotesingle{}notch\textquotesingle{}, fs=2.\+0, \texorpdfstring{$\ast$}{*}, pass\+\_\+zero=False)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_adce4c3f0ff53976dd442626172326b1e}{\+\_\+hz\+\_\+to\+\_\+erb}} (hz)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_a95698a45f8565d76ba5a43d77120ac9c}{gammatone}} (freq, ftype, order=None, numtaps=None, fs=None)
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
list \mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_ae64ec8303b2fa79a24aad5e9317b68e5}{\+\_\+\+\_\+all\+\_\+\+\_\+}}
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_ae0755694c5f3c0fd7ffccc146d000962}{abs}} = absolute
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_a76ecc62801ca1a598f57e1e89c3f862a}{\+\_\+\+POW10\+\_\+\+LOG10}} = np.\+log(10)
\item 
int \mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_a6345627611c9584ab49581b89d6133e3}{EPSILON}} = 2e-\/16
\item 
int \mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_a2488f153d8ae94e3316797a1661dbb30}{\+\_\+\+ELLIPDEG\+\_\+\+MMAX}} = 7
\item 
int \mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_a7652e5119bd8574ea5fb53c49d2cd3f9}{\+\_\+\+ARC\+\_\+\+JAC\+\_\+\+SN\+\_\+\+MAXITER}} = 10
\item 
dict \mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_a1997d304fd4096c170a317286c5ddefc}{filter\+\_\+dict}}
\item 
dict \mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_a9f2e025a5a7ab98adda5a652673c1c95}{band\+\_\+dict}}
\item 
dict \mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_af27e4e2de443cd81d20e5da16eeae926}{bessel\+\_\+norms}}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\begin{DoxyVerb}Filter design.\end{DoxyVerb}
 

\doxysubsection{Function Documentation}
\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_a7b3e35a28f953cc535b8338a3d16e42b}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!\_aberth@{\_aberth}}
\index{\_aberth@{\_aberth}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{\_aberth()}{\_aberth()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_a7b3e35a28f953cc535b8338a3d16e42b} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+\_\+aberth (\begin{DoxyParamCaption}\item[{}]{f}{, }\item[{}]{fp}{, }\item[{}]{x0}{, }\item[{}]{tol}{ = {\ttfamily 1e-\/15}, }\item[{}]{maxiter}{ = {\ttfamily 50}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Given a function `f`, its first derivative `fp`, and a set of initial
guesses `x0`, simultaneously find the roots of the polynomial using the
Aberth-Ehrlich method.

``len(x0)`` should equal the number of roots of `f`.

(This is not a complete implementation of Bini's algorithm.)
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l04723}{4723}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.



Referenced by \mbox{\hyperlink{__filter__design_8py_source_l04762}{\+\_\+bessel\+\_\+zeros()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_a2f786c9911a15f0727e21552a6d027e1}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!\_align\_nums@{\_align\_nums}}
\index{\_align\_nums@{\_align\_nums}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{\_align\_nums()}{\_align\_nums()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_a2f786c9911a15f0727e21552a6d027e1} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+\_\+align\+\_\+nums (\begin{DoxyParamCaption}\item[{}]{nums}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Aligns the shapes of multiple numerators.

Given an array of numerator coefficient arrays [[a_1, a_2,...,
a_n],..., [b_1, b_2,..., b_m]], this function pads shorter numerator
arrays with zero's so that all numerators have the same length. Such
alignment is necessary for functions like 'tf2ss', which needs the
alignment when dealing with SIMO transfer functions.

Parameters
----------
nums: array_like
    Numerator or list of numerators. Not necessarily with same length.

Returns
-------
nums: array
    The numerator. If `nums` input was a list of numerators then a 2-D
    array with padded zeros for shorter numerators is returned. Otherwise
    returns ``np.asarray(nums)``.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l01615}{1615}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.



Referenced by \mbox{\hyperlink{__filter__design_8py_source_l01661}{normalize()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_adc92d81e1dcd3827ea2a5a35dd9d9dbd}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!\_arc\_jac\_sc1@{\_arc\_jac\_sc1}}
\index{\_arc\_jac\_sc1@{\_arc\_jac\_sc1}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{\_arc\_jac\_sc1()}{\_arc\_jac\_sc1()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_adc92d81e1dcd3827ea2a5a35dd9d9dbd} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+\_\+arc\+\_\+jac\+\_\+sc1 (\begin{DoxyParamCaption}\item[{}]{w}{, }\item[{}]{m}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Real inverse Jacobian sc, with complementary modulus

Solve for z in w = sc(z, 1-m)

w - real scalar

m - modulus

From [1], sc(z, m) = -i * sn(i * z, 1 - m)

References
----------
# noqa: E501
.. [1] https://functions.wolfram.com/EllipticFunctions/JacobiSC/introductions/JacobiPQs/ShowAll.html,
   "Representations through other Jacobi functions"
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l04524}{4524}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.



References \mbox{\hyperlink{__filter__design_8py_source_l04463}{\+\_\+arc\+\_\+jac\+\_\+sn()}}.



Referenced by \mbox{\hyperlink{__filter__design_8py_source_l04550}{ellipap()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_a79130ea20d907c20de2133fa36a8b2b4}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!\_arc\_jac\_sn@{\_arc\_jac\_sn}}
\index{\_arc\_jac\_sn@{\_arc\_jac\_sn}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{\_arc\_jac\_sn()}{\_arc\_jac\_sn()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_a79130ea20d907c20de2133fa36a8b2b4} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+\_\+arc\+\_\+jac\+\_\+sn (\begin{DoxyParamCaption}\item[{}]{w}{, }\item[{}]{m}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Inverse Jacobian elliptic sn

Solve for z in w = sn(z, m)

Parameters
----------
w : complex scalar
    argument

m : scalar
    modulus; in interval [0, 1]


See [1], Eq. (56)

References
----------
.. [1] Orfanidis, "Lecture Notes on Elliptic Filter Design",
       https://www.ece.rutgers.edu/~orfanidi/ece521/notes.pdf
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l04463}{4463}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.



Referenced by \mbox{\hyperlink{__filter__design_8py_source_l04524}{\+\_\+arc\+\_\+jac\+\_\+sc1()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_ac558291278a8e0c181a04544633535e9}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!\_bessel\_poly@{\_bessel\_poly}}
\index{\_bessel\_poly@{\_bessel\_poly}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{\_bessel\_poly()}{\_bessel\_poly()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_ac558291278a8e0c181a04544633535e9} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+\_\+bessel\+\_\+poly (\begin{DoxyParamCaption}\item[{}]{n}{, }\item[{}]{reverse}{ = {\ttfamily False}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Return the coefficients of Bessel polynomial of degree `n`

If `reverse` is true, a reverse Bessel polynomial is output.

Output is a list of coefficients:
[1]                   = 1
[1,  1]               = 1*s   +  1
[1,  3,  3]           = 1*s^2 +  3*s   +  3
[1,  6, 15, 15]       = 1*s^3 +  6*s^2 + 15*s   +  15
[1, 10, 45, 105, 105] = 1*s^4 + 10*s^3 + 45*s^2 + 105*s + 105
etc.

Output is a Python list of arbitrary precision long ints, so n is only
limited by your hardware's memory.

Sequence is http://oeis.org/A001498, and output can be confirmed to
match http://oeis.org/A001498/b001498.txt :

>>> i = 0
>>> for n in range(51):
...     for x in _bessel_poly(n, reverse=True):
...         print(i, x)
...         i += 1
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l04654}{4654}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.



References \mbox{\hyperlink{__filter__design_8py_source_l04630}{\+\_\+falling\+\_\+factorial()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_a437956b9572826ca331e4c0145f478b3}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!\_bessel\_zeros@{\_bessel\_zeros}}
\index{\_bessel\_zeros@{\_bessel\_zeros}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{\_bessel\_zeros()}{\_bessel\_zeros()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_a437956b9572826ca331e4c0145f478b3} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+\_\+bessel\+\_\+zeros (\begin{DoxyParamCaption}\item[{}]{N}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Find zeros of ordinary Bessel polynomial of order `N`, by root-finding of
modified Bessel function of the second kind
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l04762}{4762}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.



References \mbox{\hyperlink{__filter__design_8py_source_l04723}{\+\_\+aberth()}}, and \mbox{\hyperlink{__filter__design_8py_source_l04698}{\+\_\+campos\+\_\+zeros()}}.



Referenced by \mbox{\hyperlink{__filter__design_8py_source_l04829}{besselap()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_a1f4c3649aa3f992a5fce219262b6b86b}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!\_campos\_zeros@{\_campos\_zeros}}
\index{\_campos\_zeros@{\_campos\_zeros}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{\_campos\_zeros()}{\_campos\_zeros()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_a1f4c3649aa3f992a5fce219262b6b86b} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+\_\+campos\+\_\+zeros (\begin{DoxyParamCaption}\item[{}]{n}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Return approximate zero locations of Bessel polynomials y_n(x) for order
`n` using polynomial fit (Campos-Calderon 2011)
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l04698}{4698}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.



Referenced by \mbox{\hyperlink{__filter__design_8py_source_l04762}{\+\_\+bessel\+\_\+zeros()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_a2aed3d7c4622770e66245baa67139fbe}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!\_cplxpair@{\_cplxpair}}
\index{\_cplxpair@{\_cplxpair}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{\_cplxpair()}{\_cplxpair()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_a2aed3d7c4622770e66245baa67139fbe} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+\_\+cplxpair (\begin{DoxyParamCaption}\item[{}]{z}{, }\item[{}]{tol}{ = {\ttfamily None}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Sort into pairs of complex conjugates.

Complex conjugates in `z` are sorted by increasing real part. In each
pair, the number with negative imaginary part appears first.

If pairs have identical real parts, they are sorted by increasing
imaginary magnitude.

Two complex numbers are considered a conjugate pair if their real and
imaginary parts differ in magnitude by less than ``tol * abs(z)``.  The
pairs are forced to be exact complex conjugates by averaging the positive
and negative values.

Purely real numbers are also sorted, but placed after the complex
conjugate pairs. A number is considered real if its imaginary part is
smaller than `tol` times the magnitude of the number.

Parameters
----------
z : array_like
    1-D input array to be sorted.
tol : float, optional
    Relative tolerance for testing realness and conjugate equality.
    Default is ``100 * spacing(1)`` of `z`'s data type (i.e., 2e-14 for
    float64)

Returns
-------
y : ndarray
    Complex conjugate pairs followed by real numbers.

Raises
------
ValueError
    If there are any complex numbers in `z` for which a conjugate
    cannot be found.

See Also
--------
_cplxreal

Examples
--------
>>> a = [4, 3, 1, 2-2j, 2+2j, 2-1j, 2+1j, 2-1j, 2+1j, 1+1j, 1-1j]
>>> z = _cplxpair(a)
>>> print(z)
[ 1.-1.j  1.+1.j  2.-1.j  2.+1.j  2.-1.j  2.+1.j  2.-2.j  2.+2.j  1.+0.j
  3.+0.j  4.+0.j]
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l00958}{958}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.



References \mbox{\hyperlink{__filter__design_8py_source_l00854}{\+\_\+cplxreal()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_a39cb8fff9a90d19a81ee134d1ee37ed4}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!\_cplxreal@{\_cplxreal}}
\index{\_cplxreal@{\_cplxreal}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{\_cplxreal()}{\_cplxreal()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_a39cb8fff9a90d19a81ee134d1ee37ed4} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+\_\+cplxreal (\begin{DoxyParamCaption}\item[{}]{z}{, }\item[{}]{tol}{ = {\ttfamily None}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Split into complex and real parts, combining conjugate pairs.

The 1-D input vector `z` is split up into its complex (`zc`) and real (`zr`)
elements. Every complex element must be part of a complex-conjugate pair,
which are combined into a single number (with positive imaginary part) in
the output. Two complex numbers are considered a conjugate pair if their
real and imaginary parts differ in magnitude by less than ``tol * abs(z)``.

Parameters
----------
z : array_like
    Vector of complex numbers to be sorted and split
tol : float, optional
    Relative tolerance for testing realness and conjugate equality.
    Default is ``100 * spacing(1)`` of `z`'s data type (i.e., 2e-14 for
    float64)

Returns
-------
zc : ndarray
    Complex elements of `z`, with each pair represented by a single value
    having positive imaginary part, sorted first by real part, and then
    by magnitude of imaginary part. The pairs are averaged when combined
    to reduce error.
zr : ndarray
    Real elements of `z` (those having imaginary part less than
    `tol` times their magnitude), sorted by value.

Raises
------
ValueError
    If there are any complex numbers in `z` for which a conjugate
    cannot be found.

See Also
--------
_cplxpair

Examples
--------
>>> a = [4, 3, 1, 2-2j, 2+2j, 2-1j, 2+1j, 2-1j, 2+1j, 1+1j, 1-1j]
>>> zc, zr = _cplxreal(a)
>>> print(zc)
[ 1.+1.j  2.+1.j  2.+1.j  2.+2.j]
>>> print(zr)
[ 1.  3.  4.]
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l00854}{854}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.



Referenced by \mbox{\hyperlink{__filter__design_8py_source_l00958}{\+\_\+cplxpair()}}, and \mbox{\hyperlink{__filter__design_8py_source_l01297}{zpk2sos()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_a5ac21026656dadfc0ee99dc0ff88d716}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!\_design\_notch\_peak\_filter@{\_design\_notch\_peak\_filter}}
\index{\_design\_notch\_peak\_filter@{\_design\_notch\_peak\_filter}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{\_design\_notch\_peak\_filter()}{\_design\_notch\_peak\_filter()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_a5ac21026656dadfc0ee99dc0ff88d716} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+\_\+design\+\_\+notch\+\_\+peak\+\_\+filter (\begin{DoxyParamCaption}\item[{}]{w0}{, }\item[{}]{Q}{, }\item[{}]{ftype}{, }\item[{}]{fs}{ = {\ttfamily 2.0}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Design notch or peak digital filter.

Parameters
----------
w0 : float
    Normalized frequency to remove from a signal. If `fs` is specified,
    this is in the same units as `fs`. By default, it is a normalized
    scalar that must satisfy  ``0 < w0 < 1``, with ``w0 = 1``
    corresponding to half of the sampling frequency.
Q : float
    Quality factor. Dimensionless parameter that characterizes
    notch filter -3 dB bandwidth ``bw`` relative to its center
    frequency, ``Q = w0/bw``.
ftype : str
    The type of IIR filter to design:

        - notch filter : ``notch``
        - peak filter  : ``peak``
fs : float, optional
    The sampling frequency of the digital system.

    .. versionadded:: 1.2.0:

Returns
-------
b, a : ndarray, ndarray
    Numerator (``b``) and denominator (``a``) polynomials
    of the IIR filter.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l05099}{5099}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.



Referenced by \mbox{\hyperlink{__filter__design_8py_source_l04937}{iirnotch()}}, and \mbox{\hyperlink{__filter__design_8py_source_l05018}{iirpeak()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_adea1a91e31a980a583aea106301c3af7}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!\_ellipdeg@{\_ellipdeg}}
\index{\_ellipdeg@{\_ellipdeg}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{\_ellipdeg()}{\_ellipdeg()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_adea1a91e31a980a583aea106301c3af7} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+\_\+ellipdeg (\begin{DoxyParamCaption}\item[{}]{n}{, }\item[{}]{m1}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Solve degree equation using nomes

Given n, m1, solve
   n * K(m) / K'(m) = K1(m1) / K1'(m1)
for m

See [1], Eq. (49)

References
----------
.. [1] Orfanidis, "Lecture Notes on Elliptic Filter Design",
       https://www.ece.rutgers.edu/~orfanidi/ece521/notes.pdf
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l04428}{4428}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.



Referenced by \mbox{\hyperlink{__filter__design_8py_source_l04550}{ellipap()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_a430d6e30bd79c1ac8415b1b3a86920ca}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!\_falling\_factorial@{\_falling\_factorial}}
\index{\_falling\_factorial@{\_falling\_factorial}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{\_falling\_factorial()}{\_falling\_factorial()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_a430d6e30bd79c1ac8415b1b3a86920ca} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+\_\+falling\+\_\+factorial (\begin{DoxyParamCaption}\item[{}]{x}{, }\item[{}]{n}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Return the factorial of `x` to the `n` falling.

This is defined as:

.. math::   x^\underline n = (x)_n = x (x-1) \cdots (x-n+1)

This can more efficiently calculate ratios of factorials, since:

n!/m! == falling_factorial(n, n-m)

where n >= m

skipping the factors that cancel out

the usual factorial n! == ff(n, n)
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l04630}{4630}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.



Referenced by \mbox{\hyperlink{__filter__design_8py_source_l04654}{\+\_\+bessel\+\_\+poly()}}, and \mbox{\hyperlink{__filter__design_8py_source_l04829}{besselap()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_adce4c3f0ff53976dd442626172326b1e}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!\_hz\_to\_erb@{\_hz\_to\_erb}}
\index{\_hz\_to\_erb@{\_hz\_to\_erb}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{\_hz\_to\_erb()}{\_hz\_to\_erb()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_adce4c3f0ff53976dd442626172326b1e} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+\_\+hz\+\_\+to\+\_\+erb (\begin{DoxyParamCaption}\item[{}]{hz}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Utility for converting from frequency (Hz) to the
Equivalent Rectangular Bandwidth (ERB) scale
ERB = frequency / EarQ + minBW
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l05382}{5382}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.



Referenced by \mbox{\hyperlink{__filter__design_8py_source_l05393}{gammatone()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_a5e0ed4ba7b94312ec66b13bf06bf8f74}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!\_is\_int\_type@{\_is\_int\_type}}
\index{\_is\_int\_type@{\_is\_int\_type}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{\_is\_int\_type()}{\_is\_int\_type()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_a5e0ed4ba7b94312ec66b13bf06bf8f74} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+\_\+is\+\_\+int\+\_\+type (\begin{DoxyParamCaption}\item[{}]{x}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Check if input is of a scalar integer type (so ``5`` and ``array(5)`` will
pass, while ``5.0`` and ``array([5])`` will fail.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l00041}{41}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.



Referenced by \mbox{\hyperlink{__filter__design_8py_source_l00119}{freqs()}}, \mbox{\hyperlink{__filter__design_8py_source_l00196}{freqs\+\_\+zpk()}}, \mbox{\hyperlink{__filter__design_8py_source_l00277}{freqz()}}, \mbox{\hyperlink{__filter__design_8py_source_l00491}{freqz\+\_\+zpk()}}, and \mbox{\hyperlink{__filter__design_8py_source_l00598}{group\+\_\+delay()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_ac0dd1dd0be3996b739e2a4af5d8a2d0a}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!\_nearest\_real\_complex\_idx@{\_nearest\_real\_complex\_idx}}
\index{\_nearest\_real\_complex\_idx@{\_nearest\_real\_complex\_idx}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{\_nearest\_real\_complex\_idx()}{\_nearest\_real\_complex\_idx()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_ac0dd1dd0be3996b739e2a4af5d8a2d0a} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+\_\+nearest\+\_\+real\+\_\+complex\+\_\+idx (\begin{DoxyParamCaption}\item[{}]{fro}{, }\item[{}]{to}{, }\item[{}]{which}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Get the next closest real or complex element based on distance\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l01275}{1275}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.



Referenced by \mbox{\hyperlink{__filter__design_8py_source_l01297}{zpk2sos()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_af24f2b004da00e3d84426d2f1b70507c}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!\_norm\_factor@{\_norm\_factor}}
\index{\_norm\_factor@{\_norm\_factor}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{\_norm\_factor()}{\_norm\_factor()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_af24f2b004da00e3d84426d2f1b70507c} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+\_\+norm\+\_\+factor (\begin{DoxyParamCaption}\item[{}]{p}{, }\item[{}]{k}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Numerically find frequency shift to apply to delay-normalized filter such
that -3 dB point is at 1 rad/sec.

`p` is an array_like of polynomial poles
`k` is a float gain

First 10 values are listed in "Bessel Scale Factors" table,
"Bessel Filters Polynomials, Poles and Circuit Elements 2003, C. Bond."
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l04801}{4801}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.



Referenced by \mbox{\hyperlink{__filter__design_8py_source_l04829}{besselap()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_a29fbb90ffea114a412f2f43b81f4a00c}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!\_pow10m1@{\_pow10m1}}
\index{\_pow10m1@{\_pow10m1}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{\_pow10m1()}{\_pow10m1()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_a29fbb90ffea114a412f2f43b81f4a00c} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+\_\+pow10m1 (\begin{DoxyParamCaption}\item[{}]{x}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}10 ** x - 1 for x near 0\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l04176}{4176}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.



Referenced by \mbox{\hyperlink{__filter__design_8py_source_l04550}{ellipap()}}, and \mbox{\hyperlink{__filter__design_8py_source_l04181}{ellipord()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_a719d7c3c96122501b193e7e67a6cc19b}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!\_relative\_degree@{\_relative\_degree}}
\index{\_relative\_degree@{\_relative\_degree}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{\_relative\_degree()}{\_relative\_degree()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_a719d7c3c96122501b193e7e67a6cc19b} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+\_\+relative\+\_\+degree (\begin{DoxyParamCaption}\item[{}]{z}{, }\item[{}]{p}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Return relative degree of transfer function from zeros and poles
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l02601}{2601}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.



Referenced by \mbox{\hyperlink{__filter__design_8py_source_l02613}{bilinear\+\_\+zpk()}}, \mbox{\hyperlink{__filter__design_8py_source_l02821}{lp2bp\+\_\+zpk()}}, \mbox{\hyperlink{__filter__design_8py_source_l02900}{lp2bs\+\_\+zpk()}}, \mbox{\hyperlink{__filter__design_8py_source_l02755}{lp2hp\+\_\+zpk()}}, and \mbox{\hyperlink{__filter__design_8py_source_l02695}{lp2lp\+\_\+zpk()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_a5c2c25900a53f28740007fa4ed1445a7}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!\_single\_zpksos@{\_single\_zpksos}}
\index{\_single\_zpksos@{\_single\_zpksos}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{\_single\_zpksos()}{\_single\_zpksos()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_a5c2c25900a53f28740007fa4ed1445a7} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+\_\+single\+\_\+zpksos (\begin{DoxyParamCaption}\item[{}]{z}{, }\item[{}]{p}{, }\item[{}]{k}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Create one second-order section from up to two zeros and poles\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l01288}{1288}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.



References \mbox{\hyperlink{__filter__design_8py_source_l01097}{zpk2tf()}}.



Referenced by \mbox{\hyperlink{__filter__design_8py_source_l01297}{zpk2sos()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_aec666fcd802c4b7014526c80cbee6ed0}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!\_validate\_gpass\_gstop@{\_validate\_gpass\_gstop}}
\index{\_validate\_gpass\_gstop@{\_validate\_gpass\_gstop}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{\_validate\_gpass\_gstop()}{\_validate\_gpass\_gstop()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_aec666fcd802c4b7014526c80cbee6ed0} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+\_\+validate\+\_\+gpass\+\_\+gstop (\begin{DoxyParamCaption}\item[{}]{gpass}{, }\item[{}]{gstop}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{__filter__design_8py_source_l02178}{2178}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_ad2dec7b3a76879ba708edb9f7d00c00c}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!\_validate\_sos@{\_validate\_sos}}
\index{\_validate\_sos@{\_validate\_sos}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{\_validate\_sos()}{\_validate\_sos()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_ad2dec7b3a76879ba708edb9f7d00c00c} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+\_\+validate\+\_\+sos (\begin{DoxyParamCaption}\item[{}]{sos}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Helper to validate a SOS input\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l00718}{718}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.



Referenced by \mbox{\hyperlink{__signaltools_8py_source_l04233}{scipy.\+signal.\+\_\+signaltools.\+sosfilt()}}, \mbox{\hyperlink{__signaltools_8py_source_l04345}{scipy.\+signal.\+\_\+signaltools.\+sosfiltfilt()}}, and \mbox{\hyperlink{__filter__design_8py_source_l00731}{sosfreqz()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_a258bb5e560cf7595cda3c4906daa5f01}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!band\_stop\_obj@{band\_stop\_obj}}
\index{band\_stop\_obj@{band\_stop\_obj}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{band\_stop\_obj()}{band\_stop\_obj()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_a258bb5e560cf7595cda3c4906daa5f01} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+band\+\_\+stop\+\_\+obj (\begin{DoxyParamCaption}\item[{}]{wp}{, }\item[{}]{ind}{, }\item[{}]{passb}{, }\item[{}]{stopb}{, }\item[{}]{gpass}{, }\item[{}]{gstop}{, }\item[{}]{type}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Band Stop Objective Function for order minimization.

Returns the non-integer order for an analog band stop filter.

Parameters
----------
wp : scalar
    Edge of passband `passb`.
ind : int, {0, 1}
    Index specifying which `passb` edge to vary (0 or 1).
passb : ndarray
    Two element sequence of fixed passband edges.
stopb : ndarray
    Two element sequence of fixed stopband edges.
gstop : float
    Amount of attenuation in stopband in dB.
gpass : float
    Amount of ripple in the passband in dB.
type : {'butter', 'cheby', 'ellip'}
    Type of filter.

Returns
-------
n : scalar
    Filter order (possibly non-integer).
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l03631}{3631}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_ad432d51b3c6588aad365b569f4fd73fc}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!bessel@{bessel}}
\index{bessel@{bessel}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{bessel()}{bessel()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_ad432d51b3c6588aad365b569f4fd73fc} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+bessel (\begin{DoxyParamCaption}\item[{}]{N}{, }\item[{}]{Wn}{, }\item[{}]{btype}{ = {\ttfamily \textquotesingle{}low\textquotesingle{}}, }\item[{}]{analog}{ = {\ttfamily False}, }\item[{}]{output}{ = {\ttfamily \textquotesingle{}ba\textquotesingle{}}, }\item[{}]{norm}{ = {\ttfamily \textquotesingle{}phase\textquotesingle{}}, }\item[{}]{fs}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Bessel/Thomson digital and analog filter design.

Design an Nth-order digital or analog Bessel filter and return the
filter coefficients.

Parameters
----------
N : int
    The order of the filter.
Wn : array_like
    A scalar or length-2 sequence giving the critical frequencies (defined
    by the `norm` parameter).
    For analog filters, `Wn` is an angular frequency (e.g., rad/s).

    For digital filters, `Wn` are in the same units as `fs`.  By default,
    `fs` is 2 half-cycles/sample, so these are normalized from 0 to 1,
    where 1 is the Nyquist frequency. (`Wn` is thus in
    half-cycles / sample.)
btype : {'lowpass', 'highpass', 'bandpass', 'bandstop'}, optional
    The type of filter.  Default is 'lowpass'.
analog : bool, optional
    When True, return an analog filter, otherwise a digital filter is
    returned. (See Notes.)
output : {'ba', 'zpk', 'sos'}, optional
    Type of output:  numerator/denominator ('ba'), pole-zero ('zpk'), or
    second-order sections ('sos'). Default is 'ba'.
norm : {'phase', 'delay', 'mag'}, optional
    Critical frequency normalization:

    ``phase``
        The filter is normalized such that the phase response reaches its
        midpoint at angular (e.g. rad/s) frequency `Wn`. This happens for
        both low-pass and high-pass filters, so this is the
        "phase-matched" case.

        The magnitude response asymptotes are the same as a Butterworth
        filter of the same order with a cutoff of `Wn`.

        This is the default, and matches MATLAB's implementation.

    ``delay``
        The filter is normalized such that the group delay in the passband
        is 1/`Wn` (e.g., seconds). This is the "natural" type obtained by
        solving Bessel polynomials.

    ``mag``
        The filter is normalized such that the gain magnitude is -3 dB at
        angular frequency `Wn`.

    .. versionadded:: 0.18.0
fs : float, optional
    The sampling frequency of the digital system.

    .. versionadded:: 1.2.0

Returns
-------
b, a : ndarray, ndarray
    Numerator (`b`) and denominator (`a`) polynomials of the IIR filter.
    Only returned if ``output='ba'``.
z, p, k : ndarray, ndarray, float
    Zeros, poles, and system gain of the IIR filter transfer
    function.  Only returned if ``output='zpk'``.
sos : ndarray
    Second-order sections representation of the IIR filter.
    Only returned if ``output='sos'``.

Notes
-----
Also known as a Thomson filter, the analog Bessel filter has maximally
flat group delay and maximally linear phase response, with very little
ringing in the step response. [1]_

The Bessel is inherently an analog filter. This function generates digital
Bessel filters using the bilinear transform, which does not preserve the
phase response of the analog filter. As such, it is only approximately
correct at frequencies below about fs/4. To get maximally-flat group
delay at higher frequencies, the analog Bessel filter must be transformed
using phase-preserving techniques.

See `besselap` for implementation details and references.

The ``'sos'`` output parameter was added in 0.16.0.

References
----------
.. [1] Thomson, W.E., "Delay Networks having Maximally Flat Frequency
       Characteristics", Proceedings of the Institution of Electrical
       Engineers, Part III, November 1949, Vol. 96, No. 44, pp. 487-490.

Examples
--------
Plot the phase-normalized frequency response, showing the relationship
to the Butterworth's cutoff frequency (green):

>>> from scipy import signal
>>> import matplotlib.pyplot as plt
>>> import numpy as np

>>> b, a = signal.butter(4, 100, 'low', analog=True)
>>> w, h = signal.freqs(b, a)
>>> plt.semilogx(w, 20 * np.log10(np.abs(h)), color='silver', ls='dashed')
>>> b, a = signal.bessel(4, 100, 'low', analog=True, norm='phase')
>>> w, h = signal.freqs(b, a)
>>> plt.semilogx(w, 20 * np.log10(np.abs(h)))
>>> plt.title('Bessel filter magnitude response (with Butterworth)')
>>> plt.xlabel('Frequency [radians / second]')
>>> plt.ylabel('Amplitude [dB]')
>>> plt.margins(0, 0.1)
>>> plt.grid(which='both', axis='both')
>>> plt.axvline(100, color='green')  # cutoff frequency
>>> plt.show()

and the phase midpoint:

>>> plt.figure()
>>> plt.semilogx(w, np.unwrap(np.angle(h)))
>>> plt.axvline(100, color='green')  # cutoff frequency
>>> plt.axhline(-np.pi, color='red')  # phase midpoint
>>> plt.title('Bessel filter phase response')
>>> plt.xlabel('Frequency [radians / second]')
>>> plt.ylabel('Phase [radians]')
>>> plt.margins(0, 0.1)
>>> plt.grid(which='both', axis='both')
>>> plt.show()

Plot the magnitude-normalized frequency response, showing the -3 dB cutoff:

>>> b, a = signal.bessel(3, 10, 'low', analog=True, norm='mag')
>>> w, h = signal.freqs(b, a)
>>> plt.semilogx(w, 20 * np.log10(np.abs(h)))
>>> plt.axhline(-3, color='red')  # -3 dB magnitude
>>> plt.axvline(10, color='green')  # cutoff frequency
>>> plt.title('Magnitude-normalized Bessel filter frequency response')
>>> plt.xlabel('Frequency [radians / second]')
>>> plt.ylabel('Amplitude [dB]')
>>> plt.margins(0, 0.1)
>>> plt.grid(which='both', axis='both')
>>> plt.show()

Plot the delay-normalized filter, showing the maximally-flat group delay
at 0.1 seconds:

>>> b, a = signal.bessel(5, 1/0.1, 'low', analog=True, norm='delay')
>>> w, h = signal.freqs(b, a)
>>> plt.figure()
>>> plt.semilogx(w[1:], -np.diff(np.unwrap(np.angle(h)))/np.diff(w))
>>> plt.axhline(0.1, color='red')  # 0.1 seconds group delay
>>> plt.title('Bessel filter group delay')
>>> plt.xlabel('Frequency [radians / second]')
>>> plt.ylabel('Group delay [seconds]')
>>> plt.margins(0, 0.1)
>>> plt.grid(which='both', axis='both')
>>> plt.show()
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l03460}{3460}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.



References \mbox{\hyperlink{__filter__design_8py_source_l02362}{iirfilter()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_a9494ea841106ba6e20f525f6782efb38}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!besselap@{besselap}}
\index{besselap@{besselap}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{besselap()}{besselap()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_a9494ea841106ba6e20f525f6782efb38} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+besselap (\begin{DoxyParamCaption}\item[{}]{N}{, }\item[{}]{norm}{ = {\ttfamily \textquotesingle{}phase\textquotesingle{}}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Return (z,p,k) for analog prototype of an Nth-order Bessel filter.

Parameters
----------
N : int
    The order of the filter.
norm : {'phase', 'delay', 'mag'}, optional
    Frequency normalization:

    ``phase``
        The filter is normalized such that the phase response reaches its
        midpoint at an angular (e.g., rad/s) cutoff frequency of 1. This
        happens for both low-pass and high-pass filters, so this is the
        "phase-matched" case. [6]_

        The magnitude response asymptotes are the same as a Butterworth
        filter of the same order with a cutoff of `Wn`.

        This is the default, and matches MATLAB's implementation.

    ``delay``
        The filter is normalized such that the group delay in the passband
        is 1 (e.g., 1 second). This is the "natural" type obtained by
        solving Bessel polynomials

    ``mag``
        The filter is normalized such that the gain magnitude is -3 dB at
        angular frequency 1. This is called "frequency normalization" by
        Bond. [1]_

    .. versionadded:: 0.18.0

Returns
-------
z : ndarray
    Zeros of the transfer function. Is always an empty array.
p : ndarray
    Poles of the transfer function.
k : scalar
    Gain of the transfer function. For phase-normalized, this is always 1.

See Also
--------
bessel : Filter design function using this prototype

Notes
-----
To find the pole locations, approximate starting points are generated [2]_
for the zeros of the ordinary Bessel polynomial [3]_, then the
Aberth-Ehrlich method [4]_ [5]_ is used on the Kv(x) Bessel function to
calculate more accurate zeros, and these locations are then inverted about
the unit circle.

References
----------
.. [1] C.R. Bond, "Bessel Filter Constants",
       http://www.crbond.com/papers/bsf.pdf
.. [2] Campos and Calderon, "Approximate closed-form formulas for the
       zeros of the Bessel Polynomials", :arXiv:`1105.0957`.
.. [3] Thomson, W.E., "Delay Networks having Maximally Flat Frequency
       Characteristics", Proceedings of the Institution of Electrical
       Engineers, Part III, November 1949, Vol. 96, No. 44, pp. 487-490.
.. [4] Aberth, "Iteration Methods for Finding all Zeros of a Polynomial
       Simultaneously", Mathematics of Computation, Vol. 27, No. 122,
       April 1973
.. [5] Ehrlich, "A modified Newton method for polynomials", Communications
       of the ACM, Vol. 10, Issue 2, pp. 107-108, Feb. 1967,
       :DOI:`10.1145/363067.363115`
.. [6] Miller and Bohn, "A Bessel Filter Crossover, and Its Relation to
       Others", RaneNote 147, 1998,
       https://www.ranecommercial.com/legacy/note147.html
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l04829}{4829}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.



References \mbox{\hyperlink{__filter__design_8py_source_l04762}{\+\_\+bessel\+\_\+zeros()}}, \mbox{\hyperlink{__filter__design_8py_source_l04630}{\+\_\+falling\+\_\+factorial()}}, and \mbox{\hyperlink{__filter__design_8py_source_l04801}{\+\_\+norm\+\_\+factor()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_a6fe7b079ffdda28a189c255cbe9fb1d2}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!bilinear@{bilinear}}
\index{bilinear@{bilinear}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{bilinear()}{bilinear()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_a6fe7b079ffdda28a189c255cbe9fb1d2} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+bilinear (\begin{DoxyParamCaption}\item[{}]{b}{, }\item[{}]{a}{, }\item[{}]{fs}{ = {\ttfamily 1.0}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Return a digital IIR filter from an analog one using a bilinear transform.

Transform a set of poles and zeros from the analog s-plane to the digital
z-plane using Tustin's method, which substitutes ``2*fs*(z-1) / (z+1)`` for
``s``, maintaining the shape of the frequency response.

Parameters
----------
b : array_like
Numerator of the analog filter transfer function.
a : array_like
Denominator of the analog filter transfer function.
fs : float
Sample rate, as ordinary frequency (e.g., hertz). No prewarping is
done in this function.

Returns
-------
b : ndarray
Numerator of the transformed digital filter transfer function.
a : ndarray
Denominator of the transformed digital filter transfer function.

See Also
--------
lp2lp, lp2hp, lp2bp, lp2bs
bilinear_zpk

Examples
--------
>>> from scipy import signal
>>> import matplotlib.pyplot as plt
>>> import numpy as np

>>> fs = 100
>>> bf = 2 * np.pi * np.array([7, 13])
>>> filts = signal.lti(*signal.butter(4, bf, btype='bandpass',
...                                   analog=True))
>>> filtz = signal.lti(*signal.bilinear(filts.num, filts.den, fs))
>>> wz, hz = signal.freqz(filtz.num, filtz.den)
>>> ws, hs = signal.freqs(filts.num, filts.den, worN=fs*wz)

>>> plt.semilogx(wz*fs/(2*np.pi), 20*np.log10(np.abs(hz).clip(1e-15)),
...              label=r'$|H_z(e^{j \omega})|$')
>>> plt.semilogx(wz*fs/(2*np.pi), 20*np.log10(np.abs(hs).clip(1e-15)),
...              label=r'$|H(j \omega)|$')
>>> plt.legend()
>>> plt.xlabel('Frequency [Hz]')
>>> plt.ylabel('Magnitude [dB]')
>>> plt.grid(True)
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l02093}{2093}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.



References \mbox{\hyperlink{__filter__design_8py_source_l01661}{normalize()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_a9da0a444f05972f5eca9cb9035d71261}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!bilinear\_zpk@{bilinear\_zpk}}
\index{bilinear\_zpk@{bilinear\_zpk}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{bilinear\_zpk()}{bilinear\_zpk()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_a9da0a444f05972f5eca9cb9035d71261} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+bilinear\+\_\+zpk (\begin{DoxyParamCaption}\item[{}]{z}{, }\item[{}]{p}{, }\item[{}]{k}{, }\item[{}]{fs}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Return a digital IIR filter from an analog one using a bilinear transform.

Transform a set of poles and zeros from the analog s-plane to the digital
z-plane using Tustin's method, which substitutes ``2*fs*(z-1) / (z+1)`` for
``s``, maintaining the shape of the frequency response.

Parameters
----------
z : array_like
Zeros of the analog filter transfer function.
p : array_like
Poles of the analog filter transfer function.
k : float
System gain of the analog filter transfer function.
fs : float
Sample rate, as ordinary frequency (e.g., hertz). No prewarping is
done in this function.

Returns
-------
z : ndarray
Zeros of the transformed digital filter transfer function.
p : ndarray
Poles of the transformed digital filter transfer function.
k : float
System gain of the transformed digital filter.

See Also
--------
lp2lp_zpk, lp2hp_zpk, lp2bp_zpk, lp2bs_zpk
bilinear

Notes
-----
.. versionadded:: 1.1.0

Examples
--------
>>> import numpy as np
>>> from scipy import signal
>>> import matplotlib.pyplot as plt

>>> fs = 100
>>> bf = 2 * np.pi * np.array([7, 13])
>>> filts = signal.lti(*signal.butter(4, bf, btype='bandpass', analog=True,
...                                   output='zpk'))
>>> filtz = signal.lti(*signal.bilinear_zpk(filts.zeros, filts.poles,
...                                         filts.gain, fs))
>>> wz, hz = signal.freqz_zpk(filtz.zeros, filtz.poles, filtz.gain)
>>> ws, hs = signal.freqs_zpk(filts.zeros, filts.poles, filts.gain,
...                           worN=fs*wz)
>>> plt.semilogx(wz*fs/(2*np.pi), 20*np.log10(np.abs(hz).clip(1e-15)),
...              label=r'$|H_z(e^{j \omega})|$')
>>> plt.semilogx(wz*fs/(2*np.pi), 20*np.log10(np.abs(hs).clip(1e-15)),
...              label=r'$|H(j \omega)|$')
>>> plt.legend()
>>> plt.xlabel('Frequency [Hz]')
>>> plt.ylabel('Magnitude [dB]')
>>> plt.grid(True)
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l02613}{2613}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.



References \mbox{\hyperlink{__filter__design_8py_source_l02601}{\+\_\+relative\+\_\+degree()}}.



Referenced by \mbox{\hyperlink{__filter__design_8py_source_l02362}{iirfilter()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_accb3d2394285c25575e31ab79e78633c}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!buttap@{buttap}}
\index{buttap@{buttap}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{buttap()}{buttap()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_accb3d2394285c25575e31ab79e78633c} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+buttap (\begin{DoxyParamCaption}\item[{}]{N}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Return (z,p,k) for analog prototype of Nth-order Butterworth filter.

The filter will have an angular (e.g., rad/s) cutoff frequency of 1.

See Also
--------
butter : Filter design function using this prototype
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l04322}{4322}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_a4568219d096c6e4e5a091c63dbde4bb8}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!butter@{butter}}
\index{butter@{butter}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{butter()}{butter()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_a4568219d096c6e4e5a091c63dbde4bb8} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+butter (\begin{DoxyParamCaption}\item[{}]{N}{, }\item[{}]{Wn}{, }\item[{}]{btype}{ = {\ttfamily \textquotesingle{}low\textquotesingle{}}, }\item[{}]{analog}{ = {\ttfamily False}, }\item[{}]{output}{ = {\ttfamily \textquotesingle{}ba\textquotesingle{}}, }\item[{}]{fs}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Butterworth digital and analog filter design.

Design an Nth-order digital or analog Butterworth filter and return
the filter coefficients.

Parameters
----------
N : int
    The order of the filter. For 'bandpass' and 'bandstop' filters,
    the resulting order of the final second-order sections ('sos')
    matrix is ``2*N``, with `N` the number of biquad sections
    of the desired system.
Wn : array_like
    The critical frequency or frequencies. For lowpass and highpass
    filters, Wn is a scalar; for bandpass and bandstop filters,
    Wn is a length-2 sequence.

    For a Butterworth filter, this is the point at which the gain
    drops to 1/sqrt(2) that of the passband (the "-3 dB point").

    For digital filters, if `fs` is not specified, `Wn` units are
    normalized from 0 to 1, where 1 is the Nyquist frequency (`Wn` is
    thus in half cycles / sample and defined as 2*critical frequencies
    / `fs`). If `fs` is specified, `Wn` is in the same units as `fs`.

    For analog filters, `Wn` is an angular frequency (e.g. rad/s).
btype : {'lowpass', 'highpass', 'bandpass', 'bandstop'}, optional
    The type of filter.  Default is 'lowpass'.
analog : bool, optional
    When True, return an analog filter, otherwise a digital filter is
    returned.
output : {'ba', 'zpk', 'sos'}, optional
    Type of output:  numerator/denominator ('ba'), pole-zero ('zpk'), or
    second-order sections ('sos'). Default is 'ba' for backwards
    compatibility, but 'sos' should be used for general-purpose filtering.
fs : float, optional
    The sampling frequency of the digital system.

    .. versionadded:: 1.2.0

Returns
-------
b, a : ndarray, ndarray
    Numerator (`b`) and denominator (`a`) polynomials of the IIR filter.
    Only returned if ``output='ba'``.
z, p, k : ndarray, ndarray, float
    Zeros, poles, and system gain of the IIR filter transfer
    function.  Only returned if ``output='zpk'``.
sos : ndarray
    Second-order sections representation of the IIR filter.
    Only returned if ``output='sos'``.

See Also
--------
buttord, buttap

Notes
-----
The Butterworth filter has maximally flat frequency response in the
passband.

The ``'sos'`` output parameter was added in 0.16.0.

If the transfer function form ``[b, a]`` is requested, numerical
problems can occur since the conversion between roots and
the polynomial coefficients is a numerically sensitive operation,
even for N >= 4. It is recommended to work with the SOS
representation.

.. warning::
    Designing high-order and narrowband IIR filters in TF form can
    result in unstable or incorrect filtering due to floating point
    numerical precision issues. Consider inspecting output filter
    characteristics `freqz` or designing the filters with second-order
    sections via ``output='sos'``.

Examples
--------
Design an analog filter and plot its frequency response, showing the
critical points:

>>> from scipy import signal
>>> import matplotlib.pyplot as plt
>>> import numpy as np

>>> b, a = signal.butter(4, 100, 'low', analog=True)
>>> w, h = signal.freqs(b, a)
>>> plt.semilogx(w, 20 * np.log10(abs(h)))
>>> plt.title('Butterworth filter frequency response')
>>> plt.xlabel('Frequency [radians / second]')
>>> plt.ylabel('Amplitude [dB]')
>>> plt.margins(0, 0.1)
>>> plt.grid(which='both', axis='both')
>>> plt.axvline(100, color='green') # cutoff frequency
>>> plt.show()

Generate a signal made up of 10 Hz and 20 Hz, sampled at 1 kHz

>>> t = np.linspace(0, 1, 1000, False)  # 1 second
>>> sig = np.sin(2*np.pi*10*t) + np.sin(2*np.pi*20*t)
>>> fig, (ax1, ax2) = plt.subplots(2, 1, sharex=True)
>>> ax1.plot(t, sig)
>>> ax1.set_title('10 Hz and 20 Hz sinusoids')
>>> ax1.axis([0, 1, -2, 2])

Design a digital high-pass filter at 15 Hz to remove the 10 Hz tone, and
apply it to the signal. (It's recommended to use second-order sections
format when filtering, to avoid numerical error with transfer function
(``ba``) format):

>>> sos = signal.butter(10, 15, 'hp', fs=1000, output='sos')
>>> filtered = signal.sosfilt(sos, sig)
>>> ax2.plot(t, filtered)
>>> ax2.set_title('After 15 Hz high-pass filter')
>>> ax2.axis([0, 1, -2, 2])
>>> ax2.set_xlabel('Time [seconds]')
>>> plt.tight_layout()
>>> plt.show()
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l02980}{2980}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.



References \mbox{\hyperlink{__filter__design_8py_source_l02362}{iirfilter()}}.



Referenced by \mbox{\hyperlink{test__filter__design_8py_source_l00247}{scipy.\+signal.\+tests.\+test\+\_\+filter\+\_\+design.\+Test\+Sos2\+Zpk.\+test\+\_\+fewer\+\_\+zeros()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_a91da99d4aea5955bfa7a499a8e815bf4}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!buttord@{buttord}}
\index{buttord@{buttord}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{buttord()}{buttord()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_a91da99d4aea5955bfa7a499a8e815bf4} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+buttord (\begin{DoxyParamCaption}\item[{}]{wp}{, }\item[{}]{ws}{, }\item[{}]{gpass}{, }\item[{}]{gstop}{, }\item[{}]{analog}{ = {\ttfamily False}, }\item[{}]{fs}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Butterworth filter order selection.

Return the order of the lowest order digital or analog Butterworth filter
that loses no more than `gpass` dB in the passband and has at least
`gstop` dB attenuation in the stopband.

Parameters
----------
wp, ws : float
    Passband and stopband edge frequencies.

    For digital filters, these are in the same units as `fs`. By default,
    `fs` is 2 half-cycles/sample, so these are normalized from 0 to 1,
    where 1 is the Nyquist frequency. (`wp` and `ws` are thus in
    half-cycles / sample.) For example:

        - Lowpass:   wp = 0.2,          ws = 0.3
        - Highpass:  wp = 0.3,          ws = 0.2
        - Bandpass:  wp = [0.2, 0.5],   ws = [0.1, 0.6]
        - Bandstop:  wp = [0.1, 0.6],   ws = [0.2, 0.5]

    For analog filters, `wp` and `ws` are angular frequencies (e.g., rad/s).
gpass : float
    The maximum loss in the passband (dB).
gstop : float
    The minimum attenuation in the stopband (dB).
analog : bool, optional
    When True, return an analog filter, otherwise a digital filter is
    returned.
fs : float, optional
    The sampling frequency of the digital system.

    .. versionadded:: 1.2.0

Returns
-------
ord : int
    The lowest order for a Butterworth filter which meets specs.
wn : ndarray or float
    The Butterworth natural frequency (i.e. the "3dB frequency"). Should
    be used with `butter` to give filter results. If `fs` is specified,
    this is in the same units, and `fs` must also be passed to `butter`.

See Also
--------
butter : Filter design using order and critical points
cheb1ord : Find order and critical points from passband and stopband spec
cheb2ord, ellipord
iirfilter : General filter design using order and critical frequencies
iirdesign : General filter design using passband and stopband spec

Examples
--------
Design an analog bandpass filter with passband within 3 dB from 20 to
50 rad/s, while rejecting at least -40 dB below 14 and above 60 rad/s.
Plot its frequency response, showing the passband and stopband
constraints in gray.

>>> from scipy import signal
>>> import matplotlib.pyplot as plt
>>> import numpy as np

>>> N, Wn = signal.buttord([20, 50], [14, 60], 3, 40, True)
>>> b, a = signal.butter(N, Wn, 'band', True)
>>> w, h = signal.freqs(b, a, np.logspace(1, 2, 500))
>>> plt.semilogx(w, 20 * np.log10(abs(h)))
>>> plt.title('Butterworth bandpass filter fit to constraints')
>>> plt.xlabel('Frequency [radians / second]')
>>> plt.ylabel('Amplitude [dB]')
>>> plt.grid(which='both', axis='both')
>>> plt.fill([1,  14,  14,   1], [-40, -40, 99, 99], '0.9', lw=0) # stop
>>> plt.fill([20, 20,  50,  50], [-99, -3, -3, -99], '0.9', lw=0) # pass
>>> plt.fill([60, 60, 1e9, 1e9], [99, -40, -40, 99], '0.9', lw=0) # stop
>>> plt.axis([10, 100, -60, 3])
>>> plt.show()
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l03690}{3690}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_a8bff6c7f370bc3d69ca665c99c72b991}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!cheb1ap@{cheb1ap}}
\index{cheb1ap@{cheb1ap}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{cheb1ap()}{cheb1ap()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_a8bff6c7f370bc3d69ca665c99c72b991} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+cheb1ap (\begin{DoxyParamCaption}\item[{}]{N}{, }\item[{}]{rp}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Return (z,p,k) for Nth-order Chebyshev type I analog lowpass filter.

The returned filter prototype has `rp` decibels of ripple in the passband.

The filter's angular (e.g. rad/s) cutoff frequency is normalized to 1,
defined as the point at which the gain first drops below ``-rp``.

See Also
--------
cheby1 : Filter design function using this prototype
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l04342}{4342}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_a7faa130bd1b19c1b14542e764b6fe3c8}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!cheb1ord@{cheb1ord}}
\index{cheb1ord@{cheb1ord}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{cheb1ord()}{cheb1ord()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_a7faa130bd1b19c1b14542e764b6fe3c8} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+cheb1ord (\begin{DoxyParamCaption}\item[{}]{wp}{, }\item[{}]{ws}{, }\item[{}]{gpass}{, }\item[{}]{gstop}{, }\item[{}]{analog}{ = {\ttfamily False}, }\item[{}]{fs}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Chebyshev type I filter order selection.

Return the order of the lowest order digital or analog Chebyshev Type I
filter that loses no more than `gpass` dB in the passband and has at
least `gstop` dB attenuation in the stopband.

Parameters
----------
wp, ws : float
    Passband and stopband edge frequencies.

    For digital filters, these are in the same units as `fs`. By default,
    `fs` is 2 half-cycles/sample, so these are normalized from 0 to 1,
    where 1 is the Nyquist frequency. (`wp` and `ws` are thus in
    half-cycles / sample.)  For example:

        - Lowpass:   wp = 0.2,          ws = 0.3
        - Highpass:  wp = 0.3,          ws = 0.2
        - Bandpass:  wp = [0.2, 0.5],   ws = [0.1, 0.6]
        - Bandstop:  wp = [0.1, 0.6],   ws = [0.2, 0.5]

    For analog filters, `wp` and `ws` are angular frequencies (e.g., rad/s).
gpass : float
    The maximum loss in the passband (dB).
gstop : float
    The minimum attenuation in the stopband (dB).
analog : bool, optional
    When True, return an analog filter, otherwise a digital filter is
    returned.
fs : float, optional
    The sampling frequency of the digital system.

    .. versionadded:: 1.2.0

Returns
-------
ord : int
    The lowest order for a Chebyshev type I filter that meets specs.
wn : ndarray or float
    The Chebyshev natural frequency (the "3dB frequency") for use with
    `cheby1` to give filter results. If `fs` is specified,
    this is in the same units, and `fs` must also be passed to `cheby1`.

See Also
--------
cheby1 : Filter design using order and critical points
buttord : Find order and critical points from passband and stopband spec
cheb2ord, ellipord
iirfilter : General filter design using order and critical frequencies
iirdesign : General filter design using passband and stopband spec

Examples
--------
Design a digital lowpass filter such that the passband is within 3 dB up
to 0.2*(fs/2), while rejecting at least -40 dB above 0.3*(fs/2). Plot its
frequency response, showing the passband and stopband constraints in gray.

>>> from scipy import signal
>>> import matplotlib.pyplot as plt
>>> import numpy as np

>>> N, Wn = signal.cheb1ord(0.2, 0.3, 3, 40)
>>> b, a = signal.cheby1(N, 3, Wn, 'low')
>>> w, h = signal.freqz(b, a)
>>> plt.semilogx(w / np.pi, 20 * np.log10(abs(h)))
>>> plt.title('Chebyshev I lowpass filter fit to constraints')
>>> plt.xlabel('Normalized frequency')
>>> plt.ylabel('Amplitude [dB]')
>>> plt.grid(which='both', axis='both')
>>> plt.fill([.01, 0.2, 0.2, .01], [-3, -3, -99, -99], '0.9', lw=0) # stop
>>> plt.fill([0.3, 0.3,   2,   2], [ 9, -40, -40,  9], '0.9', lw=0) # pass
>>> plt.axis([0.08, 1, -60, 3])
>>> plt.show()
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l03865}{3865}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_a85604d994461d93b66688f46e2274e01}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!cheb2ap@{cheb2ap}}
\index{cheb2ap@{cheb2ap}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{cheb2ap()}{cheb2ap()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_a85604d994461d93b66688f46e2274e01} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+cheb2ap (\begin{DoxyParamCaption}\item[{}]{N}{, }\item[{}]{rs}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Return (z,p,k) for Nth-order Chebyshev type I analog lowpass filter.

The returned filter prototype has `rs` decibels of ripple in the stopband.

The filter's angular (e.g. rad/s) cutoff frequency is normalized to 1,
defined as the point at which the gain first reaches ``-rs``.

See Also
--------
cheby2 : Filter design function using this prototype
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l04380}{4380}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_afa28a525115653cfbb7fa47769345631}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!cheb2ord@{cheb2ord}}
\index{cheb2ord@{cheb2ord}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{cheb2ord()}{cheb2ord()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_afa28a525115653cfbb7fa47769345631} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+cheb2ord (\begin{DoxyParamCaption}\item[{}]{wp}{, }\item[{}]{ws}{, }\item[{}]{gpass}{, }\item[{}]{gstop}{, }\item[{}]{analog}{ = {\ttfamily False}, }\item[{}]{fs}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Chebyshev type II filter order selection.

Return the order of the lowest order digital or analog Chebyshev Type II
filter that loses no more than `gpass` dB in the passband and has at least
`gstop` dB attenuation in the stopband.

Parameters
----------
wp, ws : float
    Passband and stopband edge frequencies.

    For digital filters, these are in the same units as `fs`. By default,
    `fs` is 2 half-cycles/sample, so these are normalized from 0 to 1,
    where 1 is the Nyquist frequency. (`wp` and `ws` are thus in
    half-cycles / sample.)  For example:

        - Lowpass:   wp = 0.2,          ws = 0.3
        - Highpass:  wp = 0.3,          ws = 0.2
        - Bandpass:  wp = [0.2, 0.5],   ws = [0.1, 0.6]
        - Bandstop:  wp = [0.1, 0.6],   ws = [0.2, 0.5]

    For analog filters, `wp` and `ws` are angular frequencies (e.g., rad/s).
gpass : float
    The maximum loss in the passband (dB).
gstop : float
    The minimum attenuation in the stopband (dB).
analog : bool, optional
    When True, return an analog filter, otherwise a digital filter is
    returned.
fs : float, optional
    The sampling frequency of the digital system.

    .. versionadded:: 1.2.0

Returns
-------
ord : int
    The lowest order for a Chebyshev type II filter that meets specs.
wn : ndarray or float
    The Chebyshev natural frequency (the "3dB frequency") for use with
    `cheby2` to give filter results. If `fs` is specified,
    this is in the same units, and `fs` must also be passed to `cheby2`.

See Also
--------
cheby2 : Filter design using order and critical points
buttord : Find order and critical points from passband and stopband spec
cheb1ord, ellipord
iirfilter : General filter design using order and critical frequencies
iirdesign : General filter design using passband and stopband spec

Examples
--------
Design a digital bandstop filter which rejects -60 dB from 0.2*(fs/2) to
0.5*(fs/2), while staying within 3 dB below 0.1*(fs/2) or above
0.6*(fs/2). Plot its frequency response, showing the passband and
stopband constraints in gray.

>>> from scipy import signal
>>> import matplotlib.pyplot as plt
>>> import numpy as np

>>> N, Wn = signal.cheb2ord([0.1, 0.6], [0.2, 0.5], 3, 60)
>>> b, a = signal.cheby2(N, 60, Wn, 'stop')
>>> w, h = signal.freqz(b, a)
>>> plt.semilogx(w / np.pi, 20 * np.log10(abs(h)))
>>> plt.title('Chebyshev II bandstop filter fit to constraints')
>>> plt.xlabel('Normalized frequency')
>>> plt.ylabel('Amplitude [dB]')
>>> plt.grid(which='both', axis='both')
>>> plt.fill([.01, .1, .1, .01], [-3,  -3, -99, -99], '0.9', lw=0) # stop
>>> plt.fill([.2,  .2, .5,  .5], [ 9, -60, -60,   9], '0.9', lw=0) # pass
>>> plt.fill([.6,  .6,  2,   2], [-99, -3,  -3, -99], '0.9', lw=0) # stop
>>> plt.axis([0.06, 1, -80, 3])
>>> plt.show()
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l04007}{4007}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_a0e77ed88eb55f4b49a99f4d8844e61b7}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!cheby1@{cheby1}}
\index{cheby1@{cheby1}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{cheby1()}{cheby1()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_a0e77ed88eb55f4b49a99f4d8844e61b7} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+cheby1 (\begin{DoxyParamCaption}\item[{}]{N}{, }\item[{}]{rp}{, }\item[{}]{Wn}{, }\item[{}]{btype}{ = {\ttfamily \textquotesingle{}low\textquotesingle{}}, }\item[{}]{analog}{ = {\ttfamily False}, }\item[{}]{output}{ = {\ttfamily \textquotesingle{}ba\textquotesingle{}}, }\item[{}]{fs}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Chebyshev type I digital and analog filter design.

Design an Nth-order digital or analog Chebyshev type I filter and
return the filter coefficients.

Parameters
----------
N : int
    The order of the filter.
rp : float
    The maximum ripple allowed below unity gain in the passband.
    Specified in decibels, as a positive number.
Wn : array_like
    A scalar or length-2 sequence giving the critical frequencies.
    For Type I filters, this is the point in the transition band at which
    the gain first drops below -`rp`.

    For digital filters, `Wn` are in the same units as `fs`. By default,
    `fs` is 2 half-cycles/sample, so these are normalized from 0 to 1,
    where 1 is the Nyquist frequency. (`Wn` is thus in
    half-cycles / sample.)

    For analog filters, `Wn` is an angular frequency (e.g., rad/s).
btype : {'lowpass', 'highpass', 'bandpass', 'bandstop'}, optional
    The type of filter.  Default is 'lowpass'.
analog : bool, optional
    When True, return an analog filter, otherwise a digital filter is
    returned.
output : {'ba', 'zpk', 'sos'}, optional
    Type of output:  numerator/denominator ('ba'), pole-zero ('zpk'), or
    second-order sections ('sos'). Default is 'ba' for backwards
    compatibility, but 'sos' should be used for general-purpose filtering.
fs : float, optional
    The sampling frequency of the digital system.

    .. versionadded:: 1.2.0

Returns
-------
b, a : ndarray, ndarray
    Numerator (`b`) and denominator (`a`) polynomials of the IIR filter.
    Only returned if ``output='ba'``.
z, p, k : ndarray, ndarray, float
    Zeros, poles, and system gain of the IIR filter transfer
    function.  Only returned if ``output='zpk'``.
sos : ndarray
    Second-order sections representation of the IIR filter.
    Only returned if ``output='sos'``.

See Also
--------
cheb1ord, cheb1ap

Notes
-----
The Chebyshev type I filter maximizes the rate of cutoff between the
frequency response's passband and stopband, at the expense of ripple in
the passband and increased ringing in the step response.

Type I filters roll off faster than Type II (`cheby2`), but Type II
filters do not have any ripple in the passband.

The equiripple passband has N maxima or minima (for example, a
5th-order filter has 3 maxima and 2 minima). Consequently, the DC gain is
unity for odd-order filters, or -rp dB for even-order filters.

The ``'sos'`` output parameter was added in 0.16.0.

Examples
--------
Design an analog filter and plot its frequency response, showing the
critical points:

>>> from scipy import signal
>>> import matplotlib.pyplot as plt
>>> import numpy as np

>>> b, a = signal.cheby1(4, 5, 100, 'low', analog=True)
>>> w, h = signal.freqs(b, a)
>>> plt.semilogx(w, 20 * np.log10(abs(h)))
>>> plt.title('Chebyshev Type I frequency response (rp=5)')
>>> plt.xlabel('Frequency [radians / second]')
>>> plt.ylabel('Amplitude [dB]')
>>> plt.margins(0, 0.1)
>>> plt.grid(which='both', axis='both')
>>> plt.axvline(100, color='green') # cutoff frequency
>>> plt.axhline(-5, color='green') # rp
>>> plt.show()

Generate a signal made up of 10 Hz and 20 Hz, sampled at 1 kHz

>>> t = np.linspace(0, 1, 1000, False)  # 1 second
>>> sig = np.sin(2*np.pi*10*t) + np.sin(2*np.pi*20*t)
>>> fig, (ax1, ax2) = plt.subplots(2, 1, sharex=True)
>>> ax1.plot(t, sig)
>>> ax1.set_title('10 Hz and 20 Hz sinusoids')
>>> ax1.axis([0, 1, -2, 2])

Design a digital high-pass filter at 15 Hz to remove the 10 Hz tone, and
apply it to the signal. (It's recommended to use second-order sections
format when filtering, to avoid numerical error with transfer function
(``ba``) format):

>>> sos = signal.cheby1(10, 1, 15, 'hp', fs=1000, output='sos')
>>> filtered = signal.sosfilt(sos, sig)
>>> ax2.plot(t, filtered)
>>> ax2.set_title('After 15 Hz high-pass filter')
>>> ax2.axis([0, 1, -2, 2])
>>> ax2.set_xlabel('Time [seconds]')
>>> plt.tight_layout()
>>> plt.show()
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l03105}{3105}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.



References \mbox{\hyperlink{__filter__design_8py_source_l02362}{iirfilter()}}.



Referenced by \mbox{\hyperlink{__signaltools_8py_source_l04458}{scipy.\+signal.\+\_\+signaltools.\+decimate()}}, and \mbox{\hyperlink{test__filter__design_8py_source_l01109}{scipy.\+signal.\+tests.\+test\+\_\+filter\+\_\+design.\+Test\+Freqz\+\_\+zpk.\+test\+\_\+ticket1441()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_a7ded91bfef2a44d329c94a19f884a2e9}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!cheby2@{cheby2}}
\index{cheby2@{cheby2}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{cheby2()}{cheby2()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_a7ded91bfef2a44d329c94a19f884a2e9} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+cheby2 (\begin{DoxyParamCaption}\item[{}]{N}{, }\item[{}]{rs}{, }\item[{}]{Wn}{, }\item[{}]{btype}{ = {\ttfamily \textquotesingle{}low\textquotesingle{}}, }\item[{}]{analog}{ = {\ttfamily False}, }\item[{}]{output}{ = {\ttfamily \textquotesingle{}ba\textquotesingle{}}, }\item[{}]{fs}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Chebyshev type II digital and analog filter design.

Design an Nth-order digital or analog Chebyshev type II filter and
return the filter coefficients.

Parameters
----------
N : int
    The order of the filter.
rs : float
    The minimum attenuation required in the stop band.
    Specified in decibels, as a positive number.
Wn : array_like
    A scalar or length-2 sequence giving the critical frequencies.
    For Type II filters, this is the point in the transition band at which
    the gain first reaches -`rs`.

    For digital filters, `Wn` are in the same units as `fs`. By default,
    `fs` is 2 half-cycles/sample, so these are normalized from 0 to 1,
    where 1 is the Nyquist frequency. (`Wn` is thus in
    half-cycles / sample.)

    For analog filters, `Wn` is an angular frequency (e.g., rad/s).
btype : {'lowpass', 'highpass', 'bandpass', 'bandstop'}, optional
    The type of filter.  Default is 'lowpass'.
analog : bool, optional
    When True, return an analog filter, otherwise a digital filter is
    returned.
output : {'ba', 'zpk', 'sos'}, optional
    Type of output:  numerator/denominator ('ba'), pole-zero ('zpk'), or
    second-order sections ('sos'). Default is 'ba' for backwards
    compatibility, but 'sos' should be used for general-purpose filtering.
fs : float, optional
    The sampling frequency of the digital system.

    .. versionadded:: 1.2.0

Returns
-------
b, a : ndarray, ndarray
    Numerator (`b`) and denominator (`a`) polynomials of the IIR filter.
    Only returned if ``output='ba'``.
z, p, k : ndarray, ndarray, float
    Zeros, poles, and system gain of the IIR filter transfer
    function.  Only returned if ``output='zpk'``.
sos : ndarray
    Second-order sections representation of the IIR filter.
    Only returned if ``output='sos'``.

See Also
--------
cheb2ord, cheb2ap

Notes
-----
The Chebyshev type II filter maximizes the rate of cutoff between the
frequency response's passband and stopband, at the expense of ripple in
the stopband and increased ringing in the step response.

Type II filters do not roll off as fast as Type I (`cheby1`).

The ``'sos'`` output parameter was added in 0.16.0.

Examples
--------
Design an analog filter and plot its frequency response, showing the
critical points:

>>> from scipy import signal
>>> import matplotlib.pyplot as plt
>>> import numpy as np

>>> b, a = signal.cheby2(4, 40, 100, 'low', analog=True)
>>> w, h = signal.freqs(b, a)
>>> plt.semilogx(w, 20 * np.log10(abs(h)))
>>> plt.title('Chebyshev Type II frequency response (rs=40)')
>>> plt.xlabel('Frequency [radians / second]')
>>> plt.ylabel('Amplitude [dB]')
>>> plt.margins(0, 0.1)
>>> plt.grid(which='both', axis='both')
>>> plt.axvline(100, color='green') # cutoff frequency
>>> plt.axhline(-40, color='green') # rs
>>> plt.show()

Generate a signal made up of 10 Hz and 20 Hz, sampled at 1 kHz

>>> t = np.linspace(0, 1, 1000, False)  # 1 second
>>> sig = np.sin(2*np.pi*10*t) + np.sin(2*np.pi*20*t)
>>> fig, (ax1, ax2) = plt.subplots(2, 1, sharex=True)
>>> ax1.plot(t, sig)
>>> ax1.set_title('10 Hz and 20 Hz sinusoids')
>>> ax1.axis([0, 1, -2, 2])

Design a digital high-pass filter at 17 Hz to remove the 10 Hz tone, and
apply it to the signal. (It's recommended to use second-order sections
format when filtering, to avoid numerical error with transfer function
(``ba``) format):

>>> sos = signal.cheby2(12, 20, 17, 'hp', fs=1000, output='sos')
>>> filtered = signal.sosfilt(sos, sig)
>>> ax2.plot(t, filtered)
>>> ax2.set_title('After 17 Hz high-pass filter')
>>> ax2.axis([0, 1, -2, 2])
>>> ax2.set_xlabel('Time [seconds]')
>>> plt.show()
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l03223}{3223}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.



References \mbox{\hyperlink{__filter__design_8py_source_l02362}{iirfilter()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_a61a842f3ea1494216b2d32708a8ae665}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!ellip@{ellip}}
\index{ellip@{ellip}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{ellip()}{ellip()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_a61a842f3ea1494216b2d32708a8ae665} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+ellip (\begin{DoxyParamCaption}\item[{}]{N}{, }\item[{}]{rp}{, }\item[{}]{rs}{, }\item[{}]{Wn}{, }\item[{}]{btype}{ = {\ttfamily \textquotesingle{}low\textquotesingle{}}, }\item[{}]{analog}{ = {\ttfamily False}, }\item[{}]{output}{ = {\ttfamily \textquotesingle{}ba\textquotesingle{}}, }\item[{}]{fs}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Elliptic (Cauer) digital and analog filter design.

Design an Nth-order digital or analog elliptic filter and return
the filter coefficients.

Parameters
----------
N : int
    The order of the filter.
rp : float
    The maximum ripple allowed below unity gain in the passband.
    Specified in decibels, as a positive number.
rs : float
    The minimum attenuation required in the stop band.
    Specified in decibels, as a positive number.
Wn : array_like
    A scalar or length-2 sequence giving the critical frequencies.
    For elliptic filters, this is the point in the transition band at
    which the gain first drops below -`rp`.

    For digital filters, `Wn` are in the same units as `fs`. By default,
    `fs` is 2 half-cycles/sample, so these are normalized from 0 to 1,
    where 1 is the Nyquist frequency. (`Wn` is thus in
    half-cycles / sample.)

    For analog filters, `Wn` is an angular frequency (e.g., rad/s).
btype : {'lowpass', 'highpass', 'bandpass', 'bandstop'}, optional
    The type of filter. Default is 'lowpass'.
analog : bool, optional
    When True, return an analog filter, otherwise a digital filter is
    returned.
output : {'ba', 'zpk', 'sos'}, optional
    Type of output:  numerator/denominator ('ba'), pole-zero ('zpk'), or
    second-order sections ('sos'). Default is 'ba' for backwards
    compatibility, but 'sos' should be used for general-purpose filtering.
fs : float, optional
    The sampling frequency of the digital system.

    .. versionadded:: 1.2.0

Returns
-------
b, a : ndarray, ndarray
    Numerator (`b`) and denominator (`a`) polynomials of the IIR filter.
    Only returned if ``output='ba'``.
z, p, k : ndarray, ndarray, float
    Zeros, poles, and system gain of the IIR filter transfer
    function.  Only returned if ``output='zpk'``.
sos : ndarray
    Second-order sections representation of the IIR filter.
    Only returned if ``output='sos'``.

See Also
--------
ellipord, ellipap

Notes
-----
Also known as Cauer or Zolotarev filters, the elliptical filter maximizes
the rate of transition between the frequency response's passband and
stopband, at the expense of ripple in both, and increased ringing in the
step response.

As `rp` approaches 0, the elliptical filter becomes a Chebyshev
type II filter (`cheby2`). As `rs` approaches 0, it becomes a Chebyshev
type I filter (`cheby1`). As both approach 0, it becomes a Butterworth
filter (`butter`).

The equiripple passband has N maxima or minima (for example, a
5th-order filter has 3 maxima and 2 minima). Consequently, the DC gain is
unity for odd-order filters, or -rp dB for even-order filters.

The ``'sos'`` output parameter was added in 0.16.0.

Examples
--------
Design an analog filter and plot its frequency response, showing the
critical points:

>>> from scipy import signal
>>> import matplotlib.pyplot as plt
>>> import numpy as np

>>> b, a = signal.ellip(4, 5, 40, 100, 'low', analog=True)
>>> w, h = signal.freqs(b, a)
>>> plt.semilogx(w, 20 * np.log10(abs(h)))
>>> plt.title('Elliptic filter frequency response (rp=5, rs=40)')
>>> plt.xlabel('Frequency [radians / second]')
>>> plt.ylabel('Amplitude [dB]')
>>> plt.margins(0, 0.1)
>>> plt.grid(which='both', axis='both')
>>> plt.axvline(100, color='green') # cutoff frequency
>>> plt.axhline(-40, color='green') # rs
>>> plt.axhline(-5, color='green') # rp
>>> plt.show()

Generate a signal made up of 10 Hz and 20 Hz, sampled at 1 kHz

>>> t = np.linspace(0, 1, 1000, False)  # 1 second
>>> sig = np.sin(2*np.pi*10*t) + np.sin(2*np.pi*20*t)
>>> fig, (ax1, ax2) = plt.subplots(2, 1, sharex=True)
>>> ax1.plot(t, sig)
>>> ax1.set_title('10 Hz and 20 Hz sinusoids')
>>> ax1.axis([0, 1, -2, 2])

Design a digital high-pass filter at 17 Hz to remove the 10 Hz tone, and
apply it to the signal. (It's recommended to use second-order sections
format when filtering, to avoid numerical error with transfer function
(``ba``) format):

>>> sos = signal.ellip(8, 1, 100, 17, 'hp', fs=1000, output='sos')
>>> filtered = signal.sosfilt(sos, sig)
>>> ax2.plot(t, filtered)
>>> ax2.set_title('After 17 Hz high-pass filter')
>>> ax2.axis([0, 1, -2, 2])
>>> ax2.set_xlabel('Time [seconds]')
>>> plt.tight_layout()
>>> plt.show()
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l03335}{3335}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.



References \mbox{\hyperlink{__filter__design_8py_source_l02362}{iirfilter()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_a23f21ad85d8274746e8029345a2d6dd2}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!ellipap@{ellipap}}
\index{ellipap@{ellipap}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{ellipap()}{ellipap()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_a23f21ad85d8274746e8029345a2d6dd2} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+ellipap (\begin{DoxyParamCaption}\item[{}]{N}{, }\item[{}]{rp}{, }\item[{}]{rs}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Return (z,p,k) of Nth-order elliptic analog lowpass filter.

The filter is a normalized prototype that has `rp` decibels of ripple
in the passband and a stopband `rs` decibels down.

The filter's angular (e.g., rad/s) cutoff frequency is normalized to 1,
defined as the point at which the gain first drops below ``-rp``.

See Also
--------
ellip : Filter design function using this prototype

References
----------
.. [1] Lutova, Tosic, and Evans, "Filter Design for Signal Processing",
       Chapters 5 and 12.

.. [2] Orfanidis, "Lecture Notes on Elliptic Filter Design",
       https://www.ece.rutgers.edu/~orfanidi/ece521/notes.pdf
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l04550}{4550}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.



References \mbox{\hyperlink{__filter__design_8py_source_l04524}{\+\_\+arc\+\_\+jac\+\_\+sc1()}}, \mbox{\hyperlink{__filter__design_8py_source_l04428}{\+\_\+ellipdeg()}}, and \mbox{\hyperlink{__filter__design_8py_source_l04176}{\+\_\+pow10m1()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_a6ef9f4f8f06e8223d397899d35ee6772}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!ellipord@{ellipord}}
\index{ellipord@{ellipord}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{ellipord()}{ellipord()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_a6ef9f4f8f06e8223d397899d35ee6772} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+ellipord (\begin{DoxyParamCaption}\item[{}]{wp}{, }\item[{}]{ws}{, }\item[{}]{gpass}{, }\item[{}]{gstop}{, }\item[{}]{analog}{ = {\ttfamily False}, }\item[{}]{fs}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Elliptic (Cauer) filter order selection.

Return the order of the lowest order digital or analog elliptic filter
that loses no more than `gpass` dB in the passband and has at least
`gstop` dB attenuation in the stopband.

Parameters
----------
wp, ws : float
    Passband and stopband edge frequencies.

    For digital filters, these are in the same units as `fs`. By default,
    `fs` is 2 half-cycles/sample, so these are normalized from 0 to 1,
    where 1 is the Nyquist frequency. (`wp` and `ws` are thus in
    half-cycles / sample.) For example:

        - Lowpass:   wp = 0.2,          ws = 0.3
        - Highpass:  wp = 0.3,          ws = 0.2
        - Bandpass:  wp = [0.2, 0.5],   ws = [0.1, 0.6]
        - Bandstop:  wp = [0.1, 0.6],   ws = [0.2, 0.5]

    For analog filters, `wp` and `ws` are angular frequencies (e.g., rad/s).
gpass : float
    The maximum loss in the passband (dB).
gstop : float
    The minimum attenuation in the stopband (dB).
analog : bool, optional
    When True, return an analog filter, otherwise a digital filter is
    returned.
fs : float, optional
    The sampling frequency of the digital system.

    .. versionadded:: 1.2.0

Returns
-------
ord : int
    The lowest order for an Elliptic (Cauer) filter that meets specs.
wn : ndarray or float
    The Chebyshev natural frequency (the "3dB frequency") for use with
    `ellip` to give filter results. If `fs` is specified,
    this is in the same units, and `fs` must also be passed to `ellip`.

See Also
--------
ellip : Filter design using order and critical points
buttord : Find order and critical points from passband and stopband spec
cheb1ord, cheb2ord
iirfilter : General filter design using order and critical frequencies
iirdesign : General filter design using passband and stopband spec

Examples
--------
Design an analog highpass filter such that the passband is within 3 dB
above 30 rad/s, while rejecting -60 dB at 10 rad/s. Plot its
frequency response, showing the passband and stopband constraints in gray.

>>> from scipy import signal
>>> import matplotlib.pyplot as plt
>>> import numpy as np

>>> N, Wn = signal.ellipord(30, 10, 3, 60, True)
>>> b, a = signal.ellip(N, 3, 60, Wn, 'high', True)
>>> w, h = signal.freqs(b, a, np.logspace(0, 3, 500))
>>> plt.semilogx(w, 20 * np.log10(abs(h)))
>>> plt.title('Elliptical highpass filter fit to constraints')
>>> plt.xlabel('Frequency [radians / second]')
>>> plt.ylabel('Amplitude [dB]')
>>> plt.grid(which='both', axis='both')
>>> plt.fill([.1, 10,  10,  .1], [1e4, 1e4, -60, -60], '0.9', lw=0) # stop
>>> plt.fill([30, 30, 1e9, 1e9], [-99,  -3,  -3, -99], '0.9', lw=0) # pass
>>> plt.axis([1, 300, -80, 3])
>>> plt.show()
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l04181}{4181}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.



References \mbox{\hyperlink{__filter__design_8py_source_l04176}{\+\_\+pow10m1()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_a121c7e536c227088450930f0b93805ad}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!findfreqs@{findfreqs}}
\index{findfreqs@{findfreqs}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{findfreqs()}{findfreqs()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_a121c7e536c227088450930f0b93805ad} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+findfreqs (\begin{DoxyParamCaption}\item[{}]{num}{, }\item[{}]{den}{, }\item[{}]{N}{, }\item[{}]{kind}{ = {\ttfamily \textquotesingle{}ba\textquotesingle{}}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Find array of frequencies for computing the response of an analog filter.

Parameters
----------
num, den : array_like, 1-D
    The polynomial coefficients of the numerator and denominator of the
    transfer function of the filter or LTI system, where the coefficients
    are ordered from highest to lowest degree. Or, the roots  of the
    transfer function numerator and denominator (i.e., zeroes and poles).
N : int
    The length of the array to be computed.
kind : str {'ba', 'zp'}, optional
    Specifies whether the numerator and denominator are specified by their
    polynomial coefficients ('ba'), or their roots ('zp').

Returns
-------
w : (N,) ndarray
    A 1-D array of frequencies, logarithmically spaced.

Examples
--------
Find a set of nine frequencies that span the "interesting part" of the
frequency response for the filter with the transfer function

    H(s) = s / (s^2 + 8s + 25)

>>> from scipy import signal
>>> signal.findfreqs([1, 0], [1, 8, 25], N=9)
array([  1.00000000e-02,   3.16227766e-02,   1.00000000e-01,
         3.16227766e-01,   1.00000000e+00,   3.16227766e+00,
         1.00000000e+01,   3.16227766e+01,   1.00000000e+02])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l00058}{58}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.



Referenced by \mbox{\hyperlink{__filter__design_8py_source_l00119}{freqs()}}, and \mbox{\hyperlink{__filter__design_8py_source_l00196}{freqs\+\_\+zpk()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_a9575c4eb7f36f5e534309051f96a8bb7}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!freqs@{freqs}}
\index{freqs@{freqs}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{freqs()}{freqs()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_a9575c4eb7f36f5e534309051f96a8bb7} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+freqs (\begin{DoxyParamCaption}\item[{}]{b}{, }\item[{}]{a}{, }\item[{}]{worN}{ = {\ttfamily 200}, }\item[{}]{plot}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute frequency response of analog filter.

Given the M-order numerator `b` and N-order denominator `a` of an analog
filter, compute its frequency response::

         b[0]*(jw)**M + b[1]*(jw)**(M-1) + ... + b[M]
 H(w) = ----------------------------------------------
         a[0]*(jw)**N + a[1]*(jw)**(N-1) + ... + a[N]

Parameters
----------
b : array_like
    Numerator of a linear filter.
a : array_like
    Denominator of a linear filter.
worN : {None, int, array_like}, optional
    If None, then compute at 200 frequencies around the interesting parts
    of the response curve (determined by pole-zero locations). If a single
    integer, then compute at that many frequencies. Otherwise, compute the
    response at the angular frequencies (e.g., rad/s) given in `worN`.
plot : callable, optional
    A callable that takes two arguments. If given, the return parameters
    `w` and `h` are passed to plot. Useful for plotting the frequency
    response inside `freqs`.

Returns
-------
w : ndarray
    The angular frequencies at which `h` was computed.
h : ndarray
    The frequency response.

See Also
--------
freqz : Compute the frequency response of a digital filter.

Notes
-----
Using Matplotlib's "plot" function as the callable for `plot` produces
unexpected results, this plots the real part of the complex transfer
function, not the magnitude. Try ``lambda w, h: plot(w, abs(h))``.

Examples
--------
>>> from scipy.signal import freqs, iirfilter
>>> import numpy as np

>>> b, a = iirfilter(4, [1, 10], 1, 60, analog=True, ftype='cheby1')

>>> w, h = freqs(b, a, worN=np.logspace(-1, 2, 1000))

>>> import matplotlib.pyplot as plt
>>> plt.semilogx(w, 20 * np.log10(abs(h)))
>>> plt.xlabel('Frequency')
>>> plt.ylabel('Amplitude response [dB]')
>>> plt.grid(True)
>>> plt.show()
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l00119}{119}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.



References \mbox{\hyperlink{__filter__design_8py_source_l00041}{\+\_\+is\+\_\+int\+\_\+type()}}, and \mbox{\hyperlink{__filter__design_8py_source_l00058}{findfreqs()}}.



Referenced by \mbox{\hyperlink{__ltisys_8py_source_l02632}{scipy.\+signal.\+\_\+ltisys.\+freqresp()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_a8d1dbc48cfac5f3492922f226c4cd817}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!freqs\_zpk@{freqs\_zpk}}
\index{freqs\_zpk@{freqs\_zpk}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{freqs\_zpk()}{freqs\_zpk()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_a8d1dbc48cfac5f3492922f226c4cd817} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+freqs\+\_\+zpk (\begin{DoxyParamCaption}\item[{}]{z}{, }\item[{}]{p}{, }\item[{}]{k}{, }\item[{}]{worN}{ = {\ttfamily 200}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute frequency response of analog filter.

Given the zeros `z`, poles `p`, and gain `k` of a filter, compute its
frequency response::

            (jw-z[0]) * (jw-z[1]) * ... * (jw-z[-1])
 H(w) = k * ----------------------------------------
            (jw-p[0]) * (jw-p[1]) * ... * (jw-p[-1])

Parameters
----------
z : array_like
    Zeroes of a linear filter
p : array_like
    Poles of a linear filter
k : scalar
    Gain of a linear filter
worN : {None, int, array_like}, optional
    If None, then compute at 200 frequencies around the interesting parts
    of the response curve (determined by pole-zero locations). If a single
    integer, then compute at that many frequencies. Otherwise, compute the
    response at the angular frequencies (e.g., rad/s) given in `worN`.

Returns
-------
w : ndarray
    The angular frequencies at which `h` was computed.
h : ndarray
    The frequency response.

See Also
--------
freqs : Compute the frequency response of an analog filter in TF form
freqz : Compute the frequency response of a digital filter in TF form
freqz_zpk : Compute the frequency response of a digital filter in ZPK form

Notes
-----
.. versionadded:: 0.19.0

Examples
--------
>>> import numpy as np
>>> from scipy.signal import freqs_zpk, iirfilter

>>> z, p, k = iirfilter(4, [1, 10], 1, 60, analog=True, ftype='cheby1',
...                     output='zpk')

>>> w, h = freqs_zpk(z, p, k, worN=np.logspace(-1, 2, 1000))

>>> import matplotlib.pyplot as plt
>>> plt.semilogx(w, 20 * np.log10(abs(h)))
>>> plt.xlabel('Frequency')
>>> plt.ylabel('Amplitude response [dB]')
>>> plt.grid(True)
>>> plt.show()
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l00196}{196}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.



References \mbox{\hyperlink{__filter__design_8py_source_l00041}{\+\_\+is\+\_\+int\+\_\+type()}}, and \mbox{\hyperlink{__filter__design_8py_source_l00058}{findfreqs()}}.



Referenced by \mbox{\hyperlink{__ltisys_8py_source_l02632}{scipy.\+signal.\+\_\+ltisys.\+freqresp()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_a57ecfa32b9c147c7075a33d24edd5c74}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!freqz@{freqz}}
\index{freqz@{freqz}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{freqz()}{freqz()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_a57ecfa32b9c147c7075a33d24edd5c74} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+freqz (\begin{DoxyParamCaption}\item[{}]{b}{, }\item[{}]{a}{ = {\ttfamily 1}, }\item[{}]{worN}{ = {\ttfamily 512}, }\item[{}]{whole}{ = {\ttfamily False}, }\item[{}]{plot}{ = {\ttfamily None}, }\item[{}]{fs}{ = {\ttfamily 2\texorpdfstring{$\ast$}{*}pi}, }\item[{}]{include\+\_\+nyquist}{ = {\ttfamily False}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute the frequency response of a digital filter.

Given the M-order numerator `b` and N-order denominator `a` of a digital
filter, compute its frequency response::

             jw                 -jw              -jwM
    jw    B(e  )    b[0] + b[1]e    + ... + b[M]e
 H(e  ) = ------ = -----------------------------------
             jw                 -jw              -jwN
          A(e  )    a[0] + a[1]e    + ... + a[N]e

Parameters
----------
b : array_like
    Numerator of a linear filter. If `b` has dimension greater than 1,
    it is assumed that the coefficients are stored in the first dimension,
    and ``b.shape[1:]``, ``a.shape[1:]``, and the shape of the frequencies
    array must be compatible for broadcasting.
a : array_like
    Denominator of a linear filter. If `b` has dimension greater than 1,
    it is assumed that the coefficients are stored in the first dimension,
    and ``b.shape[1:]``, ``a.shape[1:]``, and the shape of the frequencies
    array must be compatible for broadcasting.
worN : {None, int, array_like}, optional
    If a single integer, then compute at that many frequencies (default is
    N=512). This is a convenient alternative to::

        np.linspace(0, fs if whole else fs/2, N, endpoint=include_nyquist)

    Using a number that is fast for FFT computations can result in
    faster computations (see Notes).

    If an array_like, compute the response at the frequencies given.
    These are in the same units as `fs`.
whole : bool, optional
    Normally, frequencies are computed from 0 to the Nyquist frequency,
    fs/2 (upper-half of unit-circle). If `whole` is True, compute
    frequencies from 0 to fs. Ignored if worN is array_like.
plot : callable
    A callable that takes two arguments. If given, the return parameters
    `w` and `h` are passed to plot. Useful for plotting the frequency
    response inside `freqz`.
fs : float, optional
    The sampling frequency of the digital system. Defaults to 2*pi
    radians/sample (so w is from 0 to pi).

    .. versionadded:: 1.2.0
include_nyquist : bool, optional
    If `whole` is False and `worN` is an integer, setting `include_nyquist`
    to True will include the last frequency (Nyquist frequency) and is
    otherwise ignored.

    .. versionadded:: 1.5.0

Returns
-------
w : ndarray
    The frequencies at which `h` was computed, in the same units as `fs`.
    By default, `w` is normalized to the range [0, pi) (radians/sample).
h : ndarray
    The frequency response, as complex numbers.

See Also
--------
freqz_zpk
sosfreqz

Notes
-----
Using Matplotlib's :func:`matplotlib.pyplot.plot` function as the callable
for `plot` produces unexpected results, as this plots the real part of the
complex transfer function, not the magnitude.
Try ``lambda w, h: plot(w, np.abs(h))``.

A direct computation via (R)FFT is used to compute the frequency response
when the following conditions are met:

1. An integer value is given for `worN`.
2. `worN` is fast to compute via FFT (i.e.,
   `next_fast_len(worN) <scipy.fft.next_fast_len>` equals `worN`).
3. The denominator coefficients are a single value (``a.shape[0] == 1``).
4. `worN` is at least as long as the numerator coefficients
   (``worN >= b.shape[0]``).
5. If ``b.ndim > 1``, then ``b.shape[-1] == 1``.

For long FIR filters, the FFT approach can have lower error and be much
faster than the equivalent direct polynomial calculation.

Examples
--------
>>> from scipy import signal
>>> import numpy as np
>>> b = signal.firwin(80, 0.5, window=('kaiser', 8))
>>> w, h = signal.freqz(b)

>>> import matplotlib.pyplot as plt
>>> fig, ax1 = plt.subplots()
>>> ax1.set_title('Digital filter frequency response')

>>> ax1.plot(w, 20 * np.log10(abs(h)), 'b')
>>> ax1.set_ylabel('Amplitude [dB]', color='b')
>>> ax1.set_xlabel('Frequency [rad/sample]')

>>> ax2 = ax1.twinx()
>>> angles = np.unwrap(np.angle(h))
>>> ax2.plot(w, angles, 'g')
>>> ax2.set_ylabel('Angle (radians)', color='g')
>>> ax2.grid(True)
>>> ax2.axis('tight')
>>> plt.show()

Broadcasting Examples

Suppose we have two FIR filters whose coefficients are stored in the
rows of an array with shape (2, 25). For this demonstration, we'll
use random data:

>>> rng = np.random.default_rng()
>>> b = rng.random((2, 25))

To compute the frequency response for these two filters with one call
to `freqz`, we must pass in ``b.T``, because `freqz` expects the first
axis to hold the coefficients. We must then extend the shape with a
trivial dimension of length 1 to allow broadcasting with the array
of frequencies.  That is, we pass in ``b.T[..., np.newaxis]``, which has
shape (25, 2, 1):

>>> w, h = signal.freqz(b.T[..., np.newaxis], worN=1024)
>>> w.shape
(1024,)
>>> h.shape
(2, 1024)

Now, suppose we have two transfer functions, with the same numerator
coefficients ``b = [0.5, 0.5]``. The coefficients for the two denominators
are stored in the first dimension of the 2-D array  `a`::

    a = [   1      1  ]
        [ -0.25, -0.5 ]

>>> b = np.array([0.5, 0.5])
>>> a = np.array([[1, 1], [-0.25, -0.5]])

Only `a` is more than 1-D. To make it compatible for
broadcasting with the frequencies, we extend it with a trivial dimension
in the call to `freqz`:

>>> w, h = signal.freqz(b, a[..., np.newaxis], worN=1024)
>>> w.shape
(1024,)
>>> h.shape
(2, 1024)
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l00276}{276}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.



References \mbox{\hyperlink{__filter__design_8py_source_l00041}{\+\_\+is\+\_\+int\+\_\+type()}}.



Referenced by \mbox{\hyperlink{__ltisys_8py_source_l03748}{scipy.\+signal.\+\_\+ltisys.\+dfreqresp()}}, \mbox{\hyperlink{test__fir__filter__design_8py_source_l00082}{scipy.\+signal.\+tests.\+test\+\_\+fir\+\_\+filter\+\_\+design.\+Test\+Firwin.\+mse()}}, \mbox{\hyperlink{__filter__design_8py_source_l00731}{sosfreqz()}}, \mbox{\hyperlink{test__fir__filter__design_8py_source_l00387}{scipy.\+signal.\+tests.\+test\+\_\+fir\+\_\+filter\+\_\+design.\+Test\+Firwin2.\+test05()}}, \mbox{\hyperlink{test__fir__filter__design_8py_source_l00399}{scipy.\+signal.\+tests.\+test\+\_\+fir\+\_\+filter\+\_\+design.\+Test\+Firwin2.\+test06()}}, \mbox{\hyperlink{test__fir__filter__design_8py_source_l00211}{scipy.\+signal.\+tests.\+test\+\_\+fir\+\_\+filter\+\_\+design.\+Test\+Fir\+Win\+More.\+test\+\_\+fs\+\_\+nyq()}}, \mbox{\hyperlink{test__filter__design_8py_source_l00625}{scipy.\+signal.\+tests.\+test\+\_\+filter\+\_\+design.\+Test\+Freqz.\+test\+\_\+ticket1441()}}, and \mbox{\hyperlink{test__filter__design_8py_source_l01109}{scipy.\+signal.\+tests.\+test\+\_\+filter\+\_\+design.\+Test\+Freqz\+\_\+zpk.\+test\+\_\+ticket1441()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_a054b88d412ab15682d43c45663270868}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!freqz\_zpk@{freqz\_zpk}}
\index{freqz\_zpk@{freqz\_zpk}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{freqz\_zpk()}{freqz\_zpk()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_a054b88d412ab15682d43c45663270868} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+freqz\+\_\+zpk (\begin{DoxyParamCaption}\item[{}]{z}{, }\item[{}]{p}{, }\item[{}]{k}{, }\item[{}]{worN}{ = {\ttfamily 512}, }\item[{}]{whole}{ = {\ttfamily False}, }\item[{}]{fs}{ = {\ttfamily 2\texorpdfstring{$\ast$}{*}pi}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute the frequency response of a digital filter in ZPK form.

Given the Zeros, Poles and Gain of a digital filter, compute its frequency
response:

:math:`H(z)=k \prod_i (z - Z[i]) / \prod_j (z - P[j])`

where :math:`k` is the `gain`, :math:`Z` are the `zeros` and :math:`P` are
the `poles`.

Parameters
----------
z : array_like
Zeroes of a linear filter
p : array_like
Poles of a linear filter
k : scalar
Gain of a linear filter
worN : {None, int, array_like}, optional
If a single integer, then compute at that many frequencies (default is
N=512).

If an array_like, compute the response at the frequencies given.
These are in the same units as `fs`.
whole : bool, optional
Normally, frequencies are computed from 0 to the Nyquist frequency,
fs/2 (upper-half of unit-circle). If `whole` is True, compute
frequencies from 0 to fs. Ignored if w is array_like.
fs : float, optional
The sampling frequency of the digital system. Defaults to 2*pi
radians/sample (so w is from 0 to pi).

.. versionadded:: 1.2.0

Returns
-------
w : ndarray
The frequencies at which `h` was computed, in the same units as `fs`.
By default, `w` is normalized to the range [0, pi) (radians/sample).
h : ndarray
The frequency response, as complex numbers.

See Also
--------
freqs : Compute the frequency response of an analog filter in TF form
freqs_zpk : Compute the frequency response of an analog filter in ZPK form
freqz : Compute the frequency response of a digital filter in TF form

Notes
-----
.. versionadded:: 0.19.0

Examples
--------
Design a 4th-order digital Butterworth filter with cut-off of 100 Hz in a
system with sample rate of 1000 Hz, and plot the frequency response:

>>> import numpy as np
>>> from scipy import signal
>>> z, p, k = signal.butter(4, 100, output='zpk', fs=1000)
>>> w, h = signal.freqz_zpk(z, p, k, fs=1000)

>>> import matplotlib.pyplot as plt
>>> fig = plt.figure()
>>> ax1 = fig.add_subplot(1, 1, 1)
>>> ax1.set_title('Digital filter frequency response')

>>> ax1.plot(w, 20 * np.log10(abs(h)), 'b')
>>> ax1.set_ylabel('Amplitude [dB]', color='b')
>>> ax1.set_xlabel('Frequency [Hz]')
>>> ax1.grid(True)

>>> ax2 = ax1.twinx()
>>> angles = np.unwrap(np.angle(h))
>>> ax2.plot(w, angles, 'g')
>>> ax2.set_ylabel('Angle [radians]', color='g')

>>> plt.axis('tight')
>>> plt.show()
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l00491}{491}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.



References \mbox{\hyperlink{__filter__design_8py_source_l00041}{\+\_\+is\+\_\+int\+\_\+type()}}.



Referenced by \mbox{\hyperlink{__ltisys_8py_source_l03748}{scipy.\+signal.\+\_\+ltisys.\+dfreqresp()}}, and \mbox{\hyperlink{test__filter__design_8py_source_l01109}{scipy.\+signal.\+tests.\+test\+\_\+filter\+\_\+design.\+Test\+Freqz\+\_\+zpk.\+test\+\_\+ticket1441()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_a95698a45f8565d76ba5a43d77120ac9c}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!gammatone@{gammatone}}
\index{gammatone@{gammatone}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{gammatone()}{gammatone()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_a95698a45f8565d76ba5a43d77120ac9c} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+gammatone (\begin{DoxyParamCaption}\item[{}]{freq}{, }\item[{}]{ftype}{, }\item[{}]{order}{ = {\ttfamily None}, }\item[{}]{numtaps}{ = {\ttfamily None}, }\item[{}]{fs}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Gammatone filter design.

This function computes the coefficients of an FIR or IIR gammatone
digital filter [1]_.

Parameters
----------
freq : float
    Center frequency of the filter (expressed in the same units
    as `fs`).
ftype : {'fir', 'iir'}
    The type of filter the function generates. If 'fir', the function
    will generate an Nth order FIR gammatone filter. If 'iir', the
    function will generate an 8th order digital IIR filter, modeled as
    as 4th order gammatone filter.
order : int, optional
    The order of the filter. Only used when ``ftype='fir'``.
    Default is 4 to model the human auditory system. Must be between
    0 and 24.
numtaps : int, optional
    Length of the filter. Only used when ``ftype='fir'``.
    Default is ``fs*0.015`` if `fs` is greater than 1000,
    15 if `fs` is less than or equal to 1000.
fs : float, optional
    The sampling frequency of the signal. `freq` must be between
    0 and ``fs/2``. Default is 2.

Returns
-------
b, a : ndarray, ndarray
    Numerator (``b``) and denominator (``a``) polynomials of the filter.

Raises
------
ValueError
    If `freq` is less than or equal to 0 or greater than or equal to
    ``fs/2``, if `ftype` is not 'fir' or 'iir', if `order` is less than
    or equal to 0 or greater than 24 when ``ftype='fir'``

See Also
--------
firwin
iirfilter

References
----------
.. [1] Slaney, Malcolm, "An Efficient Implementation of the
    Patterson-Holdsworth Auditory Filter Bank", Apple Computer
    Technical Report 35, 1993, pp.3-8, 34-39.

Examples
--------
16-sample 4th order FIR Gammatone filter centered at 440 Hz

>>> from scipy import signal
>>> signal.gammatone(440, 'fir', numtaps=16, fs=16000)
(array([ 0.00000000e+00,  2.22196719e-07,  1.64942101e-06,  4.99298227e-06,
    1.01993969e-05,  1.63125770e-05,  2.14648940e-05,  2.29947263e-05,
    1.76776931e-05,  2.04980537e-06, -2.72062858e-05, -7.28455299e-05,
   -1.36651076e-04, -2.19066855e-04, -3.18905076e-04, -4.33156712e-04]),
   [1.0])

IIR Gammatone filter centered at 440 Hz

>>> import matplotlib.pyplot as plt
>>> import numpy as np

>>> b, a = signal.gammatone(440, 'iir', fs=16000)
>>> w, h = signal.freqz(b, a)
>>> plt.plot(w / ((2 * np.pi) / 16000), 20 * np.log10(abs(h)))
>>> plt.xscale('log')
>>> plt.title('Gammatone filter frequency response')
>>> plt.xlabel('Frequency')
>>> plt.ylabel('Amplitude [dB]')
>>> plt.margins(0, 0.1)
>>> plt.grid(which='both', axis='both')
>>> plt.axvline(440, color='green') # cutoff frequency
>>> plt.show()
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l05393}{5393}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.



References \mbox{\hyperlink{__filter__design_8py_source_l05382}{\+\_\+hz\+\_\+to\+\_\+erb()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_a625d835512a209cd19d7dafe141ef33a}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!group\_delay@{group\_delay}}
\index{group\_delay@{group\_delay}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{group\_delay()}{group\_delay()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_a625d835512a209cd19d7dafe141ef33a} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+group\+\_\+delay (\begin{DoxyParamCaption}\item[{}]{system}{, }\item[{}]{w}{ = {\ttfamily 512}, }\item[{}]{whole}{ = {\ttfamily False}, }\item[{}]{fs}{ = {\ttfamily 2\texorpdfstring{$\ast$}{*}pi}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute the group delay of a digital filter.

The group delay measures by how many samples amplitude envelopes of
various spectral components of a signal are delayed by a filter.
It is formally defined as the derivative of continuous (unwrapped) phase::

       d        jw
D(w) = - -- arg H(e)
      dw

Parameters
----------
system : tuple of array_like (b, a)
Numerator and denominator coefficients of a filter transfer function.
w : {None, int, array_like}, optional
If a single integer, then compute at that many frequencies (default is
N=512).

If an array_like, compute the delay at the frequencies given. These
are in the same units as `fs`.
whole : bool, optional
Normally, frequencies are computed from 0 to the Nyquist frequency,
fs/2 (upper-half of unit-circle). If `whole` is True, compute
frequencies from 0 to fs. Ignored if w is array_like.
fs : float, optional
The sampling frequency of the digital system. Defaults to 2*pi
radians/sample (so w is from 0 to pi).

.. versionadded:: 1.2.0

Returns
-------
w : ndarray
The frequencies at which group delay was computed, in the same units
as `fs`.  By default, `w` is normalized to the range [0, pi)
(radians/sample).
gd : ndarray
The group delay.

See Also
--------
freqz : Frequency response of a digital filter

Notes
-----
The similar function in MATLAB is called `grpdelay`.

If the transfer function :math:`H(z)` has zeros or poles on the unit
circle, the group delay at corresponding frequencies is undefined.
When such a case arises the warning is raised and the group delay
is set to 0 at those frequencies.

For the details of numerical computation of the group delay refer to [1]_.

.. versionadded:: 0.16.0

References
----------
.. [1] Richard G. Lyons, "Understanding Digital Signal Processing,
   3rd edition", p. 830.

Examples
--------
>>> from scipy import signal
>>> b, a = signal.iirdesign(0.1, 0.3, 5, 50, ftype='cheby1')
>>> w, gd = signal.group_delay((b, a))

>>> import matplotlib.pyplot as plt
>>> plt.title('Digital filter group delay')
>>> plt.plot(w, gd)
>>> plt.ylabel('Group delay [samples]')
>>> plt.xlabel('Frequency [rad/sample]')
>>> plt.show()
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l00598}{598}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.



References \mbox{\hyperlink{__filter__design_8py_source_l00041}{\+\_\+is\+\_\+int\+\_\+type()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_a2aa21ab1bccbcf879a749367fa1abdfa}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!iircomb@{iircomb}}
\index{iircomb@{iircomb}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{iircomb()}{iircomb()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_a2aa21ab1bccbcf879a749367fa1abdfa} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+iircomb (\begin{DoxyParamCaption}\item[{}]{w0}{, }\item[{}]{Q}{, }\item[{}]{ftype}{ = {\ttfamily \textquotesingle{}notch\textquotesingle{}}, }\item[{}]{fs}{ = {\ttfamily 2.0}, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{pass\+\_\+zero}{ = {\ttfamily False}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Design IIR notching or peaking digital comb filter.

A notching comb filter consists of regularly-spaced band-stop filters with
a narrow bandwidth (high quality factor). Each rejects a narrow frequency
band and leaves the rest of the spectrum little changed.

A peaking comb filter consists of regularly-spaced band-pass filters with
a narrow bandwidth (high quality factor). Each rejects components outside
a narrow frequency band.

Parameters
----------
w0 : float
    The fundamental frequency of the comb filter (the spacing between its
    peaks). This must evenly divide the sampling frequency. If `fs` is
    specified, this is in the same units as `fs`. By default, it is
    a normalized scalar that must satisfy  ``0 < w0 < 1``, with
    ``w0 = 1`` corresponding to half of the sampling frequency.
Q : float
    Quality factor. Dimensionless parameter that characterizes
    notch filter -3 dB bandwidth ``bw`` relative to its center
    frequency, ``Q = w0/bw``.
ftype : {'notch', 'peak'}
    The type of comb filter generated by the function. If 'notch', then
    the Q factor applies to the notches. If 'peak', then the Q factor
    applies to the peaks.  Default is 'notch'.
fs : float, optional
    The sampling frequency of the signal. Default is 2.0.
pass_zero : bool, optional
    If False (default), the notches (nulls) of the filter are centered on
    frequencies [0, w0, 2*w0, ...], and the peaks are centered on the
    midpoints [w0/2, 3*w0/2, 5*w0/2, ...].  If True, the peaks are centered
    on [0, w0, 2*w0, ...] (passing zero frequency) and vice versa.

    .. versionadded:: 1.9.0

Returns
-------
b, a : ndarray, ndarray
    Numerator (``b``) and denominator (``a``) polynomials
    of the IIR filter.

Raises
------
ValueError
    If `w0` is less than or equal to 0 or greater than or equal to
    ``fs/2``, if `fs` is not divisible by `w0`, if `ftype`
    is not 'notch' or 'peak'

See Also
--------
iirnotch
iirpeak

Notes
-----
For implementation details, see [1]_. The TF implementation of the
comb filter is numerically stable even at higher orders due to the
use of a single repeated pole, which won't suffer from precision loss.

References
----------
.. [1] Sophocles J. Orfanidis, "Introduction To Signal Processing",
       Prentice-Hall, 1996, ch. 11, "Digital Filter Design"

Examples
--------
Design and plot notching comb filter at 20 Hz for a
signal sampled at 200 Hz, using quality factor Q = 30

>>> from scipy import signal
>>> import matplotlib.pyplot as plt
>>> import numpy as np

>>> fs = 200.0  # Sample frequency (Hz)
>>> f0 = 20.0  # Frequency to be removed from signal (Hz)
>>> Q = 30.0  # Quality factor
>>> # Design notching comb filter
>>> b, a = signal.iircomb(f0, Q, ftype='notch', fs=fs)

>>> # Frequency response
>>> freq, h = signal.freqz(b, a, fs=fs)
>>> response = abs(h)
>>> # To avoid divide by zero when graphing
>>> response[response == 0] = 1e-20
>>> # Plot
>>> fig, ax = plt.subplots(2, 1, figsize=(8, 6), sharex=True)
>>> ax[0].plot(freq, 20*np.log10(abs(response)), color='blue')
>>> ax[0].set_title("Frequency Response")
>>> ax[0].set_ylabel("Amplitude (dB)", color='blue')
>>> ax[0].set_xlim([0, 100])
>>> ax[0].set_ylim([-30, 10])
>>> ax[0].grid(True)
>>> ax[1].plot(freq, (np.angle(h)*180/np.pi+180)%360 - 180, color='green')
>>> ax[1].set_ylabel("Angle (degrees)", color='green')
>>> ax[1].set_xlabel("Frequency (Hz)")
>>> ax[1].set_xlim([0, 100])
>>> ax[1].set_yticks([-90, -60, -30, 0, 30, 60, 90])
>>> ax[1].set_ylim([-90, 90])
>>> ax[1].grid(True)
>>> plt.show()

Design and plot peaking comb filter at 250 Hz for a
signal sampled at 1000 Hz, using quality factor Q = 30

>>> fs = 1000.0  # Sample frequency (Hz)
>>> f0 = 250.0  # Frequency to be retained (Hz)
>>> Q = 30.0  # Quality factor
>>> # Design peaking filter
>>> b, a = signal.iircomb(f0, Q, ftype='peak', fs=fs, pass_zero=True)

>>> # Frequency response
>>> freq, h = signal.freqz(b, a, fs=fs)
>>> response = abs(h)
>>> # To avoid divide by zero when graphing
>>> response[response == 0] = 1e-20
>>> # Plot
>>> fig, ax = plt.subplots(2, 1, figsize=(8, 6), sharex=True)
>>> ax[0].plot(freq, 20*np.log10(np.maximum(abs(h), 1e-5)), color='blue')
>>> ax[0].set_title("Frequency Response")
>>> ax[0].set_ylabel("Amplitude (dB)", color='blue')
>>> ax[0].set_xlim([0, 500])
>>> ax[0].set_ylim([-80, 10])
>>> ax[0].grid(True)
>>> ax[1].plot(freq, (np.angle(h)*180/np.pi+180)%360 - 180, color='green')
>>> ax[1].set_ylabel("Angle (degrees)", color='green')
>>> ax[1].set_xlabel("Frequency (Hz)")
>>> ax[1].set_xlim([0, 500])
>>> ax[1].set_yticks([-90, -60, -30, 0, 30, 60, 90])
>>> ax[1].set_ylim([-90, 90])
>>> ax[1].grid(True)
>>> plt.show()
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l05174}{5174}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_ae4d58f87f7cfea7d8b63e0809aba1c20}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!iirdesign@{iirdesign}}
\index{iirdesign@{iirdesign}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{iirdesign()}{iirdesign()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_ae4d58f87f7cfea7d8b63e0809aba1c20} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+iirdesign (\begin{DoxyParamCaption}\item[{}]{wp}{, }\item[{}]{ws}{, }\item[{}]{gpass}{, }\item[{}]{gstop}{, }\item[{}]{analog}{ = {\ttfamily False}, }\item[{}]{ftype}{ = {\ttfamily \textquotesingle{}\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_a61a842f3ea1494216b2d32708a8ae665}{ellip}}\textquotesingle{}}, }\item[{}]{output}{ = {\ttfamily \textquotesingle{}ba\textquotesingle{}}, }\item[{}]{fs}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Complete IIR digital and analog filter design.

Given passband and stopband frequencies and gains, construct an analog or
digital IIR filter of minimum order for a given basic type. Return the
output in numerator, denominator ('ba'), pole-zero ('zpk') or second order
sections ('sos') form.

Parameters
----------
wp, ws : float or array like, shape (2,)
    Passband and stopband edge frequencies. Possible values are scalars
    (for lowpass and highpass filters) or ranges (for bandpass and bandstop
    filters).
    For digital filters, these are in the same units as `fs`. By default,
    `fs` is 2 half-cycles/sample, so these are normalized from 0 to 1,
    where 1 is the Nyquist frequency. For example:

        - Lowpass:   wp = 0.2,          ws = 0.3
        - Highpass:  wp = 0.3,          ws = 0.2
        - Bandpass:  wp = [0.2, 0.5],   ws = [0.1, 0.6]
        - Bandstop:  wp = [0.1, 0.6],   ws = [0.2, 0.5]

    For analog filters, `wp` and `ws` are angular frequencies (e.g., rad/s).
    Note, that for bandpass and bandstop filters passband must lie strictly
    inside stopband or vice versa.
gpass : float
    The maximum loss in the passband (dB).
gstop : float
    The minimum attenuation in the stopband (dB).
analog : bool, optional
    When True, return an analog filter, otherwise a digital filter is
    returned.
ftype : str, optional
    The type of IIR filter to design:

        - Butterworth   : 'butter'
        - Chebyshev I   : 'cheby1'
        - Chebyshev II  : 'cheby2'
        - Cauer/elliptic: 'ellip'

output : {'ba', 'zpk', 'sos'}, optional
    Filter form of the output:

        - second-order sections (recommended): 'sos'
        - numerator/denominator (default)    : 'ba'
        - pole-zero                          : 'zpk'

    In general the second-order sections ('sos') form  is
    recommended because inferring the coefficients for the
    numerator/denominator form ('ba') suffers from numerical
    instabilities. For reasons of backward compatibility the default
    form is the numerator/denominator form ('ba'), where the 'b'
    and the 'a' in 'ba' refer to the commonly used names of the
    coefficients used.

    Note: Using the second-order sections form ('sos') is sometimes
    associated with additional computational costs: for
    data-intense use cases it is therefore recommended to also
    investigate the numerator/denominator form ('ba').

fs : float, optional
    The sampling frequency of the digital system.

    .. versionadded:: 1.2.0

Returns
-------
b, a : ndarray, ndarray
    Numerator (`b`) and denominator (`a`) polynomials of the IIR filter.
    Only returned if ``output='ba'``.
z, p, k : ndarray, ndarray, float
    Zeros, poles, and system gain of the IIR filter transfer
    function.  Only returned if ``output='zpk'``.
sos : ndarray
    Second-order sections representation of the IIR filter.
    Only returned if ``output='sos'``.

See Also
--------
butter : Filter design using order and critical points
cheby1, cheby2, ellip, bessel
buttord : Find order and critical points from passband and stopband spec
cheb1ord, cheb2ord, ellipord
iirfilter : General filter design using order and critical frequencies

Notes
-----
The ``'sos'`` output parameter was added in 0.16.0.

Examples
--------
>>> import numpy as np
>>> from scipy import signal
>>> import matplotlib.pyplot as plt
>>> import matplotlib.ticker

>>> wp = 0.2
>>> ws = 0.3
>>> gpass = 1
>>> gstop = 40

>>> system = signal.iirdesign(wp, ws, gpass, gstop)
>>> w, h = signal.freqz(*system)

>>> fig, ax1 = plt.subplots()
>>> ax1.set_title('Digital filter frequency response')
>>> ax1.plot(w, 20 * np.log10(abs(h)), 'b')
>>> ax1.set_ylabel('Amplitude [dB]', color='b')
>>> ax1.set_xlabel('Frequency [rad/sample]')
>>> ax1.grid(True)
>>> ax1.set_ylim([-120, 20])
>>> ax2 = ax1.twinx()
>>> angles = np.unwrap(np.angle(h))
>>> ax2.plot(w, angles, 'g')
>>> ax2.set_ylabel('Angle (radians)', color='g')
>>> ax2.grid(True)
>>> ax2.axis('tight')
>>> ax2.set_ylim([-6, 1])
>>> nticks = 8
>>> ax1.yaxis.set_major_locator(matplotlib.ticker.LinearLocator(nticks))
>>> ax2.yaxis.set_major_locator(matplotlib.ticker.LinearLocator(nticks))
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l02188}{2188}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.



References \mbox{\hyperlink{__filter__design_8py_source_l02362}{iirfilter()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_a937343d2df9040beea4d31c3efe33481}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!iirfilter@{iirfilter}}
\index{iirfilter@{iirfilter}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{iirfilter()}{iirfilter()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_a937343d2df9040beea4d31c3efe33481} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+iirfilter (\begin{DoxyParamCaption}\item[{}]{N}{, }\item[{}]{Wn}{, }\item[{}]{rp}{ = {\ttfamily None}, }\item[{}]{rs}{ = {\ttfamily None}, }\item[{}]{btype}{ = {\ttfamily \textquotesingle{}band\textquotesingle{}}, }\item[{}]{analog}{ = {\ttfamily False}, }\item[{}]{ftype}{ = {\ttfamily \textquotesingle{}\mbox{\hyperlink{namespacescipy_1_1signal_1_1__filter__design_a4568219d096c6e4e5a091c63dbde4bb8}{butter}}\textquotesingle{}}, }\item[{}]{output}{ = {\ttfamily \textquotesingle{}ba\textquotesingle{}}, }\item[{}]{fs}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}IIR digital and analog filter design given order and critical points.

Design an Nth-order digital or analog filter and return the filter
coefficients.

Parameters
----------
N : int
    The order of the filter.
Wn : array_like
    A scalar or length-2 sequence giving the critical frequencies.

    For digital filters, `Wn` are in the same units as `fs`. By default,
    `fs` is 2 half-cycles/sample, so these are normalized from 0 to 1,
    where 1 is the Nyquist frequency. (`Wn` is thus in
    half-cycles / sample.)

    For analog filters, `Wn` is an angular frequency (e.g., rad/s).

    When Wn is a length-2 sequence, ``Wn[0]`` must be less than ``Wn[1]``.
rp : float, optional
    For Chebyshev and elliptic filters, provides the maximum ripple
    in the passband. (dB)
rs : float, optional
    For Chebyshev and elliptic filters, provides the minimum attenuation
    in the stop band. (dB)
btype : {'bandpass', 'lowpass', 'highpass', 'bandstop'}, optional
    The type of filter.  Default is 'bandpass'.
analog : bool, optional
    When True, return an analog filter, otherwise a digital filter is
    returned.
ftype : str, optional
    The type of IIR filter to design:

        - Butterworth   : 'butter'
        - Chebyshev I   : 'cheby1'
        - Chebyshev II  : 'cheby2'
        - Cauer/elliptic: 'ellip'
        - Bessel/Thomson: 'bessel'

output : {'ba', 'zpk', 'sos'}, optional
    Filter form of the output:

        - second-order sections (recommended): 'sos'
        - numerator/denominator (default)    : 'ba'
        - pole-zero                          : 'zpk'

    In general the second-order sections ('sos') form  is
    recommended because inferring the coefficients for the
    numerator/denominator form ('ba') suffers from numerical
    instabilities. For reasons of backward compatibility the default
    form is the numerator/denominator form ('ba'), where the 'b'
    and the 'a' in 'ba' refer to the commonly used names of the
    coefficients used.

    Note: Using the second-order sections form ('sos') is sometimes
    associated with additional computational costs: for
    data-intense use cases it is therefore recommended to also
    investigate the numerator/denominator form ('ba').

fs : float, optional
    The sampling frequency of the digital system.

    .. versionadded:: 1.2.0

Returns
-------
b, a : ndarray, ndarray
    Numerator (`b`) and denominator (`a`) polynomials of the IIR filter.
    Only returned if ``output='ba'``.
z, p, k : ndarray, ndarray, float
    Zeros, poles, and system gain of the IIR filter transfer
    function.  Only returned if ``output='zpk'``.
sos : ndarray
    Second-order sections representation of the IIR filter.
    Only returned if ``output='sos'``.

See Also
--------
butter : Filter design using order and critical points
cheby1, cheby2, ellip, bessel
buttord : Find order and critical points from passband and stopband spec
cheb1ord, cheb2ord, ellipord
iirdesign : General filter design using passband and stopband spec

Notes
-----
The ``'sos'`` output parameter was added in 0.16.0.

Examples
--------
Generate a 17th-order Chebyshev II analog bandpass filter from 50 Hz to
200 Hz and plot the frequency response:

>>> import numpy as np
>>> from scipy import signal
>>> import matplotlib.pyplot as plt

>>> b, a = signal.iirfilter(17, [2*np.pi*50, 2*np.pi*200], rs=60,
...                         btype='band', analog=True, ftype='cheby2')
>>> w, h = signal.freqs(b, a, 1000)
>>> fig = plt.figure()
>>> ax = fig.add_subplot(1, 1, 1)
>>> ax.semilogx(w / (2*np.pi), 20 * np.log10(np.maximum(abs(h), 1e-5)))
>>> ax.set_title('Chebyshev Type II bandpass frequency response')
>>> ax.set_xlabel('Frequency [Hz]')
>>> ax.set_ylabel('Amplitude [dB]')
>>> ax.axis((10, 1000, -100, 10))
>>> ax.grid(which='both', axis='both')
>>> plt.show()

Create a digital filter with the same properties, in a system with
sampling rate of 2000 Hz, and plot the frequency response. (Second-order
sections implementation is required to ensure stability of a filter of
this order):

>>> sos = signal.iirfilter(17, [50, 200], rs=60, btype='band',
...                        analog=False, ftype='cheby2', fs=2000,
...                        output='sos')
>>> w, h = signal.sosfreqz(sos, 2000, fs=2000)
>>> fig = plt.figure()
>>> ax = fig.add_subplot(1, 1, 1)
>>> ax.semilogx(w, 20 * np.log10(np.maximum(abs(h), 1e-5)))
>>> ax.set_title('Chebyshev Type II bandpass frequency response')
>>> ax.set_xlabel('Frequency [Hz]')
>>> ax.set_ylabel('Amplitude [dB]')
>>> ax.axis((10, 1000, -100, 10))
>>> ax.grid(which='both', axis='both')
>>> plt.show()
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l02361}{2361}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.



References \mbox{\hyperlink{__filter__design_8py_source_l02613}{bilinear\+\_\+zpk()}}, \mbox{\hyperlink{__filter__design_8py_source_l02821}{lp2bp\+\_\+zpk()}}, \mbox{\hyperlink{__filter__design_8py_source_l02900}{lp2bs\+\_\+zpk()}}, \mbox{\hyperlink{__filter__design_8py_source_l02755}{lp2hp\+\_\+zpk()}}, \mbox{\hyperlink{__filter__design_8py_source_l02695}{lp2lp\+\_\+zpk()}}, \mbox{\hyperlink{__filter__design_8py_source_l01297}{zpk2sos()}}, and \mbox{\hyperlink{__filter__design_8py_source_l01097}{zpk2tf()}}.



Referenced by \mbox{\hyperlink{__filter__design_8py_source_l03461}{bessel()}}, \mbox{\hyperlink{__filter__design_8py_source_l02980}{butter()}}, \mbox{\hyperlink{__filter__design_8py_source_l03105}{cheby1()}}, \mbox{\hyperlink{__filter__design_8py_source_l03223}{cheby2()}}, \mbox{\hyperlink{__filter__design_8py_source_l03335}{ellip()}}, and \mbox{\hyperlink{__filter__design_8py_source_l02189}{iirdesign()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_ad597e2eb48ee608991d13e408bf5873e}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!iirnotch@{iirnotch}}
\index{iirnotch@{iirnotch}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{iirnotch()}{iirnotch()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_ad597e2eb48ee608991d13e408bf5873e} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+iirnotch (\begin{DoxyParamCaption}\item[{}]{w0}{, }\item[{}]{Q}{, }\item[{}]{fs}{ = {\ttfamily 2.0}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Design second-order IIR notch digital filter.

A notch filter is a band-stop filter with a narrow bandwidth
(high quality factor). It rejects a narrow frequency band and
leaves the rest of the spectrum little changed.

Parameters
----------
w0 : float
    Frequency to remove from a signal. If `fs` is specified, this is in
    the same units as `fs`. By default, it is a normalized scalar that must
    satisfy  ``0 < w0 < 1``, with ``w0 = 1`` corresponding to half of the
    sampling frequency.
Q : float
    Quality factor. Dimensionless parameter that characterizes
    notch filter -3 dB bandwidth ``bw`` relative to its center
    frequency, ``Q = w0/bw``.
fs : float, optional
    The sampling frequency of the digital system.

    .. versionadded:: 1.2.0

Returns
-------
b, a : ndarray, ndarray
    Numerator (``b``) and denominator (``a``) polynomials
    of the IIR filter.

See Also
--------
iirpeak

Notes
-----
.. versionadded:: 0.19.0

References
----------
.. [1] Sophocles J. Orfanidis, "Introduction To Signal Processing",
       Prentice-Hall, 1996

Examples
--------
Design and plot filter to remove the 60 Hz component from a
signal sampled at 200 Hz, using a quality factor Q = 30

>>> from scipy import signal
>>> import matplotlib.pyplot as plt
>>> import numpy as np

>>> fs = 200.0  # Sample frequency (Hz)
>>> f0 = 60.0  # Frequency to be removed from signal (Hz)
>>> Q = 30.0  # Quality factor
>>> # Design notch filter
>>> b, a = signal.iirnotch(f0, Q, fs)

>>> # Frequency response
>>> freq, h = signal.freqz(b, a, fs=fs)
>>> # Plot
>>> fig, ax = plt.subplots(2, 1, figsize=(8, 6))
>>> ax[0].plot(freq, 20*np.log10(abs(h)), color='blue')
>>> ax[0].set_title("Frequency Response")
>>> ax[0].set_ylabel("Amplitude (dB)", color='blue')
>>> ax[0].set_xlim([0, 100])
>>> ax[0].set_ylim([-25, 10])
>>> ax[0].grid(True)
>>> ax[1].plot(freq, np.unwrap(np.angle(h))*180/np.pi, color='green')
>>> ax[1].set_ylabel("Angle (degrees)", color='green')
>>> ax[1].set_xlabel("Frequency (Hz)")
>>> ax[1].set_xlim([0, 100])
>>> ax[1].set_yticks([-90, -60, -30, 0, 30, 60, 90])
>>> ax[1].set_ylim([-90, 90])
>>> ax[1].grid(True)
>>> plt.show()
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l04937}{4937}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.



References \mbox{\hyperlink{__filter__design_8py_source_l05099}{\+\_\+design\+\_\+notch\+\_\+peak\+\_\+filter()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_af928a310a30876eb852f6ef0ee25ac02}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!iirpeak@{iirpeak}}
\index{iirpeak@{iirpeak}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{iirpeak()}{iirpeak()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_af928a310a30876eb852f6ef0ee25ac02} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+iirpeak (\begin{DoxyParamCaption}\item[{}]{w0}{, }\item[{}]{Q}{, }\item[{}]{fs}{ = {\ttfamily 2.0}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Design second-order IIR peak (resonant) digital filter.

A peak filter is a band-pass filter with a narrow bandwidth
(high quality factor). It rejects components outside a narrow
frequency band.

Parameters
----------
w0 : float
    Frequency to be retained in a signal. If `fs` is specified, this is in
    the same units as `fs`. By default, it is a normalized scalar that must
    satisfy  ``0 < w0 < 1``, with ``w0 = 1`` corresponding to half of the
    sampling frequency.
Q : float
    Quality factor. Dimensionless parameter that characterizes
    peak filter -3 dB bandwidth ``bw`` relative to its center
    frequency, ``Q = w0/bw``.
fs : float, optional
    The sampling frequency of the digital system.

    .. versionadded:: 1.2.0

Returns
-------
b, a : ndarray, ndarray
    Numerator (``b``) and denominator (``a``) polynomials
    of the IIR filter.

See Also
--------
iirnotch

Notes
-----
.. versionadded:: 0.19.0

References
----------
.. [1] Sophocles J. Orfanidis, "Introduction To Signal Processing",
       Prentice-Hall, 1996

Examples
--------
Design and plot filter to remove the frequencies other than the 300 Hz
component from a signal sampled at 1000 Hz, using a quality factor Q = 30

>>> import numpy as np
>>> from scipy import signal
>>> import matplotlib.pyplot as plt

>>> fs = 1000.0  # Sample frequency (Hz)
>>> f0 = 300.0  # Frequency to be retained (Hz)
>>> Q = 30.0  # Quality factor
>>> # Design peak filter
>>> b, a = signal.iirpeak(f0, Q, fs)

>>> # Frequency response
>>> freq, h = signal.freqz(b, a, fs=fs)
>>> # Plot
>>> fig, ax = plt.subplots(2, 1, figsize=(8, 6))
>>> ax[0].plot(freq, 20*np.log10(np.maximum(abs(h), 1e-5)), color='blue')
>>> ax[0].set_title("Frequency Response")
>>> ax[0].set_ylabel("Amplitude (dB)", color='blue')
>>> ax[0].set_xlim([0, 500])
>>> ax[0].set_ylim([-50, 10])
>>> ax[0].grid(True)
>>> ax[1].plot(freq, np.unwrap(np.angle(h))*180/np.pi, color='green')
>>> ax[1].set_ylabel("Angle (degrees)", color='green')
>>> ax[1].set_xlabel("Frequency (Hz)")
>>> ax[1].set_xlim([0, 500])
>>> ax[1].set_yticks([-90, -60, -30, 0, 30, 60, 90])
>>> ax[1].set_ylim([-90, 90])
>>> ax[1].grid(True)
>>> plt.show()
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l05018}{5018}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.



References \mbox{\hyperlink{__filter__design_8py_source_l05099}{\+\_\+design\+\_\+notch\+\_\+peak\+\_\+filter()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_aaef8478cb2d3a2d9df568f00047d2931}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!lp2bp@{lp2bp}}
\index{lp2bp@{lp2bp}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{lp2bp()}{lp2bp()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_aaef8478cb2d3a2d9df568f00047d2931} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+lp2bp (\begin{DoxyParamCaption}\item[{}]{b}{, }\item[{}]{a}{, }\item[{}]{wo}{ = {\ttfamily 1.0}, }\item[{}]{bw}{ = {\ttfamily 1.0}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Transform a lowpass filter prototype to a bandpass filter.

Return an analog band-pass filter with center frequency `wo` and
bandwidth `bw` from an analog low-pass filter prototype with unity
cutoff frequency, in transfer function ('ba') representation.

Parameters
----------
b : array_like
    Numerator polynomial coefficients.
a : array_like
    Denominator polynomial coefficients.
wo : float
    Desired passband center, as angular frequency (e.g., rad/s).
    Defaults to no change.
bw : float
    Desired passband width, as angular frequency (e.g., rad/s).
    Defaults to 1.

Returns
-------
b : array_like
    Numerator polynomial coefficients of the transformed band-pass filter.
a : array_like
    Denominator polynomial coefficients of the transformed band-pass filter.

See Also
--------
lp2lp, lp2hp, lp2bs, bilinear
lp2bp_zpk

Notes
-----
This is derived from the s-plane substitution

.. math:: s \rightarrow \frac{s^2 + {\omega_0}^2}{s \cdot \mathrm{BW}}

This is the "wideband" transformation, producing a passband with
geometric (log frequency) symmetry about `wo`.

Examples
--------
>>> from scipy import signal
>>> import matplotlib.pyplot as plt

>>> lp = signal.lti([1.0], [1.0, 1.0])
>>> bp = signal.lti(*signal.lp2bp(lp.num, lp.den))
>>> w, mag_lp, p_lp = lp.bode()
>>> w, mag_bp, p_bp = bp.bode(w)

>>> plt.plot(w, mag_lp, label='Lowpass')
>>> plt.plot(w, mag_bp, label='Bandpass')
>>> plt.semilogx()
>>> plt.grid(True)
>>> plt.xlabel('Frequency [rad/s]')
>>> plt.ylabel('Magnitude [dB]')
>>> plt.legend()
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l01915}{1915}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.



References \mbox{\hyperlink{__filter__design_8py_source_l01661}{normalize()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_add44de70076884fad1e24280565faa71}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!lp2bp\_zpk@{lp2bp\_zpk}}
\index{lp2bp\_zpk@{lp2bp\_zpk}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{lp2bp\_zpk()}{lp2bp\_zpk()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_add44de70076884fad1e24280565faa71} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+lp2bp\+\_\+zpk (\begin{DoxyParamCaption}\item[{}]{z}{, }\item[{}]{p}{, }\item[{}]{k}{, }\item[{}]{wo}{ = {\ttfamily 1.0}, }\item[{}]{bw}{ = {\ttfamily 1.0}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Transform a lowpass filter prototype to a bandpass filter.

Return an analog band-pass filter with center frequency `wo` and
bandwidth `bw` from an analog low-pass filter prototype with unity
cutoff frequency, using zeros, poles, and gain ('zpk') representation.

Parameters
----------
z : array_like
    Zeros of the analog filter transfer function.
p : array_like
    Poles of the analog filter transfer function.
k : float
    System gain of the analog filter transfer function.
wo : float
    Desired passband center, as angular frequency (e.g., rad/s).
    Defaults to no change.
bw : float
    Desired passband width, as angular frequency (e.g., rad/s).
    Defaults to 1.

Returns
-------
z : ndarray
    Zeros of the transformed band-pass filter transfer function.
p : ndarray
    Poles of the transformed band-pass filter transfer function.
k : float
    System gain of the transformed band-pass filter.

See Also
--------
lp2lp_zpk, lp2hp_zpk, lp2bs_zpk, bilinear
lp2bp

Notes
-----
This is derived from the s-plane substitution

.. math:: s \rightarrow \frac{s^2 + {\omega_0}^2}{s \cdot \mathrm{BW}}

This is the "wideband" transformation, producing a passband with
geometric (log frequency) symmetry about `wo`.

.. versionadded:: 1.1.0
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l02821}{2821}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.



References \mbox{\hyperlink{__filter__design_8py_source_l02601}{\+\_\+relative\+\_\+degree()}}.



Referenced by \mbox{\hyperlink{__filter__design_8py_source_l02362}{iirfilter()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_ad3bb750049c7af67e7751863c24c1652}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!lp2bs@{lp2bs}}
\index{lp2bs@{lp2bs}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{lp2bs()}{lp2bs()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_ad3bb750049c7af67e7751863c24c1652} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+lp2bs (\begin{DoxyParamCaption}\item[{}]{b}{, }\item[{}]{a}{, }\item[{}]{wo}{ = {\ttfamily 1.0}, }\item[{}]{bw}{ = {\ttfamily 1.0}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Transform a lowpass filter prototype to a bandstop filter.

Return an analog band-stop filter with center frequency `wo` and
bandwidth `bw` from an analog low-pass filter prototype with unity
cutoff frequency, in transfer function ('ba') representation.

Parameters
----------
b : array_like
    Numerator polynomial coefficients.
a : array_like
    Denominator polynomial coefficients.
wo : float
    Desired stopband center, as angular frequency (e.g., rad/s).
    Defaults to no change.
bw : float
    Desired stopband width, as angular frequency (e.g., rad/s).
    Defaults to 1.

Returns
-------
b : array_like
    Numerator polynomial coefficients of the transformed band-stop filter.
a : array_like
    Denominator polynomial coefficients of the transformed band-stop filter.

See Also
--------
lp2lp, lp2hp, lp2bp, bilinear
lp2bs_zpk

Notes
-----
This is derived from the s-plane substitution

.. math:: s \rightarrow \frac{s \cdot \mathrm{BW}}{s^2 + {\omega_0}^2}

This is the "wideband" transformation, producing a stopband with
geometric (log frequency) symmetry about `wo`.

Examples
--------
>>> from scipy import signal
>>> import matplotlib.pyplot as plt

>>> lp = signal.lti([1.0], [1.0, 1.5])
>>> bs = signal.lti(*signal.lp2bs(lp.num, lp.den))
>>> w, mag_lp, p_lp = lp.bode()
>>> w, mag_bs, p_bs = bs.bode(w)
>>> plt.plot(w, mag_lp, label='Lowpass')
>>> plt.plot(w, mag_bs, label='Bandstop')
>>> plt.semilogx()
>>> plt.grid(True)
>>> plt.xlabel('Frequency [rad/s]')
>>> plt.ylabel('Magnitude [dB]')
>>> plt.legend()
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l02004}{2004}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.



References \mbox{\hyperlink{__filter__design_8py_source_l01661}{normalize()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_ab0030f63a715bfb905de22b463bb2005}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!lp2bs\_zpk@{lp2bs\_zpk}}
\index{lp2bs\_zpk@{lp2bs\_zpk}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{lp2bs\_zpk()}{lp2bs\_zpk()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_ab0030f63a715bfb905de22b463bb2005} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+lp2bs\+\_\+zpk (\begin{DoxyParamCaption}\item[{}]{z}{, }\item[{}]{p}{, }\item[{}]{k}{, }\item[{}]{wo}{ = {\ttfamily 1.0}, }\item[{}]{bw}{ = {\ttfamily 1.0}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Transform a lowpass filter prototype to a bandstop filter.

Return an analog band-stop filter with center frequency `wo` and
stopband width `bw` from an analog low-pass filter prototype with unity
cutoff frequency, using zeros, poles, and gain ('zpk') representation.

Parameters
----------
z : array_like
    Zeros of the analog filter transfer function.
p : array_like
    Poles of the analog filter transfer function.
k : float
    System gain of the analog filter transfer function.
wo : float
    Desired stopband center, as angular frequency (e.g., rad/s).
    Defaults to no change.
bw : float
    Desired stopband width, as angular frequency (e.g., rad/s).
    Defaults to 1.

Returns
-------
z : ndarray
    Zeros of the transformed band-stop filter transfer function.
p : ndarray
    Poles of the transformed band-stop filter transfer function.
k : float
    System gain of the transformed band-stop filter.

See Also
--------
lp2lp_zpk, lp2hp_zpk, lp2bp_zpk, bilinear
lp2bs

Notes
-----
This is derived from the s-plane substitution

.. math:: s \rightarrow \frac{s \cdot \mathrm{BW}}{s^2 + {\omega_0}^2}

This is the "wideband" transformation, producing a stopband with
geometric (log frequency) symmetry about `wo`.

.. versionadded:: 1.1.0
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l02900}{2900}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.



References \mbox{\hyperlink{__filter__design_8py_source_l02601}{\+\_\+relative\+\_\+degree()}}.



Referenced by \mbox{\hyperlink{__filter__design_8py_source_l02362}{iirfilter()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_acf80f2294b9a61970f9af0785977ac7d}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!lp2hp@{lp2hp}}
\index{lp2hp@{lp2hp}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{lp2hp()}{lp2hp()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_acf80f2294b9a61970f9af0785977ac7d} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+lp2hp (\begin{DoxyParamCaption}\item[{}]{b}{, }\item[{}]{a}{, }\item[{}]{wo}{ = {\ttfamily 1.0}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Transform a lowpass filter prototype to a highpass filter.

Return an analog high-pass filter with cutoff frequency `wo`
from an analog low-pass filter prototype with unity cutoff frequency, in
transfer function ('ba') representation.

Parameters
----------
b : array_like
    Numerator polynomial coefficients.
a : array_like
    Denominator polynomial coefficients.
wo : float
    Desired cutoff, as angular frequency (e.g., rad/s).
    Defaults to no change.

Returns
-------
b : array_like
    Numerator polynomial coefficients of the transformed high-pass filter.
a : array_like
    Denominator polynomial coefficients of the transformed high-pass filter.

See Also
--------
lp2lp, lp2bp, lp2bs, bilinear
lp2hp_zpk

Notes
-----
This is derived from the s-plane substitution

.. math:: s \rightarrow \frac{\omega_0}{s}

This maintains symmetry of the lowpass and highpass responses on a
logarithmic scale.

Examples
--------
>>> from scipy import signal
>>> import matplotlib.pyplot as plt

>>> lp = signal.lti([1.0], [1.0, 1.0])
>>> hp = signal.lti(*signal.lp2hp(lp.num, lp.den))
>>> w, mag_lp, p_lp = lp.bode()
>>> w, mag_hp, p_hp = hp.bode(w)

>>> plt.plot(w, mag_lp, label='Lowpass')
>>> plt.plot(w, mag_hp, label='Highpass')
>>> plt.semilogx()
>>> plt.grid(True)
>>> plt.xlabel('Frequency [rad/s]')
>>> plt.ylabel('Magnitude [dB]')
>>> plt.legend()
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l01832}{1832}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.



References \mbox{\hyperlink{__filter__design_8py_source_l01661}{normalize()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_a7d904ad8d1239d1f5408d1ed46d6b87c}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!lp2hp\_zpk@{lp2hp\_zpk}}
\index{lp2hp\_zpk@{lp2hp\_zpk}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{lp2hp\_zpk()}{lp2hp\_zpk()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_a7d904ad8d1239d1f5408d1ed46d6b87c} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+lp2hp\+\_\+zpk (\begin{DoxyParamCaption}\item[{}]{z}{, }\item[{}]{p}{, }\item[{}]{k}{, }\item[{}]{wo}{ = {\ttfamily 1.0}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Transform a lowpass filter prototype to a highpass filter.

Return an analog high-pass filter with cutoff frequency `wo`
from an analog low-pass filter prototype with unity cutoff frequency,
using zeros, poles, and gain ('zpk') representation.

Parameters
----------
z : array_like
    Zeros of the analog filter transfer function.
p : array_like
    Poles of the analog filter transfer function.
k : float
    System gain of the analog filter transfer function.
wo : float
    Desired cutoff, as angular frequency (e.g., rad/s).
    Defaults to no change.

Returns
-------
z : ndarray
    Zeros of the transformed high-pass filter transfer function.
p : ndarray
    Poles of the transformed high-pass filter transfer function.
k : float
    System gain of the transformed high-pass filter.

See Also
--------
lp2lp_zpk, lp2bp_zpk, lp2bs_zpk, bilinear
lp2hp

Notes
-----
This is derived from the s-plane substitution

.. math:: s \rightarrow \frac{\omega_0}{s}

This maintains symmetry of the lowpass and highpass responses on a
logarithmic scale.

.. versionadded:: 1.1.0
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l02755}{2755}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.



References \mbox{\hyperlink{__filter__design_8py_source_l02601}{\+\_\+relative\+\_\+degree()}}.



Referenced by \mbox{\hyperlink{__filter__design_8py_source_l02362}{iirfilter()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_acdb73944d070b0526aea89119ebcd64a}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!lp2lp@{lp2lp}}
\index{lp2lp@{lp2lp}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{lp2lp()}{lp2lp()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_acdb73944d070b0526aea89119ebcd64a} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+lp2lp (\begin{DoxyParamCaption}\item[{}]{b}{, }\item[{}]{a}{, }\item[{}]{wo}{ = {\ttfamily 1.0}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Transform a lowpass filter prototype to a different frequency.

Return an analog low-pass filter with cutoff frequency `wo`
from an analog low-pass filter prototype with unity cutoff frequency, in
transfer function ('ba') representation.

Parameters
----------
b : array_like
    Numerator polynomial coefficients.
a : array_like
    Denominator polynomial coefficients.
wo : float
    Desired cutoff, as angular frequency (e.g. rad/s).
    Defaults to no change.

Returns
-------
b : array_like
    Numerator polynomial coefficients of the transformed low-pass filter.
a : array_like
    Denominator polynomial coefficients of the transformed low-pass filter.

See Also
--------
lp2hp, lp2bp, lp2bs, bilinear
lp2lp_zpk

Notes
-----
This is derived from the s-plane substitution

.. math:: s \rightarrow \frac{s}{\omega_0}

Examples
--------

>>> from scipy import signal
>>> import matplotlib.pyplot as plt

>>> lp = signal.lti([1.0], [1.0, 1.0])
>>> lp2 = signal.lti(*signal.lp2lp(lp.num, lp.den, 2))
>>> w, mag_lp, p_lp = lp.bode()
>>> w, mag_lp2, p_lp2 = lp2.bode(w)

>>> plt.plot(w, mag_lp, label='Lowpass')
>>> plt.plot(w, mag_lp2, label='Transformed Lowpass')
>>> plt.semilogx()
>>> plt.grid(True)
>>> plt.xlabel('Frequency [rad/s]')
>>> plt.ylabel('Magnitude [dB]')
>>> plt.legend()
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l01760}{1760}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.



References \mbox{\hyperlink{__filter__design_8py_source_l01661}{normalize()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_afbc60fe8e91d4d924a667655144f7b3d}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!lp2lp\_zpk@{lp2lp\_zpk}}
\index{lp2lp\_zpk@{lp2lp\_zpk}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{lp2lp\_zpk()}{lp2lp\_zpk()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_afbc60fe8e91d4d924a667655144f7b3d} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+lp2lp\+\_\+zpk (\begin{DoxyParamCaption}\item[{}]{z}{, }\item[{}]{p}{, }\item[{}]{k}{, }\item[{}]{wo}{ = {\ttfamily 1.0}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Transform a lowpass filter prototype to a different frequency.

Return an analog low-pass filter with cutoff frequency `wo`
from an analog low-pass filter prototype with unity cutoff frequency,
using zeros, poles, and gain ('zpk') representation.

Parameters
----------
z : array_like
    Zeros of the analog filter transfer function.
p : array_like
    Poles of the analog filter transfer function.
k : float
    System gain of the analog filter transfer function.
wo : float
    Desired cutoff, as angular frequency (e.g., rad/s).
    Defaults to no change.

Returns
-------
z : ndarray
    Zeros of the transformed low-pass filter transfer function.
p : ndarray
    Poles of the transformed low-pass filter transfer function.
k : float
    System gain of the transformed low-pass filter.

See Also
--------
lp2hp_zpk, lp2bp_zpk, lp2bs_zpk, bilinear
lp2lp

Notes
-----
This is derived from the s-plane substitution

.. math:: s \rightarrow \frac{s}{\omega_0}

.. versionadded:: 1.1.0
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l02695}{2695}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.



References \mbox{\hyperlink{__filter__design_8py_source_l02601}{\+\_\+relative\+\_\+degree()}}.



Referenced by \mbox{\hyperlink{__filter__design_8py_source_l02362}{iirfilter()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_a4e93da165795ed541dd2fa129b781a35}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!maxflat@{maxflat}}
\index{maxflat@{maxflat}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{maxflat()}{maxflat()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_a4e93da165795ed541dd2fa129b781a35} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+maxflat (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}



Definition at line \mbox{\hyperlink{__filter__design_8py_source_l03623}{3623}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_a403f599e6854656425d2a6c393be2504}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!normalize@{normalize}}
\index{normalize@{normalize}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{normalize()}{normalize()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_a403f599e6854656425d2a6c393be2504} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+normalize (\begin{DoxyParamCaption}\item[{}]{b}{, }\item[{}]{a}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Normalize numerator/denominator of a continuous-time transfer function.

If values of `b` are too close to 0, they are removed. In that case, a
BadCoefficients warning is emitted.

Parameters
----------
b: array_like
    Numerator of the transfer function. Can be a 2-D array to normalize
    multiple transfer functions.
a: array_like
    Denominator of the transfer function. At most 1-D.

Returns
-------
num: array
    The numerator of the normalized transfer function. At least a 1-D
    array. A 2-D array if the input `num` is a 2-D array.
den: 1-D array
    The denominator of the normalized transfer function.

Notes
-----
Coefficients for both the numerator and denominator should be specified in
descending exponent order (e.g., ``s^2 + 3s + 5`` would be represented as
``[1, 3, 5]``).

Examples
--------
>>> from scipy.signal import normalize

Normalize the coefficients of the transfer function
``(3*s^2 - 2*s + 5) / (2*s^2 + 3*s + 1)``:

>>> b = [3, -2, 5]
>>> a = [2, 3, 1]
>>> normalize(b, a)
(array([ 1.5, -1. ,  2.5]), array([1. , 1.5, 0.5]))

A warning is generated if, for example, the first coefficient of
`b` is 0.  In the following example, the result is as expected:

>>> import warnings
>>> with warnings.catch_warnings(record=True) as w:
...     num, den = normalize([0, 3, 6], [2, -5, 4])

>>> num
array([1.5, 3. ])
>>> den
array([ 1. , -2.5,  2. ])

>>> print(w[0].message)
Badly conditioned filter coefficients (numerator): the results may be meaningless
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l01661}{1661}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.



References \mbox{\hyperlink{__filter__design_8py_source_l01615}{\+\_\+align\+\_\+nums()}}.



Referenced by \mbox{\hyperlink{__ltisys_8py_source_l00589}{scipy.\+signal.\+\_\+ltisys.\+Transfer\+Function.\+\_\+\+\_\+init\+\_\+\+\_\+()}}, \mbox{\hyperlink{__filter__design_8py_source_l02093}{bilinear()}}, \mbox{\hyperlink{__filter__design_8py_source_l01915}{lp2bp()}}, \mbox{\hyperlink{__filter__design_8py_source_l02004}{lp2bs()}}, \mbox{\hyperlink{__filter__design_8py_source_l01832}{lp2hp()}}, \mbox{\hyperlink{__filter__design_8py_source_l01760}{lp2lp()}}, \mbox{\hyperlink{test__filter__design_8py_source_l01206}{scipy.\+signal.\+tests.\+test\+\_\+filter\+\_\+design.\+Test\+Normalize.\+test\+\_\+allclose()}}, \mbox{\hyperlink{__lti__conversion_8py_source_l00018}{scipy.\+signal.\+\_\+lti\+\_\+conversion.\+tf2ss()}}, and \mbox{\hyperlink{__filter__design_8py_source_l01026}{tf2zpk()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_ab4b170e32f7fa6684c6c75c54fd0520d}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!sos2tf@{sos2tf}}
\index{sos2tf@{sos2tf}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{sos2tf()}{sos2tf()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_ab4b170e32f7fa6684c6c75c54fd0520d} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+sos2tf (\begin{DoxyParamCaption}\item[{}]{sos}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Return a single transfer function from a series of second-order sections

Parameters
----------
sos : array_like
    Array of second-order filter coefficients, must have shape
    ``(n_sections, 6)``. See `sosfilt` for the SOS filter format
    specification.

Returns
-------
b : ndarray
    Numerator polynomial coefficients.
a : ndarray
    Denominator polynomial coefficients.

Notes
-----
.. versionadded:: 0.16.0
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l01199}{1199}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_aa268051778baf0e9f10a285f6cfd412f}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!sos2zpk@{sos2zpk}}
\index{sos2zpk@{sos2zpk}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{sos2zpk()}{sos2zpk()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_aa268051778baf0e9f10a285f6cfd412f} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+sos2zpk (\begin{DoxyParamCaption}\item[{}]{sos}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Return zeros, poles, and gain of a series of second-order sections

Parameters
----------
sos : array_like
    Array of second-order filter coefficients, must have shape
    ``(n_sections, 6)``. See `sosfilt` for the SOS filter format
    specification.

Returns
-------
z : ndarray
    Zeros of the transfer function.
p : ndarray
    Poles of the transfer function.
k : float
    System gain.

Notes
-----
The number of zeros and poles returned will be ``n_sections * 2``
even if some of these are (effectively) zero.

.. versionadded:: 0.16.0
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l01235}{1235}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.



References \mbox{\hyperlink{__filter__design_8py_source_l01026}{tf2zpk()}}.



Referenced by \mbox{\hyperlink{test__filter__design_8py_source_l00247}{scipy.\+signal.\+tests.\+test\+\_\+filter\+\_\+design.\+Test\+Sos2\+Zpk.\+test\+\_\+fewer\+\_\+zeros()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_aea4c4ed52a5437a54057fd7a094d1936}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!sosfreqz@{sosfreqz}}
\index{sosfreqz@{sosfreqz}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{sosfreqz()}{sosfreqz()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_aea4c4ed52a5437a54057fd7a094d1936} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+sosfreqz (\begin{DoxyParamCaption}\item[{}]{sos}{, }\item[{}]{worN}{ = {\ttfamily 512}, }\item[{}]{whole}{ = {\ttfamily False}, }\item[{}]{fs}{ = {\ttfamily 2\texorpdfstring{$\ast$}{*}pi}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute the frequency response of a digital filter in SOS format.

Given `sos`, an array with shape (n, 6) of second order sections of
a digital filter, compute the frequency response of the system function::

           B0(z)   B1(z)         B{n-1}(z)
    H(z) = ----- * ----- * ... * ---------
           A0(z)   A1(z)         A{n-1}(z)

for z = exp(omega*1j), where B{k}(z) and A{k}(z) are numerator and
denominator of the transfer function of the k-th second order section.

Parameters
----------
sos : array_like
    Array of second-order filter coefficients, must have shape
    ``(n_sections, 6)``. Each row corresponds to a second-order
    section, with the first three columns providing the numerator
    coefficients and the last three providing the denominator
    coefficients.
worN : {None, int, array_like}, optional
    If a single integer, then compute at that many frequencies (default is
    N=512).  Using a number that is fast for FFT computations can result
    in faster computations (see Notes of `freqz`).

    If an array_like, compute the response at the frequencies given (must
    be 1-D). These are in the same units as `fs`.
whole : bool, optional
    Normally, frequencies are computed from 0 to the Nyquist frequency,
    fs/2 (upper-half of unit-circle). If `whole` is True, compute
    frequencies from 0 to fs.
fs : float, optional
    The sampling frequency of the digital system. Defaults to 2*pi
    radians/sample (so w is from 0 to pi).

    .. versionadded:: 1.2.0

Returns
-------
w : ndarray
    The frequencies at which `h` was computed, in the same units as `fs`.
    By default, `w` is normalized to the range [0, pi) (radians/sample).
h : ndarray
    The frequency response, as complex numbers.

See Also
--------
freqz, sosfilt

Notes
-----
.. versionadded:: 0.19.0

Examples
--------
Design a 15th-order bandpass filter in SOS format.

>>> from scipy import signal
>>> import numpy as np
>>> sos = signal.ellip(15, 0.5, 60, (0.2, 0.4), btype='bandpass',
...                    output='sos')

Compute the frequency response at 1500 points from DC to Nyquist.

>>> w, h = signal.sosfreqz(sos, worN=1500)

Plot the response.

>>> import matplotlib.pyplot as plt
>>> plt.subplot(2, 1, 1)
>>> db = 20*np.log10(np.maximum(np.abs(h), 1e-5))
>>> plt.plot(w/np.pi, db)
>>> plt.ylim(-75, 5)
>>> plt.grid(True)
>>> plt.yticks([0, -20, -40, -60])
>>> plt.ylabel('Gain [dB]')
>>> plt.title('Frequency Response')
>>> plt.subplot(2, 1, 2)
>>> plt.plot(w/np.pi, np.angle(h))
>>> plt.grid(True)
>>> plt.yticks([-np.pi, -0.5*np.pi, 0, 0.5*np.pi, np.pi],
...            [r'$-\pi$', r'$-\pi/2$', '0', r'$\pi/2$', r'$\pi$'])
>>> plt.ylabel('Phase [rad]')
>>> plt.xlabel('Normalized frequency (1.0 = Nyquist)')
>>> plt.show()

If the same filter is implemented as a single transfer function,
numerical error corrupts the frequency response:

>>> b, a = signal.ellip(15, 0.5, 60, (0.2, 0.4), btype='bandpass',
...                    output='ba')
>>> w, h = signal.freqz(b, a, worN=1500)
>>> plt.subplot(2, 1, 1)
>>> db = 20*np.log10(np.maximum(np.abs(h), 1e-5))
>>> plt.plot(w/np.pi, db)
>>> plt.ylim(-75, 5)
>>> plt.grid(True)
>>> plt.yticks([0, -20, -40, -60])
>>> plt.ylabel('Gain [dB]')
>>> plt.title('Frequency Response')
>>> plt.subplot(2, 1, 2)
>>> plt.plot(w/np.pi, np.angle(h))
>>> plt.grid(True)
>>> plt.yticks([-np.pi, -0.5*np.pi, 0, 0.5*np.pi, np.pi],
...            [r'$-\pi$', r'$-\pi/2$', '0', r'$\pi/2$', r'$\pi$'])
>>> plt.ylabel('Phase [rad]')
>>> plt.xlabel('Normalized frequency (1.0 = Nyquist)')
>>> plt.show()
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l00731}{731}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.



References \mbox{\hyperlink{__filter__design_8py_source_l00718}{\+\_\+validate\+\_\+sos()}}, and \mbox{\hyperlink{__filter__design_8py_source_l00277}{freqz()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_a91eaf3cecda0b1314ae9abe837e7a074}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!tf2sos@{tf2sos}}
\index{tf2sos@{tf2sos}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{tf2sos()}{tf2sos()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_a91eaf3cecda0b1314ae9abe837e7a074} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+tf2sos (\begin{DoxyParamCaption}\item[{}]{b}{, }\item[{}]{a}{, }\item[{}]{pairing}{ = {\ttfamily None}, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{analog}{ = {\ttfamily False}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Return second-order sections from transfer function representation

Parameters
----------
b : array_like
    Numerator polynomial coefficients.
a : array_like
    Denominator polynomial coefficients.
pairing : {None, 'nearest', 'keep_odd', 'minimal'}, optional
    The method to use to combine pairs of poles and zeros into sections.
    See `zpk2sos` for information and restrictions on `pairing` and
    `analog` arguments.
analog : bool, optional
    If True, system is analog, otherwise discrete.

    .. versionadded:: 1.8.0

Returns
-------
sos : ndarray
    Array of second-order filter coefficients, with shape
    ``(n_sections, 6)``. See `sosfilt` for the SOS filter format
    specification.

See Also
--------
zpk2sos, sosfilt

Notes
-----
It is generally discouraged to convert from TF to SOS format, since doing
so usually will not improve numerical precision errors. Instead, consider
designing filters in ZPK format and converting directly to SOS. TF is
converted to SOS by first converting to ZPK format, then converting
ZPK to SOS.

.. versionadded:: 0.16.0
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l01156}{1156}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.



References \mbox{\hyperlink{__filter__design_8py_source_l01026}{tf2zpk()}}, and \mbox{\hyperlink{__filter__design_8py_source_l01297}{zpk2sos()}}.



Referenced by \mbox{\hyperlink{test__signaltools_8py_source_l03344}{scipy.\+signal.\+tests.\+test\+\_\+signaltools.\+assert\+\_\+allclose\+\_\+cast()}}, and \mbox{\hyperlink{test__signaltools_8py_source_l03330}{scipy.\+signal.\+tests.\+test\+\_\+signaltools.\+cast\+\_\+tf2sos()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_afd8e35038fae8873d10b7f7be6b8ca8f}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!tf2zpk@{tf2zpk}}
\index{tf2zpk@{tf2zpk}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{tf2zpk()}{tf2zpk()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_afd8e35038fae8873d10b7f7be6b8ca8f} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+tf2zpk (\begin{DoxyParamCaption}\item[{}]{b}{, }\item[{}]{a}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Return zero, pole, gain (z, p, k) representation from a numerator,
denominator representation of a linear filter.

Parameters
----------
b : array_like
    Numerator polynomial coefficients.
a : array_like
    Denominator polynomial coefficients.

Returns
-------
z : ndarray
    Zeros of the transfer function.
p : ndarray
    Poles of the transfer function.
k : float
    System gain.

Notes
-----
If some values of `b` are too close to 0, they are removed. In that case,
a BadCoefficients warning is emitted.

The `b` and `a` arrays are interpreted as coefficients for positive,
descending powers of the transfer function variable. So the inputs
:math:`b = [b_0, b_1, ..., b_M]` and :math:`a =[a_0, a_1, ..., a_N]`
can represent an analog filter of the form:

.. math::

    H(s) = \frac
    {b_0 s^M + b_1 s^{(M-1)} + \cdots + b_M}
    {a_0 s^N + a_1 s^{(N-1)} + \cdots + a_N}

or a discrete-time filter of the form:

.. math::

    H(z) = \frac
    {b_0 z^M + b_1 z^{(M-1)} + \cdots + b_M}
    {a_0 z^N + a_1 z^{(N-1)} + \cdots + a_N}

This "positive powers" form is found more commonly in controls
engineering. If `M` and `N` are equal (which is true for all filters
generated by the bilinear transform), then this happens to be equivalent
to the "negative powers" discrete-time form preferred in DSP:

.. math::

    H(z) = \frac
    {b_0 + b_1 z^{-1} + \cdots + b_M z^{-M}}
    {a_0 + a_1 z^{-1} + \cdots + a_N z^{-N}}

Although this is true for common filters, remember that this is not true
in the general case. If `M` and `N` are not equal, the discrete-time
transfer function coefficients must first be converted to the "positive
powers" form before finding the poles and zeros.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l01026}{1026}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.



References \mbox{\hyperlink{__filter__design_8py_source_l01661}{normalize()}}.



Referenced by \mbox{\hyperlink{__filter__design_8py_source_l01235}{sos2zpk()}}, \mbox{\hyperlink{__lti__conversion_8py_source_l00305}{scipy.\+signal.\+\_\+lti\+\_\+conversion.\+ss2zpk()}}, \mbox{\hyperlink{__filter__design_8py_source_l01156}{tf2sos()}}, and \mbox{\hyperlink{__ltisys_8py_source_l00662}{scipy.\+signal.\+\_\+ltisys.\+Transfer\+Function.\+to\+\_\+zpk()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_a63c5cc73d85694103d8943b59e3c3fe4}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!yulewalk@{yulewalk}}
\index{yulewalk@{yulewalk}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{yulewalk()}{yulewalk()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_a63c5cc73d85694103d8943b59e3c3fe4} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+yulewalk (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}



Definition at line \mbox{\hyperlink{__filter__design_8py_source_l03627}{3627}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_a0815bb39a494870b6e7a09e38ac2d417}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!zpk2sos@{zpk2sos}}
\index{zpk2sos@{zpk2sos}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{zpk2sos()}{zpk2sos()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_a0815bb39a494870b6e7a09e38ac2d417} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+zpk2sos (\begin{DoxyParamCaption}\item[{}]{z}{, }\item[{}]{p}{, }\item[{}]{k}{, }\item[{}]{pairing}{ = {\ttfamily None}, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{analog}{ = {\ttfamily False}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Return second-order sections from zeros, poles, and gain of a system

Parameters
----------
z : array_like
    Zeros of the transfer function.
p : array_like
    Poles of the transfer function.
k : float
    System gain.
pairing : {None, 'nearest', 'keep_odd', 'minimal'}, optional
    The method to use to combine pairs of poles and zeros into sections.
    If analog is False and pairing is None, pairing is set to 'nearest';
    if analog is True, pairing must be 'minimal', and is set to that if
    it is None.
analog : bool, optional
    If True, system is analog, otherwise discrete.

    .. versionadded:: 1.8.0

Returns
-------
sos : ndarray
    Array of second-order filter coefficients, with shape
    ``(n_sections, 6)``. See `sosfilt` for the SOS filter format
    specification.

See Also
--------
sosfilt

Notes
-----
The algorithm used to convert ZPK to SOS format is designed to
minimize errors due to numerical precision issues. The pairing
algorithm attempts to minimize the peak gain of each biquadratic
section. This is done by pairing poles with the nearest zeros, starting
with the poles closest to the unit circle for discrete-time systems, and
poles closest to the imaginary axis for continuous-time systems.

``pairing='minimal'`` outputs may not be suitable for `sosfilt`,
and ``analog=True`` outputs will never be suitable for `sosfilt`.

*Algorithms*

The steps in the ``pairing='nearest'``, ``pairing='keep_odd'``,
and ``pairing='minimal'`` algorithms are mostly shared. The
``'nearest'`` algorithm attempts to minimize the peak gain, while
``'keep_odd'`` minimizes peak gain under the constraint that
odd-order systems should retain one section as first order.
``'minimal'`` is similar to ``'keep_odd'``, but no additional
poles or zeros are introduced

The algorithm steps are as follows:

As a pre-processing step for ``pairing='nearest'``,
``pairing='keep_odd'``, add poles or zeros to the origin as
necessary to obtain the same number of poles and zeros for
pairing.  If ``pairing == 'nearest'`` and there are an odd number
of poles, add an additional pole and a zero at the origin.

The following steps are then iterated over until no more poles or
zeros remain:

1. Take the (next remaining) pole (complex or real) closest to the
   unit circle (or imaginary axis, for ``analog=True``) to
   begin a new filter section.

2. If the pole is real and there are no other remaining real poles [#]_,
   add the closest real zero to the section and leave it as a first
   order section. Note that after this step we are guaranteed to be
   left with an even number of real poles, complex poles, real zeros,
   and complex zeros for subsequent pairing iterations.

3. Else:

    1. If the pole is complex and the zero is the only remaining real
       zero*, then pair the pole with the *next* closest zero
       (guaranteed to be complex). This is necessary to ensure that
       there will be a real zero remaining to eventually create a
       first-order section (thus keeping the odd order).

    2. Else pair the pole with the closest remaining zero (complex or
       real).

    3. Proceed to complete the second-order section by adding another
       pole and zero to the current pole and zero in the section:

        1. If the current pole and zero are both complex, add their
           conjugates.

        2. Else if the pole is complex and the zero is real, add the
           conjugate pole and the next closest real zero.

        3. Else if the pole is real and the zero is complex, add the
           conjugate zero and the real pole closest to those zeros.

        4. Else (we must have a real pole and real zero) add the next
           real pole closest to the unit circle, and then add the real
           zero closest to that pole.

.. [#] This conditional can only be met for specific odd-order inputs
       with the ``pairing = 'keep_odd'`` or ``'minimal'`` methods.

.. versionadded:: 0.16.0

Examples
--------

Design a 6th order low-pass elliptic digital filter for a system with a
sampling rate of 8000 Hz that has a pass-band corner frequency of
1000 Hz. The ripple in the pass-band should not exceed 0.087 dB, and
the attenuation in the stop-band should be at least 90 dB.

In the following call to `ellip`, we could use ``output='sos'``,
but for this example, we'll use ``output='zpk'``, and then convert
to SOS format with `zpk2sos`:

>>> from scipy import signal
>>> import numpy as np
>>> z, p, k = signal.ellip(6, 0.087, 90, 1000/(0.5*8000), output='zpk')

Now convert to SOS format.

>>> sos = signal.zpk2sos(z, p, k)

The coefficients of the numerators of the sections:

>>> sos[:, :3]
array([[0.0014152 , 0.00248677, 0.0014152 ],
       [1.        , 0.72976874, 1.        ],
       [1.        , 0.17607852, 1.        ]])

The symmetry in the coefficients occurs because all the zeros are on the
unit circle.

The coefficients of the denominators of the sections:

>>> sos[:, 3:]
array([[ 1.        , -1.32544025,  0.46989976],
       [ 1.        , -1.26118294,  0.62625924],
       [ 1.        , -1.2570723 ,  0.8619958 ]])

The next example shows the effect of the `pairing` option.  We have a
system with three poles and three zeros, so the SOS array will have
shape (2, 6). The means there is, in effect, an extra pole and an extra
zero at the origin in the SOS representation.

>>> z1 = np.array([-1, -0.5-0.5j, -0.5+0.5j])
>>> p1 = np.array([0.75, 0.8+0.1j, 0.8-0.1j])

With ``pairing='nearest'`` (the default), we obtain

>>> signal.zpk2sos(z1, p1, 1)
array([[ 1.  ,  1.  ,  0.5 ,  1.  , -0.75,  0.  ],
       [ 1.  ,  1.  ,  0.  ,  1.  , -1.6 ,  0.65]])

The first section has the zeros {-0.5-0.05j, -0.5+0.5j} and the poles
{0, 0.75}, and the second section has the zeros {-1, 0} and poles
{0.8+0.1j, 0.8-0.1j}. Note that the extra pole and zero at the origin
have been assigned to different sections.

With ``pairing='keep_odd'``, we obtain:

>>> signal.zpk2sos(z1, p1, 1, pairing='keep_odd')
array([[ 1.  ,  1.  ,  0.  ,  1.  , -0.75,  0.  ],
       [ 1.  ,  1.  ,  0.5 ,  1.  , -1.6 ,  0.65]])

The extra pole and zero at the origin are in the same section.
The first section is, in effect, a first-order section.

With ``pairing='minimal'``, the first-order section doesn't have
the extra pole and zero at the origin:

>>> signal.zpk2sos(z1, p1, 1, pairing='minimal')
array([[ 0.  ,  1.  ,  1.  ,  0.  ,  1.  , -0.75],
       [ 1.  ,  1.  ,  0.5 ,  1.  , -1.6 ,  0.65]])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l01297}{1297}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.



References \mbox{\hyperlink{__filter__design_8py_source_l00854}{\+\_\+cplxreal()}}, \mbox{\hyperlink{__filter__design_8py_source_l01275}{\+\_\+nearest\+\_\+real\+\_\+complex\+\_\+idx()}}, and \mbox{\hyperlink{__filter__design_8py_source_l01288}{\+\_\+single\+\_\+zpksos()}}.



Referenced by \mbox{\hyperlink{__signaltools_8py_source_l04458}{scipy.\+signal.\+\_\+signaltools.\+decimate()}}, \mbox{\hyperlink{__filter__design_8py_source_l02362}{iirfilter()}}, \mbox{\hyperlink{test__signaltools_8py_source_l02370}{scipy.\+signal.\+tests.\+test\+\_\+signaltools.\+Test\+SOSFilt\+Filt.\+test\+\_\+equivalence()}}, and \mbox{\hyperlink{__filter__design_8py_source_l01156}{tf2sos()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_a3bf4baf8dc505f8b2ef88845ec55d645}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!zpk2tf@{zpk2tf}}
\index{zpk2tf@{zpk2tf}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{zpk2tf()}{zpk2tf()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_a3bf4baf8dc505f8b2ef88845ec55d645} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+zpk2tf (\begin{DoxyParamCaption}\item[{}]{z}{, }\item[{}]{p}{, }\item[{}]{k}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Return polynomial transfer function representation from zeros and poles

Parameters
----------
z : array_like
    Zeros of the transfer function.
p : array_like
    Poles of the transfer function.
k : float
    System gain.

Returns
-------
b : ndarray
    Numerator polynomial coefficients.
a : ndarray
    Denominator polynomial coefficients.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__filter__design_8py_source_l01097}{1097}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.



Referenced by \mbox{\hyperlink{__filter__design_8py_source_l01288}{\+\_\+single\+\_\+zpksos()}}, \mbox{\hyperlink{test__signaltools_8py_source_l02382}{scipy.\+signal.\+tests.\+test\+\_\+signaltools.\+filtfilt\+\_\+gust\+\_\+opt()}}, \mbox{\hyperlink{__filter__design_8py_source_l02362}{iirfilter()}}, \mbox{\hyperlink{test__signaltools_8py_source_l02370}{scipy.\+signal.\+tests.\+test\+\_\+signaltools.\+Test\+SOSFilt\+Filt.\+test\+\_\+equivalence()}}, \mbox{\hyperlink{test__filter__design_8py_source_l00193}{scipy.\+signal.\+tests.\+test\+\_\+filter\+\_\+design.\+Test\+Zpk2\+Tf.\+test\+\_\+identity()}}, \mbox{\hyperlink{__ltisys_8py_source_l01044}{scipy.\+signal.\+\_\+ltisys.\+Zeros\+Poles\+Gain.\+to\+\_\+tf()}}, and \mbox{\hyperlink{__lti__conversion_8py_source_l00285}{scipy.\+signal.\+\_\+lti\+\_\+conversion.\+zpk2ss()}}.



\doxysubsection{Variable Documentation}
\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_ae64ec8303b2fa79a24aad5e9317b68e5}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!\_\_all\_\_@{\_\_all\_\_}}
\index{\_\_all\_\_@{\_\_all\_\_}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{\_\_all\_\_}{\_\_all\_\_}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_ae64ec8303b2fa79a24aad5e9317b68e5} 
list scipy.\+signal.\+\_\+filter\+\_\+design.\+\_\+\+\_\+all\+\_\+\+\_\+\hspace{0.3cm}{\ttfamily [private]}}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ [\textcolor{stringliteral}{'findfreqs'},\ \textcolor{stringliteral}{'freqs'},\ \textcolor{stringliteral}{'freqz'},\ \textcolor{stringliteral}{'tf2zpk'},\ \textcolor{stringliteral}{'zpk2tf'},\ \textcolor{stringliteral}{'normalize'},}
\DoxyCodeLine{00002\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'lp2lp'},\ \textcolor{stringliteral}{'lp2hp'},\ \textcolor{stringliteral}{'lp2bp'},\ \textcolor{stringliteral}{'lp2bs'},\ \textcolor{stringliteral}{'bilinear'},\ \textcolor{stringliteral}{'iirdesign'},}
\DoxyCodeLine{00003\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'iirfilter'},\ \textcolor{stringliteral}{'butter'},\ \textcolor{stringliteral}{'cheby1'},\ \textcolor{stringliteral}{'cheby2'},\ \textcolor{stringliteral}{'ellip'},\ \textcolor{stringliteral}{'bessel'},}
\DoxyCodeLine{00004\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'band\_stop\_obj'},\ \textcolor{stringliteral}{'buttord'},\ \textcolor{stringliteral}{'cheb1ord'},\ \textcolor{stringliteral}{'cheb2ord'},\ \textcolor{stringliteral}{'ellipord'},}
\DoxyCodeLine{00005\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'buttap'},\ \textcolor{stringliteral}{'cheb1ap'},\ \textcolor{stringliteral}{'cheb2ap'},\ \textcolor{stringliteral}{'ellipap'},\ \textcolor{stringliteral}{'besselap'},}
\DoxyCodeLine{00006\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'BadCoefficients'},\ \textcolor{stringliteral}{'freqs\_zpk'},\ \textcolor{stringliteral}{'freqz\_zpk'},}
\DoxyCodeLine{00007\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'tf2sos'},\ \textcolor{stringliteral}{'sos2tf'},\ \textcolor{stringliteral}{'zpk2sos'},\ \textcolor{stringliteral}{'sos2zpk'},\ \textcolor{stringliteral}{'group\_delay'},}
\DoxyCodeLine{00008\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'sosfreqz'},\ \textcolor{stringliteral}{'iirnotch'},\ \textcolor{stringliteral}{'iirpeak'},\ \textcolor{stringliteral}{'bilinear\_zpk'},}
\DoxyCodeLine{00009\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'lp2lp\_zpk'},\ \textcolor{stringliteral}{'lp2hp\_zpk'},\ \textcolor{stringliteral}{'lp2bp\_zpk'},\ \textcolor{stringliteral}{'lp2bs\_zpk'},}
\DoxyCodeLine{00010\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'gammatone'},\ \textcolor{stringliteral}{'iircomb'}]}

\end{DoxyCode}


Definition at line \mbox{\hyperlink{__filter__design_8py_source_l00021}{21}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_a7652e5119bd8574ea5fb53c49d2cd3f9}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!\_ARC\_JAC\_SN\_MAXITER@{\_ARC\_JAC\_SN\_MAXITER}}
\index{\_ARC\_JAC\_SN\_MAXITER@{\_ARC\_JAC\_SN\_MAXITER}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{\_ARC\_JAC\_SN\_MAXITER}{\_ARC\_JAC\_SN\_MAXITER}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_a7652e5119bd8574ea5fb53c49d2cd3f9} 
int scipy.\+signal.\+\_\+filter\+\_\+design.\+\_\+\+ARC\+\_\+\+JAC\+\_\+\+SN\+\_\+\+MAXITER = 10\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{__filter__design_8py_source_l04460}{4460}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_a2488f153d8ae94e3316797a1661dbb30}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!\_ELLIPDEG\_MMAX@{\_ELLIPDEG\_MMAX}}
\index{\_ELLIPDEG\_MMAX@{\_ELLIPDEG\_MMAX}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{\_ELLIPDEG\_MMAX}{\_ELLIPDEG\_MMAX}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_a2488f153d8ae94e3316797a1661dbb30} 
int scipy.\+signal.\+\_\+filter\+\_\+design.\+\_\+\+ELLIPDEG\+\_\+\+MMAX = 7\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{__filter__design_8py_source_l04425}{4425}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_a76ecc62801ca1a598f57e1e89c3f862a}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!\_POW10\_LOG10@{\_POW10\_LOG10}}
\index{\_POW10\_LOG10@{\_POW10\_LOG10}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{\_POW10\_LOG10}{\_POW10\_LOG10}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_a76ecc62801ca1a598f57e1e89c3f862a} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+\_\+\+POW10\+\_\+\+LOG10 = np.\+log(10)\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{__filter__design_8py_source_l04173}{4173}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_ae0755694c5f3c0fd7ffccc146d000962}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!abs@{abs}}
\index{abs@{abs}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{abs}{abs}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_ae0755694c5f3c0fd7ffccc146d000962} 
scipy.\+signal.\+\_\+filter\+\_\+design.\+abs = absolute}



Definition at line \mbox{\hyperlink{__filter__design_8py_source_l00038}{38}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_a9f2e025a5a7ab98adda5a652673c1c95}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!band\_dict@{band\_dict}}
\index{band\_dict@{band\_dict}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{band\_dict}{band\_dict}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_a9f2e025a5a7ab98adda5a652673c1c95} 
dict scipy.\+signal.\+\_\+filter\+\_\+design.\+band\+\_\+dict}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ \{\textcolor{stringliteral}{'band'}:\ \textcolor{stringliteral}{'bandpass'},}
\DoxyCodeLine{00002\ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'bandpass'}:\ \textcolor{stringliteral}{'bandpass'},}
\DoxyCodeLine{00003\ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'pass'}:\ \textcolor{stringliteral}{'bandpass'},}
\DoxyCodeLine{00004\ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'bp'}:\ \textcolor{stringliteral}{'bandpass'},}
\DoxyCodeLine{00005\ }
\DoxyCodeLine{00006\ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'bs'}:\ \textcolor{stringliteral}{'bandstop'},}
\DoxyCodeLine{00007\ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'bandstop'}:\ \textcolor{stringliteral}{'bandstop'},}
\DoxyCodeLine{00008\ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'bands'}:\ \textcolor{stringliteral}{'bandstop'},}
\DoxyCodeLine{00009\ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'stop'}:\ \textcolor{stringliteral}{'bandstop'},}
\DoxyCodeLine{00010\ }
\DoxyCodeLine{00011\ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'l'}:\ \textcolor{stringliteral}{'lowpass'},}
\DoxyCodeLine{00012\ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'low'}:\ \textcolor{stringliteral}{'lowpass'},}
\DoxyCodeLine{00013\ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'lowpass'}:\ \textcolor{stringliteral}{'lowpass'},}
\DoxyCodeLine{00014\ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'lp'}:\ \textcolor{stringliteral}{'lowpass'},}
\DoxyCodeLine{00015\ }
\DoxyCodeLine{00016\ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'high'}:\ \textcolor{stringliteral}{'highpass'},}
\DoxyCodeLine{00017\ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'highpass'}:\ \textcolor{stringliteral}{'highpass'},}
\DoxyCodeLine{00018\ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'h'}:\ \textcolor{stringliteral}{'highpass'},}
\DoxyCodeLine{00019\ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'hp'}:\ \textcolor{stringliteral}{'highpass'},}
\DoxyCodeLine{00020\ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}

\end{DoxyCode}


Definition at line \mbox{\hyperlink{__filter__design_8py_source_l05598}{5598}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_af27e4e2de443cd81d20e5da16eeae926}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!bessel\_norms@{bessel\_norms}}
\index{bessel\_norms@{bessel\_norms}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{bessel\_norms}{bessel\_norms}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_af27e4e2de443cd81d20e5da16eeae926} 
dict scipy.\+signal.\+\_\+filter\+\_\+design.\+bessel\+\_\+norms}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ \{\textcolor{stringliteral}{'bessel'}:\ \textcolor{stringliteral}{'phase'},}
\DoxyCodeLine{00002\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'bessel\_phase'}:\ \textcolor{stringliteral}{'phase'},}
\DoxyCodeLine{00003\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'bessel\_delay'}:\ \textcolor{stringliteral}{'delay'},}
\DoxyCodeLine{00004\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'bessel\_mag'}:\ \textcolor{stringliteral}{'mag'}\}}

\end{DoxyCode}


Definition at line \mbox{\hyperlink{__filter__design_8py_source_l05619}{5619}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_a6345627611c9584ab49581b89d6133e3}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!EPSILON@{EPSILON}}
\index{EPSILON@{EPSILON}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{EPSILON}{EPSILON}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_a6345627611c9584ab49581b89d6133e3} 
int scipy.\+signal.\+\_\+filter\+\_\+design.\+EPSILON = 2e-\/16}



Definition at line \mbox{\hyperlink{__filter__design_8py_source_l04422}{4422}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.

\Hypertarget{namespacescipy_1_1signal_1_1__filter__design_a1997d304fd4096c170a317286c5ddefc}\index{scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}!filter\_dict@{filter\_dict}}
\index{filter\_dict@{filter\_dict}!scipy.signal.\_filter\_design@{scipy.signal.\_filter\_design}}
\doxysubsubsection{\texorpdfstring{filter\_dict}{filter\_dict}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__filter__design_a1997d304fd4096c170a317286c5ddefc} 
dict scipy.\+signal.\+\_\+filter\+\_\+design.\+filter\+\_\+dict}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ \{\textcolor{stringliteral}{'butter'}:\ [buttap,\ buttord],}
\DoxyCodeLine{00002\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'butterworth'}:\ [buttap,\ buttord],}
\DoxyCodeLine{00003\ }
\DoxyCodeLine{00004\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'cauer'}:\ [ellipap,\ ellipord],}
\DoxyCodeLine{00005\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'elliptic'}:\ [ellipap,\ ellipord],}
\DoxyCodeLine{00006\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'ellip'}:\ [ellipap,\ ellipord],}
\DoxyCodeLine{00007\ }
\DoxyCodeLine{00008\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'bessel'}:\ [besselap],}
\DoxyCodeLine{00009\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'bessel\_phase'}:\ [besselap],}
\DoxyCodeLine{00010\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'bessel\_delay'}:\ [besselap],}
\DoxyCodeLine{00011\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'bessel\_mag'}:\ [besselap],}
\DoxyCodeLine{00012\ }
\DoxyCodeLine{00013\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'cheby1'}:\ [cheb1ap,\ cheb1ord],}
\DoxyCodeLine{00014\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'chebyshev1'}:\ [cheb1ap,\ cheb1ord],}
\DoxyCodeLine{00015\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'chebyshevi'}:\ [cheb1ap,\ cheb1ord],}
\DoxyCodeLine{00016\ }
\DoxyCodeLine{00017\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'cheby2'}:\ [cheb2ap,\ cheb2ord],}
\DoxyCodeLine{00018\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'chebyshev2'}:\ [cheb2ap,\ cheb2ord],}
\DoxyCodeLine{00019\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'chebyshevii'}:\ [cheb2ap,\ cheb2ord],}
\DoxyCodeLine{00020\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}

\end{DoxyCode}


Definition at line \mbox{\hyperlink{__filter__design_8py_source_l05577}{5577}} of file \mbox{\hyperlink{__filter__design_8py_source}{\+\_\+filter\+\_\+design.\+py}}.

