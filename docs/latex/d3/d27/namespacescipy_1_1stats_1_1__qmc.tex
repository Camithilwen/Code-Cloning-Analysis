\doxysection{scipy.\+stats.\+\_\+qmc Namespace Reference}
\hypertarget{namespacescipy_1_1stats_1_1__qmc}{}\label{namespacescipy_1_1stats_1_1__qmc}\index{scipy.stats.\_qmc@{scipy.stats.\_qmc}}
\doxysubsubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classscipy_1_1stats_1_1__qmc_1_1Halton}{Halton}}
\item 
class \mbox{\hyperlink{classscipy_1_1stats_1_1__qmc_1_1LatinHypercube}{Latin\+Hypercube}}
\item 
class \mbox{\hyperlink{classscipy_1_1stats_1_1__qmc_1_1MultinomialQMC}{Multinomial\+QMC}}
\item 
class \mbox{\hyperlink{classscipy_1_1stats_1_1__qmc_1_1MultivariateNormalQMC}{Multivariate\+Normal\+QMC}}
\item 
class \mbox{\hyperlink{classscipy_1_1stats_1_1__qmc_1_1PoissonDisk}{Poisson\+Disk}}
\item 
class \mbox{\hyperlink{classscipy_1_1stats_1_1__qmc_1_1QMCEngine}{QMCEngine}}
\item 
class \mbox{\hyperlink{classscipy_1_1stats_1_1__qmc_1_1Sobol}{Sobol}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
np.\+random.\+Generator \mbox{\hyperlink{namespacescipy_1_1stats_1_1__qmc_a99530aabb901c029b9c24e5cc9f0f5ec}{check\+\_\+random\+\_\+state}} (Int\+Number\texorpdfstring{$\vert$}{|}None seed=...)
\item 
Generator\+Type \mbox{\hyperlink{namespacescipy_1_1stats_1_1__qmc_a2f2c5dc8605784ba0fdf9936b59df395}{check\+\_\+random\+\_\+state}} (Generator\+Type seed)
\item 
\mbox{\hyperlink{namespacescipy_1_1stats_1_1__qmc_a1af3e5c60b0fbc5c4d257feb9e2a9423}{check\+\_\+random\+\_\+state}} (seed=None)
\item 
np.\+ndarray \mbox{\hyperlink{namespacescipy_1_1stats_1_1__qmc_ae76f690673ebcc776891798b0e128d4a}{scale}} (npt.\+Array\+Like sample, npt.\+Array\+Like l\+\_\+bounds, npt.\+Array\+Like u\+\_\+bounds, \texorpdfstring{$\ast$}{*}, bool reverse=False)
\item 
float \mbox{\hyperlink{namespacescipy_1_1stats_1_1__qmc_a9bba96ae85ce5dcf83d9960340b9298c}{discrepancy}} (npt.\+Array\+Like sample, \texorpdfstring{$\ast$}{*}, bool iterative=False, Literal\mbox{[}"{}CD"{}, "{}WD"{}, "{}MD"{}, "{}L2-\/star"{}\mbox{]} method="{}CD"{}, Int\+Number workers=1)
\item 
float \mbox{\hyperlink{namespacescipy_1_1stats_1_1__qmc_a33205602634d9d5ce04705a48d798551}{update\+\_\+discrepancy}} (npt.\+Array\+Like x\+\_\+new, npt.\+Array\+Like sample, Decimal\+Number initial\+\_\+disc)
\item 
\mbox{\hyperlink{namespacescipy_1_1stats_1_1__qmc_a5c28a8dac5cfeaeacca8c1cf345f9b05}{\+\_\+perturb\+\_\+discrepancy}} (np.\+ndarray sample, int i1, int i2, int k, float disc)
\item 
np.\+ndarray \mbox{\hyperlink{namespacescipy_1_1stats_1_1__qmc_a73db6f8ac0e878841d09657004b0649c}{primes\+\_\+from\+\_\+2\+\_\+to}} (int n)
\item 
list\mbox{[}int\mbox{]} \mbox{\hyperlink{namespacescipy_1_1stats_1_1__qmc_a4a2a87897d180c083d702531cdca44cf}{n\+\_\+primes}} (Int\+Number n)
\item 
np.\+ndarray \mbox{\hyperlink{namespacescipy_1_1stats_1_1__qmc_aac2dadc825d19fe30b9e0ab9f0c35df3}{\+\_\+van\+\_\+der\+\_\+corput\+\_\+permutations}} (Int\+Number base, \texorpdfstring{$\ast$}{*}, Seed\+Type random\+\_\+state=None)
\item 
np.\+ndarray \mbox{\hyperlink{namespacescipy_1_1stats_1_1__qmc_a43c0482d0724d18fd957cd241692c0b2}{van\+\_\+der\+\_\+corput}} (Int\+Number n, Int\+Number base=2, \texorpdfstring{$\ast$}{*}, Int\+Number start\+\_\+index=0, bool scramble=False, npt.\+Array\+Like\texorpdfstring{$\vert$}{|}None permutations=None, Seed\+Type seed=None, Int\+Number workers=1)
\item 
Callable\texorpdfstring{$\vert$}{|}None \mbox{\hyperlink{namespacescipy_1_1stats_1_1__qmc_a4f12c2d08735f2790606871d9c479dfb}{\+\_\+select\+\_\+optimizer}} (Literal\mbox{[}"{}random-\/cd"{}, "{}lloyd"{}\mbox{]}\texorpdfstring{$\vert$}{|}None optimization, dict config)
\item 
np.\+ndarray \mbox{\hyperlink{namespacescipy_1_1stats_1_1__qmc_a7a6cb5783a79ae04ed930416584199f1}{\+\_\+random\+\_\+cd}} (np.\+ndarray best\+\_\+sample, int n\+\_\+iters, int n\+\_\+nochange, Generator\+Type rng, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}dict kwargs)
\item 
float \mbox{\hyperlink{namespacescipy_1_1stats_1_1__qmc_a1560e2d0fcca8df9754edd2c64589cf6}{\+\_\+l1\+\_\+norm}} (np.\+ndarray sample)
\item 
np.\+ndarray \mbox{\hyperlink{namespacescipy_1_1stats_1_1__qmc_a939675ced92e21d78912310257cf3708}{\+\_\+lloyd\+\_\+iteration}} (np.\+ndarray sample, float decay, str qhull\+\_\+options)
\item 
np.\+ndarray \mbox{\hyperlink{namespacescipy_1_1stats_1_1__qmc_a890631119b89c4f4f62bb023ad6c60f1}{\+\_\+lloyd\+\_\+centroidal\+\_\+voronoi\+\_\+tessellation}} (npt.\+Array\+Like sample, \texorpdfstring{$\ast$}{*}, Decimal\+Number tol=1e-\/5, Int\+Number maxiter=10, str\texorpdfstring{$\vert$}{|}None qhull\+\_\+options=None, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}dict kwargs)
\item 
Int\+Number \mbox{\hyperlink{namespacescipy_1_1stats_1_1__qmc_a50556dec8eaef56be3606788d98bd945}{\+\_\+validate\+\_\+workers}} (Int\+Number workers=1)
\item 
tuple\mbox{[}np.\+ndarray,...\mbox{]} \mbox{\hyperlink{namespacescipy_1_1stats_1_1__qmc_a8c10cc54f2dedf13beea8285ed2fe079}{\+\_\+validate\+\_\+bounds}} (npt.\+Array\+Like l\+\_\+bounds, npt.\+Array\+Like u\+\_\+bounds, int d)
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
list \mbox{\hyperlink{namespacescipy_1_1stats_1_1__qmc_a70091f28f1441e9df78adfb2a6c2e02b}{\+\_\+\+\_\+all\+\_\+\+\_\+}}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\begin{DoxyVerb}Quasi-Monte Carlo engines and helpers.\end{DoxyVerb}
 

\doxysubsection{Function Documentation}
\Hypertarget{namespacescipy_1_1stats_1_1__qmc_a1560e2d0fcca8df9754edd2c64589cf6}\index{scipy.stats.\_qmc@{scipy.stats.\_qmc}!\_l1\_norm@{\_l1\_norm}}
\index{\_l1\_norm@{\_l1\_norm}!scipy.stats.\_qmc@{scipy.stats.\_qmc}}
\doxysubsubsection{\texorpdfstring{\_l1\_norm()}{\_l1\_norm()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1stats_1_1__qmc_a1560e2d0fcca8df9754edd2c64589cf6} 
 float scipy.\+stats.\+\_\+qmc.\+\_\+l1\+\_\+norm (\begin{DoxyParamCaption}\item[{np.\+ndarray}]{sample}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{__qmc_8py_source_l02373}{2373}} of file \mbox{\hyperlink{__qmc_8py_source}{\+\_\+qmc.\+py}}.

\Hypertarget{namespacescipy_1_1stats_1_1__qmc_a890631119b89c4f4f62bb023ad6c60f1}\index{scipy.stats.\_qmc@{scipy.stats.\_qmc}!\_lloyd\_centroidal\_voronoi\_tessellation@{\_lloyd\_centroidal\_voronoi\_tessellation}}
\index{\_lloyd\_centroidal\_voronoi\_tessellation@{\_lloyd\_centroidal\_voronoi\_tessellation}!scipy.stats.\_qmc@{scipy.stats.\_qmc}}
\doxysubsubsection{\texorpdfstring{\_lloyd\_centroidal\_voronoi\_tessellation()}{\_lloyd\_centroidal\_voronoi\_tessellation()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1stats_1_1__qmc_a890631119b89c4f4f62bb023ad6c60f1} 
 np.\+ndarray scipy.\+stats.\+\_\+qmc.\+\_\+lloyd\+\_\+centroidal\+\_\+voronoi\+\_\+tessellation (\begin{DoxyParamCaption}\item[{npt.\+Array\+Like}]{sample}{, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{Decimal\+Number }]{tol}{ = {\ttfamily 1e-\/5}, }\item[{Int\+Number }]{maxiter}{ = {\ttfamily 10}, }\item[{str \texorpdfstring{$\vert$}{|} None }]{qhull\+\_\+options}{ = {\ttfamily None}, }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}dict }]{kwargs}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Approximate Centroidal Voronoi Tessellation.

Perturb samples in N-dimensions using Lloyd-Max algorithm.

Parameters
----------
sample : array_like (n, d)
    The sample to iterate on. With ``n`` the number of samples and ``d``
    the dimension. Samples must be in :math:`[0, 1]^d`, with ``d>=2``.
tol : float, optional
    Tolerance for termination. If the min of the L1-norm over the samples
    changes less than `tol`, it stops the algorithm. Default is 1e-5.
maxiter : int, optional
    Maximum number of iterations. It will stop the algorithm even if
    `tol` is above the threshold.
    Too many iterations tend to cluster the samples as a hypersphere.
    Default is 10.
qhull_options : str, optional
    Additional options to pass to Qhull. See Qhull manual
    for details. (Default: "Qbb Qc Qz Qj Qx" for ndim > 4 and
    "Qbb Qc Qz Qj" otherwise.)

Returns
-------
sample : array_like (n, d)
    The sample after being processed by Lloyd-Max algorithm.

Notes
-----
Lloyd-Max algorithm is an iterative process with the purpose of improving
the dispersion of samples. For given sample: (i) compute a Voronoi
Tessellation; (ii) find the centroid of each Voronoi cell; (iii) move the
samples toward the centroid of their respective cell. See [1]_, [2]_.

A relaxation factor is used to control how fast samples can move at each
iteration. This factor is starting at 2 and ending at 1 after `maxiter`
following an exponential decay.

The process converges to equally spaced samples. It implies that measures
like the discrepancy could suffer from too many iterations. On the other
hand, L1 and L2 distances should improve. This is especially true with
QMC methods which tend to favor the discrepancy over other criteria.

.. note::

    The current implementation does not intersect the Voronoi Tessellation
    with the boundaries. This implies that for a low number of samples,
    empirically below 20, no Voronoi cell is touching the boundaries.
    Hence, samples cannot be moved close to the boundaries.

    Further improvements could consider the samples at infinity so that
    all boundaries are segments of some Voronoi cells. This would fix
    the computation of the centroid position.

.. warning::

   The Voronoi Tessellation step is expensive and quickly becomes
   intractable with dimensions as low as 10 even for a sample
   of size as low as 1000.

.. versionadded:: 1.9.0

References
----------
.. [1] Lloyd. "Least Squares Quantization in PCM".
   IEEE Transactions on Information Theory, 1982.
.. [2] Max J. "Quantizing for minimum distortion".
   IEEE Transactions on Information Theory, 1960.

Examples
--------
>>> import numpy as np
>>> from scipy.spatial import distance
>>> rng = np.random.default_rng()
>>> sample = rng.random((128, 2))

.. note::

    The samples need to be in :math:`[0, 1]^d`. `scipy.stats.qmc.scale`
    can be used to scale the samples from their
    original bounds to :math:`[0, 1]^d`. And back to their original bounds.

Compute the quality of the sample using the L1 criterion.

>>> def l1_norm(sample):
...    return distance.pdist(sample, 'cityblock').min()

>>> l1_norm(sample)
0.00161...  # random

Now process the sample using Lloyd's algorithm and check the improvement
on the L1. The value should increase.

>>> sample = _lloyd_centroidal_voronoi_tessellation(sample)
>>> l1_norm(sample)
0.0278...  # random
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__qmc_8py_source_l02441}{2441}} of file \mbox{\hyperlink{__qmc_8py_source}{\+\_\+qmc.\+py}}.



References \mbox{\hyperlink{__qmc_8py_source_l02381}{\+\_\+lloyd\+\_\+iteration()}}.

\Hypertarget{namespacescipy_1_1stats_1_1__qmc_a939675ced92e21d78912310257cf3708}\index{scipy.stats.\_qmc@{scipy.stats.\_qmc}!\_lloyd\_iteration@{\_lloyd\_iteration}}
\index{\_lloyd\_iteration@{\_lloyd\_iteration}!scipy.stats.\_qmc@{scipy.stats.\_qmc}}
\doxysubsubsection{\texorpdfstring{\_lloyd\_iteration()}{\_lloyd\_iteration()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1stats_1_1__qmc_a939675ced92e21d78912310257cf3708} 
 np.\+ndarray scipy.\+stats.\+\_\+qmc.\+\_\+lloyd\+\_\+iteration (\begin{DoxyParamCaption}\item[{np.\+ndarray}]{sample}{, }\item[{float}]{decay}{, }\item[{str }]{qhull\+\_\+options}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Lloyd-Max algorithm iteration.

Based on the implementation of Stéfan van der Walt:

https://github.com/stefanv/lloyd

which is:

    Copyright (c) 2021-04-21 Stéfan van der Walt
    https://github.com/stefanv/lloyd
    MIT License

Parameters
----------
sample : array_like (n, d)
    The sample to iterate on.
decay : float
    Relaxation decay. A positive value would move the samples toward
    their centroid, and negative value would move them away.
    1 would move the samples to their centroid.
qhull_options : str
    Additional options to pass to Qhull. See Qhull manual
    for details. (Default: "Qbb Qc Qz Qj Qx" for ndim > 4 and
    "Qbb Qc Qz Qj" otherwise.)

Returns
-------
sample : array_like (n, d)
    The sample after an iteration of Lloyd's algorithm.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__qmc_8py_source_l02377}{2377}} of file \mbox{\hyperlink{__qmc_8py_source}{\+\_\+qmc.\+py}}.



Referenced by \mbox{\hyperlink{__qmc_8py_source_l02448}{\+\_\+lloyd\+\_\+centroidal\+\_\+voronoi\+\_\+tessellation()}}.

\Hypertarget{namespacescipy_1_1stats_1_1__qmc_a5c28a8dac5cfeaeacca8c1cf345f9b05}\index{scipy.stats.\_qmc@{scipy.stats.\_qmc}!\_perturb\_discrepancy@{\_perturb\_discrepancy}}
\index{\_perturb\_discrepancy@{\_perturb\_discrepancy}!scipy.stats.\_qmc@{scipy.stats.\_qmc}}
\doxysubsubsection{\texorpdfstring{\_perturb\_discrepancy()}{\_perturb\_discrepancy()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1stats_1_1__qmc_a5c28a8dac5cfeaeacca8c1cf345f9b05} 
scipy.\+stats.\+\_\+qmc.\+\_\+perturb\+\_\+discrepancy (\begin{DoxyParamCaption}\item[{np.\+ndarray}]{sample}{, }\item[{int}]{i1}{, }\item[{int}]{i2}{, }\item[{int}]{k}{, }\item[{float}]{disc}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Centered discrepancy after an elementary perturbation of a LHS.

An elementary perturbation consists of an exchange of coordinates between
two points: ``sample[i1, k] <-> sample[i2, k]``. By construction,
this operation conserves the LHS properties.

Parameters
----------
sample : array_like (n, d)
    The sample (before permutation) to compute the discrepancy from.
i1 : int
    The first line of the elementary permutation.
i2 : int
    The second line of the elementary permutation.
k : int
    The column of the elementary permutation.
disc : float
    Centered discrepancy of the design before permutation.

Returns
-------
discrepancy : float
    Centered discrepancy of the design after permutation.

References
----------
.. [1] Jin et al. "An efficient algorithm for constructing optimal design
   of computer experiments", Journal of Statistical Planning and
   Inference, 2005.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__qmc_8py_source_l00370}{370}} of file \mbox{\hyperlink{__qmc_8py_source}{\+\_\+qmc.\+py}}.



Referenced by \mbox{\hyperlink{__qmc_8py_source_l02321}{\+\_\+random\+\_\+cd()}}.

\Hypertarget{namespacescipy_1_1stats_1_1__qmc_a7a6cb5783a79ae04ed930416584199f1}\index{scipy.stats.\_qmc@{scipy.stats.\_qmc}!\_random\_cd@{\_random\_cd}}
\index{\_random\_cd@{\_random\_cd}!scipy.stats.\_qmc@{scipy.stats.\_qmc}}
\doxysubsubsection{\texorpdfstring{\_random\_cd()}{\_random\_cd()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1stats_1_1__qmc_a7a6cb5783a79ae04ed930416584199f1} 
 np.\+ndarray scipy.\+stats.\+\_\+qmc.\+\_\+random\+\_\+cd (\begin{DoxyParamCaption}\item[{np.\+ndarray}]{best\+\_\+sample}{, }\item[{int}]{n\+\_\+iters}{, }\item[{int}]{n\+\_\+nochange}{, }\item[{Generator\+Type}]{rng}{, }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}dict }]{kwargs}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Optimal LHS on CD.

Create a base LHS and do random permutations of coordinates to
lower the centered discrepancy.
Because it starts with a normal LHS, it also works with the
`centered` keyword argument.

Two stopping criterion are used to stop the algorithm: at most,
`n_iters` iterations are performed; or if there is no improvement
for `n_nochange` consecutive iterations.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__qmc_8py_source_l02318}{2318}} of file \mbox{\hyperlink{__qmc_8py_source}{\+\_\+qmc.\+py}}.



References \mbox{\hyperlink{__qmc_8py_source_l00371}{\+\_\+perturb\+\_\+discrepancy()}}, and \mbox{\hyperlink{__qmc_8py_source_l00176}{discrepancy()}}.

\Hypertarget{namespacescipy_1_1stats_1_1__qmc_a4f12c2d08735f2790606871d9c479dfb}\index{scipy.stats.\_qmc@{scipy.stats.\_qmc}!\_select\_optimizer@{\_select\_optimizer}}
\index{\_select\_optimizer@{\_select\_optimizer}!scipy.stats.\_qmc@{scipy.stats.\_qmc}}
\doxysubsubsection{\texorpdfstring{\_select\_optimizer()}{\_select\_optimizer()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1stats_1_1__qmc_a4f12c2d08735f2790606871d9c479dfb} 
 Callable \texorpdfstring{$\vert$}{|} None scipy.\+stats.\+\_\+qmc.\+\_\+select\+\_\+optimizer (\begin{DoxyParamCaption}\item[{Literal\mbox{[}"{}random-\/cd"{}, "{}lloyd"{}\mbox{]} \texorpdfstring{$\vert$}{|} None}]{optimization}{, }\item[{dict }]{config}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}A factory for optimization methods.\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__qmc_8py_source_l02290}{2290}} of file \mbox{\hyperlink{__qmc_8py_source}{\+\_\+qmc.\+py}}.

\Hypertarget{namespacescipy_1_1stats_1_1__qmc_a8c10cc54f2dedf13beea8285ed2fe079}\index{scipy.stats.\_qmc@{scipy.stats.\_qmc}!\_validate\_bounds@{\_validate\_bounds}}
\index{\_validate\_bounds@{\_validate\_bounds}!scipy.stats.\_qmc@{scipy.stats.\_qmc}}
\doxysubsubsection{\texorpdfstring{\_validate\_bounds()}{\_validate\_bounds()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1stats_1_1__qmc_a8c10cc54f2dedf13beea8285ed2fe079} 
 tuple\mbox{[}np.\+ndarray, ...\mbox{]} scipy.\+stats.\+\_\+qmc.\+\_\+validate\+\_\+bounds (\begin{DoxyParamCaption}\item[{npt.\+Array\+Like}]{l\+\_\+bounds}{, }\item[{npt.\+Array\+Like}]{u\+\_\+bounds}{, }\item[{int }]{d}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Bounds input validation.

Parameters
----------
l_bounds, u_bounds : array_like (d,)
    Lower and upper bounds.
d : int
    Dimension to use for broadcasting.

Returns
-------
l_bounds, u_bounds : array_like (d,)
    Lower and upper bounds.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__qmc_8py_source_l02620}{2620}} of file \mbox{\hyperlink{__qmc_8py_source}{\+\_\+qmc.\+py}}.



Referenced by \mbox{\hyperlink{__qmc_8py_source_l00094}{scale()}}.

\Hypertarget{namespacescipy_1_1stats_1_1__qmc_a50556dec8eaef56be3606788d98bd945}\index{scipy.stats.\_qmc@{scipy.stats.\_qmc}!\_validate\_workers@{\_validate\_workers}}
\index{\_validate\_workers@{\_validate\_workers}!scipy.stats.\_qmc@{scipy.stats.\_qmc}}
\doxysubsubsection{\texorpdfstring{\_validate\_workers()}{\_validate\_workers()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1stats_1_1__qmc_a50556dec8eaef56be3606788d98bd945} 
 Int\+Number scipy.\+stats.\+\_\+qmc.\+\_\+validate\+\_\+workers (\begin{DoxyParamCaption}\item[{Int\+Number }]{workers}{ = {\ttfamily 1}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Validate `workers` based on platform and value.

Parameters
----------
workers : int, optional
    Number of workers to use for parallel processing. If -1 is
    given all CPU threads are used. Default is 1.

Returns
-------
Workers : int
    Number of CPU used by the algorithm
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__qmc_8py_source_l02590}{2590}} of file \mbox{\hyperlink{__qmc_8py_source}{\+\_\+qmc.\+py}}.



Referenced by \mbox{\hyperlink{__qmc_8py_source_l01053}{scipy.\+stats.\+\_\+qmc.\+Halton.\+\_\+random()}}, and \mbox{\hyperlink{__qmc_8py_source_l00176}{discrepancy()}}.

\Hypertarget{namespacescipy_1_1stats_1_1__qmc_aac2dadc825d19fe30b9e0ab9f0c35df3}\index{scipy.stats.\_qmc@{scipy.stats.\_qmc}!\_van\_der\_corput\_permutations@{\_van\_der\_corput\_permutations}}
\index{\_van\_der\_corput\_permutations@{\_van\_der\_corput\_permutations}!scipy.stats.\_qmc@{scipy.stats.\_qmc}}
\doxysubsubsection{\texorpdfstring{\_van\_der\_corput\_permutations()}{\_van\_der\_corput\_permutations()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1stats_1_1__qmc_aac2dadc825d19fe30b9e0ab9f0c35df3} 
 np.\+ndarray scipy.\+stats.\+\_\+qmc.\+\_\+van\+\_\+der\+\_\+corput\+\_\+permutations (\begin{DoxyParamCaption}\item[{Int\+Number}]{base}{, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{Seed\+Type }]{random\+\_\+state}{ = {\ttfamily None}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Permutations for scrambling a Van der Corput sequence.

Parameters
----------
base : int
    Base of the sequence.
random_state : {None, int, `numpy.random.Generator`}, optional
    If `seed` is an int or None, a new `numpy.random.Generator` is
    created using ``np.random.default_rng(seed)``.
    If `seed` is already a ``Generator`` instance, then the provided
    instance is used.

Returns
-------
permutations : array_like
    Permutation indices.

Notes
-----
In Algorithm 1 of Owen 2017, a permutation of `np.arange(base)` is
created for each positive integer `k` such that `1 - base**-k < 1`
using floating-point arithmetic. For double precision floats, the
condition `1 - base**-k < 1` can also be written as `base**-k >
2**-54`, which makes it more apparent how many permutations we need
to create.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__qmc_8py_source_l00531}{531}} of file \mbox{\hyperlink{__qmc_8py_source}{\+\_\+qmc.\+py}}.



Referenced by \mbox{\hyperlink{__qmc_8py_source_l01037}{scipy.\+stats.\+\_\+qmc.\+Halton.\+\_\+initialize\+\_\+permutations()}}, and \mbox{\hyperlink{__qmc_8py_source_l00577}{van\+\_\+der\+\_\+corput()}}.

\Hypertarget{namespacescipy_1_1stats_1_1__qmc_a2f2c5dc8605784ba0fdf9936b59df395}\index{scipy.stats.\_qmc@{scipy.stats.\_qmc}!check\_random\_state@{check\_random\_state}}
\index{check\_random\_state@{check\_random\_state}!scipy.stats.\_qmc@{scipy.stats.\_qmc}}
\doxysubsubsection{\texorpdfstring{check\_random\_state()}{check\_random\_state()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily \label{namespacescipy_1_1stats_1_1__qmc_a2f2c5dc8605784ba0fdf9936b59df395} 
 Generator\+Type scipy.\+stats.\+\_\+qmc.\+check\+\_\+random\+\_\+state (\begin{DoxyParamCaption}\item[{Generator\+Type}]{seed}{}\end{DoxyParamCaption})}



Definition at line \mbox{\hyperlink{__qmc_8py_source_l00057}{57}} of file \mbox{\hyperlink{__qmc_8py_source}{\+\_\+qmc.\+py}}.

\Hypertarget{namespacescipy_1_1stats_1_1__qmc_a99530aabb901c029b9c24e5cc9f0f5ec}\index{scipy.stats.\_qmc@{scipy.stats.\_qmc}!check\_random\_state@{check\_random\_state}}
\index{check\_random\_state@{check\_random\_state}!scipy.stats.\_qmc@{scipy.stats.\_qmc}}
\doxysubsubsection{\texorpdfstring{check\_random\_state()}{check\_random\_state()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily \label{namespacescipy_1_1stats_1_1__qmc_a99530aabb901c029b9c24e5cc9f0f5ec} 
 np.\+random.\+Generator scipy.\+stats.\+\_\+qmc.\+check\+\_\+random\+\_\+state (\begin{DoxyParamCaption}\item[{Int\+Number \texorpdfstring{$\vert$}{|} None }]{seed}{ = {\ttfamily ...}}\end{DoxyParamCaption})}



Definition at line \mbox{\hyperlink{__qmc_8py_source_l00052}{52}} of file \mbox{\hyperlink{__qmc_8py_source}{\+\_\+qmc.\+py}}.

\Hypertarget{namespacescipy_1_1stats_1_1__qmc_a1af3e5c60b0fbc5c4d257feb9e2a9423}\index{scipy.stats.\_qmc@{scipy.stats.\_qmc}!check\_random\_state@{check\_random\_state}}
\index{check\_random\_state@{check\_random\_state}!scipy.stats.\_qmc@{scipy.stats.\_qmc}}
\doxysubsubsection{\texorpdfstring{check\_random\_state()}{check\_random\_state()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily \label{namespacescipy_1_1stats_1_1__qmc_a1af3e5c60b0fbc5c4d257feb9e2a9423} 
scipy.\+stats.\+\_\+qmc.\+check\+\_\+random\+\_\+state (\begin{DoxyParamCaption}\item[{}]{seed}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Turn `seed` into a `numpy.random.Generator` instance.

Parameters
----------
seed : {None, int, `numpy.random.Generator`, `numpy.random.RandomState`}, optional  # noqa
    If `seed` is an int or None, a new `numpy.random.Generator` is
    created using ``np.random.default_rng(seed)``.
    If `seed` is already a ``Generator`` or ``RandomState`` instance, then
    the provided instance is used.

Returns
-------
seed : {`numpy.random.Generator`, `numpy.random.RandomState`}
    Random number generator.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__qmc_8py_source_l00062}{62}} of file \mbox{\hyperlink{__qmc_8py_source}{\+\_\+qmc.\+py}}.

\Hypertarget{namespacescipy_1_1stats_1_1__qmc_a9bba96ae85ce5dcf83d9960340b9298c}\index{scipy.stats.\_qmc@{scipy.stats.\_qmc}!discrepancy@{discrepancy}}
\index{discrepancy@{discrepancy}!scipy.stats.\_qmc@{scipy.stats.\_qmc}}
\doxysubsubsection{\texorpdfstring{discrepancy()}{discrepancy()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1stats_1_1__qmc_a9bba96ae85ce5dcf83d9960340b9298c} 
 float scipy.\+stats.\+\_\+qmc.\+discrepancy (\begin{DoxyParamCaption}\item[{npt.\+Array\+Like}]{sample}{, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{bool }]{iterative}{ = {\ttfamily False}, }\item[{Literal\mbox{[}"{}CD"{}, "{}WD"{}, "{}MD"{}, "{}L2-\/star"{}\mbox{]} }]{method}{ = {\ttfamily "{}CD"{}}, }\item[{Int\+Number }]{workers}{ = {\ttfamily 1}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Discrepancy of a given sample.

Parameters
----------
sample : array_like (n, d)
    The sample to compute the discrepancy from.
iterative : bool, optional
    Must be False if not using it for updating the discrepancy.
    Default is False. Refer to the notes for more details.
method : str, optional
    Type of discrepancy, can be ``CD``, ``WD``, ``MD`` or ``L2-star``.
    Refer to the notes for more details. Default is ``CD``.
workers : int, optional
    Number of workers to use for parallel processing. If -1 is given all
    CPU threads are used. Default is 1.

Returns
-------
discrepancy : float
    Discrepancy.

Notes
-----
The discrepancy is a uniformity criterion used to assess the space filling
of a number of samples in a hypercube. A discrepancy quantifies the
distance between the continuous uniform distribution on a hypercube and the
discrete uniform distribution on :math:`n` distinct sample points.

The lower the value is, the better the coverage of the parameter space is.

For a collection of subsets of the hypercube, the discrepancy is the
difference between the fraction of sample points in one of those
subsets and the volume of that subset. There are different definitions of
discrepancy corresponding to different collections of subsets. Some
versions take a root mean square difference over subsets instead of
a maximum.

A measure of uniformity is reasonable if it satisfies the following
criteria [1]_:

1. It is invariant under permuting factors and/or runs.
2. It is invariant under rotation of the coordinates.
3. It can measure not only uniformity of the sample over the hypercube,
   but also the projection uniformity of the sample over non-empty
   subset of lower dimension hypercubes.
4. There is some reasonable geometric meaning.
5. It is easy to compute.
6. It satisfies the Koksma-Hlawka-like inequality.
7. It is consistent with other criteria in experimental design.

Four methods are available:

* ``CD``: Centered Discrepancy - subspace involves a corner of the
  hypercube
* ``WD``: Wrap-around Discrepancy - subspace can wrap around bounds
* ``MD``: Mixture Discrepancy - mix between CD/WD covering more criteria
* ``L2-star``: L2-star discrepancy - like CD BUT variant to rotation

See [2]_ for precise definitions of each method.

Lastly, using ``iterative=True``, it is possible to compute the
discrepancy as if we had :math:`n+1` samples. This is useful if we want
to add a point to a sampling and check the candidate which would give the
lowest discrepancy. Then you could just update the discrepancy with
each candidate using `update_discrepancy`. This method is faster than
computing the discrepancy for a large number of candidates.

References
----------
.. [1] Fang et al. "Design and modeling for computer experiments".
   Computer Science and Data Analysis Series, 2006.
.. [2] Zhou Y.-D. et al. "Mixture discrepancy for quasi-random point sets."
   Journal of Complexity, 29 (3-4) , pp. 283-301, 2013.
.. [3] T. T. Warnock. "Computational investigations of low discrepancy
   point sets." Applications of Number Theory to Numerical
   Analysis, Academic Press, pp. 319-343, 1972.

Examples
--------
Calculate the quality of the sample using the discrepancy:

>>> import numpy as np
>>> from scipy.stats import qmc
>>> space = np.array([[1, 3], [2, 6], [3, 2], [4, 5], [5, 1], [6, 4]])
>>> l_bounds = [0.5, 0.5]
>>> u_bounds = [6.5, 6.5]
>>> space = qmc.scale(space, l_bounds, u_bounds, reverse=True)
>>> space
array([[0.08333333, 0.41666667],
       [0.25      , 0.91666667],
       [0.41666667, 0.25      ],
       [0.58333333, 0.75      ],
       [0.75      , 0.08333333],
       [0.91666667, 0.58333333]])
>>> qmc.discrepancy(space)
0.008142039609053464

We can also compute iteratively the ``CD`` discrepancy by using
``iterative=True``.

>>> disc_init = qmc.discrepancy(space[:-1], iterative=True)
>>> disc_init
0.04769081147119336
>>> qmc.update_discrepancy(space[-1], space[:-1], disc_init)
0.008142039609053513
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__qmc_8py_source_l00171}{171}} of file \mbox{\hyperlink{__qmc_8py_source}{\+\_\+qmc.\+py}}.



References \mbox{\hyperlink{__qmc_8py_source_l02590}{\+\_\+validate\+\_\+workers()}}.



Referenced by \mbox{\hyperlink{__qmc_8py_source_l02321}{\+\_\+random\+\_\+cd()}}.

\Hypertarget{namespacescipy_1_1stats_1_1__qmc_a4a2a87897d180c083d702531cdca44cf}\index{scipy.stats.\_qmc@{scipy.stats.\_qmc}!n\_primes@{n\_primes}}
\index{n\_primes@{n\_primes}!scipy.stats.\_qmc@{scipy.stats.\_qmc}}
\doxysubsubsection{\texorpdfstring{n\_primes()}{n\_primes()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1stats_1_1__qmc_a4a2a87897d180c083d702531cdca44cf} 
 list\mbox{[}int\mbox{]} scipy.\+stats.\+\_\+qmc.\+n\+\_\+primes (\begin{DoxyParamCaption}\item[{Int\+Number}]{n}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}List of the n-first prime numbers.

Parameters
----------
n : int
    Number of prime numbers wanted.

Returns
-------
primes : list(int)
    List of primes.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__qmc_8py_source_l00492}{492}} of file \mbox{\hyperlink{__qmc_8py_source}{\+\_\+qmc.\+py}}.



References \mbox{\hyperlink{__qmc_8py_source_l00460}{primes\+\_\+from\+\_\+2\+\_\+to()}}.

\Hypertarget{namespacescipy_1_1stats_1_1__qmc_a73db6f8ac0e878841d09657004b0649c}\index{scipy.stats.\_qmc@{scipy.stats.\_qmc}!primes\_from\_2\_to@{primes\_from\_2\_to}}
\index{primes\_from\_2\_to@{primes\_from\_2\_to}!scipy.stats.\_qmc@{scipy.stats.\_qmc}}
\doxysubsubsection{\texorpdfstring{primes\_from\_2\_to()}{primes\_from\_2\_to()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1stats_1_1__qmc_a73db6f8ac0e878841d09657004b0649c} 
 np.\+ndarray scipy.\+stats.\+\_\+qmc.\+primes\+\_\+from\+\_\+2\+\_\+to (\begin{DoxyParamCaption}\item[{int}]{n}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Prime numbers from 2 to *n*.

Parameters
----------
n : int
    Sup bound with ``n >= 6``.

Returns
-------
primes : list(int)
    Primes in ``2 <= p < n``.

Notes
-----
Taken from [1]_ by P.T. Roy, written consent given on 23.04.2021
by the original author, Bruno Astrolino, for free use in SciPy under
the 3-clause BSD.

References
----------
.. [1] `StackOverflow <https://stackoverflow.com/questions/2068372>`_.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__qmc_8py_source_l00460}{460}} of file \mbox{\hyperlink{__qmc_8py_source}{\+\_\+qmc.\+py}}.



Referenced by \mbox{\hyperlink{__qmc_8py_source_l01331}{scipy.\+stats.\+\_\+qmc.\+Latin\+Hypercube.\+\_\+random\+\_\+oa\+\_\+lhs()}}, and \mbox{\hyperlink{__qmc_8py_source_l00492}{n\+\_\+primes()}}.

\Hypertarget{namespacescipy_1_1stats_1_1__qmc_ae76f690673ebcc776891798b0e128d4a}\index{scipy.stats.\_qmc@{scipy.stats.\_qmc}!scale@{scale}}
\index{scale@{scale}!scipy.stats.\_qmc@{scipy.stats.\_qmc}}
\doxysubsubsection{\texorpdfstring{scale()}{scale()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1stats_1_1__qmc_ae76f690673ebcc776891798b0e128d4a} 
 np.\+ndarray scipy.\+stats.\+\_\+qmc.\+scale (\begin{DoxyParamCaption}\item[{npt.\+Array\+Like}]{sample}{, }\item[{npt.\+Array\+Like}]{l\+\_\+bounds}{, }\item[{npt.\+Array\+Like}]{u\+\_\+bounds}{, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{bool }]{reverse}{ = {\ttfamily False}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Sample scaling from unit hypercube to different bounds.

To convert a sample from :math:`[0, 1)` to :math:`[a, b), b>a`,
with :math:`a` the lower bounds and :math:`b` the upper bounds.
The following transformation is used:

.. math::

(b - a) \cdot \text{sample} + a

Parameters
----------
sample : array_like (n, d)
Sample to scale.
l_bounds, u_bounds : array_like (d,)
Lower and upper bounds (resp. :math:`a`, :math:`b`) of transformed
data. If `reverse` is True, range of the original data to transform
to the unit hypercube.
reverse : bool, optional
Reverse the transformation from different bounds to the unit hypercube.
Default is False.

Returns
-------
sample : array_like (n, d)
Scaled sample.

Examples
--------
Transform 3 samples in the unit hypercube to bounds:

>>> from scipy.stats import qmc
>>> l_bounds = [-2, 0]
>>> u_bounds = [6, 5]
>>> sample = [[0.5 , 0.75],
...           [0.5 , 0.5],
...           [0.75, 0.25]]
>>> sample_scaled = qmc.scale(sample, l_bounds, u_bounds)
>>> sample_scaled
array([[2.  , 3.75],
[2.  , 2.5 ],
[4.  , 1.25]])

And convert back to the unit hypercube:

>>> sample_ = qmc.scale(sample_scaled, l_bounds, u_bounds, reverse=True)
>>> sample_
array([[0.5 , 0.75],
[0.5 , 0.5 ],
[0.75, 0.25]])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__qmc_8py_source_l00088}{88}} of file \mbox{\hyperlink{__qmc_8py_source}{\+\_\+qmc.\+py}}.



References \mbox{\hyperlink{__qmc_8py_source_l02622}{\+\_\+validate\+\_\+bounds()}}.

\Hypertarget{namespacescipy_1_1stats_1_1__qmc_a33205602634d9d5ce04705a48d798551}\index{scipy.stats.\_qmc@{scipy.stats.\_qmc}!update\_discrepancy@{update\_discrepancy}}
\index{update\_discrepancy@{update\_discrepancy}!scipy.stats.\_qmc@{scipy.stats.\_qmc}}
\doxysubsubsection{\texorpdfstring{update\_discrepancy()}{update\_discrepancy()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1stats_1_1__qmc_a33205602634d9d5ce04705a48d798551} 
 float scipy.\+stats.\+\_\+qmc.\+update\+\_\+discrepancy (\begin{DoxyParamCaption}\item[{npt.\+Array\+Like}]{x\+\_\+new}{, }\item[{npt.\+Array\+Like}]{sample}{, }\item[{Decimal\+Number}]{initial\+\_\+disc}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Update the centered discrepancy with a new sample.

Parameters
----------
x_new : array_like (1, d)
    The new sample to add in `sample`.
sample : array_like (n, d)
    The initial sample.
initial_disc : float
    Centered discrepancy of the `sample`.

Returns
-------
discrepancy : float
    Centered discrepancy of the sample composed of `x_new` and `sample`.

Examples
--------
We can also compute iteratively the discrepancy by using
``iterative=True``.

>>> import numpy as np
>>> from scipy.stats import qmc
>>> space = np.array([[1, 3], [2, 6], [3, 2], [4, 5], [5, 1], [6, 4]])
>>> l_bounds = [0.5, 0.5]
>>> u_bounds = [6.5, 6.5]
>>> space = qmc.scale(space, l_bounds, u_bounds, reverse=True)
>>> disc_init = qmc.discrepancy(space[:-1], iterative=True)
>>> disc_init
0.04769081147119336
>>> qmc.update_discrepancy(space[-1], space[:-1], disc_init)
0.008142039609053513
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__qmc_8py_source_l00309}{309}} of file \mbox{\hyperlink{__qmc_8py_source}{\+\_\+qmc.\+py}}.

\Hypertarget{namespacescipy_1_1stats_1_1__qmc_a43c0482d0724d18fd957cd241692c0b2}\index{scipy.stats.\_qmc@{scipy.stats.\_qmc}!van\_der\_corput@{van\_der\_corput}}
\index{van\_der\_corput@{van\_der\_corput}!scipy.stats.\_qmc@{scipy.stats.\_qmc}}
\doxysubsubsection{\texorpdfstring{van\_der\_corput()}{van\_der\_corput()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1stats_1_1__qmc_a43c0482d0724d18fd957cd241692c0b2} 
 np.\+ndarray scipy.\+stats.\+\_\+qmc.\+van\+\_\+der\+\_\+corput (\begin{DoxyParamCaption}\item[{Int\+Number}]{n}{, }\item[{Int\+Number }]{base}{ = {\ttfamily 2}, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{Int\+Number }]{start\+\_\+index}{ = {\ttfamily 0}, }\item[{bool }]{scramble}{ = {\ttfamily False}, }\item[{npt.\+Array\+Like \texorpdfstring{$\vert$}{|} None }]{permutations}{ = {\ttfamily None}, }\item[{Seed\+Type }]{seed}{ = {\ttfamily None}, }\item[{Int\+Number }]{workers}{ = {\ttfamily 1}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Van der Corput sequence.

Pseudo-random number generator based on a b-adic expansion.

Scrambling uses permutations of the remainders (see [1]_). Multiple
permutations are applied to construct a point. The sequence of
permutations has to be the same for all points of the sequence.

Parameters
----------
n : int
    Number of element of the sequence.
base : int, optional
    Base of the sequence. Default is 2.
start_index : int, optional
    Index to start the sequence from. Default is 0.
scramble : bool, optional
    If True, use Owen scrambling. Otherwise no scrambling is done.
    Default is True.
permutations : array_like, optional
    Permutations used for scrambling.
seed : {None, int, `numpy.random.Generator`}, optional
    If `seed` is an int or None, a new `numpy.random.Generator` is
    created using ``np.random.default_rng(seed)``.
    If `seed` is already a ``Generator`` instance, then the provided
    instance is used.
workers : int, optional
    Number of workers to use for parallel processing. If -1 is
    given all CPU threads are used. Default is 1.

Returns
-------
sequence : list (n,)
    Sequence of Van der Corput.

References
----------
.. [1] A. B. Owen. "A randomized Halton algorithm in R",
   :arxiv:`1706.02808`, 2017.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__qmc_8py_source_l00569}{569}} of file \mbox{\hyperlink{__qmc_8py_source}{\+\_\+qmc.\+py}}.



References \mbox{\hyperlink{__qmc_8py_source_l00533}{\+\_\+van\+\_\+der\+\_\+corput\+\_\+permutations()}}.



Referenced by \mbox{\hyperlink{__qmc_8py_source_l01053}{scipy.\+stats.\+\_\+qmc.\+Halton.\+\_\+random()}}.



\doxysubsection{Variable Documentation}
\Hypertarget{namespacescipy_1_1stats_1_1__qmc_a70091f28f1441e9df78adfb2a6c2e02b}\index{scipy.stats.\_qmc@{scipy.stats.\_qmc}!\_\_all\_\_@{\_\_all\_\_}}
\index{\_\_all\_\_@{\_\_all\_\_}!scipy.stats.\_qmc@{scipy.stats.\_qmc}}
\doxysubsubsection{\texorpdfstring{\_\_all\_\_}{\_\_all\_\_}}
{\footnotesize\ttfamily \label{namespacescipy_1_1stats_1_1__qmc_a70091f28f1441e9df78adfb2a6c2e02b} 
list scipy.\+stats.\+\_\+qmc.\+\_\+\+\_\+all\+\_\+\+\_\+\hspace{0.3cm}{\ttfamily [private]}}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ [\textcolor{stringliteral}{'scale'},\ \textcolor{stringliteral}{'discrepancy'},\ \textcolor{stringliteral}{'update\_discrepancy'},}
\DoxyCodeLine{00002\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'QMCEngine'},\ \textcolor{stringliteral}{'Sobol'},\ \textcolor{stringliteral}{'Halton'},\ \textcolor{stringliteral}{'LatinHypercube'},\ \textcolor{stringliteral}{'PoissonDisk'},}
\DoxyCodeLine{00003\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'MultinomialQMC'},\ \textcolor{stringliteral}{'MultivariateNormalQMC'}]}

\end{DoxyCode}


Definition at line \mbox{\hyperlink{__qmc_8py_source_l00046}{46}} of file \mbox{\hyperlink{__qmc_8py_source}{\+\_\+qmc.\+py}}.

