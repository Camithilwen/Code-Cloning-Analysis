\doxysection{scipy.\+ndimage.\+\_\+interpolation Namespace Reference}
\hypertarget{namespacescipy_1_1ndimage_1_1__interpolation}{}\label{namespacescipy_1_1ndimage_1_1__interpolation}\index{scipy.ndimage.\_interpolation@{scipy.ndimage.\_interpolation}}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacescipy_1_1ndimage_1_1__interpolation_a4633643f50ca2ab60dac0c772aa04f4b}{spline\+\_\+filter1d}} (input, order=3, axis=-\/1, output=numpy.\+float64, mode=\textquotesingle{}mirror\textquotesingle{})
\item 
\mbox{\hyperlink{namespacescipy_1_1ndimage_1_1__interpolation_a12262008d7d2f963421cd92c9c015be0}{spline\+\_\+filter}} (input, order=3, output=numpy.\+float64, mode=\textquotesingle{}mirror\textquotesingle{})
\item 
\mbox{\hyperlink{namespacescipy_1_1ndimage_1_1__interpolation_a9118108328fb08d8fd900a524565e623}{\+\_\+prepad\+\_\+for\+\_\+spline\+\_\+filter}} (input, mode, cval)
\item 
\mbox{\hyperlink{namespacescipy_1_1ndimage_1_1__interpolation_afbaf1ed27b34a877be24672a8009625e}{geometric\+\_\+transform}} (input, mapping, output\+\_\+shape=None, output=None, order=3, mode=\textquotesingle{}constant\textquotesingle{}, cval=0.\+0, prefilter=\mbox{\hyperlink{classTrue}{True}}, extra\+\_\+arguments=(), extra\+\_\+keywords=\{\})
\item 
\mbox{\hyperlink{namespacescipy_1_1ndimage_1_1__interpolation_aff6f1bbee32816e75c58eb421c4c3160}{map\+\_\+coordinates}} (input, coordinates, output=None, order=3, mode=\textquotesingle{}constant\textquotesingle{}, cval=0.\+0, prefilter=\mbox{\hyperlink{classTrue}{True}})
\item 
\mbox{\hyperlink{namespacescipy_1_1ndimage_1_1__interpolation_abd95335ac6c151c9ec784c413edb6401}{affine\+\_\+transform}} (input, matrix, offset=0.\+0, output\+\_\+shape=None, output=None, order=3, mode=\textquotesingle{}constant\textquotesingle{}, cval=0.\+0, prefilter=\mbox{\hyperlink{classTrue}{True}})
\item 
\mbox{\hyperlink{namespacescipy_1_1ndimage_1_1__interpolation_a6141e26d9a9aa095a6c8b0168fd552fa}{shift}} (input, shift, output=None, order=3, mode=\textquotesingle{}constant\textquotesingle{}, cval=0.\+0, prefilter=\mbox{\hyperlink{classTrue}{True}})
\item 
\mbox{\hyperlink{namespacescipy_1_1ndimage_1_1__interpolation_a564e028bd8509c069188641a9a408e1e}{zoom}} (input, zoom, output=None, order=3, mode=\textquotesingle{}constant\textquotesingle{}, cval=0.\+0, prefilter=\mbox{\hyperlink{classTrue}{True}}, \texorpdfstring{$\ast$}{*}, grid\+\_\+mode=False)
\item 
\mbox{\hyperlink{namespacescipy_1_1ndimage_1_1__interpolation_a6bf9560fc833b87edb39fba44a603172}{rotate}} (input, angle, axes=(1, 0), reshape=\mbox{\hyperlink{classTrue}{True}}, output=None, order=3, mode=\textquotesingle{}constant\textquotesingle{}, cval=0.\+0, prefilter=\mbox{\hyperlink{classTrue}{True}})
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
list \mbox{\hyperlink{namespacescipy_1_1ndimage_1_1__interpolation_a4c870ab111302de6c68e810b0fba50d7}{\+\_\+\+\_\+all\+\_\+\+\_\+}}
\end{DoxyCompactItemize}


\doxysubsection{Function Documentation}
\Hypertarget{namespacescipy_1_1ndimage_1_1__interpolation_a9118108328fb08d8fd900a524565e623}\index{scipy.ndimage.\_interpolation@{scipy.ndimage.\_interpolation}!\_prepad\_for\_spline\_filter@{\_prepad\_for\_spline\_filter}}
\index{\_prepad\_for\_spline\_filter@{\_prepad\_for\_spline\_filter}!scipy.ndimage.\_interpolation@{scipy.ndimage.\_interpolation}}
\doxysubsubsection{\texorpdfstring{\_prepad\_for\_spline\_filter()}{\_prepad\_for\_spline\_filter()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1ndimage_1_1__interpolation_a9118108328fb08d8fd900a524565e623} 
scipy.\+ndimage.\+\_\+interpolation.\+\_\+prepad\+\_\+for\+\_\+spline\+\_\+filter (\begin{DoxyParamCaption}\item[{}]{input}{, }\item[{}]{mode}{, }\item[{}]{cval}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{__interpolation_8py_source_l00198}{198}} of file \mbox{\hyperlink{__interpolation_8py_source}{\+\_\+interpolation.\+py}}.

\Hypertarget{namespacescipy_1_1ndimage_1_1__interpolation_abd95335ac6c151c9ec784c413edb6401}\index{scipy.ndimage.\_interpolation@{scipy.ndimage.\_interpolation}!affine\_transform@{affine\_transform}}
\index{affine\_transform@{affine\_transform}!scipy.ndimage.\_interpolation@{scipy.ndimage.\_interpolation}}
\doxysubsubsection{\texorpdfstring{affine\_transform()}{affine\_transform()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1ndimage_1_1__interpolation_abd95335ac6c151c9ec784c413edb6401} 
scipy.\+ndimage.\+\_\+interpolation.\+affine\+\_\+transform (\begin{DoxyParamCaption}\item[{}]{input}{, }\item[{}]{matrix}{, }\item[{}]{offset}{ = {\ttfamily 0.0}, }\item[{}]{output\+\_\+shape}{ = {\ttfamily None}, }\item[{}]{output}{ = {\ttfamily None}, }\item[{}]{order}{ = {\ttfamily 3}, }\item[{}]{mode}{ = {\ttfamily \textquotesingle{}constant\textquotesingle{}}, }\item[{}]{cval}{ = {\ttfamily 0.0}, }\item[{}]{prefilter}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Apply an affine transformation.

Given an output image pixel index vector ``o``, the pixel value
is determined from the input image at position
``np.dot(matrix, o) + offset``.

This does 'pull' (or 'backward') resampling, transforming the output space
to the input to locate data. Affine transformations are often described in
the 'push' (or 'forward') direction, transforming input to output. If you
have a matrix for the 'push' transformation, use its inverse
(:func:`numpy.linalg.inv`) in this function.

Parameters
----------
%(input)s
matrix : ndarray
    The inverse coordinate transformation matrix, mapping output
    coordinates to input coordinates. If ``ndim`` is the number of
    dimensions of ``input``, the given matrix must have one of the
    following shapes:

        - ``(ndim, ndim)``: the linear transformation matrix for each
          output coordinate.
        - ``(ndim,)``: assume that the 2-D transformation matrix is
          diagonal, with the diagonal specified by the given value. A more
          efficient algorithm is then used that exploits the separability
          of the problem.
        - ``(ndim + 1, ndim + 1)``: assume that the transformation is
          specified using homogeneous coordinates [1]_. In this case, any
          value passed to ``offset`` is ignored.
        - ``(ndim, ndim + 1)``: as above, but the bottom row of a
          homogeneous transformation matrix is always ``[0, 0, ..., 1]``,
          and may be omitted.

offset : float or sequence, optional
    The offset into the array where the transform is applied. If a float,
    `offset` is the same for each axis. If a sequence, `offset` should
    contain one value for each axis.
output_shape : tuple of ints, optional
    Shape tuple.
%(output)s
order : int, optional
    The order of the spline interpolation, default is 3.
    The order has to be in the range 0-5.
%(mode_interp_constant)s
%(cval)s
%(prefilter)s

Returns
-------
affine_transform : ndarray
    The transformed input.

Notes
-----
The given matrix and offset are used to find for each point in the
output the corresponding coordinates in the input by an affine
transformation. The value of the input at those coordinates is
determined by spline interpolation of the requested order. Points
outside the boundaries of the input are filled according to the given
mode.

.. versionchanged:: 0.18.0
    Previously, the exact interpretation of the affine transformation
    depended on whether the matrix was supplied as a 1-D or a
    2-D array. If a 1-D array was supplied
    to the matrix parameter, the output pixel value at index ``o``
    was determined from the input image at position
    ``matrix * (o + offset)``.

For complex-valued `input`, this function transforms the real and imaginary
components independently.

.. versionadded:: 1.6.0
    Complex-valued support added.

References
----------
.. [1] https://en.wikipedia.org/wiki/Homogeneous_coordinates
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__interpolation_8py_source_l00465}{465}} of file \mbox{\hyperlink{__interpolation_8py_source}{\+\_\+interpolation.\+py}}.



References \mbox{\hyperlink{__interpolation_8py_source_l00467}{affine\+\_\+transform()}}, and \mbox{\hyperlink{__interpolation_8py_source_l00136}{spline\+\_\+filter()}}.



Referenced by \mbox{\hyperlink{__interpolation_8py_source_l00467}{affine\+\_\+transform()}}, and \mbox{\hyperlink{__interpolation_8py_source_l00826}{rotate()}}.

\Hypertarget{namespacescipy_1_1ndimage_1_1__interpolation_afbaf1ed27b34a877be24672a8009625e}\index{scipy.ndimage.\_interpolation@{scipy.ndimage.\_interpolation}!geometric\_transform@{geometric\_transform}}
\index{geometric\_transform@{geometric\_transform}!scipy.ndimage.\_interpolation@{scipy.ndimage.\_interpolation}}
\doxysubsubsection{\texorpdfstring{geometric\_transform()}{geometric\_transform()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1ndimage_1_1__interpolation_afbaf1ed27b34a877be24672a8009625e} 
scipy.\+ndimage.\+\_\+interpolation.\+geometric\+\_\+transform (\begin{DoxyParamCaption}\item[{}]{input}{, }\item[{}]{mapping}{, }\item[{}]{output\+\_\+shape}{ = {\ttfamily None}, }\item[{}]{output}{ = {\ttfamily None}, }\item[{}]{order}{ = {\ttfamily 3}, }\item[{}]{mode}{ = {\ttfamily \textquotesingle{}constant\textquotesingle{}}, }\item[{}]{cval}{ = {\ttfamily 0.0}, }\item[{}]{prefilter}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}, }\item[{}]{extra\+\_\+arguments}{ = {\ttfamily ()}, }\item[{}]{extra\+\_\+keywords}{ = {\ttfamily \{\}}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Apply an arbitrary geometric transform.

The given mapping function is used to find, for each point in the
output, the corresponding coordinates in the input. The value of the
input at those coordinates is determined by spline interpolation of
the requested order.

Parameters
----------
%(input)s
mapping : {callable, scipy.LowLevelCallable}
    A callable object that accepts a tuple of length equal to the output
    array rank, and returns the corresponding input coordinates as a tuple
    of length equal to the input array rank.
output_shape : tuple of ints, optional
    Shape tuple.
%(output)s
order : int, optional
    The order of the spline interpolation, default is 3.
    The order has to be in the range 0-5.
%(mode_interp_constant)s
%(cval)s
%(prefilter)s
extra_arguments : tuple, optional
    Extra arguments passed to `mapping`.
extra_keywords : dict, optional
    Extra keywords passed to `mapping`.

Returns
-------
output : ndarray
    The filtered input.

See Also
--------
map_coordinates, affine_transform, spline_filter1d


Notes
-----
This function also accepts low-level callback functions with one
the following signatures and wrapped in `scipy.LowLevelCallable`:

.. code:: c

   int mapping(npy_intp *output_coordinates, double *input_coordinates,
               int output_rank, int input_rank, void *user_data)
   int mapping(intptr_t *output_coordinates, double *input_coordinates,
               int output_rank, int input_rank, void *user_data)

The calling function iterates over the elements of the output array,
calling the callback function at each element. The coordinates of the
current output element are passed through ``output_coordinates``. The
callback function must return the coordinates at which the input must
be interpolated in ``input_coordinates``. The rank of the input and
output arrays are given by ``input_rank`` and ``output_rank``
respectively. ``user_data`` is the data pointer provided
to `scipy.LowLevelCallable` as-is.

The callback function must return an integer error status that is zero
if something went wrong and one otherwise. If an error occurs, you should
normally set the Python error status with an informative message
before returning, otherwise a default error message is set by the
calling function.

In addition, some other low-level function pointer specifications
are accepted, but these are for backward compatibility only and should
not be used in new code.

For complex-valued `input`, this function transforms the real and imaginary
components independently.

.. versionadded:: 1.6.0
    Complex-valued support added.

Examples
--------
>>> import numpy as np
>>> from scipy.ndimage import geometric_transform
>>> a = np.arange(12.).reshape((4, 3))
>>> def shift_func(output_coords):
...     return (output_coords[0] - 0.5, output_coords[1] - 0.5)
...
>>> geometric_transform(a, shift_func)
array([[ 0.   ,  0.   ,  0.   ],
       [ 0.   ,  1.362,  2.738],
       [ 0.   ,  4.812,  6.187],
       [ 0.   ,  8.263,  9.637]])

>>> b = [1, 2, 3, 4, 5]
>>> def shift_func(output_coords):
...     return (output_coords[0] - 3,)
...
>>> geometric_transform(b, shift_func, mode='constant')
array([0, 0, 0, 1, 2])
>>> geometric_transform(b, shift_func, mode='nearest')
array([1, 1, 1, 1, 2])
>>> geometric_transform(b, shift_func, mode='reflect')
array([3, 2, 1, 1, 2])
>>> geometric_transform(b, shift_func, mode='wrap')
array([2, 3, 4, 1, 2])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__interpolation_8py_source_l00215}{215}} of file \mbox{\hyperlink{__interpolation_8py_source}{\+\_\+interpolation.\+py}}.



References \mbox{\hyperlink{__interpolation_8py_source_l00218}{geometric\+\_\+transform()}}, and \mbox{\hyperlink{__interpolation_8py_source_l00136}{spline\+\_\+filter()}}.



Referenced by \mbox{\hyperlink{__interpolation_8py_source_l00218}{geometric\+\_\+transform()}}.

\Hypertarget{namespacescipy_1_1ndimage_1_1__interpolation_aff6f1bbee32816e75c58eb421c4c3160}\index{scipy.ndimage.\_interpolation@{scipy.ndimage.\_interpolation}!map\_coordinates@{map\_coordinates}}
\index{map\_coordinates@{map\_coordinates}!scipy.ndimage.\_interpolation@{scipy.ndimage.\_interpolation}}
\doxysubsubsection{\texorpdfstring{map\_coordinates()}{map\_coordinates()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1ndimage_1_1__interpolation_aff6f1bbee32816e75c58eb421c4c3160} 
scipy.\+ndimage.\+\_\+interpolation.\+map\+\_\+coordinates (\begin{DoxyParamCaption}\item[{}]{input}{, }\item[{}]{coordinates}{, }\item[{}]{output}{ = {\ttfamily None}, }\item[{}]{order}{ = {\ttfamily 3}, }\item[{}]{mode}{ = {\ttfamily \textquotesingle{}constant\textquotesingle{}}, }\item[{}]{cval}{ = {\ttfamily 0.0}, }\item[{}]{prefilter}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Map the input array to new coordinates by interpolation.

The array of coordinates is used to find, for each point in the output,
the corresponding coordinates in the input. The value of the input at
those coordinates is determined by spline interpolation of the
requested order.

The shape of the output is derived from that of the coordinate
array by dropping the first axis. The values of the array along
the first axis are the coordinates in the input array at which the
output value is found.

Parameters
----------
%(input)s
coordinates : array_like
    The coordinates at which `input` is evaluated.
%(output)s
order : int, optional
    The order of the spline interpolation, default is 3.
    The order has to be in the range 0-5.
%(mode_interp_constant)s
%(cval)s
%(prefilter)s

Returns
-------
map_coordinates : ndarray
    The result of transforming the input. The shape of the output is
    derived from that of `coordinates` by dropping the first axis.

See Also
--------
spline_filter, geometric_transform, scipy.interpolate

Notes
-----
For complex-valued `input`, this function maps the real and imaginary
components independently.

.. versionadded:: 1.6.0
    Complex-valued support added.

Examples
--------
>>> from scipy import ndimage
>>> import numpy as np
>>> a = np.arange(12.).reshape((4, 3))
>>> a
array([[  0.,   1.,   2.],
       [  3.,   4.,   5.],
       [  6.,   7.,   8.],
       [  9.,  10.,  11.]])
>>> ndimage.map_coordinates(a, [[0.5, 2], [0.5, 1]], order=1)
array([ 2.,  7.])

Above, the interpolated value of a[0.5, 0.5] gives output[0], while
a[2, 1] is output[1].

>>> inds = np.array([[0.5, 2], [0.5, 4]])
>>> ndimage.map_coordinates(a, inds, order=1, cval=-33.3)
array([  2. , -33.3])
>>> ndimage.map_coordinates(a, inds, order=1, mode='nearest')
array([ 2.,  8.])
>>> ndimage.map_coordinates(a, inds, order=1, cval=0, output=bool)
array([ True, False], dtype=bool)
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__interpolation_8py_source_l00359}{359}} of file \mbox{\hyperlink{__interpolation_8py_source}{\+\_\+interpolation.\+py}}.



References \mbox{\hyperlink{__interpolation_8py_source_l00360}{map\+\_\+coordinates()}}, and \mbox{\hyperlink{__interpolation_8py_source_l00136}{spline\+\_\+filter()}}.



Referenced by \mbox{\hyperlink{__interpolation_8py_source_l00360}{map\+\_\+coordinates()}}.

\Hypertarget{namespacescipy_1_1ndimage_1_1__interpolation_a6bf9560fc833b87edb39fba44a603172}\index{scipy.ndimage.\_interpolation@{scipy.ndimage.\_interpolation}!rotate@{rotate}}
\index{rotate@{rotate}!scipy.ndimage.\_interpolation@{scipy.ndimage.\_interpolation}}
\doxysubsubsection{\texorpdfstring{rotate()}{rotate()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1ndimage_1_1__interpolation_a6bf9560fc833b87edb39fba44a603172} 
scipy.\+ndimage.\+\_\+interpolation.\+rotate (\begin{DoxyParamCaption}\item[{}]{input}{, }\item[{}]{angle}{, }\item[{}]{axes}{ = {\ttfamily (1,~0)}, }\item[{}]{reshape}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}, }\item[{}]{output}{ = {\ttfamily None}, }\item[{}]{order}{ = {\ttfamily 3}, }\item[{}]{mode}{ = {\ttfamily \textquotesingle{}constant\textquotesingle{}}, }\item[{}]{cval}{ = {\ttfamily 0.0}, }\item[{}]{prefilter}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Rotate an array.

The array is rotated in the plane defined by the two axes given by the
`axes` parameter using spline interpolation of the requested order.

Parameters
----------
%(input)s
angle : float
    The rotation angle in degrees.
axes : tuple of 2 ints, optional
    The two axes that define the plane of rotation. Default is the first
    two axes.
reshape : bool, optional
    If `reshape` is true, the output shape is adapted so that the input
    array is contained completely in the output. Default is True.
%(output)s
order : int, optional
    The order of the spline interpolation, default is 3.
    The order has to be in the range 0-5.
%(mode_interp_constant)s
%(cval)s
%(prefilter)s

Returns
-------
rotate : ndarray
    The rotated input.

Notes
-----
For complex-valued `input`, this function rotates the real and imaginary
components independently.

.. versionadded:: 1.6.0
    Complex-valued support added.

Examples
--------
>>> from scipy import ndimage, datasets
>>> import matplotlib.pyplot as plt
>>> fig = plt.figure(figsize=(10, 3))
>>> ax1, ax2, ax3 = fig.subplots(1, 3)
>>> img = datasets.ascent()
>>> img_45 = ndimage.rotate(img, 45, reshape=False)
>>> full_img_45 = ndimage.rotate(img, 45, reshape=True)
>>> ax1.imshow(img, cmap='gray')
>>> ax1.set_axis_off()
>>> ax2.imshow(img_45, cmap='gray')
>>> ax2.set_axis_off()
>>> ax3.imshow(full_img_45, cmap='gray')
>>> ax3.set_axis_off()
>>> fig.set_layout_engine('tight')
>>> plt.show()
>>> print(img.shape)
(512, 512)
>>> print(img_45.shape)
(512, 512)
>>> print(full_img_45.shape)
(724, 724)
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__interpolation_8py_source_l00825}{825}} of file \mbox{\hyperlink{__interpolation_8py_source}{\+\_\+interpolation.\+py}}.



References \mbox{\hyperlink{__interpolation_8py_source_l00467}{affine\+\_\+transform()}}.

\Hypertarget{namespacescipy_1_1ndimage_1_1__interpolation_a6141e26d9a9aa095a6c8b0168fd552fa}\index{scipy.ndimage.\_interpolation@{scipy.ndimage.\_interpolation}!shift@{shift}}
\index{shift@{shift}!scipy.ndimage.\_interpolation@{scipy.ndimage.\_interpolation}}
\doxysubsubsection{\texorpdfstring{shift()}{shift()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1ndimage_1_1__interpolation_a6141e26d9a9aa095a6c8b0168fd552fa} 
scipy.\+ndimage.\+\_\+interpolation.\+shift (\begin{DoxyParamCaption}\item[{}]{input}{, }\item[{}]{shift}{, }\item[{}]{output}{ = {\ttfamily None}, }\item[{}]{order}{ = {\ttfamily 3}, }\item[{}]{mode}{ = {\ttfamily \textquotesingle{}constant\textquotesingle{}}, }\item[{}]{cval}{ = {\ttfamily 0.0}, }\item[{}]{prefilter}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Shift an array.

The array is shifted using spline interpolation of the requested order.
Points outside the boundaries of the input are filled according to the
given mode.

Parameters
----------
%(input)s
shift : float or sequence
    The shift along the axes. If a float, `shift` is the same for each
    axis. If a sequence, `shift` should contain one value for each axis.
%(output)s
order : int, optional
    The order of the spline interpolation, default is 3.
    The order has to be in the range 0-5.
%(mode_interp_constant)s
%(cval)s
%(prefilter)s

Returns
-------
shift : ndarray
    The shifted input.

Notes
-----
For complex-valued `input`, this function shifts the real and imaginary
components independently.

.. versionadded:: 1.6.0
    Complex-valued support added.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__interpolation_8py_source_l00621}{621}} of file \mbox{\hyperlink{__interpolation_8py_source}{\+\_\+interpolation.\+py}}.



References \mbox{\hyperlink{__interpolation_8py_source_l00136}{spline\+\_\+filter()}}.

\Hypertarget{namespacescipy_1_1ndimage_1_1__interpolation_a12262008d7d2f963421cd92c9c015be0}\index{scipy.ndimage.\_interpolation@{scipy.ndimage.\_interpolation}!spline\_filter@{spline\_filter}}
\index{spline\_filter@{spline\_filter}!scipy.ndimage.\_interpolation@{scipy.ndimage.\_interpolation}}
\doxysubsubsection{\texorpdfstring{spline\_filter()}{spline\_filter()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1ndimage_1_1__interpolation_a12262008d7d2f963421cd92c9c015be0} 
scipy.\+ndimage.\+\_\+interpolation.\+spline\+\_\+filter (\begin{DoxyParamCaption}\item[{}]{input}{, }\item[{}]{order}{ = {\ttfamily 3}, }\item[{}]{output}{ = {\ttfamily numpy.float64}, }\item[{}]{mode}{ = {\ttfamily \textquotesingle{}mirror\textquotesingle{}}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Multidimensional spline filter.

For more details, see `spline_filter1d`.

See Also
--------
spline_filter1d : Calculate a 1-D spline filter along the given axis.

Notes
-----
The multidimensional filter is implemented as a sequence of
1-D spline filters. The intermediate arrays are stored
in the same data type as the output. Therefore, for output types
with a limited precision, the results may be imprecise because
intermediate results may be stored with insufficient precision.

For complex-valued `input`, this function processes the real and imaginary
components independently.

.. versionadded:: 1.6.0
    Complex-valued support added.

Examples
--------
We can filter an image using multidimentional splines:

>>> from scipy.ndimage import spline_filter
>>> import numpy as np
>>> import matplotlib.pyplot as plt
>>> orig_img = np.eye(20)  # create an image
>>> orig_img[10, :] = 1.0
>>> sp_filter = spline_filter(orig_img, order=3)
>>> f, ax = plt.subplots(1, 2, sharex=True)
>>> for ind, data in enumerate([[orig_img, "original image"],
...                             [sp_filter, "spline filter"]]):
...     ax[ind].imshow(data[0], cmap='gray_r')
...     ax[ind].set_title(data[1])
>>> plt.tight_layout()
>>> plt.show()
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__interpolation_8py_source_l00136}{136}} of file \mbox{\hyperlink{__interpolation_8py_source}{\+\_\+interpolation.\+py}}.



References \mbox{\hyperlink{__interpolation_8py_source_l00136}{spline\+\_\+filter()}}, and \mbox{\hyperlink{__interpolation_8py_source_l00049}{spline\+\_\+filter1d()}}.



Referenced by \mbox{\hyperlink{__interpolation_8py_source_l00467}{affine\+\_\+transform()}}, \mbox{\hyperlink{__interpolation_8py_source_l00218}{geometric\+\_\+transform()}}, \mbox{\hyperlink{__interpolation_8py_source_l00360}{map\+\_\+coordinates()}}, \mbox{\hyperlink{__interpolation_8py_source_l00622}{shift()}}, \mbox{\hyperlink{__interpolation_8py_source_l00136}{spline\+\_\+filter()}}, and \mbox{\hyperlink{__interpolation_8py_source_l00696}{zoom()}}.

\Hypertarget{namespacescipy_1_1ndimage_1_1__interpolation_a4633643f50ca2ab60dac0c772aa04f4b}\index{scipy.ndimage.\_interpolation@{scipy.ndimage.\_interpolation}!spline\_filter1d@{spline\_filter1d}}
\index{spline\_filter1d@{spline\_filter1d}!scipy.ndimage.\_interpolation@{scipy.ndimage.\_interpolation}}
\doxysubsubsection{\texorpdfstring{spline\_filter1d()}{spline\_filter1d()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1ndimage_1_1__interpolation_a4633643f50ca2ab60dac0c772aa04f4b} 
scipy.\+ndimage.\+\_\+interpolation.\+spline\+\_\+filter1d (\begin{DoxyParamCaption}\item[{}]{input}{, }\item[{}]{order}{ = {\ttfamily 3}, }\item[{}]{axis}{ = {\ttfamily -\/1}, }\item[{}]{output}{ = {\ttfamily numpy.float64}, }\item[{}]{mode}{ = {\ttfamily \textquotesingle{}mirror\textquotesingle{}}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Calculate a 1-D spline filter along the given axis.

The lines of the array along the given axis are filtered by a
spline filter. The order of the spline must be >= 2 and <= 5.

Parameters
----------
%(input)s
order : int, optional
    The order of the spline, default is 3.
axis : int, optional
    The axis along which the spline filter is applied. Default is the last
    axis.
output : ndarray or dtype, optional
    The array in which to place the output, or the dtype of the returned
    array. Default is ``numpy.float64``.
%(mode_interp_mirror)s

Returns
-------
spline_filter1d : ndarray
    The filtered input.

Notes
-----
All of the interpolation functions in `ndimage` do spline interpolation of
the input image. If using B-splines of `order > 1`, the input image
values have to be converted to B-spline coefficients first, which is
done by applying this 1-D filter sequentially along all
axes of the input. All functions that require B-spline coefficients
will automatically filter their inputs, a behavior controllable with
the `prefilter` keyword argument. For functions that accept a `mode`
parameter, the result will only be correct if it matches the `mode`
used when filtering.

For complex-valued `input`, this function processes the real and imaginary
components independently.

.. versionadded:: 1.6.0
    Complex-valued support added.

See Also
--------
spline_filter : Multidimensional spline filter.

Examples
--------
We can filter an image using 1-D spline along the given axis:

>>> from scipy.ndimage import spline_filter1d
>>> import numpy as np
>>> import matplotlib.pyplot as plt
>>> orig_img = np.eye(20)  # create an image
>>> orig_img[10, :] = 1.0
>>> sp_filter_axis_0 = spline_filter1d(orig_img, axis=0)
>>> sp_filter_axis_1 = spline_filter1d(orig_img, axis=1)
>>> f, ax = plt.subplots(1, 3, sharex=True)
>>> for ind, data in enumerate([[orig_img, "original image"],
...             [sp_filter_axis_0, "spline filter (axis=0)"],
...             [sp_filter_axis_1, "spline filter (axis=1)"]]):
...     ax[ind].imshow(data[0], cmap='gray_r')
...     ax[ind].set_title(data[1])
>>> plt.tight_layout()
>>> plt.show()
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__interpolation_8py_source_l00048}{48}} of file \mbox{\hyperlink{__interpolation_8py_source}{\+\_\+interpolation.\+py}}.



References \mbox{\hyperlink{__interpolation_8py_source_l00049}{spline\+\_\+filter1d()}}.



Referenced by \mbox{\hyperlink{__interpolation_8py_source_l00136}{spline\+\_\+filter()}}, and \mbox{\hyperlink{__interpolation_8py_source_l00049}{spline\+\_\+filter1d()}}.

\Hypertarget{namespacescipy_1_1ndimage_1_1__interpolation_a564e028bd8509c069188641a9a408e1e}\index{scipy.ndimage.\_interpolation@{scipy.ndimage.\_interpolation}!zoom@{zoom}}
\index{zoom@{zoom}!scipy.ndimage.\_interpolation@{scipy.ndimage.\_interpolation}}
\doxysubsubsection{\texorpdfstring{zoom()}{zoom()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1ndimage_1_1__interpolation_a564e028bd8509c069188641a9a408e1e} 
scipy.\+ndimage.\+\_\+interpolation.\+zoom (\begin{DoxyParamCaption}\item[{}]{input}{, }\item[{}]{zoom}{, }\item[{}]{output}{ = {\ttfamily None}, }\item[{}]{order}{ = {\ttfamily 3}, }\item[{}]{mode}{ = {\ttfamily \textquotesingle{}constant\textquotesingle{}}, }\item[{}]{cval}{ = {\ttfamily 0.0}, }\item[{}]{prefilter}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{grid\+\_\+mode}{ = {\ttfamily False}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Zoom an array.

The array is zoomed using spline interpolation of the requested order.

Parameters
----------
%(input)s
zoom : float or sequence
    The zoom factor along the axes. If a float, `zoom` is the same for each
    axis. If a sequence, `zoom` should contain one value for each axis.
%(output)s
order : int, optional
    The order of the spline interpolation, default is 3.
    The order has to be in the range 0-5.
%(mode_interp_constant)s
%(cval)s
%(prefilter)s
grid_mode : bool, optional
    If False, the distance from the pixel centers is zoomed. Otherwise, the
    distance including the full pixel extent is used. For example, a 1d
    signal of length 5 is considered to have length 4 when `grid_mode` is
    False, but length 5 when `grid_mode` is True. See the following
    visual illustration:

    .. code-block:: text

            | pixel 1 | pixel 2 | pixel 3 | pixel 4 | pixel 5 |
                 |<-------------------------------------->|
                                    vs.
            |<----------------------------------------------->|

    The starting point of the arrow in the diagram above corresponds to
    coordinate location 0 in each mode.

Returns
-------
zoom : ndarray
    The zoomed input.

Notes
-----
For complex-valued `input`, this function zooms the real and imaginary
components independently.

.. versionadded:: 1.6.0
    Complex-valued support added.

Examples
--------
>>> from scipy import ndimage, datasets
>>> import matplotlib.pyplot as plt

>>> fig = plt.figure()
>>> ax1 = fig.add_subplot(121)  # left side
>>> ax2 = fig.add_subplot(122)  # right side
>>> ascent = datasets.ascent()
>>> result = ndimage.zoom(ascent, 3.0)
>>> ax1.imshow(ascent, vmin=0, vmax=255)
>>> ax2.imshow(result, vmin=0, vmax=255)
>>> plt.show()

>>> print(ascent.shape)
(512, 512)

>>> print(result.shape)
(1536, 1536)
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__interpolation_8py_source_l00695}{695}} of file \mbox{\hyperlink{__interpolation_8py_source}{\+\_\+interpolation.\+py}}.



References \mbox{\hyperlink{__interpolation_8py_source_l00136}{spline\+\_\+filter()}}.



\doxysubsection{Variable Documentation}
\Hypertarget{namespacescipy_1_1ndimage_1_1__interpolation_a4c870ab111302de6c68e810b0fba50d7}\index{scipy.ndimage.\_interpolation@{scipy.ndimage.\_interpolation}!\_\_all\_\_@{\_\_all\_\_}}
\index{\_\_all\_\_@{\_\_all\_\_}!scipy.ndimage.\_interpolation@{scipy.ndimage.\_interpolation}}
\doxysubsubsection{\texorpdfstring{\_\_all\_\_}{\_\_all\_\_}}
{\footnotesize\ttfamily \label{namespacescipy_1_1ndimage_1_1__interpolation_a4c870ab111302de6c68e810b0fba50d7} 
list scipy.\+ndimage.\+\_\+interpolation.\+\_\+\+\_\+all\+\_\+\+\_\+\hspace{0.3cm}{\ttfamily [private]}}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ [\textcolor{stringliteral}{'spline\_filter1d'},\ \textcolor{stringliteral}{'spline\_filter'},\ \textcolor{stringliteral}{'geometric\_transform'},}
\DoxyCodeLine{00002\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'map\_coordinates'},\ \textcolor{stringliteral}{'affine\_transform'},\ \textcolor{stringliteral}{'shift'},\ \textcolor{stringliteral}{'zoom'},\ \textcolor{stringliteral}{'rotate'}]}

\end{DoxyCode}


Definition at line \mbox{\hyperlink{__interpolation_8py_source_l00043}{43}} of file \mbox{\hyperlink{__interpolation_8py_source}{\+\_\+interpolation.\+py}}.

