\doxysection{sklearn.\+cluster.\+\_\+agglomerative Namespace Reference}
\hypertarget{namespacesklearn_1_1cluster_1_1__agglomerative}{}\label{namespacesklearn_1_1cluster_1_1__agglomerative}\index{sklearn.cluster.\_agglomerative@{sklearn.cluster.\_agglomerative}}
\doxysubsubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classsklearn_1_1cluster_1_1__agglomerative_1_1AgglomerativeClustering}{Agglomerative\+Clustering}}
\item 
class \mbox{\hyperlink{classsklearn_1_1cluster_1_1__agglomerative_1_1FeatureAgglomeration}{Feature\+Agglomeration}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacesklearn_1_1cluster_1_1__agglomerative_a0b13ca3962b9ec0e5bcb2be861306e2e}{\+\_\+fix\+\_\+connectivity}} (X, connectivity, affinity)
\begin{DoxyCompactList}\small\item\em For non fully-\/connected graphs. \end{DoxyCompactList}\item 
\mbox{\hyperlink{namespacesklearn_1_1cluster_1_1__agglomerative_ad65876a4f74782f89c454de63e0f4310}{\+\_\+single\+\_\+linkage\+\_\+tree}} (connectivity, n\+\_\+samples, n\+\_\+nodes, n\+\_\+clusters, n\+\_\+connected\+\_\+components, return\+\_\+distance)
\item 
\mbox{\hyperlink{namespacesklearn_1_1cluster_1_1__agglomerative_acb2df287905ff22850b785d38d08f6c8}{ward\+\_\+tree}} (X, \texorpdfstring{$\ast$}{*}, connectivity=None, n\+\_\+clusters=None, return\+\_\+distance=False)
\begin{DoxyCompactList}\small\item\em Hierarchical tree building functions. \end{DoxyCompactList}\item 
\mbox{\hyperlink{namespacesklearn_1_1cluster_1_1__agglomerative_a38921d78a1744f9449ba29ce8bfd0e49}{linkage\+\_\+tree}} (X, connectivity=None, n\+\_\+clusters=None, linkage="{}complete"{}, affinity="{}euclidean"{}, return\+\_\+distance=False)
\item 
\mbox{\hyperlink{namespacesklearn_1_1cluster_1_1__agglomerative_a74bd194f2944183b66e9cb9fd7d025b6}{\+\_\+complete\+\_\+linkage}} (\texorpdfstring{$\ast$}{*}args, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}kwargs)
\item 
\mbox{\hyperlink{namespacesklearn_1_1cluster_1_1__agglomerative_ae673b271cfd3a443e0adf8d540112875}{\+\_\+average\+\_\+linkage}} (\texorpdfstring{$\ast$}{*}args, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}kwargs)
\item 
\mbox{\hyperlink{namespacesklearn_1_1cluster_1_1__agglomerative_ac529c06cbb70f05802322a9dbd3a7769}{\+\_\+single\+\_\+linkage}} (\texorpdfstring{$\ast$}{*}args, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}kwargs)
\item 
\mbox{\hyperlink{namespacesklearn_1_1cluster_1_1__agglomerative_aa4100f38e807bc25c3d687cd064e8468}{\+\_\+hc\+\_\+cut}} (n\+\_\+clusters, children, n\+\_\+leaves)
\begin{DoxyCompactList}\small\item\em Functions for cutting hierarchical clustering tree. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacesklearn_1_1cluster_1_1__agglomerative_a2b1947c000f96fb6a39bbaafc58697aa}{\+\_\+\+TREE\+\_\+\+BUILDERS}}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\begin{DoxyVerb}Hierarchical Agglomerative Clustering

These routines perform some hierarchical agglomerative clustering of some
input data.
\end{DoxyVerb}
 

\doxysubsection{Function Documentation}
\Hypertarget{namespacesklearn_1_1cluster_1_1__agglomerative_ae673b271cfd3a443e0adf8d540112875}\index{sklearn.cluster.\_agglomerative@{sklearn.cluster.\_agglomerative}!\_average\_linkage@{\_average\_linkage}}
\index{\_average\_linkage@{\_average\_linkage}!sklearn.cluster.\_agglomerative@{sklearn.cluster.\_agglomerative}}
\doxysubsubsection{\texorpdfstring{\_average\_linkage()}{\_average\_linkage()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1cluster_1_1__agglomerative_ae673b271cfd3a443e0adf8d540112875} 
sklearn.\+cluster.\+\_\+agglomerative.\+\_\+average\+\_\+linkage (\begin{DoxyParamCaption}\item[{\texorpdfstring{$\ast$}{*}}]{args}{, }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{kwargs}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{__agglomerative_8py_source_l00708}{708}} of file \mbox{\hyperlink{__agglomerative_8py_source}{\+\_\+agglomerative.\+py}}.

\Hypertarget{namespacesklearn_1_1cluster_1_1__agglomerative_a74bd194f2944183b66e9cb9fd7d025b6}\index{sklearn.cluster.\_agglomerative@{sklearn.cluster.\_agglomerative}!\_complete\_linkage@{\_complete\_linkage}}
\index{\_complete\_linkage@{\_complete\_linkage}!sklearn.cluster.\_agglomerative@{sklearn.cluster.\_agglomerative}}
\doxysubsubsection{\texorpdfstring{\_complete\_linkage()}{\_complete\_linkage()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1cluster_1_1__agglomerative_a74bd194f2944183b66e9cb9fd7d025b6} 
sklearn.\+cluster.\+\_\+agglomerative.\+\_\+complete\+\_\+linkage (\begin{DoxyParamCaption}\item[{\texorpdfstring{$\ast$}{*}}]{args}{, }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{kwargs}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{__agglomerative_8py_source_l00703}{703}} of file \mbox{\hyperlink{__agglomerative_8py_source}{\+\_\+agglomerative.\+py}}.

\Hypertarget{namespacesklearn_1_1cluster_1_1__agglomerative_a0b13ca3962b9ec0e5bcb2be861306e2e}\index{sklearn.cluster.\_agglomerative@{sklearn.cluster.\_agglomerative}!\_fix\_connectivity@{\_fix\_connectivity}}
\index{\_fix\_connectivity@{\_fix\_connectivity}!sklearn.cluster.\_agglomerative@{sklearn.cluster.\_agglomerative}}
\doxysubsubsection{\texorpdfstring{\_fix\_connectivity()}{\_fix\_connectivity()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1cluster_1_1__agglomerative_a0b13ca3962b9ec0e5bcb2be861306e2e} 
sklearn.\+cluster.\+\_\+agglomerative.\+\_\+fix\+\_\+connectivity (\begin{DoxyParamCaption}\item[{}]{X}{, }\item[{}]{connectivity}{, }\item[{}]{affinity}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



For non fully-\/connected graphs. 

\begin{DoxyVerb}Fixes the connectivity matrix.

The different steps are:

- copies it
- makes it symmetric
- converts it to LIL if necessary
- completes it if necessary.

Parameters
----------
X : array-like of shape (n_samples, n_features)
    Feature matrix representing `n_samples` samples to be clustered.

connectivity : sparse matrix, default=None
    Connectivity matrix. Defines for each sample the neighboring samples
    following a given structure of the data. The matrix is assumed to
    be symmetric and only the upper triangular half is used.
    Default is `None`, i.e, the Ward algorithm is unstructured.

affinity : {"euclidean", "precomputed"}, default="euclidean"
    Which affinity to use. At the moment `precomputed` and
    ``euclidean`` are supported. `euclidean` uses the
    negative squared Euclidean distance between points.

Returns
-------
connectivity : sparse matrix
    The fixed connectivity matrix.

n_connected_components : int
    The number of connected components in the graph.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__agglomerative_8py_source_l00046}{46}} of file \mbox{\hyperlink{__agglomerative_8py_source}{\+\_\+agglomerative.\+py}}.



Referenced by \mbox{\hyperlink{__agglomerative_8py_source_l00433}{linkage\+\_\+tree()}}, and \mbox{\hyperlink{__agglomerative_8py_source_l00191}{ward\+\_\+tree()}}.

\Hypertarget{namespacesklearn_1_1cluster_1_1__agglomerative_aa4100f38e807bc25c3d687cd064e8468}\index{sklearn.cluster.\_agglomerative@{sklearn.cluster.\_agglomerative}!\_hc\_cut@{\_hc\_cut}}
\index{\_hc\_cut@{\_hc\_cut}!sklearn.cluster.\_agglomerative@{sklearn.cluster.\_agglomerative}}
\doxysubsubsection{\texorpdfstring{\_hc\_cut()}{\_hc\_cut()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1cluster_1_1__agglomerative_aa4100f38e807bc25c3d687cd064e8468} 
sklearn.\+cluster.\+\_\+agglomerative.\+\_\+hc\+\_\+cut (\begin{DoxyParamCaption}\item[{}]{n\+\_\+clusters}{, }\item[{}]{children}{, }\item[{}]{n\+\_\+leaves}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Functions for cutting hierarchical clustering tree. 

\begin{DoxyVerb}Function cutting the ward tree for a given number of clusters.

Parameters
----------
n_clusters : int or ndarray
    The number of clusters to form.

children : ndarray of shape (n_nodes-1, 2)
    The children of each non-leaf node. Values less than `n_samples`
    correspond to leaves of the tree which are the original samples.
    A node `i` greater than or equal to `n_samples` is a non-leaf
    node and has children `children_[i - n_samples]`. Alternatively
    at the i-th iteration, children[i][0] and children[i][1]
    are merged to form node `n_samples + i`.

n_leaves : int
    Number of leaves of the tree.

Returns
-------
labels : array [n_samples]
    Cluster labels for each point.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__agglomerative_8py_source_l00729}{729}} of file \mbox{\hyperlink{__agglomerative_8py_source}{\+\_\+agglomerative.\+py}}.



Referenced by \mbox{\hyperlink{__agglomerative_8py_source_l00993}{sklearn.\+cluster.\+\_\+agglomerative.\+Agglomerative\+Clustering.\+\_\+fit()}}.

\Hypertarget{namespacesklearn_1_1cluster_1_1__agglomerative_ac529c06cbb70f05802322a9dbd3a7769}\index{sklearn.cluster.\_agglomerative@{sklearn.cluster.\_agglomerative}!\_single\_linkage@{\_single\_linkage}}
\index{\_single\_linkage@{\_single\_linkage}!sklearn.cluster.\_agglomerative@{sklearn.cluster.\_agglomerative}}
\doxysubsubsection{\texorpdfstring{\_single\_linkage()}{\_single\_linkage()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1cluster_1_1__agglomerative_ac529c06cbb70f05802322a9dbd3a7769} 
sklearn.\+cluster.\+\_\+agglomerative.\+\_\+single\+\_\+linkage (\begin{DoxyParamCaption}\item[{\texorpdfstring{$\ast$}{*}}]{args}{, }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{kwargs}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{__agglomerative_8py_source_l00713}{713}} of file \mbox{\hyperlink{__agglomerative_8py_source}{\+\_\+agglomerative.\+py}}.

\Hypertarget{namespacesklearn_1_1cluster_1_1__agglomerative_ad65876a4f74782f89c454de63e0f4310}\index{sklearn.cluster.\_agglomerative@{sklearn.cluster.\_agglomerative}!\_single\_linkage\_tree@{\_single\_linkage\_tree}}
\index{\_single\_linkage\_tree@{\_single\_linkage\_tree}!sklearn.cluster.\_agglomerative@{sklearn.cluster.\_agglomerative}}
\doxysubsubsection{\texorpdfstring{\_single\_linkage\_tree()}{\_single\_linkage\_tree()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1cluster_1_1__agglomerative_ad65876a4f74782f89c454de63e0f4310} 
sklearn.\+cluster.\+\_\+agglomerative.\+\_\+single\+\_\+linkage\+\_\+tree (\begin{DoxyParamCaption}\item[{}]{connectivity}{, }\item[{}]{n\+\_\+samples}{, }\item[{}]{n\+\_\+nodes}{, }\item[{}]{n\+\_\+clusters}{, }\item[{}]{n\+\_\+connected\+\_\+components}{, }\item[{}]{return\+\_\+distance}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Perform single linkage clustering on sparse data via the minimum
spanning tree from scipy.sparse.csgraph, then using union-find to label.
The parent array is then generated by walking through the tree.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__agglomerative_8py_source_l00122}{122}} of file \mbox{\hyperlink{__agglomerative_8py_source}{\+\_\+agglomerative.\+py}}.



Referenced by \mbox{\hyperlink{__agglomerative_8py_source_l00433}{linkage\+\_\+tree()}}.

\Hypertarget{namespacesklearn_1_1cluster_1_1__agglomerative_a38921d78a1744f9449ba29ce8bfd0e49}\index{sklearn.cluster.\_agglomerative@{sklearn.cluster.\_agglomerative}!linkage\_tree@{linkage\_tree}}
\index{linkage\_tree@{linkage\_tree}!sklearn.cluster.\_agglomerative@{sklearn.cluster.\_agglomerative}}
\doxysubsubsection{\texorpdfstring{linkage\_tree()}{linkage\_tree()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1cluster_1_1__agglomerative_a38921d78a1744f9449ba29ce8bfd0e49} 
sklearn.\+cluster.\+\_\+agglomerative.\+linkage\+\_\+tree (\begin{DoxyParamCaption}\item[{}]{X}{, }\item[{}]{connectivity}{ = {\ttfamily None}, }\item[{}]{n\+\_\+clusters}{ = {\ttfamily None}, }\item[{}]{linkage}{ = {\ttfamily "{}complete"{}}, }\item[{}]{affinity}{ = {\ttfamily "{}euclidean"{}}, }\item[{}]{return\+\_\+distance}{ = {\ttfamily False}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Linkage agglomerative clustering based on a Feature matrix.

The inertia matrix uses a Heapq-based representation.

This is the structured version, that takes into account some topological
structure between samples.

Read more in the :ref:`User Guide <hierarchical_clustering>`.

Parameters
----------
X : array-like of shape (n_samples, n_features)
    Feature matrix representing `n_samples` samples to be clustered.

connectivity : sparse matrix, default=None
    Connectivity matrix. Defines for each sample the neighboring samples
    following a given structure of the data. The matrix is assumed to
    be symmetric and only the upper triangular half is used.
    Default is `None`, i.e, the Ward algorithm is unstructured.

n_clusters : int, default=None
    Stop early the construction of the tree at `n_clusters`. This is
    useful to decrease computation time if the number of clusters is
    not small compared to the number of samples. In this case, the
    complete tree is not computed, thus the 'children' output is of
    limited use, and the 'parents' output should rather be used.
    This option is valid only when specifying a connectivity matrix.

linkage : {"average", "complete", "single"}, default="complete"
    Which linkage criteria to use. The linkage criterion determines which
    distance to use between sets of observation.
        - "average" uses the average of the distances of each observation of
          the two sets.
        - "complete" or maximum linkage uses the maximum distances between
          all observations of the two sets.
        - "single" uses the minimum of the distances between all
          observations of the two sets.

affinity : str or callable, default='euclidean'
    Which metric to use. Can be 'euclidean', 'manhattan', or any
    distance known to paired distance (see metric.pairwise).

return_distance : bool, default=False
    Whether or not to return the distances between the clusters.

Returns
-------
children : ndarray of shape (n_nodes-1, 2)
    The children of each non-leaf node. Values less than `n_samples`
    correspond to leaves of the tree which are the original samples.
    A node `i` greater than or equal to `n_samples` is a non-leaf
    node and has children `children_[i - n_samples]`. Alternatively
    at the i-th iteration, children[i][0] and children[i][1]
    are merged to form node `n_samples + i`.

n_connected_components : int
    The number of connected components in the graph.

n_leaves : int
    The number of leaves in the tree.

parents : ndarray of shape (n_nodes, ) or None
    The parent of each node. Only returned when a connectivity matrix
    is specified, elsewhere 'None' is returned.

distances : ndarray of shape (n_nodes-1,)
    Returned when `return_distance` is set to `True`.

    distances[i] refers to the distance between children[i][0] and
    children[i][1] when they are merged.

See Also
--------
ward_tree : Hierarchical clustering with ward linkage.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__agglomerative_8py_source_l00426}{426}} of file \mbox{\hyperlink{__agglomerative_8py_source}{\+\_\+agglomerative.\+py}}.



References \mbox{\hyperlink{__agglomerative_8py_source_l00046}{\+\_\+fix\+\_\+connectivity()}}, \mbox{\hyperlink{__agglomerative_8py_source_l00129}{\+\_\+single\+\_\+linkage\+\_\+tree()}}, and \mbox{\hyperlink{__agglomerative_8py_source_l00433}{linkage\+\_\+tree()}}.



Referenced by \mbox{\hyperlink{__agglomerative_8py_source_l00433}{linkage\+\_\+tree()}}.

\Hypertarget{namespacesklearn_1_1cluster_1_1__agglomerative_acb2df287905ff22850b785d38d08f6c8}\index{sklearn.cluster.\_agglomerative@{sklearn.cluster.\_agglomerative}!ward\_tree@{ward\_tree}}
\index{ward\_tree@{ward\_tree}!sklearn.cluster.\_agglomerative@{sklearn.cluster.\_agglomerative}}
\doxysubsubsection{\texorpdfstring{ward\_tree()}{ward\_tree()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1cluster_1_1__agglomerative_acb2df287905ff22850b785d38d08f6c8} 
sklearn.\+cluster.\+\_\+agglomerative.\+ward\+\_\+tree (\begin{DoxyParamCaption}\item[{}]{X}{, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{connectivity}{ = {\ttfamily None}, }\item[{}]{n\+\_\+clusters}{ = {\ttfamily None}, }\item[{}]{return\+\_\+distance}{ = {\ttfamily False}}\end{DoxyParamCaption})}



Hierarchical tree building functions. 

\begin{DoxyVerb}Ward clustering based on a Feature matrix.

Recursively merges the pair of clusters that minimally increases
within-cluster variance.

The inertia matrix uses a Heapq-based representation.

This is the structured version, that takes into account some topological
structure between samples.

Read more in the :ref:`User Guide <hierarchical_clustering>`.

Parameters
----------
X : array-like of shape (n_samples, n_features)
    Feature matrix representing `n_samples` samples to be clustered.

connectivity : {array-like, sparse matrix}, default=None
    Connectivity matrix. Defines for each sample the neighboring samples
    following a given structure of the data. The matrix is assumed to
    be symmetric and only the upper triangular half is used.
    Default is None, i.e, the Ward algorithm is unstructured.

n_clusters : int, default=None
    `n_clusters` should be less than `n_samples`.  Stop early the
    construction of the tree at `n_clusters.` This is useful to decrease
    computation time if the number of clusters is not small compared to the
    number of samples. In this case, the complete tree is not computed, thus
    the 'children' output is of limited use, and the 'parents' output should
    rather be used. This option is valid only when specifying a connectivity
    matrix.

return_distance : bool, default=False
    If `True`, return the distance between the clusters.

Returns
-------
children : ndarray of shape (n_nodes-1, 2)
    The children of each non-leaf node. Values less than `n_samples`
    correspond to leaves of the tree which are the original samples.
    A node `i` greater than or equal to `n_samples` is a non-leaf
    node and has children `children_[i - n_samples]`. Alternatively
    at the i-th iteration, children[i][0] and children[i][1]
    are merged to form node `n_samples + i`.

n_connected_components : int
    The number of connected components in the graph.

n_leaves : int
    The number of leaves in the tree.

parents : ndarray of shape (n_nodes,) or None
    The parent of each node. Only returned when a connectivity matrix
    is specified, elsewhere 'None' is returned.

distances : ndarray of shape (n_nodes-1,)
    Only returned if `return_distance` is set to `True` (for compatibility).
    The distances between the centers of the nodes. `distances[i]`
    corresponds to a weighted Euclidean distance between
    the nodes `children[i, 1]` and `children[i, 2]`. If the nodes refer to
    leaves of the tree, then `distances[i]` is their unweighted Euclidean
    distance. Distances are updated in the following way
    (from scipy.hierarchy.linkage):

    The new entry :math:`d(u,v)` is computed as follows,

    .. math::

       d(u,v) = \\sqrt{\\frac{|v|+|s|}
                           {T}d(v,s)^2
                    + \\frac{|v|+|t|}
                           {T}d(v,t)^2
                    - \\frac{|v|}
                           {T}d(s,t)^2}

    where :math:`u` is the newly joined cluster consisting of
    clusters :math:`s` and :math:`t`, :math:`v` is an unused
    cluster in the forest, :math:`T=|v|+|s|+|t|`, and
    :math:`|*|` is the cardinality of its argument. This is also
    known as the incremental algorithm.

Examples
--------
>>> import numpy as np
>>> from sklearn.cluster import ward_tree
>>> X = np.array([[1, 2], [1, 4], [1, 0],
...               [4, 2], [4, 4], [4, 0]])
>>> children, n_connected_components, n_leaves, parents = ward_tree(X)
>>> children
array([[0, 1],
       [3, 5],
       [2, 6],
       [4, 7],
       [8, 9]])
>>> n_connected_components
1
>>> n_leaves
6
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__agglomerative_8py_source_l00191}{191}} of file \mbox{\hyperlink{__agglomerative_8py_source}{\+\_\+agglomerative.\+py}}.



References \mbox{\hyperlink{__agglomerative_8py_source_l00046}{\+\_\+fix\+\_\+connectivity()}}.



\doxysubsection{Variable Documentation}
\Hypertarget{namespacesklearn_1_1cluster_1_1__agglomerative_a2b1947c000f96fb6a39bbaafc58697aa}\index{sklearn.cluster.\_agglomerative@{sklearn.cluster.\_agglomerative}!\_TREE\_BUILDERS@{\_TREE\_BUILDERS}}
\index{\_TREE\_BUILDERS@{\_TREE\_BUILDERS}!sklearn.cluster.\_agglomerative@{sklearn.cluster.\_agglomerative}}
\doxysubsubsection{\texorpdfstring{\_TREE\_BUILDERS}{\_TREE\_BUILDERS}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1cluster_1_1__agglomerative_a2b1947c000f96fb6a39bbaafc58697aa} 
sklearn.\+cluster.\+\_\+agglomerative.\+\_\+\+TREE\+\_\+\+BUILDERS\hspace{0.3cm}{\ttfamily [protected]}}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ dict(}
\DoxyCodeLine{00002\ \ \ \ \ ward=ward\_tree,}
\DoxyCodeLine{00003\ \ \ \ \ complete=\_complete\_linkage,}
\DoxyCodeLine{00004\ \ \ \ \ average=\_average\_linkage,}
\DoxyCodeLine{00005\ \ \ \ \ single=\_single\_linkage,}
\DoxyCodeLine{00006\ )}

\end{DoxyCode}


Definition at line \mbox{\hyperlink{__agglomerative_8py_source_l00718}{718}} of file \mbox{\hyperlink{__agglomerative_8py_source}{\+\_\+agglomerative.\+py}}.

