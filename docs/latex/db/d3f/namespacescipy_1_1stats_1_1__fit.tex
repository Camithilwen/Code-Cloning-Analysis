\doxysection{scipy.\+stats.\+\_\+fit Namespace Reference}
\hypertarget{namespacescipy_1_1stats_1_1__fit}{}\label{namespacescipy_1_1stats_1_1__fit}\index{scipy.stats.\_fit@{scipy.stats.\_fit}}
\doxysubsubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classscipy_1_1stats_1_1__fit_1_1FitResult}{Fit\+Result}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacescipy_1_1stats_1_1__fit_ad0524a2cd7d61417718d08726ec7feb8}{\+\_\+combine\+\_\+bounds}} (name, user\+\_\+bounds, shape\+\_\+domain, integral)
\item 
\mbox{\hyperlink{namespacescipy_1_1stats_1_1__fit_aed076696685b96f8ff3325439f911081}{fit}} (dist, data, bounds=None, \texorpdfstring{$\ast$}{*}, guess=None, method=\textquotesingle{}mle\textquotesingle{}, optimizer=optimize.\+differential\+\_\+evolution)
\item 
\mbox{\hyperlink{namespacescipy_1_1stats_1_1__fit_a9cfadf2e268aa9baafe11695c13e0669}{goodness\+\_\+of\+\_\+fit}} (dist, data, \texorpdfstring{$\ast$}{*}, known\+\_\+params=None, fit\+\_\+params=None, guessed\+\_\+params=None, statistic=\textquotesingle{}ad\textquotesingle{}, n\+\_\+mc\+\_\+samples=9999, random\+\_\+state=None)
\item 
\mbox{\hyperlink{namespacescipy_1_1stats_1_1__fit_abd3a3802a6d18ded8fb7864f8da6e479}{\+\_\+get\+\_\+fit\+\_\+fun}} (dist, data, guessed\+\_\+params, fixed\+\_\+params)
\item 
\mbox{\hyperlink{namespacescipy_1_1stats_1_1__fit_a9c590305c31e942e5c2e5b4ef32230a5}{\+\_\+fit\+\_\+norm}} (data, floc=None, fscale=None)
\item 
\mbox{\hyperlink{namespacescipy_1_1stats_1_1__fit_ab03350c7a0f30b7b5dca2f7fee6687d6}{\+\_\+anderson\+\_\+darling}} (dist, data)
\item 
\mbox{\hyperlink{namespacescipy_1_1stats_1_1__fit_aed402b8f42b1af34b8cb123278bbd20b}{\+\_\+compute\+\_\+dplus}} (cdfvals)
\item 
\mbox{\hyperlink{namespacescipy_1_1stats_1_1__fit_a92afd7d9473a342d7f793ce7433e76a6}{\+\_\+compute\+\_\+dminus}} (cdfvals, axis=-\/1)
\item 
\mbox{\hyperlink{namespacescipy_1_1stats_1_1__fit_a5a624646a86534bce5ef8736703d9f69}{\+\_\+kolmogorov\+\_\+smirnov}} (dist, data)
\item 
\mbox{\hyperlink{namespacescipy_1_1stats_1_1__fit_a3fdc31d480a4b6c74d1efa637646707f}{\+\_\+corr}} (X, M)
\item 
\mbox{\hyperlink{namespacescipy_1_1stats_1_1__fit_a084106ca46092c21efedbe17f2a9932a}{\+\_\+filliben}} (dist, data)
\item 
\mbox{\hyperlink{namespacescipy_1_1stats_1_1__fit_a3a1826b799877d5693fbab76a3c19635}{\+\_\+cramer\+\_\+von\+\_\+mises}} (dist, data)
\item 
\mbox{\hyperlink{namespacescipy_1_1stats_1_1__fit_a3ede123b4a3486558c529bcb728a84b5}{\+\_\+gof\+\_\+iv}} (dist, data, known\+\_\+params, fit\+\_\+params, guessed\+\_\+params, statistic, n\+\_\+mc\+\_\+samples, random\+\_\+state)
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacescipy_1_1stats_1_1__fit_aa71a306222e85699ffa1d74d4e32aa8f}{Goodness\+Of\+Fit\+Result}}
\item 
dict \mbox{\hyperlink{namespacescipy_1_1stats_1_1__fit_a902eb37b32ed19a6c15ea3f8fd18b235}{\+\_\+fit\+\_\+funs}} = \{stats.\+norm\+: \+\_\+fit\+\_\+norm\}
\item 
\mbox{\hyperlink{namespacescipy_1_1stats_1_1__fit_acf61196fdcbb546f0a24b0a15f20fd02}{alternative}}
\item 
dict \mbox{\hyperlink{namespacescipy_1_1stats_1_1__fit_a5599fa8ec8c5b0cc8b2c564a25ae9b3b}{\+\_\+compare\+\_\+dict}}
\end{DoxyCompactItemize}


\doxysubsection{Function Documentation}
\Hypertarget{namespacescipy_1_1stats_1_1__fit_ab03350c7a0f30b7b5dca2f7fee6687d6}\index{scipy.stats.\_fit@{scipy.stats.\_fit}!\_anderson\_darling@{\_anderson\_darling}}
\index{\_anderson\_darling@{\_anderson\_darling}!scipy.stats.\_fit@{scipy.stats.\_fit}}
\doxysubsubsection{\texorpdfstring{\_anderson\_darling()}{\_anderson\_darling()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1stats_1_1__fit_ab03350c7a0f30b7b5dca2f7fee6687d6} 
scipy.\+stats.\+\_\+fit.\+\_\+anderson\+\_\+darling (\begin{DoxyParamCaption}\item[{}]{dist}{, }\item[{}]{data}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{__fit_8py_source_l01194}{1194}} of file \mbox{\hyperlink{__fit_8py_source}{\+\_\+fit.\+py}}.

\Hypertarget{namespacescipy_1_1stats_1_1__fit_ad0524a2cd7d61417718d08726ec7feb8}\index{scipy.stats.\_fit@{scipy.stats.\_fit}!\_combine\_bounds@{\_combine\_bounds}}
\index{\_combine\_bounds@{\_combine\_bounds}!scipy.stats.\_fit@{scipy.stats.\_fit}}
\doxysubsubsection{\texorpdfstring{\_combine\_bounds()}{\_combine\_bounds()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1stats_1_1__fit_ad0524a2cd7d61417718d08726ec7feb8} 
scipy.\+stats.\+\_\+fit.\+\_\+combine\+\_\+bounds (\begin{DoxyParamCaption}\item[{}]{name}{, }\item[{}]{user\+\_\+bounds}{, }\item[{}]{shape\+\_\+domain}{, }\item[{}]{integral}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Intersection of user-defined bounds and distribution PDF/PMF domain\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__fit_8py_source_l00008}{8}} of file \mbox{\hyperlink{__fit_8py_source}{\+\_\+fit.\+py}}.



Referenced by \mbox{\hyperlink{__fit_8py_source_l00298}{fit()}}.

\Hypertarget{namespacescipy_1_1stats_1_1__fit_a92afd7d9473a342d7f793ce7433e76a6}\index{scipy.stats.\_fit@{scipy.stats.\_fit}!\_compute\_dminus@{\_compute\_dminus}}
\index{\_compute\_dminus@{\_compute\_dminus}!scipy.stats.\_fit@{scipy.stats.\_fit}}
\doxysubsubsection{\texorpdfstring{\_compute\_dminus()}{\_compute\_dminus()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1stats_1_1__fit_a92afd7d9473a342d7f793ce7433e76a6} 
scipy.\+stats.\+\_\+fit.\+\_\+compute\+\_\+dminus (\begin{DoxyParamCaption}\item[{}]{cdfvals}{, }\item[{}]{axis}{ = {\ttfamily -\/1}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{__fit_8py_source_l01208}{1208}} of file \mbox{\hyperlink{__fit_8py_source}{\+\_\+fit.\+py}}.

\Hypertarget{namespacescipy_1_1stats_1_1__fit_aed402b8f42b1af34b8cb123278bbd20b}\index{scipy.stats.\_fit@{scipy.stats.\_fit}!\_compute\_dplus@{\_compute\_dplus}}
\index{\_compute\_dplus@{\_compute\_dplus}!scipy.stats.\_fit@{scipy.stats.\_fit}}
\doxysubsubsection{\texorpdfstring{\_compute\_dplus()}{\_compute\_dplus()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1stats_1_1__fit_aed402b8f42b1af34b8cb123278bbd20b} 
scipy.\+stats.\+\_\+fit.\+\_\+compute\+\_\+dplus (\begin{DoxyParamCaption}\item[{}]{cdfvals}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{__fit_8py_source_l01203}{1203}} of file \mbox{\hyperlink{__fit_8py_source}{\+\_\+fit.\+py}}.

\Hypertarget{namespacescipy_1_1stats_1_1__fit_a3fdc31d480a4b6c74d1efa637646707f}\index{scipy.stats.\_fit@{scipy.stats.\_fit}!\_corr@{\_corr}}
\index{\_corr@{\_corr}!scipy.stats.\_fit@{scipy.stats.\_fit}}
\doxysubsubsection{\texorpdfstring{\_corr()}{\_corr()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1stats_1_1__fit_a3fdc31d480a4b6c74d1efa637646707f} 
scipy.\+stats.\+\_\+fit.\+\_\+corr (\begin{DoxyParamCaption}\item[{}]{X}{, }\item[{}]{M}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{__fit_8py_source_l01221}{1221}} of file \mbox{\hyperlink{__fit_8py_source}{\+\_\+fit.\+py}}.

\Hypertarget{namespacescipy_1_1stats_1_1__fit_a3a1826b799877d5693fbab76a3c19635}\index{scipy.stats.\_fit@{scipy.stats.\_fit}!\_cramer\_von\_mises@{\_cramer\_von\_mises}}
\index{\_cramer\_von\_mises@{\_cramer\_von\_mises}!scipy.stats.\_fit@{scipy.stats.\_fit}}
\doxysubsubsection{\texorpdfstring{\_cramer\_von\_mises()}{\_cramer\_von\_mises()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1stats_1_1__fit_a3a1826b799877d5693fbab76a3c19635} 
scipy.\+stats.\+\_\+fit.\+\_\+cramer\+\_\+von\+\_\+mises (\begin{DoxyParamCaption}\item[{}]{dist}{, }\item[{}]{data}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{__fit_8py_source_l01257}{1257}} of file \mbox{\hyperlink{__fit_8py_source}{\+\_\+fit.\+py}}.

\Hypertarget{namespacescipy_1_1stats_1_1__fit_a084106ca46092c21efedbe17f2a9932a}\index{scipy.stats.\_fit@{scipy.stats.\_fit}!\_filliben@{\_filliben}}
\index{\_filliben@{\_filliben}!scipy.stats.\_fit@{scipy.stats.\_fit}}
\doxysubsubsection{\texorpdfstring{\_filliben()}{\_filliben()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1stats_1_1__fit_a084106ca46092c21efedbe17f2a9932a} 
scipy.\+stats.\+\_\+fit.\+\_\+filliben (\begin{DoxyParamCaption}\item[{}]{dist}{, }\item[{}]{data}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{__fit_8py_source_l01232}{1232}} of file \mbox{\hyperlink{__fit_8py_source}{\+\_\+fit.\+py}}.

\Hypertarget{namespacescipy_1_1stats_1_1__fit_a9c590305c31e942e5c2e5b4ef32230a5}\index{scipy.stats.\_fit@{scipy.stats.\_fit}!\_fit\_norm@{\_fit\_norm}}
\index{\_fit\_norm@{\_fit\_norm}!scipy.stats.\_fit@{scipy.stats.\_fit}}
\doxysubsubsection{\texorpdfstring{\_fit\_norm()}{\_fit\_norm()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1stats_1_1__fit_a9c590305c31e942e5c2e5b4ef32230a5} 
scipy.\+stats.\+\_\+fit.\+\_\+fit\+\_\+norm (\begin{DoxyParamCaption}\item[{}]{data}{, }\item[{}]{floc}{ = {\ttfamily None}, }\item[{}]{fscale}{ = {\ttfamily None}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{__fit_8py_source_l01173}{1173}} of file \mbox{\hyperlink{__fit_8py_source}{\+\_\+fit.\+py}}.

\Hypertarget{namespacescipy_1_1stats_1_1__fit_abd3a3802a6d18ded8fb7864f8da6e479}\index{scipy.stats.\_fit@{scipy.stats.\_fit}!\_get\_fit\_fun@{\_get\_fit\_fun}}
\index{\_get\_fit\_fun@{\_get\_fit\_fun}!scipy.stats.\_fit@{scipy.stats.\_fit}}
\doxysubsubsection{\texorpdfstring{\_get\_fit\_fun()}{\_get\_fit\_fun()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1stats_1_1__fit_abd3a3802a6d18ded8fb7864f8da6e479} 
scipy.\+stats.\+\_\+fit.\+\_\+get\+\_\+fit\+\_\+fun (\begin{DoxyParamCaption}\item[{}]{dist}{, }\item[{}]{data}{, }\item[{}]{guessed\+\_\+params}{, }\item[{}]{fixed\+\_\+params}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{__fit_8py_source_l01136}{1136}} of file \mbox{\hyperlink{__fit_8py_source}{\+\_\+fit.\+py}}.

\Hypertarget{namespacescipy_1_1stats_1_1__fit_a3ede123b4a3486558c529bcb728a84b5}\index{scipy.stats.\_fit@{scipy.stats.\_fit}!\_gof\_iv@{\_gof\_iv}}
\index{\_gof\_iv@{\_gof\_iv}!scipy.stats.\_fit@{scipy.stats.\_fit}}
\doxysubsubsection{\texorpdfstring{\_gof\_iv()}{\_gof\_iv()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1stats_1_1__fit_a3ede123b4a3486558c529bcb728a84b5} 
scipy.\+stats.\+\_\+fit.\+\_\+gof\+\_\+iv (\begin{DoxyParamCaption}\item[{}]{dist}{, }\item[{}]{data}{, }\item[{}]{known\+\_\+params}{, }\item[{}]{fit\+\_\+params}{, }\item[{}]{guessed\+\_\+params}{, }\item[{}]{statistic}{, }\item[{}]{n\+\_\+mc\+\_\+samples}{, }\item[{}]{random\+\_\+state}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{__fit_8py_source_l01270}{1270}} of file \mbox{\hyperlink{__fit_8py_source}{\+\_\+fit.\+py}}.

\Hypertarget{namespacescipy_1_1stats_1_1__fit_a5a624646a86534bce5ef8736703d9f69}\index{scipy.stats.\_fit@{scipy.stats.\_fit}!\_kolmogorov\_smirnov@{\_kolmogorov\_smirnov}}
\index{\_kolmogorov\_smirnov@{\_kolmogorov\_smirnov}!scipy.stats.\_fit@{scipy.stats.\_fit}}
\doxysubsubsection{\texorpdfstring{\_kolmogorov\_smirnov()}{\_kolmogorov\_smirnov()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1stats_1_1__fit_a5a624646a86534bce5ef8736703d9f69} 
scipy.\+stats.\+\_\+fit.\+\_\+kolmogorov\+\_\+smirnov (\begin{DoxyParamCaption}\item[{}]{dist}{, }\item[{}]{data}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{__fit_8py_source_l01213}{1213}} of file \mbox{\hyperlink{__fit_8py_source}{\+\_\+fit.\+py}}.

\Hypertarget{namespacescipy_1_1stats_1_1__fit_aed076696685b96f8ff3325439f911081}\index{scipy.stats.\_fit@{scipy.stats.\_fit}!fit@{fit}}
\index{fit@{fit}!scipy.stats.\_fit@{scipy.stats.\_fit}}
\doxysubsubsection{\texorpdfstring{fit()}{fit()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1stats_1_1__fit_aed076696685b96f8ff3325439f911081} 
scipy.\+stats.\+\_\+fit.\+fit (\begin{DoxyParamCaption}\item[{}]{dist}{, }\item[{}]{data}{, }\item[{}]{bounds}{ = {\ttfamily None}, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{guess}{ = {\ttfamily None}, }\item[{}]{method}{ = {\ttfamily \textquotesingle{}mle\textquotesingle{}}, }\item[{}]{optimizer}{ = {\ttfamily optimize.differential\+\_\+evolution}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Fit a discrete or continuous distribution to data

Given a distribution, data, and bounds on the parameters of the
distribution, return maximum likelihood estimates of the parameters.

Parameters
----------
dist : `scipy.stats.rv_continuous` or `scipy.stats.rv_discrete`
The object representing the distribution to be fit to the data.
data : 1D array_like
The data to which the distribution is to be fit. If the data contain
any of ``np.nan``, ``np.inf``, or -``np.inf``, the fit method will
raise a ``ValueError``.
bounds : dict or sequence of tuples, optional
If a dictionary, each key is the name of a parameter of the
distribution, and the corresponding value is a tuple containing the
lower and upper bound on that parameter.  If the distribution is
defined only for a finite range of values of that parameter, no entry
for that parameter is required; e.g., some distributions have
parameters which must be on the interval [0, 1]. Bounds for parameters
location (``loc``) and scale (``scale``) are optional; by default,
they are fixed to 0 and 1, respectively.

If a sequence, element *i* is a tuple containing the lower and upper
bound on the *i*\ th parameter of the distribution. In this case,
bounds for *all* distribution shape parameters must be provided.
Optionally, bounds for location and scale may follow the
distribution shape parameters.

If a shape is to be held fixed (e.g. if it is known), the
lower and upper bounds may be equal. If a user-provided lower or upper
bound is beyond a bound of the domain for which the distribution is
defined, the bound of the distribution's domain will replace the
user-provided value. Similarly, parameters which must be integral
will be constrained to integral values within the user-provided bounds.
guess : dict or array_like, optional
If a dictionary, each key is the name of a parameter of the
distribution, and the corresponding value is a guess for the value
of the parameter.

If a sequence, element *i* is a guess for the *i*\ th parameter of the
distribution. In this case, guesses for *all* distribution shape
parameters must be provided.

If `guess` is not provided, guesses for the decision variables will
not be passed to the optimizer. If `guess` is provided, guesses for
any missing parameters will be set at the mean of the lower and
upper bounds. Guesses for parameters which must be integral will be
rounded to integral values, and guesses that lie outside the
intersection of the user-provided bounds and the domain of the
distribution will be clipped.
method : {'mle', 'mse'}
With ``method="mle"`` (default), the fit is computed by minimizing
the negative log-likelihood function. A large, finite penalty
(rather than infinite negative log-likelihood) is applied for
observations beyond the support of the distribution.
With ``method="mse"``, the fit is computed by minimizing
the negative log-product spacing function. The same penalty is applied
for observations beyond the support. We follow the approach of [1]_,
which is generalized for samples with repeated observations.
optimizer : callable, optional
`optimizer` is a callable that accepts the following positional
argument.

fun : callable
    The objective function to be optimized. `fun` accepts one argument
    ``x``, candidate shape parameters of the distribution, and returns
    the objective function value given ``x``, `dist`, and the provided
    `data`.
    The job of `optimizer` is to find values of the decision variables
    that minimizes `fun`.

`optimizer` must also accept the following keyword argument.

bounds : sequence of tuples
    The bounds on values of the decision variables; each element will
    be a tuple containing the lower and upper bound on a decision
    variable.

If `guess` is provided, `optimizer` must also accept the following
keyword argument.

x0 : array_like
    The guesses for each decision variable.

If the distribution has any shape parameters that must be integral or
if the distribution is discrete and the location parameter is not
fixed, `optimizer` must also accept the following keyword argument.

integrality : array_like of bools
    For each decision variable, True if the decision variable
    must be constrained to integer values and False if the decision
    variable is continuous.

`optimizer` must return an object, such as an instance of
`scipy.optimize.OptimizeResult`, which holds the optimal values of
the decision variables in an attribute ``x``. If attributes
``fun``, ``status``, or ``message`` are provided, they will be
included in the result object returned by `fit`.

Returns
-------
result : `~scipy.stats._result_classes.FitResult`
An object with the following fields.

params : namedtuple
    A namedtuple containing the maximum likelihood estimates of the
    shape parameters, location, and (if applicable) scale of the
    distribution.
success : bool or None
    Whether the optimizer considered the optimization to terminate
    successfully or not.
message : str or None
    Any status message provided by the optimizer.

The object has the following method:

nllf(params=None, data=None)
    By default, the negative log-likehood function at the fitted
    `params` for the given `data`. Accepts a tuple containing
    alternative shapes, location, and scale of the distribution and
    an array of alternative data.

plot(ax=None)
    Superposes the PDF/PMF of the fitted distribution over a normalized
    histogram of the data.

See Also
--------
rv_continuous,  rv_discrete

Notes
-----
Optimization is more likely to converge to the maximum likelihood estimate
when the user provides tight bounds containing the maximum likelihood
estimate. For example, when fitting a binomial distribution to data, the
number of experiments underlying each sample may be known, in which case
the corresponding shape parameter ``n`` can be fixed.

References
----------
.. [1] Shao, Yongzhao, and Marjorie G. Hahn. "Maximum product of spacings
   method: a unified formulation with illustration of strong
   consistency." Illinois Journal of Mathematics 43.3 (1999): 489-499.

Examples
--------
Suppose we wish to fit a distribution to the following data.

>>> import numpy as np
>>> from scipy import stats
>>> rng = np.random.default_rng()
>>> dist = stats.nbinom
>>> shapes = (5, 0.5)
>>> data = dist.rvs(*shapes, size=1000, random_state=rng)

Suppose we do not know how the data were generated, but we suspect that
it follows a negative binomial distribution with parameters *n* and *p*\.
(See `scipy.stats.nbinom`.) We believe that the parameter *n* was fewer
than 30, and we know that the parameter *p* must lie on the interval
[0, 1]. We record this information in a variable `bounds` and pass
this information to `fit`.

>>> bounds = [(0, 30), (0, 1)]
>>> res = stats.fit(dist, data, bounds)

`fit` searches within the user-specified `bounds` for the
values that best match the data (in the sense of maximum likelihood
estimation). In this case, it found shape values similar to those
from which the data were actually generated.

>>> res.params
FitParams(n=5.0, p=0.5028157644634368, loc=0.0)  # may vary

We can visualize the results by superposing the probability mass function
of the distribution (with the shapes fit to the data) over a normalized
histogram of the data.

>>> import matplotlib.pyplot as plt  # matplotlib must be installed to plot
>>> res.plot()
>>> plt.show()

Note that the estimate for *n* was exactly integral; this is because
the domain of the `nbinom` PMF includes only integral *n*, and the `nbinom`
object "knows" that. `nbinom` also knows that the shape *p* must be a
value between 0 and 1. In such a case - when the domain of the distribution
with respect to a parameter is finite - we are not required to specify
bounds for the parameter.

>>> bounds = {'n': (0, 30)}  # omit parameter p using a `dict`
>>> res2 = stats.fit(dist, data, bounds)
>>> res2.params
FitParams(n=5.0, p=0.5016492009232932, loc=0.0)  # may vary

If we wish to force the distribution to be fit with *n* fixed at 6, we can
set both the lower and upper bounds on *n* to 6. Note, however, that the
value of the objective function being optimized is typically worse (higher)
in this case.

>>> bounds = {'n': (6, 6)}  # fix parameter `n`
>>> res3 = stats.fit(dist, data, bounds)
>>> res3.params
FitParams(n=6.0, p=0.5486556076755706, loc=0.0)  # may vary
>>> res3.nllf() > res.nllf()
True  # may vary

Note that the numerical results of the previous examples are typical, but
they may vary because the default optimizer used by `fit`,
`scipy.optimize.differential_evolution`, is stochastic. However, we can
customize the settings used by the optimizer to ensure reproducibility -
or even use a different optimizer entirely - using the `optimizer`
parameter.

>>> from scipy.optimize import differential_evolution
>>> rng = np.random.default_rng(767585560716548)
>>> def optimizer(fun, bounds, *, integrality):
...     return differential_evolution(fun, bounds, strategy='best2bin',
...                                   seed=rng, integrality=integrality)
>>> bounds = [(0, 30), (0, 1)]
>>> res4 = stats.fit(dist, data, bounds, optimizer=optimizer)
>>> res4.params
FitParams(n=5.0, p=0.5015183149259951, loc=0.0)
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__fit_8py_source_l00297}{297}} of file \mbox{\hyperlink{__fit_8py_source}{\+\_\+fit.\+py}}.



References \mbox{\hyperlink{__fit_8py_source_l00008}{\+\_\+combine\+\_\+bounds()}}.

\Hypertarget{namespacescipy_1_1stats_1_1__fit_a9cfadf2e268aa9baafe11695c13e0669}\index{scipy.stats.\_fit@{scipy.stats.\_fit}!goodness\_of\_fit@{goodness\_of\_fit}}
\index{goodness\_of\_fit@{goodness\_of\_fit}!scipy.stats.\_fit@{scipy.stats.\_fit}}
\doxysubsubsection{\texorpdfstring{goodness\_of\_fit()}{goodness\_of\_fit()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1stats_1_1__fit_a9cfadf2e268aa9baafe11695c13e0669} 
scipy.\+stats.\+\_\+fit.\+goodness\+\_\+of\+\_\+fit (\begin{DoxyParamCaption}\item[{}]{dist}{, }\item[{}]{data}{, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{known\+\_\+params}{ = {\ttfamily None}, }\item[{}]{fit\+\_\+params}{ = {\ttfamily None}, }\item[{}]{guessed\+\_\+params}{ = {\ttfamily None}, }\item[{}]{statistic}{ = {\ttfamily \textquotesingle{}ad\textquotesingle{}}, }\item[{}]{n\+\_\+mc\+\_\+samples}{ = {\ttfamily 9999}, }\item[{}]{random\+\_\+state}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Perform a goodness of fit test comparing data to a distribution family.

Given a distribution family and data, perform a test of the null hypothesis
that the data were drawn from a distribution in that family. Any known
parameters of the distribution may be specified. Remaining parameters of
the distribution will be fit to the data, and the p-value of the test
is computed accordingly. Several statistics for comparing the distribution
to data are available.

Parameters
----------
dist : `scipy.stats.rv_continuous`
    The object representing the distribution family under the null
    hypothesis.
data : 1D array_like
    Finite, uncensored data to be tested.
known_params : dict, optional
    A dictionary containing name-value pairs of known distribution
    parameters. Monte Carlo samples are randomly drawn from the
    null-hypothesized distribution with these values of the parameters.
    Before the statistic is evaluated for each Monte Carlo sample, only
    remaining unknown parameters of the null-hypothesized distribution
    family are fit to the samples; the known parameters are held fixed.
    If all parameters of the distribution family are known, then the step
    of fitting the distribution family to each sample is omitted.
fit_params : dict, optional
    A dictionary containing name-value pairs of distribution parameters
    that have already been fit to the data, e.g. using `scipy.stats.fit`
    or the ``fit`` method of `dist`. Monte Carlo samples are drawn from the
    null-hypothesized distribution with these specified values of the
    parameter. On those Monte Carlo samples, however, these and all other
    unknown parameters of the null-hypothesized distribution family are
    fit before the statistic is evaluated.
guessed_params : dict, optional
    A dictionary containing name-value pairs of distribution parameters
    which have been guessed. These parameters are always considered as
    free parameters and are fit both to the provided `data` as well as
    to the Monte Carlo samples drawn from the null-hypothesized
    distribution. The purpose of these `guessed_params` is to be used as
    initial values for the numerical fitting procedure.
statistic : {"ad", "ks", "cvm", "filliben"}, optional
    The statistic used to compare data to a distribution after fitting
    unknown parameters of the distribution family to the data. The
    Anderson-Darling ("ad") [1]_, Kolmogorov-Smirnov ("ks") [1]_,
    Cramer-von Mises ("cvm") [1]_, and Filliben ("filliben") [7]_
    statistics are available.
n_mc_samples : int, default: 9999
    The number of Monte Carlo samples drawn from the null hypothesized
    distribution to form the null distribution of the statistic. The
    sample size of each is the same as the given `data`.
random_state : {None, int, `numpy.random.Generator`,
                `numpy.random.RandomState`}, optional

    Pseudorandom number generator state used to generate the Monte Carlo
    samples.

    If `random_state` is ``None`` (default), the
    `numpy.random.RandomState` singleton is used.
    If `random_state` is an int, a new ``RandomState`` instance is used,
    seeded with `random_state`.
    If `random_state` is already a ``Generator`` or ``RandomState``
    instance, then the provided instance is used.

Returns
-------
res : GoodnessOfFitResult
    An object with the following attributes.

    fit_result : `~scipy.stats._result_classes.FitResult`
        An object representing the fit of the provided `dist` to `data`.
        This  object includes the values of distribution family parameters
        that fully define the null-hypothesized distribution, that is,
        the distribution from which Monte Carlo samples are drawn.
    statistic : float
        The value of the statistic comparing provided `data` to the
        null-hypothesized distribution.
    pvalue : float
        The proportion of elements in the null distribution with
        statistic values at least as extreme as the statistic value of the
        provided `data`.
    null_distribution : ndarray
        The value of the statistic for each Monte Carlo sample
        drawn from the null-hypothesized distribution.

Notes
-----
This is a generalized Monte Carlo goodness-of-fit procedure, special cases
of which correspond with various Anderson-Darling tests, Lilliefors' test,
etc. The test is described in [2]_, [3]_, and [4]_ as a parametric
bootstrap test. This is a Monte Carlo test in which parameters that
specify the distribution from which samples are drawn have been estimated
from the data. We describe the test using "Monte Carlo" rather than
"parametric bootstrap" throughout to avoid confusion with the more familiar
nonparametric bootstrap, and describe how the test is performed below.

*Traditional goodness of fit tests*

Traditionally, critical values corresponding with a fixed set of
significance levels are pre-calculated using Monte Carlo methods. Users
perform the test by calculating the value of the test statistic only for
their observed `data` and comparing this value to tabulated critical
values. This practice is not very flexible, as tables are not available for
all distributions and combinations of known and unknown parameter values.
Also, results can be inaccurate when critical values are interpolated from
limited tabulated data to correspond with the user's sample size and
fitted parameter values. To overcome these shortcomings, this function
allows the user to perform the Monte Carlo trials adapted to their
particular data.

*Algorithmic overview*

In brief, this routine executes the following steps:

  1. Fit unknown parameters to the given `data`, thereby forming the
     "null-hypothesized" distribution, and compute the statistic of
     this pair of data and distribution.
  2. Draw random samples from this null-hypothesized distribution.
  3. Fit the unknown parameters to each random sample.
  4. Calculate the statistic between each sample and the distribution that
     has been fit to the sample.
  5. Compare the value of the statistic corresponding with `data` from (1)
     against the values of the statistic corresponding with the random
     samples from (4). The p-value is the proportion of samples with a
     statistic value greater than or equal to the statistic of the observed
     data.

In more detail, the steps are as follows.

First, any unknown parameters of the distribution family specified by
`dist` are fit to the provided `data` using maximum likelihood estimation.
(One exception is the normal distribution with unknown location and scale:
we use the bias-corrected standard deviation ``np.std(data, ddof=1)`` for
the scale as recommended in [1]_.)
These values of the parameters specify a particular member of the
distribution family referred to as the "null-hypothesized distribution",
that is, the distribution from which the data were sampled under the null
hypothesis. The `statistic`, which compares data to a distribution, is
computed between `data` and the null-hypothesized distribution.

Next, many (specifically `n_mc_samples`) new samples, each containing the
same number of observations as `data`, are drawn from the
null-hypothesized distribution. All unknown parameters of the distribution
family `dist` are fit to *each resample*, and the `statistic` is computed
between each sample and its corresponding fitted distribution. These
values of the statistic form the Monte Carlo null distribution (not to be
confused with the "null-hypothesized distribution" above).

The p-value of the test is the proportion of statistic values in the Monte
Carlo null distribution that are at least as extreme as the statistic value
of the provided `data`. More precisely, the p-value is given by

.. math::

    p = \frac{b + 1}
             {m + 1}

where :math:`b` is the number of statistic values in the Monte Carlo null
distribution that are greater than or equal to the the statistic value
calculated for `data`, and :math:`m` is the number of elements in the
Monte Carlo null distribution (`n_mc_samples`). The addition of :math:`1`
to the numerator and denominator can be thought of as including the
value of the statistic corresponding with `data` in the null distribution,
but a more formal explanation is given in [5]_.

*Limitations*

The test can be very slow for some distribution families because unknown
parameters of the distribution family must be fit to each of the Monte
Carlo samples, and for most distributions in SciPy, distribution fitting
performed via numerical optimization.

*Anti-Pattern*

For this reason, it may be tempting
to treat parameters of the distribution pre-fit to `data` (by the user)
as though they were `known_params`, as specification of all parameters of
the distribution precludes the need to fit the distribution to each Monte
Carlo sample. (This is essentially how the original Kilmogorov-Smirnov
test is performed.) Although such a test can provide evidence against the
null hypothesis, the test is conservative in the sense that small p-values
will tend to (greatly) *overestimate* the probability of making a type I
error (that is, rejecting the null hypothesis although it is true), and the
power of the test is low (that is, it is less likely to reject the null
hypothesis even when the null hypothesis is false).
This is because the Monte Carlo samples are less likely to agree with the
null-hypothesized distribution as well as `data`. This tends to increase
the values of the statistic recorded in the null distribution, so that a
larger number of them exceed the value of statistic for `data`, thereby
inflating the p-value.

References
----------
.. [1] M. A. Stephens (1974). "EDF Statistics for Goodness of Fit and
       Some Comparisons." Journal of the American Statistical Association,
       Vol. 69, pp. 730-737.
.. [2] W. Stute, W. G. Manteiga, and M. P. Quindimil (1993).
       "Bootstrap based goodness-of-fit-tests." Metrika 40.1: 243-256.
.. [3] C. Genest, & B Rémillard. (2008). "Validity of the parametric
       bootstrap for goodness-of-fit testing in semiparametric models."
       Annales de l'IHP Probabilités et statistiques. Vol. 44. No. 6.
.. [4] I. Kojadinovic and J. Yan (2012). "Goodness-of-fit testing based on
       a weighted bootstrap: A fast large-sample alternative to the
       parametric bootstrap." Canadian Journal of Statistics 40.3: 480-500.
.. [5] B. Phipson and G. K. Smyth (2010). "Permutation P-values Should
       Never Be Zero: Calculating Exact P-values When Permutations Are
       Randomly Drawn." Statistical Applications in Genetics and Molecular
       Biology 9.1.
.. [6] H. W. Lilliefors (1967). "On the Kolmogorov-Smirnov test for
       normality with mean and variance unknown." Journal of the American
       statistical Association 62.318: 399-402.
.. [7] Filliben, James J. "The probability plot correlation coefficient
       test for normality." Technometrics 17.1 (1975): 111-117.

Examples
--------
A well-known test of the null hypothesis that data were drawn from a
given distribution is the Kolmogorov-Smirnov (KS) test, available in SciPy
as `scipy.stats.ks_1samp`. Suppose we wish to test whether the following
data:

>>> import numpy as np
>>> from scipy import stats
>>> rng = np.random.default_rng()
>>> x = stats.uniform.rvs(size=75, random_state=rng)

were sampled from a normal distribution. To perform a KS test, the
empirical distribution function of the observed data will be compared
against the (theoretical) cumulative distribution function of a normal
distribution. Of course, to do this, the normal distribution under the null
hypothesis must be fully specified. This is commonly done by first fitting
the ``loc`` and ``scale`` parameters of the distribution to the observed
data, then performing the test.

>>> loc, scale = np.mean(x), np.std(x, ddof=1)
>>> cdf = stats.norm(loc, scale).cdf
>>> stats.ks_1samp(x, cdf)
KstestResult(statistic=0.1119257570456813, pvalue=0.2827756409939257)

An advantage of the KS-test is that the p-value - the probability of
obtaining a value of the test statistic under the null hypothesis as
extreme as the value obtained from the observed data - can be calculated
exactly and efficiently. `goodness_of_fit` can only approximate these
results.

>>> known_params = {'loc': loc, 'scale': scale}
>>> res = stats.goodness_of_fit(stats.norm, x, known_params=known_params,
...                             statistic='ks', random_state=rng)
>>> res.statistic, res.pvalue
(0.1119257570456813, 0.2788)

The statistic matches exactly, but the p-value is estimated by forming
a "Monte Carlo null distribution", that is, by explicitly drawing random
samples from `scipy.stats.norm` with the provided parameters and
calculating the stastic for each. The fraction of these statistic values
at least as extreme as ``res.statistic`` approximates the exact p-value
calculated by `scipy.stats.ks_1samp`.

However, in many cases, we would prefer to test only that the data were
sampled from one of *any* member of the normal distribution family, not
specifically from the normal distribution with the location and scale
fitted to the observed sample. In this case, Lilliefors [6]_ argued that
the KS test is far too conservative (that is, the p-value overstates
the actual probability of rejecting a true null hypothesis) and thus lacks
power - the ability to reject the null hypothesis when the null hypothesis
is actually false.
Indeed, our p-value above is approximately 0.28, which is far too large
to reject the null hypothesis at any common significance level.

Consider why this might be. Note that in the KS test above, the statistic
always compares data against the CDF of a normal distribution fitted to the
*observed data*. This tends to reduce the value of the statistic for the
observed data, but it is "unfair" when computing the statistic for other
samples, such as those we randomly draw to form the Monte Carlo null
distribution. It is easy to correct for this: whenever we compute the KS
statistic of a sample, we use the CDF of a normal distribution fitted
to *that sample*. The null distribution in this case has not been
calculated exactly and is tyically approximated using Monte Carlo methods
as described above. This is where `goodness_of_fit` excels.

>>> res = stats.goodness_of_fit(stats.norm, x, statistic='ks',
...                             random_state=rng)
>>> res.statistic, res.pvalue
(0.1119257570456813, 0.0196)

Indeed, this p-value is much smaller, and small enough to (correctly)
reject the null hypothesis at common signficance levels, including 5% and
2.5%.

However, the KS statistic is not very sensitive to all deviations from
normality. The original advantage of the KS statistic was the ability
to compute the null distribution theoretically, but a more sensitive
statistic - resulting in a higher test power - can be used now that we can
approximate the null distribution
computationally. The Anderson-Darling statistic [1]_ tends to be more
sensitive, and critical values of the this statistic have been tabulated
for various significance levels and sample sizes using Monte Carlo methods.

>>> res = stats.anderson(x, 'norm')
>>> print(res.statistic)
1.2139573337497467
>>> print(res.critical_values)
[0.549 0.625 0.75  0.875 1.041]
>>> print(res.significance_level)
[15.  10.   5.   2.5  1. ]

Here, the observed value of the statistic exceeds the critical value
corresponding with a 1% significance level. This tells us that the p-value
of the observed data is less than 1%, but what is it? We could interpolate
from these (already-interpolated) values, but `goodness_of_fit` can
estimate it directly.

>>> res = stats.goodness_of_fit(stats.norm, x, statistic='ad',
...                             random_state=rng)
>>> res.statistic, res.pvalue
(1.2139573337497467, 0.0034)

A further advantage is that use of `goodness_of_fit` is not limited to
a particular set of distributions or conditions on which parameters
are known versus which must be estimated from data. Instead,
`goodness_of_fit` can estimate p-values relatively quickly for any
distribution with a sufficiently fast and reliable ``fit`` method. For
instance, here we perform a goodness of fit test using the Cramer-von Mises
statistic against the Rayleigh distribution with known location and unknown
scale.

>>> rng = np.random.default_rng()
>>> x = stats.chi(df=2.2, loc=0, scale=2).rvs(size=1000, random_state=rng)
>>> res = stats.goodness_of_fit(stats.rayleigh, x, statistic='cvm',
...                             known_params={'loc': 0}, random_state=rng)

This executes fairly quickly, but to check the reliability of the ``fit``
method, we should inspect the fit result.

>>> res.fit_result  # location is as specified, and scale is reasonable
  params: FitParams(loc=0.0, scale=2.1026719844231243)
 success: True
 message: 'The fit was performed successfully.'
>>> import matplotlib.pyplot as plt  # matplotlib must be installed to plot
>>> res.fit_result.plot()
>>> plt.show()

If the distribution is not fit to the observed data as well as possible,
the test may not control the type I error rate, that is, the chance of
rejecting the null hypothesis even when it is true.

We should also look for extreme outliers in the null distribution that
may be caused by unreliable fitting. These do not necessarily invalidate
the result, but they tend to reduce the test's power.

>>> _, ax = plt.subplots()
>>> ax.hist(np.log10(res.null_distribution))
>>> ax.set_xlabel("log10 of CVM statistic under the null hypothesis")
>>> ax.set_ylabel("Frequency")
>>> ax.set_title("Histogram of the Monte Carlo null distribution")
>>> plt.show()

This plot seems reassuring.

If ``fit`` method is working reliably, and if the distribution of the test
statistic is not particularly sensitive to the values of the fitted
parameters, then the p-value provided by `goodness_of_fit` is expected to
be a good approximation.

>>> res.statistic, res.pvalue
(0.2231991510248692, 0.0525)
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__fit_8py_source_l00722}{722}} of file \mbox{\hyperlink{__fit_8py_source}{\+\_\+fit.\+py}}.



\doxysubsection{Variable Documentation}
\Hypertarget{namespacescipy_1_1stats_1_1__fit_a5599fa8ec8c5b0cc8b2c564a25ae9b3b}\index{scipy.stats.\_fit@{scipy.stats.\_fit}!\_compare\_dict@{\_compare\_dict}}
\index{\_compare\_dict@{\_compare\_dict}!scipy.stats.\_fit@{scipy.stats.\_fit}}
\doxysubsubsection{\texorpdfstring{\_compare\_dict}{\_compare\_dict}}
{\footnotesize\ttfamily \label{namespacescipy_1_1stats_1_1__fit_a5599fa8ec8c5b0cc8b2c564a25ae9b3b} 
dict scipy.\+stats.\+\_\+fit.\+\_\+compare\+\_\+dict\hspace{0.3cm}{\ttfamily [protected]}}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ \{\textcolor{stringliteral}{"{}ad"{}}:\ \_anderson\_darling,\ \textcolor{stringliteral}{"{}ks"{}}:\ \_kolmogorov\_smirnov,}
\DoxyCodeLine{00002\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}cvm"{}}:\ \_cramer\_von\_mises,\ \textcolor{stringliteral}{"{}filliben"{}}:\ \_filliben\}}

\end{DoxyCode}


Definition at line \mbox{\hyperlink{__fit_8py_source_l01266}{1266}} of file \mbox{\hyperlink{__fit_8py_source}{\+\_\+fit.\+py}}.

\Hypertarget{namespacescipy_1_1stats_1_1__fit_a902eb37b32ed19a6c15ea3f8fd18b235}\index{scipy.stats.\_fit@{scipy.stats.\_fit}!\_fit\_funs@{\_fit\_funs}}
\index{\_fit\_funs@{\_fit\_funs}!scipy.stats.\_fit@{scipy.stats.\_fit}}
\doxysubsubsection{\texorpdfstring{\_fit\_funs}{\_fit\_funs}}
{\footnotesize\ttfamily \label{namespacescipy_1_1stats_1_1__fit_a902eb37b32ed19a6c15ea3f8fd18b235} 
dict scipy.\+stats.\+\_\+fit.\+\_\+fit\+\_\+funs = \{stats.\+norm\+: \+\_\+fit\+\_\+norm\}\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{__fit_8py_source_l01186}{1186}} of file \mbox{\hyperlink{__fit_8py_source}{\+\_\+fit.\+py}}.

\Hypertarget{namespacescipy_1_1stats_1_1__fit_acf61196fdcbb546f0a24b0a15f20fd02}\index{scipy.stats.\_fit@{scipy.stats.\_fit}!alternative@{alternative}}
\index{alternative@{alternative}!scipy.stats.\_fit@{scipy.stats.\_fit}}
\doxysubsubsection{\texorpdfstring{alternative}{alternative}}
{\footnotesize\ttfamily \label{namespacescipy_1_1stats_1_1__fit_acf61196fdcbb546f0a24b0a15f20fd02} 
scipy.\+stats.\+\_\+fit.\+alternative}



Definition at line \mbox{\hyperlink{__fit_8py_source_l01254}{1254}} of file \mbox{\hyperlink{__fit_8py_source}{\+\_\+fit.\+py}}.

\Hypertarget{namespacescipy_1_1stats_1_1__fit_aa71a306222e85699ffa1d74d4e32aa8f}\index{scipy.stats.\_fit@{scipy.stats.\_fit}!GoodnessOfFitResult@{GoodnessOfFitResult}}
\index{GoodnessOfFitResult@{GoodnessOfFitResult}!scipy.stats.\_fit@{scipy.stats.\_fit}}
\doxysubsubsection{\texorpdfstring{GoodnessOfFitResult}{GoodnessOfFitResult}}
{\footnotesize\ttfamily \label{namespacescipy_1_1stats_1_1__fit_aa71a306222e85699ffa1d74d4e32aa8f} 
scipy.\+stats.\+\_\+fit.\+Goodness\+Of\+Fit\+Result}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ \mbox{\hyperlink{classnamedtuple}{namedtuple}}(\textcolor{stringliteral}{'GoodnessOfFitResult'},}
\DoxyCodeLine{00002\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (\textcolor{stringliteral}{'fit\_result'},\ \textcolor{stringliteral}{'statistic'},\ \textcolor{stringliteral}{'pvalue'},}
\DoxyCodeLine{00003\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'null\_distribution'}))}

\end{DoxyCode}


Definition at line \mbox{\hyperlink{__fit_8py_source_l00717}{717}} of file \mbox{\hyperlink{__fit_8py_source}{\+\_\+fit.\+py}}.

