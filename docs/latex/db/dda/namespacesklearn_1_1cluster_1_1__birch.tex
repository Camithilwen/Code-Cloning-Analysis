\doxysection{sklearn.\+cluster.\+\_\+birch Namespace Reference}
\hypertarget{namespacesklearn_1_1cluster_1_1__birch}{}\label{namespacesklearn_1_1cluster_1_1__birch}\index{sklearn.cluster.\_birch@{sklearn.cluster.\_birch}}
\doxysubsubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classsklearn_1_1cluster_1_1__birch_1_1__CFNode}{\+\_\+\+CFNode}}
\item 
class \mbox{\hyperlink{classsklearn_1_1cluster_1_1__birch_1_1__CFSubcluster}{\+\_\+\+CFSubcluster}}
\item 
class \mbox{\hyperlink{classsklearn_1_1cluster_1_1__birch_1_1Birch}{Birch}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacesklearn_1_1cluster_1_1__birch_a23c4790c95cd51c557a42478218c1090}{\+\_\+iterate\+\_\+sparse\+\_\+X}} (X)
\item 
\mbox{\hyperlink{namespacesklearn_1_1cluster_1_1__birch_a199e399ad2374166d923b25e26d2303e}{\+\_\+split\+\_\+node}} (node, threshold, branching\+\_\+factor)
\end{DoxyCompactItemize}


\doxysubsection{Function Documentation}
\Hypertarget{namespacesklearn_1_1cluster_1_1__birch_a23c4790c95cd51c557a42478218c1090}\index{sklearn.cluster.\_birch@{sklearn.cluster.\_birch}!\_iterate\_sparse\_X@{\_iterate\_sparse\_X}}
\index{\_iterate\_sparse\_X@{\_iterate\_sparse\_X}!sklearn.cluster.\_birch@{sklearn.cluster.\_birch}}
\doxysubsubsection{\texorpdfstring{\_iterate\_sparse\_X()}{\_iterate\_sparse\_X()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1cluster_1_1__birch_a23c4790c95cd51c557a42478218c1090} 
sklearn.\+cluster.\+\_\+birch.\+\_\+iterate\+\_\+sparse\+\_\+X (\begin{DoxyParamCaption}\item[{}]{X}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}This little hack returns a densified row when iterating over a sparse
matrix, instead of constructing a sparse matrix for every row that is
expensive.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__birch_8py_source_l00028}{28}} of file \mbox{\hyperlink{__birch_8py_source}{\+\_\+birch.\+py}}.

\Hypertarget{namespacesklearn_1_1cluster_1_1__birch_a199e399ad2374166d923b25e26d2303e}\index{sklearn.cluster.\_birch@{sklearn.cluster.\_birch}!\_split\_node@{\_split\_node}}
\index{\_split\_node@{\_split\_node}!sklearn.cluster.\_birch@{sklearn.cluster.\_birch}}
\doxysubsubsection{\texorpdfstring{\_split\_node()}{\_split\_node()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1cluster_1_1__birch_a199e399ad2374166d923b25e26d2303e} 
sklearn.\+cluster.\+\_\+birch.\+\_\+split\+\_\+node (\begin{DoxyParamCaption}\item[{}]{node}{, }\item[{}]{threshold}{, }\item[{}]{branching\+\_\+factor}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}The node has to be split if there is no place for a new subcluster
in the node.
1. Two empty nodes and two empty subclusters are initialized.
2. The pair of distant subclusters are found.
3. The properties of the empty subclusters and nodes are updated
   according to the nearest distance between the subclusters to the
   pair of distant subclusters.
4. The two nodes are set as children to the two subclusters.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__birch_8py_source_l00046}{46}} of file \mbox{\hyperlink{__birch_8py_source}{\+\_\+birch.\+py}}.



Referenced by \mbox{\hyperlink{__birch_8py_source_l00194}{sklearn.\+cluster.\+\_\+birch.\+\_\+\+CFNode.\+insert\+\_\+cf\+\_\+subcluster()}}.

