\doxysection{numpy.\+lib.\+function\+\_\+base Namespace Reference}
\hypertarget{namespacenumpy_1_1lib_1_1function__base}{}\label{namespacenumpy_1_1lib_1_1function__base}\index{numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classnumpy_1_1lib_1_1function__base_1_1vectorize}{vectorize}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a6663e9e17400c1da951e9bd9b33dc36b}{\+\_\+rot90\+\_\+dispatcher}} (m, k=None, axes=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a5374f6a2d928557250c44f626ee930ba}{rot90}} (m, k=1, axes=(0, 1))
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_ab07a4474ef9b3aed3b94c9991f0f55f7}{\+\_\+flip\+\_\+dispatcher}} (m, axis=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_ad88c114152e04ed3734835f74c231a74}{flip}} (m, axis=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a531c572a52ebfaba6055e1d1b7c88ba2}{iterable}} (y)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_ae637341fadc83cb34e4fd7ce2b856c61}{\+\_\+average\+\_\+dispatcher}} (a, axis=None, weights=None, returned=None, \texorpdfstring{$\ast$}{*}, keepdims=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a3527862c00989f1721d7132951c505cb}{average}} (a, axis=None, weights=None, returned=False, \texorpdfstring{$\ast$}{*}, keepdims=np.\+\_\+\+No\+Value)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_abc6385b3c574b743167157dae3e84545}{asarray\+\_\+chkfinite}} (a, dtype=None, order=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_aceacb7828da5503ff904677f933fbb6b}{\+\_\+piecewise\+\_\+dispatcher}} (x, condlist, funclist, \texorpdfstring{$\ast$}{*}args, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}kw)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a1cd513d50354ad3bf31cdf9a39773dbf}{piecewise}} (x, condlist, funclist, \texorpdfstring{$\ast$}{*}args, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}kw)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_aaca57a36f8bb8337a548b07cdeb235ef}{\+\_\+select\+\_\+dispatcher}} (condlist, choicelist, default=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a5593cdafb52222befa97feaabb012c44}{select}} (condlist, choicelist, default=0)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a5e9ac66acdcd7af7d6526bc5e3def29e}{\+\_\+copy\+\_\+dispatcher}} (a, order=None, subok=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_afb1a45e10c0c1606be5642979696590c}{copy}} (a, order=\textquotesingle{}\mbox{\hyperlink{classK}{K}}\textquotesingle{}, subok=False)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_af14a18842fd055aa06165c99aeb4811c}{\+\_\+gradient\+\_\+dispatcher}} (f, \texorpdfstring{$\ast$}{*}varargs, axis=None, edge\+\_\+order=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_ad34816c3b1cf5a22aa4e2ec2d74013a7}{gradient}} (f, \texorpdfstring{$\ast$}{*}varargs, axis=None, edge\+\_\+order=1)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a7dd7ee8cd55e5286490297bd24a56e70}{\+\_\+diff\+\_\+dispatcher}} (a, n=None, axis=None, prepend=None, \mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a13549a07e8b31d8a0658c402bd920251}{append}}=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a5eb0a6129e9afd0c17390fcf39834c97}{diff}} (a, n=1, axis=-\/1, prepend=np.\+\_\+\+No\+Value, \mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a13549a07e8b31d8a0658c402bd920251}{append}}=np.\+\_\+\+No\+Value)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_af7e4ecc4b33b992085fab6942d41d08f}{\+\_\+interp\+\_\+dispatcher}} (x, xp, fp, left=None, right=None, period=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_ab5b0bfb8023fc47d9991cb3429af814f}{interp}} (x, xp, fp, left=None, right=None, period=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a0165bfb4f4fcf0d1ad84866ab52eeb28}{\+\_\+angle\+\_\+dispatcher}} (z, deg=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a0cf6fbcc0e56edf854c6c4cb60c10568}{angle}} (z, deg=False)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_af5f63ee2eec9b1a1deeb882cccad2f53}{\+\_\+unwrap\+\_\+dispatcher}} (p, discont=None, axis=None, \texorpdfstring{$\ast$}{*}, period=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_af51a9341b1e9e575ac795009f0c38a96}{unwrap}} (p, discont=None, axis=-\/1, \texorpdfstring{$\ast$}{*}, period=2 \texorpdfstring{$\ast$}{*}pi)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a4ece2e212e3125f1026cf6c4d86e40b9}{\+\_\+sort\+\_\+complex}} (a)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a12184eaf5717d61a52570d93c2dfc98f}{sort\+\_\+complex}} (a)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_ae0c81f1007b64a18be5fb25e2c1d0b2f}{\+\_\+trim\+\_\+zeros}} (filt, trim=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_adcdbca2c84c981abdf7f356dbf3c66bc}{trim\+\_\+zeros}} (filt, trim=\textquotesingle{}fb\textquotesingle{})
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_abfcce310d04442337ab72600d2376054}{\+\_\+extract\+\_\+dispatcher}} (condition, arr)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_ae2b248407fcb2f95fee57aa96e087bb0}{extract}} (condition, arr)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_af7b9453c54c6da5ab749ecfeda5aefdb}{\+\_\+place\+\_\+dispatcher}} (arr, mask, vals)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_ae4e851f1e69da703565e781dc75ba601}{place}} (arr, mask, vals)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a09dbeec0a20ef95416268f8965120fba}{disp}} (mesg, device=None, linefeed=\mbox{\hyperlink{classTrue}{True}})
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a8fd4d999d6b5a10b0393280c42c6af87}{\+\_\+parse\+\_\+gufunc\+\_\+signature}} (signature)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a432b28466a45d69935947e5c43eac939}{\+\_\+update\+\_\+dim\+\_\+sizes}} (dim\+\_\+sizes, arg, core\+\_\+dims)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a2dcca8942511a26a4466c9792dac08e3}{\+\_\+parse\+\_\+input\+\_\+dimensions}} (args, input\+\_\+core\+\_\+dims)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_accd84e4110f0ef89eace0688b4ec6d9e}{\+\_\+calculate\+\_\+shapes}} (broadcast\+\_\+shape, dim\+\_\+sizes, list\+\_\+of\+\_\+core\+\_\+dims)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a817fda32f3fd4bb659c8798d0b764339}{\+\_\+create\+\_\+arrays}} (broadcast\+\_\+shape, dim\+\_\+sizes, list\+\_\+of\+\_\+core\+\_\+dims, dtypes, results=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a098cf30623cd1dd51dc488a3c994bcf9}{\+\_\+cov\+\_\+dispatcher}} (m, y=None, rowvar=None, bias=None, ddof=None, fweights=None, aweights=None, \texorpdfstring{$\ast$}{*}, dtype=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a7e8ca70892b1c0811235a7b5fe913298}{cov}} (m, y=None, rowvar=\mbox{\hyperlink{classTrue}{True}}, bias=False, ddof=None, fweights=None, aweights=None, \texorpdfstring{$\ast$}{*}, dtype=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a5d5b34ad224a6500ffe7fe27e0c77016}{\+\_\+corrcoef\+\_\+dispatcher}} (x, y=None, rowvar=None, bias=None, ddof=None, \texorpdfstring{$\ast$}{*}, dtype=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a95a9fea59381aec7072fe5894abf7da4}{corrcoef}} (x, y=None, rowvar=\mbox{\hyperlink{classTrue}{True}}, bias=np.\+\_\+\+No\+Value, ddof=np.\+\_\+\+No\+Value, \texorpdfstring{$\ast$}{*}, dtype=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_af25ec614bed6130cd2a0d4610369203f}{blackman}} (M)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a04f32cf5c260956aeada9d703c74620e}{bartlett}} (M)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a5485a32d8c4e900a028bf62da520be04}{hanning}} (M)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_ad6daf481775305b9274f38dbf7f28075}{hamming}} (M)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a5223ef0995959b8e90373a8c0535b541}{\+\_\+chbevl}} (x, vals)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a415e4dc396dc474b62ec8f37a101ed98}{\+\_\+i0\+\_\+1}} (x)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a80035258d3cf2d7837975b6760b7caae}{\+\_\+i0\+\_\+2}} (x)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a680690bfaf9f6a7acc8ac34ca0d0dc5f}{\+\_\+i0\+\_\+dispatcher}} (x)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a56c6f434b7fb3ba18363854522256b98}{i0}} (x)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a3c484a36cce93348651a5fe19e2ac5e8}{kaiser}} (M, beta)
\begin{DoxyCompactList}\small\item\em End of cephes code for i0. \end{DoxyCompactList}\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a187839059f6c15a7083b0cfd2c8370b8}{\+\_\+sinc\+\_\+dispatcher}} (x)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a1037c45a8411f2e3cd9dcf9a9ed7c75c}{sinc}} (x)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a697831795d3e31b4fec41f491f42d566}{\+\_\+msort\+\_\+dispatcher}} (a)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a95c594f2c56716496924f9606f7751cd}{msort}} (a)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a9416be2583f39d18e7d839905d4da827}{\+\_\+ureduce}} (a, func, keepdims=False, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}kwargs)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_ac35a05205b994efe996d7488299c6a71}{\+\_\+median\+\_\+dispatcher}} (a, axis=None, out=None, overwrite\+\_\+input=None, keepdims=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a862b8d45a444babe7129725541b2e8bb}{median}} (a, axis=None, out=None, overwrite\+\_\+input=False, keepdims=False)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_ac13a3070ca6d89e5a7b77afbc6b93b5b}{\+\_\+median}} (a, axis=None, out=None, overwrite\+\_\+input=False)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_af1cf27d258037d68c147af61bbf917df}{\+\_\+percentile\+\_\+dispatcher}} (a, q, axis=None, out=None, overwrite\+\_\+input=None, method=None, keepdims=None, \texorpdfstring{$\ast$}{*}, interpolation=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_ac3ae5ac7471a713865dd2dc26700da81}{percentile}} (a, q, axis=None, out=None, overwrite\+\_\+input=False, method="{}linear"{}, keepdims=False, \texorpdfstring{$\ast$}{*}, interpolation=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a61f07055fb4287e4ef52e31047cdffd0}{\+\_\+quantile\+\_\+dispatcher}} (a, q, axis=None, out=None, overwrite\+\_\+input=None, method=None, keepdims=None, \texorpdfstring{$\ast$}{*}, interpolation=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_ac6d144dd2bec66f30d731e55572eeda4}{quantile}} (a, q, axis=None, out=None, overwrite\+\_\+input=False, method="{}linear"{}, keepdims=False, \texorpdfstring{$\ast$}{*}, interpolation=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_ac7ee7858a5049c52b0a7591c97e9d2a2}{\+\_\+quantile\+\_\+unchecked}} (a, q, axis=None, out=None, overwrite\+\_\+input=False, method="{}linear"{}, keepdims=False)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_aafd779e8ab92d87504d8fa98658602b0}{\+\_\+quantile\+\_\+is\+\_\+valid}} (q)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a078381834838b66c27a96ec6d798cbaf}{\+\_\+check\+\_\+interpolation\+\_\+as\+\_\+method}} (method, interpolation, fname)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_ab4872dd9e8f7cad54bca94832b667b68}{\+\_\+compute\+\_\+virtual\+\_\+index}} (n, quantiles, float alpha, float beta)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a38535df22bea17a5450c1cbe06705650}{\+\_\+get\+\_\+gamma}} (virtual\+\_\+indexes, previous\+\_\+indexes, method)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a86f6bbc21ee745dd0bacb3c0d4cc8d99}{\+\_\+lerp}} (a, b, t, out=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_acccb5a05da78ca94a57a1c46c71b2893}{\+\_\+get\+\_\+gamma\+\_\+mask}} (\mbox{\hyperlink{namespacenumpy_1_1core_1_1fromnumeric_aa22b69964320c5aabb55d909c8780c9f}{shape}}, default\+\_\+value, conditioned\+\_\+value, where)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a837273439cfedef9a15b4dd17c759dbd}{\+\_\+discret\+\_\+interpolation\+\_\+to\+\_\+boundaries}} (index, gamma\+\_\+condition\+\_\+fun)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a30f111ae2e860dff2f018169b638fdd6}{\+\_\+closest\+\_\+observation}} (n, quantiles)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_af570374bc269eec1dec2cb524aaee2a0}{\+\_\+inverted\+\_\+cdf}} (n, quantiles)
\item 
np.\+array \mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_afae9d682b7d8f24138adc42f0bb8a2dd}{\+\_\+quantile\+\_\+ureduce\+\_\+func}} (np.\+array a, np.\+array q, int axis=None, out=None, bool overwrite\+\_\+input=False, method="{}linear"{})
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a73b582efb533df6bedb038ce54e55892}{\+\_\+get\+\_\+indexes}} (arr, virtual\+\_\+indexes, valid\+\_\+values\+\_\+count)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a786f8aa690fe7768451c43830db49011}{\+\_\+quantile}} (np.\+array arr, np.\+array quantiles, int axis=-\/1, method="{}linear"{}, out=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_aaf350a26e5dc3b49c88020b5d05885f7}{\+\_\+trapz\+\_\+dispatcher}} (y, x=None, dx=None, axis=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a78a1f30ec367d053bf4eee0cf62e3007}{trapz}} (y, x=None, dx=1.\+0, axis=-\/1)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a8d4316cb1a56b565ad0b6b3de8e421ba}{\+\_\+fake\+\_\+trapz}} (y, x=None, dx=1.\+0, axis=-\/1)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a03fdae5868cf1a1d0605583ce647ebac}{\+\_\+meshgrid\+\_\+dispatcher}} (\texorpdfstring{$\ast$}{*}xi, \mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_afb1a45e10c0c1606be5642979696590c}{copy}}=None, sparse=None, indexing=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a6d88bc97622504e8818d631de5e3e3b9}{meshgrid}} (\texorpdfstring{$\ast$}{*}xi, \mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_afb1a45e10c0c1606be5642979696590c}{copy}}=\mbox{\hyperlink{classTrue}{True}}, sparse=False, indexing=\textquotesingle{}xy\textquotesingle{})
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a1e424db95791f2e98e0c8f8a202b55e6}{\+\_\+delete\+\_\+dispatcher}} (arr, obj, axis=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a4663e1646f5d9ce74aa757c3c9b4a463}{delete}} (arr, obj, axis=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_aa999aff78932c3fd4272e93e2f485c60}{\+\_\+insert\+\_\+dispatcher}} (arr, obj, values, axis=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_ae0b6af9b1d56f8f1d7d88ffcc050bed3}{insert}} (arr, obj, values, axis=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a18950a0bfec4d88a8d2fbdade58647ac}{\+\_\+append\+\_\+dispatcher}} (arr, values, axis=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a13549a07e8b31d8a0658c402bd920251}{append}} (arr, values, axis=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a9ae65b20eed1e549338d2939691f061c}{\+\_\+digitize\+\_\+dispatcher}} (x, bins, right=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_aa259b287cb75f0a18e0ef9a53296e62d}{digitize}} (x, bins, right=False)
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_ad03f4b858ee9cb78b9adf3cbb4465b1d}{array\+\_\+function\+\_\+dispatch}}
\item 
list \mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a4589dbd0ee958d024d654ddc8118f8fd}{\+\_\+\+\_\+all\+\_\+\+\_\+}}
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_abef37d5da5475303548c0d850c3ca93d}{\+\_\+\+Quantile\+Methods}}
\item 
str \mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a85d9035d2b11bf7f5b20a6e4b4c51f45}{\+\_\+\+DIMENSION\+\_\+\+NAME}} = r\textquotesingle{}\textbackslash{}w+\textquotesingle{}
\item 
str \mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a58631ca9768a039f025fec3bcdbe50ed}{\+\_\+\+CORE\+\_\+\+DIMENSION\+\_\+\+LIST}} = \textquotesingle{}(?\+:\{0\+:\}(?\+:,\{0\+:\})\texorpdfstring{$\ast$}{*})?\textquotesingle{}.format(\+\_\+\+DIMENSION\+\_\+\+NAME)
\item 
str \mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a6cdf3ca9d1e59a41d35ff1fe635d91c7}{\+\_\+\+ARGUMENT}} = r\textquotesingle{}\textbackslash{}(\{\}\textbackslash{})\textquotesingle{}.format(\+\_\+\+CORE\+\_\+\+DIMENSION\+\_\+\+LIST)
\item 
str \mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a504fea436affc23ee55663f83ad378ea}{\+\_\+\+ARGUMENT\+\_\+\+LIST}} = \textquotesingle{}\{0\+:\}(?\+:,\{0\+:\})\texorpdfstring{$\ast$}{*}\textquotesingle{}.format(\+\_\+\+ARGUMENT)
\item 
str \mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a2960f69f383be4a34e3432599f93d8d7}{\+\_\+\+SIGNATURE}} = \textquotesingle{}\texorpdfstring{$^\wedge$}{\string^}\{0\+:\}-\/$>$\{0\+:\}\$\textquotesingle{}.format(\+\_\+\+ARGUMENT\+\_\+\+LIST)
\item 
list \mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_ada1d6d9089e5008cba16f91bac09e8d7}{\+\_\+i0A}}
\begin{DoxyCompactList}\small\item\em Code from cephes for i0. \end{DoxyCompactList}\item 
list \mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a25cc2115172d1dffd8ffb230438df384}{\+\_\+i0B}}
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a8c9b90c4dd4cd3412883c837417e9d76}{\+\_\+\+\_\+code\+\_\+\+\_\+}}
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_aceb4c8da1b6a4c7f663a9bec83d64ced}{\+\_\+\+\_\+globals\+\_\+\+\_\+}}
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a7c359e77276e077a31f8131fa90dca65}{\+\_\+\+\_\+defaults\+\_\+\+\_\+}}
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a995c0544cdd6d939b1e3021f5cd0e17b}{\+\_\+\+\_\+closure\+\_\+\+\_\+}}
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a919e4237f38755bcc68f7005b82952cd}{\+\_\+\+\_\+kwdefaults\+\_\+\+\_\+}}
\end{DoxyCompactItemize}


\doxysubsection{Function Documentation}
\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a0165bfb4f4fcf0d1ad84866ab52eeb28}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_angle\_dispatcher@{\_angle\_dispatcher}}
\index{\_angle\_dispatcher@{\_angle\_dispatcher}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_angle\_dispatcher()}{\_angle\_dispatcher()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a0165bfb4f4fcf0d1ad84866ab52eeb28} 
numpy.\+lib.\+function\+\_\+base.\+\_\+angle\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{z}{, }\item[{}]{deg}{ = {\ttfamily None}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l01602}{1602}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a18950a0bfec4d88a8d2fbdade58647ac}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_append\_dispatcher@{\_append\_dispatcher}}
\index{\_append\_dispatcher@{\_append\_dispatcher}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_append\_dispatcher()}{\_append\_dispatcher()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a18950a0bfec4d88a8d2fbdade58647ac} 
numpy.\+lib.\+function\+\_\+base.\+\_\+append\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{arr}{, }\item[{}]{values}{, }\item[{}]{axis}{ = {\ttfamily None}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l05559}{5559}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_ae637341fadc83cb34e4fd7ce2b856c61}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_average\_dispatcher@{\_average\_dispatcher}}
\index{\_average\_dispatcher@{\_average\_dispatcher}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_average\_dispatcher()}{\_average\_dispatcher()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_ae637341fadc83cb34e4fd7ce2b856c61} 
numpy.\+lib.\+function\+\_\+base.\+\_\+average\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{a}{, }\item[{}]{axis}{ = {\ttfamily None}, }\item[{}]{weights}{ = {\ttfamily None}, }\item[{}]{returned}{ = {\ttfamily None}, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{keepdims}{ = {\ttfamily None}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l00393}{393}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_accd84e4110f0ef89eace0688b4ec6d9e}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_calculate\_shapes@{\_calculate\_shapes}}
\index{\_calculate\_shapes@{\_calculate\_shapes}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_calculate\_shapes()}{\_calculate\_shapes()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_accd84e4110f0ef89eace0688b4ec6d9e} 
numpy.\+lib.\+function\+\_\+base.\+\_\+calculate\+\_\+shapes (\begin{DoxyParamCaption}\item[{}]{broadcast\+\_\+shape}{, }\item[{}]{dim\+\_\+sizes}{, }\item[{}]{list\+\_\+of\+\_\+core\+\_\+dims}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Helper for calculating broadcast shapes with core dimensions.\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l02095}{2095}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.



Referenced by \mbox{\hyperlink{lib_2function__base_8py_source_l02102}{\+\_\+create\+\_\+arrays()}}, and \mbox{\hyperlink{lib_2function__base_8py_source_l02464}{numpy.\+lib.\+function\+\_\+base.\+vectorize.\+\_\+vectorize\+\_\+call\+\_\+with\+\_\+signature()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a5223ef0995959b8e90373a8c0535b541}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_chbevl@{\_chbevl}}
\index{\_chbevl@{\_chbevl}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_chbevl()}{\_chbevl()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a5223ef0995959b8e90373a8c0535b541} 
numpy.\+lib.\+function\+\_\+base.\+\_\+chbevl (\begin{DoxyParamCaption}\item[{}]{x}{, }\item[{}]{vals}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l03406}{3406}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a078381834838b66c27a96ec6d798cbaf}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_check\_interpolation\_as\_method@{\_check\_interpolation\_as\_method}}
\index{\_check\_interpolation\_as\_method@{\_check\_interpolation\_as\_method}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_check\_interpolation\_as\_method()}{\_check\_interpolation\_as\_method()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a078381834838b66c27a96ec6d798cbaf} 
numpy.\+lib.\+function\+\_\+base.\+\_\+check\+\_\+interpolation\+\_\+as\+\_\+method (\begin{DoxyParamCaption}\item[{}]{method}{, }\item[{}]{interpolation}{, }\item[{}]{fname}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l04577}{4577}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a30f111ae2e860dff2f018169b638fdd6}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_closest\_observation@{\_closest\_observation}}
\index{\_closest\_observation@{\_closest\_observation}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_closest\_observation()}{\_closest\_observation()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a30f111ae2e860dff2f018169b638fdd6} 
numpy.\+lib.\+function\+\_\+base.\+\_\+closest\+\_\+observation (\begin{DoxyParamCaption}\item[{}]{n}{, }\item[{}]{quantiles}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l04685}{4685}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_ab4872dd9e8f7cad54bca94832b667b68}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_compute\_virtual\_index@{\_compute\_virtual\_index}}
\index{\_compute\_virtual\_index@{\_compute\_virtual\_index}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_compute\_virtual\_index()}{\_compute\_virtual\_index()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_ab4872dd9e8f7cad54bca94832b667b68} 
numpy.\+lib.\+function\+\_\+base.\+\_\+compute\+\_\+virtual\+\_\+index (\begin{DoxyParamCaption}\item[{}]{n}{, }\item[{}]{quantiles}{, }\item[{float}]{alpha}{, }\item[{float}]{beta}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Compute the floating point indexes of an array for the linear
interpolation of quantiles.
n : array_like
    The sample sizes.
quantiles : array_like
    The quantiles values.
alpha : float
    A constant used to correct the index computed.
beta : float
    A constant used to correct the index computed.

alpha and beta values depend on the chosen method
(see quantile documentation)

Reference:
Hyndman&Fan paper "Sample Quantiles in Statistical Packages",
DOI: 10.1080/00031305.1996.10473566
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l04594}{4594}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a5e9ac66acdcd7af7d6526bc5e3def29e}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_copy\_dispatcher@{\_copy\_dispatcher}}
\index{\_copy\_dispatcher@{\_copy\_dispatcher}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_copy\_dispatcher()}{\_copy\_dispatcher()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a5e9ac66acdcd7af7d6526bc5e3def29e} 
numpy.\+lib.\+function\+\_\+base.\+\_\+copy\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{a}{, }\item[{}]{order}{ = {\ttfamily None}, }\item[{}]{subok}{ = {\ttfamily None}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l00869}{869}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a5d5b34ad224a6500ffe7fe27e0c77016}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_corrcoef\_dispatcher@{\_corrcoef\_dispatcher}}
\index{\_corrcoef\_dispatcher@{\_corrcoef\_dispatcher}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_corrcoef\_dispatcher()}{\_corrcoef\_dispatcher()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a5d5b34ad224a6500ffe7fe27e0c77016} 
numpy.\+lib.\+function\+\_\+base.\+\_\+corrcoef\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{x}{, }\item[{}]{y}{ = {\ttfamily None}, }\item[{}]{rowvar}{ = {\ttfamily None}, }\item[{}]{bias}{ = {\ttfamily None}, }\item[{}]{ddof}{ = {\ttfamily None}, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{dtype}{ = {\ttfamily None}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l02752}{2752}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a098cf30623cd1dd51dc488a3c994bcf9}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_cov\_dispatcher@{\_cov\_dispatcher}}
\index{\_cov\_dispatcher@{\_cov\_dispatcher}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_cov\_dispatcher()}{\_cov\_dispatcher()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a098cf30623cd1dd51dc488a3c994bcf9} 
numpy.\+lib.\+function\+\_\+base.\+\_\+cov\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{m}{, }\item[{}]{y}{ = {\ttfamily None}, }\item[{}]{rowvar}{ = {\ttfamily None}, }\item[{}]{bias}{ = {\ttfamily None}, }\item[{}]{ddof}{ = {\ttfamily None}, }\item[{}]{fweights}{ = {\ttfamily None}, }\item[{}]{aweights}{ = {\ttfamily None}, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{dtype}{ = {\ttfamily None}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l02525}{2525}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a817fda32f3fd4bb659c8798d0b764339}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_create\_arrays@{\_create\_arrays}}
\index{\_create\_arrays@{\_create\_arrays}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_create\_arrays()}{\_create\_arrays()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a817fda32f3fd4bb659c8798d0b764339} 
numpy.\+lib.\+function\+\_\+base.\+\_\+create\+\_\+arrays (\begin{DoxyParamCaption}\item[{}]{broadcast\+\_\+shape}{, }\item[{}]{dim\+\_\+sizes}{, }\item[{}]{list\+\_\+of\+\_\+core\+\_\+dims}{, }\item[{}]{dtypes}{, }\item[{}]{results}{ = {\ttfamily None}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Helper for creating output arrays in vectorize.\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l02101}{2101}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.



References \mbox{\hyperlink{lib_2function__base_8py_source_l02095}{\+\_\+calculate\+\_\+shapes()}}.



Referenced by \mbox{\hyperlink{lib_2function__base_8py_source_l02464}{numpy.\+lib.\+function\+\_\+base.\+vectorize.\+\_\+vectorize\+\_\+call\+\_\+with\+\_\+signature()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a1e424db95791f2e98e0c8f8a202b55e6}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_delete\_dispatcher@{\_delete\_dispatcher}}
\index{\_delete\_dispatcher@{\_delete\_dispatcher}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_delete\_dispatcher()}{\_delete\_dispatcher()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a1e424db95791f2e98e0c8f8a202b55e6} 
numpy.\+lib.\+function\+\_\+base.\+\_\+delete\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{arr}{, }\item[{}]{obj}{, }\item[{}]{axis}{ = {\ttfamily None}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l05169}{5169}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a7dd7ee8cd55e5286490297bd24a56e70}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_diff\_dispatcher@{\_diff\_dispatcher}}
\index{\_diff\_dispatcher@{\_diff\_dispatcher}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_diff\_dispatcher()}{\_diff\_dispatcher()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a7dd7ee8cd55e5286490297bd24a56e70} 
numpy.\+lib.\+function\+\_\+base.\+\_\+diff\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{a}{, }\item[{}]{n}{ = {\ttfamily None}, }\item[{}]{axis}{ = {\ttfamily None}, }\item[{}]{prepend}{ = {\ttfamily None}, }\item[{}]{append}{ = {\ttfamily None}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l01320}{1320}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a9ae65b20eed1e549338d2939691f061c}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_digitize\_dispatcher@{\_digitize\_dispatcher}}
\index{\_digitize\_dispatcher@{\_digitize\_dispatcher}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_digitize\_dispatcher()}{\_digitize\_dispatcher()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a9ae65b20eed1e549338d2939691f061c} 
numpy.\+lib.\+function\+\_\+base.\+\_\+digitize\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{x}{, }\item[{}]{bins}{, }\item[{}]{right}{ = {\ttfamily None}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l05621}{5621}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a837273439cfedef9a15b4dd17c759dbd}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_discret\_interpolation\_to\_boundaries@{\_discret\_interpolation\_to\_boundaries}}
\index{\_discret\_interpolation\_to\_boundaries@{\_discret\_interpolation\_to\_boundaries}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_discret\_interpolation\_to\_boundaries()}{\_discret\_interpolation\_to\_boundaries()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a837273439cfedef9a15b4dd17c759dbd} 
numpy.\+lib.\+function\+\_\+base.\+\_\+discret\+\_\+interpolation\+\_\+to\+\_\+boundaries (\begin{DoxyParamCaption}\item[{}]{index}{, }\item[{}]{gamma\+\_\+condition\+\_\+fun}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l04671}{4671}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_abfcce310d04442337ab72600d2376054}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_extract\_dispatcher@{\_extract\_dispatcher}}
\index{\_extract\_dispatcher@{\_extract\_dispatcher}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_extract\_dispatcher()}{\_extract\_dispatcher()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_abfcce310d04442337ab72600d2376054} 
numpy.\+lib.\+function\+\_\+base.\+\_\+extract\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{condition}{, }\item[{}]{arr}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l01857}{1857}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a8d4316cb1a56b565ad0b6b3de8e421ba}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_fake\_trapz@{\_fake\_trapz}}
\index{\_fake\_trapz@{\_fake\_trapz}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_fake\_trapz()}{\_fake\_trapz()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a8d4316cb1a56b565ad0b6b3de8e421ba} 
numpy.\+lib.\+function\+\_\+base.\+\_\+fake\+\_\+trapz (\begin{DoxyParamCaption}\item[{}]{y}{, }\item[{}]{x}{ = {\ttfamily None}, }\item[{}]{dx}{ = {\ttfamily 1.0}, }\item[{}]{axis}{ = {\ttfamily -\/1}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l04995}{4995}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_ab07a4474ef9b3aed3b94c9991f0f55f7}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_flip\_dispatcher@{\_flip\_dispatcher}}
\index{\_flip\_dispatcher@{\_flip\_dispatcher}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_flip\_dispatcher()}{\_flip\_dispatcher()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_ab07a4474ef9b3aed3b94c9991f0f55f7} 
numpy.\+lib.\+function\+\_\+base.\+\_\+flip\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{m}{, }\item[{}]{axis}{ = {\ttfamily None}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l00250}{250}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a38535df22bea17a5450c1cbe06705650}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_get\_gamma@{\_get\_gamma}}
\index{\_get\_gamma@{\_get\_gamma}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_get\_gamma()}{\_get\_gamma()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a38535df22bea17a5450c1cbe06705650} 
numpy.\+lib.\+function\+\_\+base.\+\_\+get\+\_\+gamma (\begin{DoxyParamCaption}\item[{}]{virtual\+\_\+indexes}{, }\item[{}]{previous\+\_\+indexes}{, }\item[{}]{method}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Compute gamma (a.k.a 'm' or 'weight') for the linear interpolation
of quantiles.

virtual_indexes : array_like
    The indexes where the percentile is supposed to be found in the sorted
    sample.
previous_indexes : array_like
    The floor values of virtual_indexes.
interpolation : dict
    The interpolation method chosen, which may have a specific rule
    modifying gamma.

gamma is usually the fractional part of virtual_indexes but can be modified
by the interpolation method.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l04619}{4619}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.



Referenced by \mbox{\hyperlink{lib_2function__base_8py_source_l04771}{\+\_\+quantile()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_acccb5a05da78ca94a57a1c46c71b2893}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_get\_gamma\_mask@{\_get\_gamma\_mask}}
\index{\_get\_gamma\_mask@{\_get\_gamma\_mask}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_get\_gamma\_mask()}{\_get\_gamma\_mask()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_acccb5a05da78ca94a57a1c46c71b2893} 
numpy.\+lib.\+function\+\_\+base.\+\_\+get\+\_\+gamma\+\_\+mask (\begin{DoxyParamCaption}\item[{}]{shape}{, }\item[{}]{default\+\_\+value}{, }\item[{}]{conditioned\+\_\+value}{, }\item[{}]{where}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l04665}{4665}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a73b582efb533df6bedb038ce54e55892}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_get\_indexes@{\_get\_indexes}}
\index{\_get\_indexes@{\_get\_indexes}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_get\_indexes()}{\_get\_indexes()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a73b582efb533df6bedb038ce54e55892} 
numpy.\+lib.\+function\+\_\+base.\+\_\+get\+\_\+indexes (\begin{DoxyParamCaption}\item[{}]{arr}{, }\item[{}]{virtual\+\_\+indexes}{, }\item[{}]{valid\+\_\+values\+\_\+count}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Get the valid indexes of arr neighbouring virtual_indexes.
Note
This is a companion function to linear interpolation of
Quantiles

Returns
-------
(previous_indexes, next_indexes): Tuple
    A Tuple of virtual_indexes neighbouring indexes
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l04730}{4730}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.



Referenced by \mbox{\hyperlink{lib_2function__base_8py_source_l04771}{\+\_\+quantile()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_af14a18842fd055aa06165c99aeb4811c}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_gradient\_dispatcher@{\_gradient\_dispatcher}}
\index{\_gradient\_dispatcher@{\_gradient\_dispatcher}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_gradient\_dispatcher()}{\_gradient\_dispatcher()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_af14a18842fd055aa06165c99aeb4811c} 
numpy.\+lib.\+function\+\_\+base.\+\_\+gradient\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{f}{, }\item[{\texorpdfstring{$\ast$}{*}}]{varargs}{, }\item[{}]{axis}{ = {\ttfamily None}, }\item[{}]{edge\+\_\+order}{ = {\ttfamily None}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l00967}{967}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a415e4dc396dc474b62ec8f37a101ed98}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_i0\_1@{\_i0\_1}}
\index{\_i0\_1@{\_i0\_1}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_i0\_1()}{\_i0\_1()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a415e4dc396dc474b62ec8f37a101ed98} 
numpy.\+lib.\+function\+\_\+base.\+\_\+i0\+\_\+1 (\begin{DoxyParamCaption}\item[{}]{x}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l03418}{3418}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a80035258d3cf2d7837975b6760b7caae}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_i0\_2@{\_i0\_2}}
\index{\_i0\_2@{\_i0\_2}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_i0\_2()}{\_i0\_2()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a80035258d3cf2d7837975b6760b7caae} 
numpy.\+lib.\+function\+\_\+base.\+\_\+i0\+\_\+2 (\begin{DoxyParamCaption}\item[{}]{x}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l03422}{3422}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a680690bfaf9f6a7acc8ac34ca0d0dc5f}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_i0\_dispatcher@{\_i0\_dispatcher}}
\index{\_i0\_dispatcher@{\_i0\_dispatcher}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_i0\_dispatcher()}{\_i0\_dispatcher()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a680690bfaf9f6a7acc8ac34ca0d0dc5f} 
numpy.\+lib.\+function\+\_\+base.\+\_\+i0\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{x}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l03426}{3426}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_aa999aff78932c3fd4272e93e2f485c60}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_insert\_dispatcher@{\_insert\_dispatcher}}
\index{\_insert\_dispatcher@{\_insert\_dispatcher}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_insert\_dispatcher()}{\_insert\_dispatcher()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_aa999aff78932c3fd4272e93e2f485c60} 
numpy.\+lib.\+function\+\_\+base.\+\_\+insert\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{arr}{, }\item[{}]{obj}{, }\item[{}]{values}{, }\item[{}]{axis}{ = {\ttfamily None}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l05365}{5365}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_af7e4ecc4b33b992085fab6942d41d08f}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_interp\_dispatcher@{\_interp\_dispatcher}}
\index{\_interp\_dispatcher@{\_interp\_dispatcher}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_interp\_dispatcher()}{\_interp\_dispatcher()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_af7e4ecc4b33b992085fab6942d41d08f} 
numpy.\+lib.\+function\+\_\+base.\+\_\+interp\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{x}{, }\item[{}]{xp}{, }\item[{}]{fp}{, }\item[{}]{left}{ = {\ttfamily None}, }\item[{}]{right}{ = {\ttfamily None}, }\item[{}]{period}{ = {\ttfamily None}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l01457}{1457}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_af570374bc269eec1dec2cb524aaee2a0}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_inverted\_cdf@{\_inverted\_cdf}}
\index{\_inverted\_cdf@{\_inverted\_cdf}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_inverted\_cdf()}{\_inverted\_cdf()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_af570374bc269eec1dec2cb524aaee2a0} 
numpy.\+lib.\+function\+\_\+base.\+\_\+inverted\+\_\+cdf (\begin{DoxyParamCaption}\item[{}]{n}{, }\item[{}]{quantiles}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l04691}{4691}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a86f6bbc21ee745dd0bacb3c0d4cc8d99}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_lerp@{\_lerp}}
\index{\_lerp@{\_lerp}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_lerp()}{\_lerp()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a86f6bbc21ee745dd0bacb3c0d4cc8d99} 
numpy.\+lib.\+function\+\_\+base.\+\_\+lerp (\begin{DoxyParamCaption}\item[{}]{a}{, }\item[{}]{b}{, }\item[{}]{t}{, }\item[{}]{out}{ = {\ttfamily None}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Compute the linear interpolation weighted by gamma on each point of
two same shape array.

a : array_like
    Left bound.
b : array_like
    Right bound.
t : array_like
    The interpolation weight.
out : array_like
    Output array.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l04641}{4641}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.



References \mbox{\hyperlink{lib_2function__base_8py_source_l04771}{\+\_\+quantile()}}.



Referenced by \mbox{\hyperlink{lib_2function__base_8py_source_l04771}{\+\_\+quantile()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_ac13a3070ca6d89e5a7b77afbc6b93b5b}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_median@{\_median}}
\index{\_median@{\_median}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_median()}{\_median()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_ac13a3070ca6d89e5a7b77afbc6b93b5b} 
numpy.\+lib.\+function\+\_\+base.\+\_\+median (\begin{DoxyParamCaption}\item[{}]{a}{, }\item[{}]{axis}{ = {\ttfamily None}, }\item[{}]{out}{ = {\ttfamily None}, }\item[{}]{overwrite\+\_\+input}{ = {\ttfamily False}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l03931}{3931}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_ac35a05205b994efe996d7488299c6a71}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_median\_dispatcher@{\_median\_dispatcher}}
\index{\_median\_dispatcher@{\_median\_dispatcher}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_median\_dispatcher()}{\_median\_dispatcher()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_ac35a05205b994efe996d7488299c6a71} 
numpy.\+lib.\+function\+\_\+base.\+\_\+median\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{a}{, }\item[{}]{axis}{ = {\ttfamily None}, }\item[{}]{out}{ = {\ttfamily None}, }\item[{}]{overwrite\+\_\+input}{ = {\ttfamily None}, }\item[{}]{keepdims}{ = {\ttfamily None}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l03840}{3840}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a03fdae5868cf1a1d0605583ce647ebac}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_meshgrid\_dispatcher@{\_meshgrid\_dispatcher}}
\index{\_meshgrid\_dispatcher@{\_meshgrid\_dispatcher}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_meshgrid\_dispatcher()}{\_meshgrid\_dispatcher()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a03fdae5868cf1a1d0605583ce647ebac} 
numpy.\+lib.\+function\+\_\+base.\+\_\+meshgrid\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{\texorpdfstring{$\ast$}{*}}]{xi}{, }\item[{}]{copy}{ = {\ttfamily None}, }\item[{}]{sparse}{ = {\ttfamily None}, }\item[{}]{indexing}{ = {\ttfamily None}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l05006}{5006}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a697831795d3e31b4fec41f491f42d566}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_msort\_dispatcher@{\_msort\_dispatcher}}
\index{\_msort\_dispatcher@{\_msort\_dispatcher}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_msort\_dispatcher()}{\_msort\_dispatcher()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a697831795d3e31b4fec41f491f42d566} 
numpy.\+lib.\+function\+\_\+base.\+\_\+msort\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{a}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l03713}{3713}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a8fd4d999d6b5a10b0393280c42c6af87}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_parse\_gufunc\_signature@{\_parse\_gufunc\_signature}}
\index{\_parse\_gufunc\_signature@{\_parse\_gufunc\_signature}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_parse\_gufunc\_signature()}{\_parse\_gufunc\_signature()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a8fd4d999d6b5a10b0393280c42c6af87} 
numpy.\+lib.\+function\+\_\+base.\+\_\+parse\+\_\+gufunc\+\_\+signature (\begin{DoxyParamCaption}\item[{}]{signature}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Parse string signatures for a generalized universal function.

Arguments
---------
signature : string
    Generalized universal function signature, e.g., ``(m,n),(n,p)->(m,p)``
    for ``np.matmul``.

Returns
-------
Tuple of input and output core dimensions parsed from the signature, each
of the form List[Tuple[str, ...]].
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l02007}{2007}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a2dcca8942511a26a4466c9792dac08e3}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_parse\_input\_dimensions@{\_parse\_input\_dimensions}}
\index{\_parse\_input\_dimensions@{\_parse\_input\_dimensions}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_parse\_input\_dimensions()}{\_parse\_input\_dimensions()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a2dcca8942511a26a4466c9792dac08e3} 
numpy.\+lib.\+function\+\_\+base.\+\_\+parse\+\_\+input\+\_\+dimensions (\begin{DoxyParamCaption}\item[{}]{args}{, }\item[{}]{input\+\_\+core\+\_\+dims}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Parse broadcast and core dimensions for vectorize with a signature.

Arguments
---------
args : Tuple[ndarray, ...]
    Tuple of input arguments to examine.
input_core_dims : List[Tuple[str, ...]]
    List of core dimensions corresponding to each input.

Returns
-------
broadcast_shape : Tuple[int, ...]
    Common shape to broadcast all non-core dimensions to.
dim_sizes : Dict[str, int]
    Common sizes for named core dimensions.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l02066}{2066}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.



References \mbox{\hyperlink{lib_2function__base_8py_source_l02032}{\+\_\+update\+\_\+dim\+\_\+sizes()}}.



Referenced by \mbox{\hyperlink{lib_2function__base_8py_source_l02464}{numpy.\+lib.\+function\+\_\+base.\+vectorize.\+\_\+vectorize\+\_\+call\+\_\+with\+\_\+signature()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_af1cf27d258037d68c147af61bbf917df}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_percentile\_dispatcher@{\_percentile\_dispatcher}}
\index{\_percentile\_dispatcher@{\_percentile\_dispatcher}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_percentile\_dispatcher()}{\_percentile\_dispatcher()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_af1cf27d258037d68c147af61bbf917df} 
numpy.\+lib.\+function\+\_\+base.\+\_\+percentile\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{a}{, }\item[{}]{q}{, }\item[{}]{axis}{ = {\ttfamily None}, }\item[{}]{out}{ = {\ttfamily None}, }\item[{}]{overwrite\+\_\+input}{ = {\ttfamily None}, }\item[{}]{method}{ = {\ttfamily None}, }\item[{}]{keepdims}{ = {\ttfamily None}, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{interpolation}{ = {\ttfamily None}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l03987}{3987}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_aceacb7828da5503ff904677f933fbb6b}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_piecewise\_dispatcher@{\_piecewise\_dispatcher}}
\index{\_piecewise\_dispatcher@{\_piecewise\_dispatcher}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_piecewise\_dispatcher()}{\_piecewise\_dispatcher()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_aceacb7828da5503ff904677f933fbb6b} 
numpy.\+lib.\+function\+\_\+base.\+\_\+piecewise\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{x}{, }\item[{}]{condlist}{, }\item[{}]{funclist}{, }\item[{\texorpdfstring{$\ast$}{*}}]{args}{, }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{kw}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l00635}{635}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_af7b9453c54c6da5ab749ecfeda5aefdb}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_place\_dispatcher@{\_place\_dispatcher}}
\index{\_place\_dispatcher@{\_place\_dispatcher}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_place\_dispatcher()}{\_place\_dispatcher()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_af7b9453c54c6da5ab749ecfeda5aefdb} 
numpy.\+lib.\+function\+\_\+base.\+\_\+place\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{arr}{, }\item[{}]{mask}{, }\item[{}]{vals}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l01913}{1913}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a786f8aa690fe7768451c43830db49011}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_quantile@{\_quantile}}
\index{\_quantile@{\_quantile}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_quantile()}{\_quantile()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a786f8aa690fe7768451c43830db49011} 
numpy.\+lib.\+function\+\_\+base.\+\_\+quantile (\begin{DoxyParamCaption}\item[{np.\+array}]{arr}{, }\item[{np.\+array}]{quantiles}{, }\item[{int }]{axis}{ = {\ttfamily -\/1}, }\item[{}]{method}{ = {\ttfamily "{}linear"{}}, }\item[{}]{out}{ = {\ttfamily None}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Private function that doesn't support extended axis or keepdims.
These methods are extended to this function using _ureduce
See nanpercentile for parameter usage
It computes the quantiles of the array for the given axis.
A linear interpolation is performed based on the `interpolation`.

By default, the method is "linear" where alpha == beta == 1 which
performs the 7th method of Hyndman&Fan.
With "median_unbiased" we get alpha == beta == 1/3
thus the 8th method of Hyndman&Fan.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l04765}{4765}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.



References \mbox{\hyperlink{lib_2function__base_8py_source_l04619}{\+\_\+get\+\_\+gamma()}}, \mbox{\hyperlink{lib_2function__base_8py_source_l04730}{\+\_\+get\+\_\+indexes()}}, \mbox{\hyperlink{lib_2function__base_8py_source_l04641}{\+\_\+lerp()}}, and \mbox{\hyperlink{core_2fromnumeric_8py_source_l00096}{numpy.\+core.\+fromnumeric.\+take()}}.



Referenced by \mbox{\hyperlink{lib_2function__base_8py_source_l04641}{\+\_\+lerp()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a61f07055fb4287e4ef52e31047cdffd0}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_quantile\_dispatcher@{\_quantile\_dispatcher}}
\index{\_quantile\_dispatcher@{\_quantile\_dispatcher}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_quantile\_dispatcher()}{\_quantile\_dispatcher()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a61f07055fb4287e4ef52e31047cdffd0} 
numpy.\+lib.\+function\+\_\+base.\+\_\+quantile\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{a}{, }\item[{}]{q}{, }\item[{}]{axis}{ = {\ttfamily None}, }\item[{}]{out}{ = {\ttfamily None}, }\item[{}]{overwrite\+\_\+input}{ = {\ttfamily None}, }\item[{}]{method}{ = {\ttfamily None}, }\item[{}]{keepdims}{ = {\ttfamily None}, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{interpolation}{ = {\ttfamily None}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l04287}{4287}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_aafd779e8ab92d87504d8fa98658602b0}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_quantile\_is\_valid@{\_quantile\_is\_valid}}
\index{\_quantile\_is\_valid@{\_quantile\_is\_valid}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_quantile\_is\_valid()}{\_quantile\_is\_valid()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_aafd779e8ab92d87504d8fa98658602b0} 
numpy.\+lib.\+function\+\_\+base.\+\_\+quantile\+\_\+is\+\_\+valid (\begin{DoxyParamCaption}\item[{}]{q}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l04565}{4565}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_ac7ee7858a5049c52b0a7591c97e9d2a2}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_quantile\_unchecked@{\_quantile\_unchecked}}
\index{\_quantile\_unchecked@{\_quantile\_unchecked}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_quantile\_unchecked()}{\_quantile\_unchecked()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_ac7ee7858a5049c52b0a7591c97e9d2a2} 
numpy.\+lib.\+function\+\_\+base.\+\_\+quantile\+\_\+unchecked (\begin{DoxyParamCaption}\item[{}]{a}{, }\item[{}]{q}{, }\item[{}]{axis}{ = {\ttfamily None}, }\item[{}]{out}{ = {\ttfamily None}, }\item[{}]{overwrite\+\_\+input}{ = {\ttfamily False}, }\item[{}]{method}{ = {\ttfamily "{}linear"{}}, }\item[{}]{keepdims}{ = {\ttfamily False}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Assumes that q is in [0, 1], and is an ndarray\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l04547}{4547}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.



References \mbox{\hyperlink{lib_2function__base_8py_source_l03763}{\+\_\+ureduce()}}.



Referenced by \mbox{\hyperlink{lib_2function__base_8py_source_l04001}{percentile()}}, and \mbox{\hyperlink{lib_2function__base_8py_source_l04301}{quantile()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_afae9d682b7d8f24138adc42f0bb8a2dd}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_quantile\_ureduce\_func@{\_quantile\_ureduce\_func}}
\index{\_quantile\_ureduce\_func@{\_quantile\_ureduce\_func}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_quantile\_ureduce\_func()}{\_quantile\_ureduce\_func()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_afae9d682b7d8f24138adc42f0bb8a2dd} 
 np.\+array numpy.\+lib.\+function\+\_\+base.\+\_\+quantile\+\_\+ureduce\+\_\+func (\begin{DoxyParamCaption}\item[{np.\+array}]{a}{, }\item[{np.\+array}]{q}{, }\item[{int }]{axis}{ = {\ttfamily None}, }\item[{}]{out}{ = {\ttfamily None}, }\item[{bool }]{overwrite\+\_\+input}{ = {\ttfamily False}, }\item[{}]{method}{ = {\ttfamily "{}linear"{}}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l04697}{4697}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a6663e9e17400c1da951e9bd9b33dc36b}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_rot90\_dispatcher@{\_rot90\_dispatcher}}
\index{\_rot90\_dispatcher@{\_rot90\_dispatcher}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_rot90\_dispatcher()}{\_rot90\_dispatcher()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a6663e9e17400c1da951e9bd9b33dc36b} 
numpy.\+lib.\+function\+\_\+base.\+\_\+rot90\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{m}{, }\item[{}]{k}{ = {\ttfamily None}, }\item[{}]{axes}{ = {\ttfamily None}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l00154}{154}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_aaca57a36f8bb8337a548b07cdeb235ef}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_select\_dispatcher@{\_select\_dispatcher}}
\index{\_select\_dispatcher@{\_select\_dispatcher}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_select\_dispatcher()}{\_select\_dispatcher()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_aaca57a36f8bb8337a548b07cdeb235ef} 
numpy.\+lib.\+function\+\_\+base.\+\_\+select\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{condlist}{, }\item[{}]{choicelist}{, }\item[{}]{default}{ = {\ttfamily None}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l00763}{763}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a187839059f6c15a7083b0cfd2c8370b8}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_sinc\_dispatcher@{\_sinc\_dispatcher}}
\index{\_sinc\_dispatcher@{\_sinc\_dispatcher}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_sinc\_dispatcher()}{\_sinc\_dispatcher()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a187839059f6c15a7083b0cfd2c8370b8} 
numpy.\+lib.\+function\+\_\+base.\+\_\+sinc\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{x}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l03628}{3628}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a4ece2e212e3125f1026cf6c4d86e40b9}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_sort\_complex@{\_sort\_complex}}
\index{\_sort\_complex@{\_sort\_complex}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_sort\_complex()}{\_sort\_complex()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a4ece2e212e3125f1026cf6c4d86e40b9} 
numpy.\+lib.\+function\+\_\+base.\+\_\+sort\+\_\+complex (\begin{DoxyParamCaption}\item[{}]{a}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l01759}{1759}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_aaf350a26e5dc3b49c88020b5d05885f7}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_trapz\_dispatcher@{\_trapz\_dispatcher}}
\index{\_trapz\_dispatcher@{\_trapz\_dispatcher}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_trapz\_dispatcher()}{\_trapz\_dispatcher()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_aaf350a26e5dc3b49c88020b5d05885f7} 
numpy.\+lib.\+function\+\_\+base.\+\_\+trapz\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{y}{, }\item[{}]{x}{ = {\ttfamily None}, }\item[{}]{dx}{ = {\ttfamily None}, }\item[{}]{axis}{ = {\ttfamily None}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l04854}{4854}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_ae0c81f1007b64a18be5fb25e2c1d0b2f}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_trim\_zeros@{\_trim\_zeros}}
\index{\_trim\_zeros@{\_trim\_zeros}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_trim\_zeros()}{\_trim\_zeros()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_ae0c81f1007b64a18be5fb25e2c1d0b2f} 
numpy.\+lib.\+function\+\_\+base.\+\_\+trim\+\_\+zeros (\begin{DoxyParamCaption}\item[{}]{filt}{, }\item[{}]{trim}{ = {\ttfamily None}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l01800}{1800}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_af5f63ee2eec9b1a1deeb882cccad2f53}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_unwrap\_dispatcher@{\_unwrap\_dispatcher}}
\index{\_unwrap\_dispatcher@{\_unwrap\_dispatcher}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_unwrap\_dispatcher()}{\_unwrap\_dispatcher()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_af5f63ee2eec9b1a1deeb882cccad2f53} 
numpy.\+lib.\+function\+\_\+base.\+\_\+unwrap\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{p}{, }\item[{}]{discont}{ = {\ttfamily None}, }\item[{}]{axis}{ = {\ttfamily None}, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{period}{ = {\ttfamily None}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l01659}{1659}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a432b28466a45d69935947e5c43eac939}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_update\_dim\_sizes@{\_update\_dim\_sizes}}
\index{\_update\_dim\_sizes@{\_update\_dim\_sizes}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_update\_dim\_sizes()}{\_update\_dim\_sizes()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a432b28466a45d69935947e5c43eac939} 
numpy.\+lib.\+function\+\_\+base.\+\_\+update\+\_\+dim\+\_\+sizes (\begin{DoxyParamCaption}\item[{}]{dim\+\_\+sizes}{, }\item[{}]{arg}{, }\item[{}]{core\+\_\+dims}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Incrementally check and update core dimension sizes for a single argument.

Arguments
---------
dim_sizes : Dict[str, int]
    Sizes of existing core dimensions. Will be updated in-place.
arg : ndarray
    Argument to examine.
core_dims : Tuple[str, ...]
    Core dimensions for this argument.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l02032}{2032}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.



Referenced by \mbox{\hyperlink{lib_2function__base_8py_source_l02066}{\+\_\+parse\+\_\+input\+\_\+dimensions()}}, and \mbox{\hyperlink{lib_2function__base_8py_source_l02464}{numpy.\+lib.\+function\+\_\+base.\+vectorize.\+\_\+vectorize\+\_\+call\+\_\+with\+\_\+signature()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a9416be2583f39d18e7d839905d4da827}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_ureduce@{\_ureduce}}
\index{\_ureduce@{\_ureduce}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_ureduce()}{\_ureduce()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a9416be2583f39d18e7d839905d4da827} 
numpy.\+lib.\+function\+\_\+base.\+\_\+ureduce (\begin{DoxyParamCaption}\item[{}]{a}{, }\item[{}]{func}{, }\item[{}]{keepdims}{ = {\ttfamily False}, }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{kwargs}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Internal Function.
Call `func` with `a` as first argument swapping the axes to use extended
axis on functions that don't support it natively.

Returns result and a.shape with axis dims set to 1.

Parameters
----------
a : array_like
    Input array or object that can be converted to an array.
func : callable
    Reduction function capable of receiving a single axis argument.
    It is called with `a` as first argument followed by `kwargs`.
kwargs : keyword arguments
    additional keyword arguments to pass to `func`.

Returns
-------
result : tuple
    Result of func(a, **kwargs) and a.shape with axis dims set to 1
    which can be used to reshape the result to the same shape a ufunc with
    keepdims=True would produce.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l03763}{3763}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.



Referenced by \mbox{\hyperlink{lib_2function__base_8py_source_l04553}{\+\_\+quantile\+\_\+unchecked()}}, \mbox{\hyperlink{lib_2function__base_8py_source_l03846}{median()}}, and \mbox{\hyperlink{extras_8py_source_l00659}{numpy.\+ma.\+extras.\+median()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a0cf6fbcc0e56edf854c6c4cb60c10568}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!angle@{angle}}
\index{angle@{angle}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{angle()}{angle()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a0cf6fbcc0e56edf854c6c4cb60c10568} 
numpy.\+lib.\+function\+\_\+base.\+angle (\begin{DoxyParamCaption}\item[{}]{z}{, }\item[{}]{deg}{ = {\ttfamily False}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the angle of the complex argument.

Parameters
----------
z : array_like
    A complex number or sequence of complex numbers.
deg : bool, optional
    Return angle in degrees if True, radians if False (default).

Returns
-------
angle : ndarray or scalar
    The counterclockwise angle from the positive real axis on the complex
    plane in the range ``(-pi, pi]``, with dtype as numpy.float64.

    .. versionchanged:: 1.16.0
        This function works on subclasses of ndarray like `ma.array`.

See Also
--------
arctan2
absolute

Notes
-----
Although the angle of the complex number 0 is undefined, ``numpy.angle(0)``
returns the value 0.

Examples
--------
>>> np.angle([1.0, 1.0j, 1+1j])               # in radians
array([ 0.        ,  1.57079633,  0.78539816]) # may vary
>>> np.angle(1+1j, deg=True)                  # in degrees
45.0
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l01607}{1607}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a13549a07e8b31d8a0658c402bd920251}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!append@{append}}
\index{append@{append}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{append()}{append()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a13549a07e8b31d8a0658c402bd920251} 
numpy.\+lib.\+function\+\_\+base.\+append (\begin{DoxyParamCaption}\item[{}]{arr}{, }\item[{}]{values}{, }\item[{}]{axis}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Append values to the end of an array.

Parameters
----------
arr : array_like
    Values are appended to a copy of this array.
values : array_like
    These values are appended to a copy of `arr`.  It must be of the
    correct shape (the same shape as `arr`, excluding `axis`).  If
    `axis` is not specified, `values` can be any shape and will be
    flattened before use.
axis : int, optional
    The axis along which `values` are appended.  If `axis` is not
    given, both `arr` and `values` are flattened before use.

Returns
-------
append : ndarray
    A copy of `arr` with `values` appended to `axis`.  Note that
    `append` does not occur in-place: a new array is allocated and
    filled.  If `axis` is None, `out` is a flattened array.

See Also
--------
insert : Insert elements into an array.
delete : Delete elements from an array.

Examples
--------
>>> np.append([1, 2, 3], [[4, 5, 6], [7, 8, 9]])
array([1, 2, 3, ..., 7, 8, 9])

When `axis` is specified, `values` must have the correct shape.

>>> np.append([[1, 2, 3], [4, 5, 6]], [[7, 8, 9]], axis=0)
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])
>>> np.append([[1, 2, 3], [4, 5, 6]], [7, 8, 9], axis=0)
Traceback (most recent call last):
    ...
ValueError: all the input arrays must have same number of dimensions, but
the array at index 0 has 2 dimension(s) and the array at index 1 has 1
dimension(s)
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l05564}{5564}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.



References \mbox{\hyperlink{core_2fromnumeric_8py_source_l01769}{numpy.\+core.\+fromnumeric.\+ravel()}}.



Referenced by \mbox{\hyperlink{numpy_2core_2tests_2test__indexing_8py_source_l00859}{numpy.\+core.\+tests.\+test\+\_\+indexing.\+Test\+Multi\+Indexing\+Automated.\+\_\+get\+\_\+multi\+\_\+index()}}, \mbox{\hyperlink{crackfortran_8py_source_l00995}{numpy.\+f2py.\+crackfortran.\+analyzeline()}}, \mbox{\hyperlink{crackfortran_8py_source_l02606}{numpy.\+f2py.\+crackfortran.\+analyzevars()}}, \mbox{\hyperlink{cfuncs_8py_source_l01437}{numpy.\+f2py.\+cfuncs.\+append\+\_\+needs()}}, \mbox{\hyperlink{__type__aliases_8py_source_l00058}{numpy.\+core.\+\_\+type\+\_\+aliases.\+bitname()}}, \mbox{\hyperlink{rules_8py_source_l01241}{numpy.\+f2py.\+rules.\+buildmodule()}}, \mbox{\hyperlink{crackfortran_8py_source_l00700}{numpy.\+f2py.\+crackfortran.\+crackline()}}, \mbox{\hyperlink{core_2einsumfunc_8py_source_l00707}{numpy.\+core.\+einsumfunc.\+einsum\+\_\+path()}}, \mbox{\hyperlink{crackfortran_8py_source_l03062}{numpy.\+f2py.\+crackfortran.\+param\+\_\+parse()}}, \mbox{\hyperlink{crackfortran_8py_source_l02064}{numpy.\+f2py.\+crackfortran.\+postcrack()}}, \mbox{\hyperlink{numpy_2testing_2__private_2utils_8py_source_l02148}{numpy.\+testing.\+\_\+private.\+utils.\+suppress\+\_\+warnings.\+record()}}, \mbox{\hyperlink{f2py2e_8py_source_l00416}{numpy.\+f2py.\+f2py2e.\+run\+\_\+main()}}, \mbox{\hyperlink{test__typing_8py_source_l00090}{numpy.\+typing.\+tests.\+test\+\_\+typing.\+run\+\_\+mypy()}}, and \mbox{\hyperlink{crackfortran_8py_source_l01691}{numpy.\+f2py.\+crackfortran.\+updatevars()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_abc6385b3c574b743167157dae3e84545}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!asarray\_chkfinite@{asarray\_chkfinite}}
\index{asarray\_chkfinite@{asarray\_chkfinite}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{asarray\_chkfinite()}{asarray\_chkfinite()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_abc6385b3c574b743167157dae3e84545} 
numpy.\+lib.\+function\+\_\+base.\+asarray\+\_\+chkfinite (\begin{DoxyParamCaption}\item[{}]{a}{, }\item[{}]{dtype}{ = {\ttfamily None}, }\item[{}]{order}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Convert the input to an array, checking for NaNs or Infs.

Parameters
----------
a : array_like
    Input data, in any form that can be converted to an array.  This
    includes lists, lists of tuples, tuples, tuples of tuples, tuples
    of lists and ndarrays.  Success requires no NaNs or Infs.
dtype : data-type, optional
    By default, the data-type is inferred from the input data.
order : {'C', 'F', 'A', 'K'}, optional
    Memory layout.  'A' and 'K' depend on the order of input array a.
    'C' row-major (C-style),
    'F' column-major (Fortran-style) memory representation.
    'A' (any) means 'F' if `a` is Fortran contiguous, 'C' otherwise
    'K' (keep) preserve input order
    Defaults to 'C'.

Returns
-------
out : ndarray
    Array interpretation of `a`.  No copy is performed if the input
    is already an ndarray.  If `a` is a subclass of ndarray, a base
    class ndarray is returned.

Raises
------
ValueError
    Raises ValueError if `a` contains NaN (Not a Number) or Inf (Infinity).

See Also
--------
asarray : Create and array.
asanyarray : Similar function which passes through subclasses.
ascontiguousarray : Convert input to a contiguous array.
asfarray : Convert input to a floating point ndarray.
asfortranarray : Convert input to an ndarray with column-major
                 memory order.
fromiter : Create an array from an iterator.
fromfunction : Construct an array by executing a function on grid
               positions.

Examples
--------
Convert a list into an array.  If all elements are finite
``asarray_chkfinite`` is identical to ``asarray``.

>>> a = [1, 2]
>>> np.asarray_chkfinite(a, dtype=float)
array([1., 2.])

Raises ValueError if array_like contains Nans or Infs.

>>> a = [1, 2, np.inf]
>>> try:
...     np.asarray_chkfinite(a)
... except ValueError:
...     print('ValueError')
...
ValueError
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l00565}{565}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.



References \mbox{\hyperlink{core_2fromnumeric_8py_source_l02422}{numpy.\+core.\+fromnumeric.\+all()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a3527862c00989f1721d7132951c505cb}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!average@{average}}
\index{average@{average}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{average()}{average()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a3527862c00989f1721d7132951c505cb} 
numpy.\+lib.\+function\+\_\+base.\+average (\begin{DoxyParamCaption}\item[{}]{a}{, }\item[{}]{axis}{ = {\ttfamily None}, }\item[{}]{weights}{ = {\ttfamily None}, }\item[{}]{returned}{ = {\ttfamily False}, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{keepdims}{ = {\ttfamily np.\+\_\+NoValue}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute the weighted average along the specified axis.

Parameters
----------
a : array_like
    Array containing data to be averaged. If `a` is not an array, a
    conversion is attempted.
axis : None or int or tuple of ints, optional
    Axis or axes along which to average `a`.  The default,
    axis=None, will average over all of the elements of the input array.
    If axis is negative it counts from the last to the first axis.

    .. versionadded:: 1.7.0

    If axis is a tuple of ints, averaging is performed on all of the axes
    specified in the tuple instead of a single axis or all the axes as
    before.
weights : array_like, optional
    An array of weights associated with the values in `a`. Each value in
    `a` contributes to the average according to its associated weight.
    The weights array can either be 1-D (in which case its length must be
    the size of `a` along the given axis) or of the same shape as `a`.
    If `weights=None`, then all data in `a` are assumed to have a
    weight equal to one.  The 1-D calculation is::

        avg = sum(a * weights) / sum(weights)

    The only constraint on `weights` is that `sum(weights)` must not be 0.
returned : bool, optional
    Default is `False`. If `True`, the tuple (`average`, `sum_of_weights`)
    is returned, otherwise only the average is returned.
    If `weights=None`, `sum_of_weights` is equivalent to the number of
    elements over which the average is taken.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the original `a`.
    *Note:* `keepdims` will not work with instances of `numpy.matrix`
    or other classes whose methods do not support `keepdims`.

    .. versionadded:: 1.23.0

Returns
-------
retval, [sum_of_weights] : array_type or double
    Return the average along the specified axis. When `returned` is `True`,
    return a tuple with the average as the first element and the sum
    of the weights as the second element. `sum_of_weights` is of the
    same type as `retval`. The result dtype follows a genereal pattern.
    If `weights` is None, the result dtype will be that of `a` , or ``float64``
    if `a` is integral. Otherwise, if `weights` is not None and `a` is non-
    integral, the result type will be the type of lowest precision capable of
    representing values of both `a` and `weights`. If `a` happens to be
    integral, the previous rules still applies but the result dtype will
    at least be ``float64``.

Raises
------
ZeroDivisionError
    When all weights along axis are zero. See `numpy.ma.average` for a
    version robust to this type of error.
TypeError
    When the length of 1D `weights` is not the same as the shape of `a`
    along axis.

See Also
--------
mean

ma.average : average for masked arrays -- useful if your data contains
             "missing" values
numpy.result_type : Returns the type that results from applying the
                    numpy type promotion rules to the arguments.

Examples
--------
>>> data = np.arange(1, 5)
>>> data
array([1, 2, 3, 4])
>>> np.average(data)
2.5
>>> np.average(np.arange(1, 11), weights=np.arange(10, 0, -1))
4.0

>>> data = np.arange(6).reshape((3, 2))
>>> data
array([[0, 1],
       [2, 3],
       [4, 5]])
>>> np.average(data, axis=1, weights=[1./4, 3./4])
array([0.75, 2.75, 4.75])
>>> np.average(data, weights=[1./4, 3./4])
Traceback (most recent call last):
    ...
TypeError: Axis must be specified when shapes of a and weights differ.

>>> a = np.ones(5, dtype=np.float128)
>>> w = np.ones(5, dtype=np.complex64)
>>> avg = np.average(a, weights=w)
>>> print(avg.dtype)
complex256

With ``keepdims=True``, the following result has shape (3, 1).

>>> np.average(data, axis=1, keepdims=True)
array([[0.5],
       [2.5],
       [4.5]])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l00399}{399}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.



References \mbox{\hyperlink{core_2fromnumeric_8py_source_l02179}{numpy.\+core.\+fromnumeric.\+sum()}}.



Referenced by \mbox{\hyperlink{lib_2function__base_8py_source_l02532}{cov()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a04f32cf5c260956aeada9d703c74620e}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!bartlett@{bartlett}}
\index{bartlett@{bartlett}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{bartlett()}{bartlett()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a04f32cf5c260956aeada9d703c74620e} 
numpy.\+lib.\+function\+\_\+base.\+bartlett (\begin{DoxyParamCaption}\item[{}]{M}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the Bartlett window.

The Bartlett window is very similar to a triangular window, except
that the end points are at zero.  It is often used in signal
processing for tapering a signal, without generating too much
ripple in the frequency domain.

Parameters
----------
M : int
    Number of points in the output window. If zero or less, an
    empty array is returned.

Returns
-------
out : array
    The triangular window, with the maximum value normalized to one
    (the value one appears only if the number of samples is odd), with
    the first and last samples equal to zero.

See Also
--------
blackman, hamming, hanning, kaiser

Notes
-----
The Bartlett window is defined as

.. math:: w(n) = \\frac{2}{M-1} \\left(
          \\frac{M-1}{2} - \\left|n - \\frac{M-1}{2}\\right|
          \\right)

Most references to the Bartlett window come from the signal processing
literature, where it is used as one of many windowing functions for
smoothing values.  Note that convolution with this window produces linear
interpolation.  It is also known as an apodization (which means "removing
the foot", i.e. smoothing discontinuities at the beginning and end of the
sampled signal) or tapering function. The Fourier transform of the
Bartlett window is the product of two sinc functions. Note the excellent
discussion in Kanasewich [2]_.

References
----------
.. [1] M.S. Bartlett, "Periodogram Analysis and Continuous Spectra",
       Biometrika 37, 1-16, 1950.
.. [2] E.R. Kanasewich, "Time Sequence Analysis in Geophysics",
       The University of Alberta Press, 1975, pp. 109-110.
.. [3] A.V. Oppenheim and R.W. Schafer, "Discrete-Time Signal
       Processing", Prentice-Hall, 1999, pp. 468-471.
.. [4] Wikipedia, "Window function",
       https://en.wikipedia.org/wiki/Window_function
.. [5] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,
       "Numerical Recipes", Cambridge University Press, 1986, page 429.

Examples
--------
>>> import matplotlib.pyplot as plt
>>> np.bartlett(12)
array([ 0.        ,  0.18181818,  0.36363636,  0.54545455,  0.72727273, # may vary
        0.90909091,  0.90909091,  0.72727273,  0.54545455,  0.36363636,
        0.18181818,  0.        ])

Plot the window and its frequency response (requires SciPy and matplotlib):

>>> from numpy.fft import fft, fftshift
>>> window = np.bartlett(51)
>>> plt.plot(window)
[<matplotlib.lines.Line2D object at 0x...>]
>>> plt.title("Bartlett window")
Text(0.5, 1.0, 'Bartlett window')
>>> plt.ylabel("Amplitude")
Text(0, 0.5, 'Amplitude')
>>> plt.xlabel("Sample")
Text(0.5, 0, 'Sample')
>>> plt.show()

>>> plt.figure()
<Figure size 640x480 with 0 Axes>
>>> A = fft(window, 2048) / 25.5
>>> mag = np.abs(fftshift(A))
>>> freq = np.linspace(-0.5, 0.5, len(A))
>>> with np.errstate(divide='ignore', invalid='ignore'):
...     response = 20 * np.log10(mag)
...
>>> response = np.clip(response, -100, 100)
>>> plt.plot(freq, response)
[<matplotlib.lines.Line2D object at 0x...>]
>>> plt.title("Frequency response of Bartlett window")
Text(0.5, 1.0, 'Frequency response of Bartlett window')
>>> plt.ylabel("Magnitude [dB]")
Text(0, 0.5, 'Magnitude [dB]')
>>> plt.xlabel("Normalized frequency [cycles per sample]")
Text(0.5, 0, 'Normalized frequency [cycles per sample]')
>>> _ = plt.axis('tight')
>>> plt.show()
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l03016}{3016}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.



References \mbox{\hyperlink{numpy_2core_2numeric_8py_source_l00138}{numpy.\+core.\+numeric.\+ones()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_af25ec614bed6130cd2a0d4610369203f}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!blackman@{blackman}}
\index{blackman@{blackman}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{blackman()}{blackman()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_af25ec614bed6130cd2a0d4610369203f} 
numpy.\+lib.\+function\+\_\+base.\+blackman (\begin{DoxyParamCaption}\item[{}]{M}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the Blackman window.

The Blackman window is a taper formed by using the first three
terms of a summation of cosines. It was designed to have close to the
minimal leakage possible.  It is close to optimal, only slightly worse
than a Kaiser window.

Parameters
----------
M : int
    Number of points in the output window. If zero or less, an empty
    array is returned.

Returns
-------
out : ndarray
    The window, with the maximum value normalized to one (the value one
    appears only if the number of samples is odd).

See Also
--------
bartlett, hamming, hanning, kaiser

Notes
-----
The Blackman window is defined as

.. math::  w(n) = 0.42 - 0.5 \\cos(2\\pi n/M) + 0.08 \\cos(4\\pi n/M)

Most references to the Blackman window come from the signal processing
literature, where it is used as one of many windowing functions for
smoothing values.  It is also known as an apodization (which means
"removing the foot", i.e. smoothing discontinuities at the beginning
and end of the sampled signal) or tapering function. It is known as a
"near optimal" tapering function, almost as good (by some measures)
as the kaiser window.

References
----------
Blackman, R.B. and Tukey, J.W., (1958) The measurement of power spectra,
Dover Publications, New York.

Oppenheim, A.V., and R.W. Schafer. Discrete-Time Signal Processing.
Upper Saddle River, NJ: Prentice-Hall, 1999, pp. 468-471.

Examples
--------
>>> import matplotlib.pyplot as plt
>>> np.blackman(12)
array([-1.38777878e-17,   3.26064346e-02,   1.59903635e-01, # may vary
        4.14397981e-01,   7.36045180e-01,   9.67046769e-01,
        9.67046769e-01,   7.36045180e-01,   4.14397981e-01,
        1.59903635e-01,   3.26064346e-02,  -1.38777878e-17])

Plot the window and the frequency response:

>>> from numpy.fft import fft, fftshift
>>> window = np.blackman(51)
>>> plt.plot(window)
[<matplotlib.lines.Line2D object at 0x...>]
>>> plt.title("Blackman window")
Text(0.5, 1.0, 'Blackman window')
>>> plt.ylabel("Amplitude")
Text(0, 0.5, 'Amplitude')
>>> plt.xlabel("Sample")
Text(0.5, 0, 'Sample')
>>> plt.show()

>>> plt.figure()
<Figure size 640x480 with 0 Axes>
>>> A = fft(window, 2048) / 25.5
>>> mag = np.abs(fftshift(A))
>>> freq = np.linspace(-0.5, 0.5, len(A))
>>> with np.errstate(divide='ignore', invalid='ignore'):
...     response = 20 * np.log10(mag)
...
>>> response = np.clip(response, -100, 100)
>>> plt.plot(freq, response)
[<matplotlib.lines.Line2D object at 0x...>]
>>> plt.title("Frequency response of Blackman window")
Text(0.5, 1.0, 'Frequency response of Blackman window')
>>> plt.ylabel("Magnitude [dB]")
Text(0, 0.5, 'Magnitude [dB]')
>>> plt.xlabel("Normalized frequency [cycles per sample]")
Text(0.5, 0, 'Normalized frequency [cycles per sample]')
>>> _ = plt.axis('tight')
>>> plt.show()
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l02911}{2911}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.



References \mbox{\hyperlink{numpy_2core_2numeric_8py_source_l00138}{numpy.\+core.\+numeric.\+ones()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_afb1a45e10c0c1606be5642979696590c}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!copy@{copy}}
\index{copy@{copy}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{copy()}{copy()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_afb1a45e10c0c1606be5642979696590c} 
numpy.\+lib.\+function\+\_\+base.\+copy (\begin{DoxyParamCaption}\item[{}]{a}{, }\item[{}]{order}{ = {\ttfamily \textquotesingle{}\mbox{\hyperlink{classK}{K}}\textquotesingle{}}, }\item[{}]{subok}{ = {\ttfamily False}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Return an array copy of the given object.

Parameters
----------
a : array_like
    Input data.
order : {'C', 'F', 'A', 'K'}, optional
    Controls the memory layout of the copy. 'C' means C-order,
    'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,
    'C' otherwise. 'K' means match the layout of `a` as closely
    as possible. (Note that this function and :meth:`ndarray.copy` are very
    similar, but have different default values for their order=
    arguments.)
subok : bool, optional
    If True, then sub-classes will be passed-through, otherwise the
    returned array will be forced to be a base-class array (defaults to False).

    .. versionadded:: 1.19.0

Returns
-------
arr : ndarray
    Array interpretation of `a`.

See Also
--------
ndarray.copy : Preferred method for creating an array copy

Notes
-----
This is equivalent to:

>>> np.array(a, copy=True)  #doctest: +SKIP

Examples
--------
Create an array x, with a reference y and a copy z:

>>> x = np.array([1, 2, 3])
>>> y = x
>>> z = np.copy(x)

Note that, when we modify x, y changes, but not z:

>>> x[0] = 10
>>> x[0] == y[0]
True
>>> x[0] == z[0]
False

Note that, np.copy clears previously set WRITEABLE=False flag.

>>> a = np.array([1, 2, 3])
>>> a.flags["WRITEABLE"] = False
>>> b = np.copy(a)
>>> b.flags["WRITEABLE"]
True
>>> b[0] = 3
>>> b
array([3, 2, 3])

Note that np.copy is a shallow copy and will not copy object
elements within arrays. This is mainly important for arrays
containing Python objects. The new array will contain the
same object which may lead to surprises if that object can
be modified (is mutable):

>>> a = np.array([1, 'm', [2, 3, 4]], dtype=object)
>>> b = np.copy(a)
>>> b[2][0] = 10
>>> a
array([1, 'm', list([10, 3, 4])], dtype=object)

To ensure all elements within an ``object`` array are copied,
use `copy.deepcopy`:

>>> import copy
>>> a = np.array([1, 'm', [2, 3, 4]], dtype=object)
>>> c = copy.deepcopy(a)
>>> c[2][0] = 10
>>> c
array([1, 'm', list([10, 3, 4])], dtype=object)
>>> a
array([1, 'm', list([2, 3, 4])], dtype=object)
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l00874}{874}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a95a9fea59381aec7072fe5894abf7da4}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!corrcoef@{corrcoef}}
\index{corrcoef@{corrcoef}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{corrcoef()}{corrcoef()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a95a9fea59381aec7072fe5894abf7da4} 
numpy.\+lib.\+function\+\_\+base.\+corrcoef (\begin{DoxyParamCaption}\item[{}]{x}{, }\item[{}]{y}{ = {\ttfamily None}, }\item[{}]{rowvar}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}, }\item[{}]{bias}{ = {\ttfamily np.\+\_\+NoValue}, }\item[{}]{ddof}{ = {\ttfamily np.\+\_\+NoValue}, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{dtype}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Return Pearson product-moment correlation coefficients.

Please refer to the documentation for `cov` for more detail.  The
relationship between the correlation coefficient matrix, `R`, and the
covariance matrix, `C`, is

.. math:: R_{ij} = \\frac{ C_{ij} } { \\sqrt{ C_{ii} C_{jj} } }

The values of `R` are between -1 and 1, inclusive.

Parameters
----------
x : array_like
    A 1-D or 2-D array containing multiple variables and observations.
    Each row of `x` represents a variable, and each column a single
    observation of all those variables. Also see `rowvar` below.
y : array_like, optional
    An additional set of variables and observations. `y` has the same
    shape as `x`.
rowvar : bool, optional
    If `rowvar` is True (default), then each row represents a
    variable, with observations in the columns. Otherwise, the relationship
    is transposed: each column represents a variable, while the rows
    contain observations.
bias : _NoValue, optional
    Has no effect, do not use.

    .. deprecated:: 1.10.0
ddof : _NoValue, optional
    Has no effect, do not use.

    .. deprecated:: 1.10.0
dtype : data-type, optional
    Data-type of the result. By default, the return data-type will have
    at least `numpy.float64` precision.

    .. versionadded:: 1.20

Returns
-------
R : ndarray
    The correlation coefficient matrix of the variables.

See Also
--------
cov : Covariance matrix

Notes
-----
Due to floating point rounding the resulting array may not be Hermitian,
the diagonal elements may not be 1, and the elements may not satisfy the
inequality abs(a) <= 1. The real and imaginary parts are clipped to the
interval [-1,  1] in an attempt to improve on that situation but is not
much help in the complex case.

This function accepts but discards arguments `bias` and `ddof`.  This is
for backwards compatibility with previous versions of this function.  These
arguments had no effect on the return values of the function and can be
safely ignored in this and previous versions of numpy.

Examples
--------
In this example we generate two random arrays, ``xarr`` and ``yarr``, and
compute the row-wise and column-wise Pearson correlation coefficients,
``R``. Since ``rowvar`` is  true by  default, we first find the row-wise
Pearson correlation coefficients between the variables of ``xarr``.

>>> import numpy as np
>>> rng = np.random.default_rng(seed=42)
>>> xarr = rng.random((3, 3))
>>> xarr
array([[0.77395605, 0.43887844, 0.85859792],
       [0.69736803, 0.09417735, 0.97562235],
       [0.7611397 , 0.78606431, 0.12811363]])
>>> R1 = np.corrcoef(xarr)
>>> R1
array([[ 1.        ,  0.99256089, -0.68080986],
       [ 0.99256089,  1.        , -0.76492172],
       [-0.68080986, -0.76492172,  1.        ]])

If we add another set of variables and observations ``yarr``, we can
compute the row-wise Pearson correlation coefficients between the
variables in ``xarr`` and ``yarr``.

>>> yarr = rng.random((3, 3))
>>> yarr
array([[0.45038594, 0.37079802, 0.92676499],
       [0.64386512, 0.82276161, 0.4434142 ],
       [0.22723872, 0.55458479, 0.06381726]])
>>> R2 = np.corrcoef(xarr, yarr)
>>> R2
array([[ 1.        ,  0.99256089, -0.68080986,  0.75008178, -0.934284  ,
        -0.99004057],
       [ 0.99256089,  1.        , -0.76492172,  0.82502011, -0.97074098,
        -0.99981569],
       [-0.68080986, -0.76492172,  1.        , -0.99507202,  0.89721355,
         0.77714685],
       [ 0.75008178,  0.82502011, -0.99507202,  1.        , -0.93657855,
        -0.83571711],
       [-0.934284  , -0.97074098,  0.89721355, -0.93657855,  1.        ,
         0.97517215],
       [-0.99004057, -0.99981569,  0.77714685, -0.83571711,  0.97517215,
         1.        ]])

Finally if we use the option ``rowvar=False``, the columns are now
being treated as the variables and we will find the column-wise Pearson
correlation coefficients between variables in ``xarr`` and ``yarr``.

>>> R3 = np.corrcoef(xarr, yarr, rowvar=False)
>>> R3
array([[ 1.        ,  0.77598074, -0.47458546, -0.75078643, -0.9665554 ,
         0.22423734],
       [ 0.77598074,  1.        , -0.92346708, -0.99923895, -0.58826587,
        -0.44069024],
       [-0.47458546, -0.92346708,  1.        ,  0.93773029,  0.23297648,
         0.75137473],
       [-0.75078643, -0.99923895,  0.93773029,  1.        ,  0.55627469,
         0.47536961],
       [-0.9665554 , -0.58826587,  0.23297648,  0.55627469,  1.        ,
        -0.46666491],
       [ 0.22423734, -0.44069024,  0.75137473,  0.47536961, -0.46666491,
         1.        ]])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l02758}{2758}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.



References \mbox{\hyperlink{lib_2function__base_8py_source_l02532}{cov()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a7e8ca70892b1c0811235a7b5fe913298}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!cov@{cov}}
\index{cov@{cov}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{cov()}{cov()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a7e8ca70892b1c0811235a7b5fe913298} 
numpy.\+lib.\+function\+\_\+base.\+cov (\begin{DoxyParamCaption}\item[{}]{m}{, }\item[{}]{y}{ = {\ttfamily None}, }\item[{}]{rowvar}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}, }\item[{}]{bias}{ = {\ttfamily False}, }\item[{}]{ddof}{ = {\ttfamily None}, }\item[{}]{fweights}{ = {\ttfamily None}, }\item[{}]{aweights}{ = {\ttfamily None}, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{dtype}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Estimate a covariance matrix, given data and weights.

Covariance indicates the level to which two variables vary together.
If we examine N-dimensional samples, :math:`X = [x_1, x_2, ... x_N]^T`,
then the covariance matrix element :math:`C_{ij}` is the covariance of
:math:`x_i` and :math:`x_j`. The element :math:`C_{ii}` is the variance
of :math:`x_i`.

See the notes for an outline of the algorithm.

Parameters
----------
m : array_like
    A 1-D or 2-D array containing multiple variables and observations.
    Each row of `m` represents a variable, and each column a single
    observation of all those variables. Also see `rowvar` below.
y : array_like, optional
    An additional set of variables and observations. `y` has the same form
    as that of `m`.
rowvar : bool, optional
    If `rowvar` is True (default), then each row represents a
    variable, with observations in the columns. Otherwise, the relationship
    is transposed: each column represents a variable, while the rows
    contain observations.
bias : bool, optional
    Default normalization (False) is by ``(N - 1)``, where ``N`` is the
    number of observations given (unbiased estimate). If `bias` is True,
    then normalization is by ``N``. These values can be overridden by using
    the keyword ``ddof`` in numpy versions >= 1.5.
ddof : int, optional
    If not ``None`` the default value implied by `bias` is overridden.
    Note that ``ddof=1`` will return the unbiased estimate, even if both
    `fweights` and `aweights` are specified, and ``ddof=0`` will return
    the simple average. See the notes for the details. The default value
    is ``None``.

    .. versionadded:: 1.5
fweights : array_like, int, optional
    1-D array of integer frequency weights; the number of times each
    observation vector should be repeated.

    .. versionadded:: 1.10
aweights : array_like, optional
    1-D array of observation vector weights. These relative weights are
    typically large for observations considered "important" and smaller for
    observations considered less "important". If ``ddof=0`` the array of
    weights can be used to assign probabilities to observation vectors.

    .. versionadded:: 1.10
dtype : data-type, optional
    Data-type of the result. By default, the return data-type will have
    at least `numpy.float64` precision.

    .. versionadded:: 1.20

Returns
-------
out : ndarray
    The covariance matrix of the variables.

See Also
--------
corrcoef : Normalized covariance matrix

Notes
-----
Assume that the observations are in the columns of the observation
array `m` and let ``f = fweights`` and ``a = aweights`` for brevity. The
steps to compute the weighted covariance are as follows::

    >>> m = np.arange(10, dtype=np.float64)
    >>> f = np.arange(10) * 2
    >>> a = np.arange(10) ** 2.
    >>> ddof = 1
    >>> w = f * a
    >>> v1 = np.sum(w)
    >>> v2 = np.sum(w * a)
    >>> m -= np.sum(m * w, axis=None, keepdims=True) / v1
    >>> cov = np.dot(m * w, m.T) * v1 / (v1**2 - ddof * v2)

Note that when ``a == 1``, the normalization factor
``v1 / (v1**2 - ddof * v2)`` goes over to ``1 / (np.sum(f) - ddof)``
as it should.

Examples
--------
Consider two variables, :math:`x_0` and :math:`x_1`, which
correlate perfectly, but in opposite directions:

>>> x = np.array([[0, 2], [1, 1], [2, 0]]).T
>>> x
array([[0, 1, 2],
       [2, 1, 0]])

Note how :math:`x_0` increases while :math:`x_1` decreases. The covariance
matrix shows this clearly:

>>> np.cov(x)
array([[ 1., -1.],
       [-1.,  1.]])

Note that element :math:`C_{0,1}`, which shows the correlation between
:math:`x_0` and :math:`x_1`, is negative.

Further, note how `x` and `y` are combined:

>>> x = [-2.1, -1,  4.3]
>>> y = [3,  1.1,  0.12]
>>> X = np.stack((x, y), axis=0)
>>> np.cov(X)
array([[11.71      , -4.286     ], # may vary
       [-4.286     ,  2.144133]])
>>> np.cov(x, y)
array([[11.71      , -4.286     ], # may vary
       [-4.286     ,  2.144133]])
>>> np.cov(x)
array(11.71)
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l02531}{2531}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.



References \mbox{\hyperlink{core_2fromnumeric_8py_source_l02323}{numpy.\+core.\+fromnumeric.\+any()}}, \mbox{\hyperlink{lib_2function__base_8py_source_l00400}{average()}}, \mbox{\hyperlink{core_2fromnumeric_8py_source_l00201}{numpy.\+core.\+fromnumeric.\+reshape()}}, and \mbox{\hyperlink{core_2fromnumeric_8py_source_l02179}{numpy.\+core.\+fromnumeric.\+sum()}}.



Referenced by \mbox{\hyperlink{lib_2function__base_8py_source_l02759}{corrcoef()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a4663e1646f5d9ce74aa757c3c9b4a463}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!delete@{delete}}
\index{delete@{delete}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{delete()}{delete()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a4663e1646f5d9ce74aa757c3c9b4a463} 
numpy.\+lib.\+function\+\_\+base.\+delete (\begin{DoxyParamCaption}\item[{}]{arr}{, }\item[{}]{obj}{, }\item[{}]{axis}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Return a new array with sub-arrays along an axis deleted. For a one
dimensional array, this returns those entries not returned by
`arr[obj]`.

Parameters
----------
arr : array_like
    Input array.
obj : slice, int or array of ints
    Indicate indices of sub-arrays to remove along the specified axis.

    .. versionchanged:: 1.19.0
        Boolean indices are now treated as a mask of elements to remove,
        rather than being cast to the integers 0 and 1.

axis : int, optional
    The axis along which to delete the subarray defined by `obj`.
    If `axis` is None, `obj` is applied to the flattened array.

Returns
-------
out : ndarray
    A copy of `arr` with the elements specified by `obj` removed. Note
    that `delete` does not occur in-place. If `axis` is None, `out` is
    a flattened array.

See Also
--------
insert : Insert elements into an array.
append : Append elements at the end of an array.

Notes
-----
Often it is preferable to use a boolean mask. For example:

>>> arr = np.arange(12) + 1
>>> mask = np.ones(len(arr), dtype=bool)
>>> mask[[0,2,4]] = False
>>> result = arr[mask,...]

Is equivalent to ``np.delete(arr, [0,2,4], axis=0)``, but allows further
use of `mask`.

Examples
--------
>>> arr = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])
>>> arr
array([[ 1,  2,  3,  4],
       [ 5,  6,  7,  8],
       [ 9, 10, 11, 12]])
>>> np.delete(arr, 1, 0)
array([[ 1,  2,  3,  4],
       [ 9, 10, 11, 12]])

>>> np.delete(arr, np.s_[::2], 1)
array([[ 2,  4],
       [ 6,  8],
       [10, 12]])
>>> np.delete(arr, [1,3,5], None)
array([ 1,  3,  5,  7,  8,  9, 10, 11, 12])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l05174}{5174}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.



References \mbox{\hyperlink{numpy_2core_2numeric_8py_source_l00138}{numpy.\+core.\+numeric.\+ones()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a5eb0a6129e9afd0c17390fcf39834c97}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!diff@{diff}}
\index{diff@{diff}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{diff()}{diff()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a5eb0a6129e9afd0c17390fcf39834c97} 
numpy.\+lib.\+function\+\_\+base.\+diff (\begin{DoxyParamCaption}\item[{}]{a}{, }\item[{}]{n}{ = {\ttfamily 1}, }\item[{}]{axis}{ = {\ttfamily -\/1}, }\item[{}]{prepend}{ = {\ttfamily np.\+\_\+NoValue}, }\item[{}]{append}{ = {\ttfamily np.\+\_\+NoValue}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Calculate the n-th discrete difference along the given axis.

The first difference is given by ``out[i] = a[i+1] - a[i]`` along
the given axis, higher differences are calculated by using `diff`
recursively.

Parameters
----------
a : array_like
    Input array
n : int, optional
    The number of times values are differenced. If zero, the input
    is returned as-is.
axis : int, optional
    The axis along which the difference is taken, default is the
    last axis.
prepend, append : array_like, optional
    Values to prepend or append to `a` along axis prior to
    performing the difference.  Scalar values are expanded to
    arrays with length 1 in the direction of axis and the shape
    of the input array in along all other axes.  Otherwise the
    dimension and shape must match `a` except along axis.

    .. versionadded:: 1.16.0

Returns
-------
diff : ndarray
    The n-th differences. The shape of the output is the same as `a`
    except along `axis` where the dimension is smaller by `n`. The
    type of the output is the same as the type of the difference
    between any two elements of `a`. This is the same as the type of
    `a` in most cases. A notable exception is `datetime64`, which
    results in a `timedelta64` output array.

See Also
--------
gradient, ediff1d, cumsum

Notes
-----
Type is preserved for boolean arrays, so the result will contain
`False` when consecutive elements are the same and `True` when they
differ.

For unsigned integer arrays, the results will also be unsigned. This
should not be surprising, as the result is consistent with
calculating the difference directly:

>>> u8_arr = np.array([1, 0], dtype=np.uint8)
>>> np.diff(u8_arr)
array([255], dtype=uint8)
>>> u8_arr[1,...] - u8_arr[0,...]
255

If this is not desirable, then the array should be cast to a larger
integer type first:

>>> i16_arr = u8_arr.astype(np.int16)
>>> np.diff(i16_arr)
array([-1], dtype=int16)

Examples
--------
>>> x = np.array([1, 2, 4, 7, 0])
>>> np.diff(x)
array([ 1,  2,  3, -7])
>>> np.diff(x, n=2)
array([  1,   1, -10])

>>> x = np.array([[1, 3, 6, 10], [0, 5, 6, 8]])
>>> np.diff(x)
array([[2, 3, 4],
       [5, 1, 2]])
>>> np.diff(x, axis=0)
array([[-1,  2,  0, -2]])

>>> x = np.arange('1066-10-13', '1066-10-16', dtype=np.datetime64)
>>> np.diff(x)
array([1, 1], dtype='timedelta64[D]')
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l01325}{1325}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.



Referenced by \mbox{\hyperlink{lib_2index__tricks_8py_source_l00993}{numpy.\+lib.\+index\+\_\+tricks.\+diag\+\_\+indices\+\_\+from()}}, \mbox{\hyperlink{lib_2index__tricks_8py_source_l00786}{numpy.\+lib.\+index\+\_\+tricks.\+fill\+\_\+diagonal()}}, \mbox{\hyperlink{lib_2function__base_8py_source_l04859}{trapz()}}, and \mbox{\hyperlink{lib_2function__base_8py_source_l01664}{unwrap()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_aa259b287cb75f0a18e0ef9a53296e62d}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!digitize@{digitize}}
\index{digitize@{digitize}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{digitize()}{digitize()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_aa259b287cb75f0a18e0ef9a53296e62d} 
numpy.\+lib.\+function\+\_\+base.\+digitize (\begin{DoxyParamCaption}\item[{}]{x}{, }\item[{}]{bins}{, }\item[{}]{right}{ = {\ttfamily False}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the indices of the bins to which each value in input array belongs.

=========  =============  ============================
`right`    order of bins  returned index `i` satisfies
=========  =============  ============================
``False``  increasing     ``bins[i-1] <= x < bins[i]``
``True``   increasing     ``bins[i-1] < x <= bins[i]``
``False``  decreasing     ``bins[i-1] > x >= bins[i]``
``True``   decreasing     ``bins[i-1] >= x > bins[i]``
=========  =============  ============================

If values in `x` are beyond the bounds of `bins`, 0 or ``len(bins)`` is
returned as appropriate.

Parameters
----------
x : array_like
    Input array to be binned. Prior to NumPy 1.10.0, this array had to
    be 1-dimensional, but can now have any shape.
bins : array_like
    Array of bins. It has to be 1-dimensional and monotonic.
right : bool, optional
    Indicating whether the intervals include the right or the left bin
    edge. Default behavior is (right==False) indicating that the interval
    does not include the right edge. The left bin end is open in this
    case, i.e., bins[i-1] <= x < bins[i] is the default behavior for
    monotonically increasing bins.

Returns
-------
indices : ndarray of ints
    Output array of indices, of same shape as `x`.

Raises
------
ValueError
    If `bins` is not monotonic.
TypeError
    If the type of the input is complex.

See Also
--------
bincount, histogram, unique, searchsorted

Notes
-----
If values in `x` are such that they fall outside the bin range,
attempting to index `bins` with the indices that `digitize` returns
will result in an IndexError.

.. versionadded:: 1.10.0

`np.digitize` is  implemented in terms of `np.searchsorted`. This means
that a binary search is used to bin the values, which scales much better
for larger number of bins than the previous linear search. It also removes
the requirement for the input array to be 1-dimensional.

For monotonically _increasing_ `bins`, the following are equivalent::

    np.digitize(x, bins, right=True)
    np.searchsorted(bins, x, side='left')

Note that as the order of the arguments are reversed, the side must be too.
The `searchsorted` call is marginally faster, as it does not do any
monotonicity checks. Perhaps more importantly, it supports all dtypes.

Examples
--------
>>> x = np.array([0.2, 6.4, 3.0, 1.6])
>>> bins = np.array([0.0, 1.0, 2.5, 4.0, 10.0])
>>> inds = np.digitize(x, bins)
>>> inds
array([1, 4, 3, 2])
>>> for n in range(x.size):
...   print(bins[inds[n]-1], "<=", x[n], "<", bins[inds[n]])
...
0.0 <= 0.2 < 1.0
4.0 <= 6.4 < 10.0
2.5 <= 3.0 < 4.0
1.0 <= 1.6 < 2.5

>>> x = np.array([1.2, 10.0, 12.4, 15.5, 20.])
>>> bins = np.array([0, 5, 10, 15, 20])
>>> np.digitize(x,bins,right=True)
array([1, 2, 3, 4, 4])
>>> np.digitize(x,bins,right=False)
array([1, 3, 3, 4, 5])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l05626}{5626}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a09dbeec0a20ef95416268f8965120fba}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!disp@{disp}}
\index{disp@{disp}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{disp()}{disp()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a09dbeec0a20ef95416268f8965120fba} 
numpy.\+lib.\+function\+\_\+base.\+disp (\begin{DoxyParamCaption}\item[{}]{mesg}{, }\item[{}]{device}{ = {\ttfamily None}, }\item[{}]{linefeed}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Display a message on a device.

Parameters
----------
mesg : str
    Message to display.
device : object
    Device to write message. If None, defaults to ``sys.stdout`` which is
    very similar to ``print``. `device` needs to have ``write()`` and
    ``flush()`` methods.
linefeed : bool, optional
    Option whether to print a line feed or not. Defaults to True.

Raises
------
AttributeError
    If `device` does not have a ``write()`` or ``flush()`` method.

Examples
--------
Besides ``sys.stdout``, a file-like object can also be used as it has
both required methods:

>>> from io import StringIO
>>> buf = StringIO()
>>> np.disp(u'"Display" in a file', device=buf)
>>> buf.getvalue()
'"Display" in a file\\n'
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l01957}{1957}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_ae2b248407fcb2f95fee57aa96e087bb0}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!extract@{extract}}
\index{extract@{extract}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{extract()}{extract()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_ae2b248407fcb2f95fee57aa96e087bb0} 
numpy.\+lib.\+function\+\_\+base.\+extract (\begin{DoxyParamCaption}\item[{}]{condition}{, }\item[{}]{arr}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the elements of an array that satisfy some condition.

This is equivalent to ``np.compress(ravel(condition), ravel(arr))``.  If
`condition` is boolean ``np.extract`` is equivalent to ``arr[condition]``.

Note that `place` does the exact opposite of `extract`.

Parameters
----------
condition : array_like
    An array whose nonzero or True entries indicate the elements of `arr`
    to extract.
arr : array_like
    Input array of the same size as `condition`.

Returns
-------
extract : ndarray
    Rank 1 array of values from `arr` where `condition` is True.

See Also
--------
take, put, copyto, compress, place

Examples
--------
>>> arr = np.arange(12).reshape((3, 4))
>>> arr
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
>>> condition = np.mod(arr, 3)==0
>>> condition
array([[ True, False, False,  True],
       [False, False,  True, False],
       [False,  True, False, False]])
>>> np.extract(condition, arr)
array([0, 3, 6, 9])


If `condition` is boolean:

>>> arr[condition]
array([0, 3, 6, 9])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l01862}{1862}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.



References \mbox{\hyperlink{core_2fromnumeric_8py_source_l01769}{numpy.\+core.\+fromnumeric.\+ravel()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_ad88c114152e04ed3734835f74c231a74}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!flip@{flip}}
\index{flip@{flip}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{flip()}{flip()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_ad88c114152e04ed3734835f74c231a74} 
numpy.\+lib.\+function\+\_\+base.\+flip (\begin{DoxyParamCaption}\item[{}]{m}{, }\item[{}]{axis}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Reverse the order of elements in an array along the given axis.

The shape of the array is preserved, but the elements are reordered.

.. versionadded:: 1.12.0

Parameters
----------
m : array_like
    Input array.
axis : None or int or tuple of ints, optional
     Axis or axes along which to flip over. The default,
     axis=None, will flip over all of the axes of the input array.
     If axis is negative it counts from the last to the first axis.

     If axis is a tuple of ints, flipping is performed on all of the axes
     specified in the tuple.

     .. versionchanged:: 1.15.0
        None and tuples of axes are supported

Returns
-------
out : array_like
    A view of `m` with the entries of axis reversed.  Since a view is
    returned, this operation is done in constant time.

See Also
--------
flipud : Flip an array vertically (axis=0).
fliplr : Flip an array horizontally (axis=1).

Notes
-----
flip(m, 0) is equivalent to flipud(m).

flip(m, 1) is equivalent to fliplr(m).

flip(m, n) corresponds to ``m[...,::-1,...]`` with ``::-1`` at position n.

flip(m) corresponds to ``m[::-1,::-1,...,::-1]`` with ``::-1`` at all
positions.

flip(m, (0, 1)) corresponds to ``m[::-1,::-1,...]`` with ``::-1`` at
position 0 and position 1.

Examples
--------
>>> A = np.arange(8).reshape((2,2,2))
>>> A
array([[[0, 1],
        [2, 3]],
       [[4, 5],
        [6, 7]]])
>>> np.flip(A, 0)
array([[[4, 5],
        [6, 7]],
       [[0, 1],
        [2, 3]]])
>>> np.flip(A, 1)
array([[[2, 3],
        [0, 1]],
       [[6, 7],
        [4, 5]]])
>>> np.flip(A)
array([[[7, 6],
        [5, 4]],
       [[3, 2],
        [1, 0]]])
>>> np.flip(A, (0, 2))
array([[[5, 4],
        [7, 6]],
       [[1, 0],
        [3, 2]]])
>>> A = np.random.randn(3,4,5)
>>> np.all(np.flip(A,2) == A[:,:,::-1,...])
True
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l00255}{255}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.



Referenced by \mbox{\hyperlink{lib_2function__base_8py_source_l00159}{rot90()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_ad34816c3b1cf5a22aa4e2ec2d74013a7}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!gradient@{gradient}}
\index{gradient@{gradient}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{gradient()}{gradient()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_ad34816c3b1cf5a22aa4e2ec2d74013a7} 
numpy.\+lib.\+function\+\_\+base.\+gradient (\begin{DoxyParamCaption}\item[{}]{f}{, }\item[{\texorpdfstring{$\ast$}{*}}]{varargs}{, }\item[{}]{axis}{ = {\ttfamily None}, }\item[{}]{edge\+\_\+order}{ = {\ttfamily 1}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the gradient of an N-dimensional array.

The gradient is computed using second order accurate central differences
in the interior points and either first or second order accurate one-sides
(forward or backwards) differences at the boundaries.
The returned gradient hence has the same shape as the input array.

Parameters
----------
f : array_like
    An N-dimensional array containing samples of a scalar function.
varargs : list of scalar or array, optional
    Spacing between f values. Default unitary spacing for all dimensions.
    Spacing can be specified using:

    1. single scalar to specify a sample distance for all dimensions.
    2. N scalars to specify a constant sample distance for each dimension.
       i.e. `dx`, `dy`, `dz`, ...
    3. N arrays to specify the coordinates of the values along each
       dimension of F. The length of the array must match the size of
       the corresponding dimension
    4. Any combination of N scalars/arrays with the meaning of 2. and 3.

    If `axis` is given, the number of varargs must equal the number of axes.
    Default: 1.

edge_order : {1, 2}, optional
    Gradient is calculated using N-th order accurate differences
    at the boundaries. Default: 1.

    .. versionadded:: 1.9.1

axis : None or int or tuple of ints, optional
    Gradient is calculated only along the given axis or axes
    The default (axis = None) is to calculate the gradient for all the axes
    of the input array. axis may be negative, in which case it counts from
    the last to the first axis.

    .. versionadded:: 1.11.0

Returns
-------
gradient : ndarray or list of ndarray
    A list of ndarrays (or a single ndarray if there is only one dimension)
    corresponding to the derivatives of f with respect to each dimension.
    Each derivative has the same shape as f.

Examples
--------
>>> f = np.array([1, 2, 4, 7, 11, 16], dtype=float)
>>> np.gradient(f)
array([1. , 1.5, 2.5, 3.5, 4.5, 5. ])
>>> np.gradient(f, 2)
array([0.5 ,  0.75,  1.25,  1.75,  2.25,  2.5 ])

Spacing can be also specified with an array that represents the coordinates
of the values F along the dimensions.
For instance a uniform spacing:

>>> x = np.arange(f.size)
>>> np.gradient(f, x)
array([1. ,  1.5,  2.5,  3.5,  4.5,  5. ])

Or a non uniform one:

>>> x = np.array([0., 1., 1.5, 3.5, 4., 6.], dtype=float)
>>> np.gradient(f, x)
array([1. ,  3. ,  3.5,  6.7,  6.9,  2.5])

For two dimensional arrays, the return will be two arrays ordered by
axis. In this example the first array stands for the gradient in
rows and the second one in columns direction:

>>> np.gradient(np.array([[1, 2, 6], [3, 4, 5]], dtype=float))
[array([[ 2.,  2., -1.],
       [ 2.,  2., -1.]]), array([[1. , 2.5, 4. ],
       [1. , 1. , 1. ]])]

In this example the spacing is also specified:
uniform for axis=0 and non uniform for axis=1

>>> dx = 2.
>>> y = [1., 1.5, 3.5]
>>> np.gradient(np.array([[1, 2, 6], [3, 4, 5]], dtype=float), dx, y)
[array([[ 1. ,  1. , -0.5],
       [ 1. ,  1. , -0.5]]), array([[2. , 2. , 2. ],
       [2. , 1.7, 0.5]])]

It is possible to specify how boundaries are treated using `edge_order`

>>> x = np.array([0, 1, 2, 3, 4])
>>> f = x**2
>>> np.gradient(f, edge_order=1)
array([1.,  2.,  4.,  6.,  7.])
>>> np.gradient(f, edge_order=2)
array([0., 2., 4., 6., 8.])

The `axis` keyword can be used to specify a subset of axes of which the
gradient is calculated

>>> np.gradient(np.array([[1, 2, 6], [3, 4, 5]], dtype=float), axis=0)
array([[ 2.,  2., -1.],
       [ 2.,  2., -1.]])

Notes
-----
Assuming that :math:`f\\in C^{3}` (i.e., :math:`f` has at least 3 continuous
derivatives) and let :math:`h_{*}` be a non-homogeneous stepsize, we
minimize the "consistency error" :math:`\\eta_{i}` between the true gradient
and its estimate from a linear combination of the neighboring grid-points:

.. math::

    \\eta_{i} = f_{i}^{\\left(1\\right)} -
                \\left[ \\alpha f\\left(x_{i}\\right) +
                        \\beta f\\left(x_{i} + h_{d}\\right) +
                        \\gamma f\\left(x_{i}-h_{s}\\right)
                \\right]

By substituting :math:`f(x_{i} + h_{d})` and :math:`f(x_{i} - h_{s})`
with their Taylor series expansion, this translates into solving
the following the linear system:

.. math::

    \\left\\{
        \\begin{array}{r}
            \\alpha+\\beta+\\gamma=0 \\\\
            \\beta h_{d}-\\gamma h_{s}=1 \\\\
            \\beta h_{d}^{2}+\\gamma h_{s}^{2}=0
        \\end{array}
    \\right.

The resulting approximation of :math:`f_{i}^{(1)}` is the following:

.. math::

    \\hat f_{i}^{(1)} =
        \\frac{
            h_{s}^{2}f\\left(x_{i} + h_{d}\\right)
            + \\left(h_{d}^{2} - h_{s}^{2}\\right)f\\left(x_{i}\\right)
            - h_{d}^{2}f\\left(x_{i}-h_{s}\\right)}
            { h_{s}h_{d}\\left(h_{d} + h_{s}\\right)}
        + \\mathcal{O}\\left(\\frac{h_{d}h_{s}^{2}
                            + h_{s}h_{d}^{2}}{h_{d}
                            + h_{s}}\\right)

It is worth noting that if :math:`h_{s}=h_{d}`
(i.e., data are evenly spaced)
we find the standard second order approximation:

.. math::

    \\hat f_{i}^{(1)}=
        \\frac{f\\left(x_{i+1}\\right) - f\\left(x_{i-1}\\right)}{2h}
        + \\mathcal{O}\\left(h^{2}\\right)

With a similar procedure the forward/backward approximations used for
boundaries can be derived.

References
----------
.. [1]  Quarteroni A., Sacco R., Saleri F. (2007) Numerical Mathematics
        (Texts in Applied Mathematics). New York: Springer.
.. [2]  Durran D. R. (1999) Numerical Methods for Wave Equations
        in Geophysical Fluid Dynamics. New York: Springer.
.. [3]  Fornberg B. (1988) Generation of Finite Difference Formulas on
        Arbitrarily Spaced Grids,
        Mathematics of Computation 51, no. 184 : 699-706.
        `PDF <http://www.ams.org/journals/mcom/1988-51-184/
        S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf>`_.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l00973}{973}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.



References \mbox{\hyperlink{core_2fromnumeric_8py_source_l02422}{numpy.\+core.\+fromnumeric.\+all()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_ad6daf481775305b9274f38dbf7f28075}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!hamming@{hamming}}
\index{hamming@{hamming}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{hamming()}{hamming()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_ad6daf481775305b9274f38dbf7f28075} 
numpy.\+lib.\+function\+\_\+base.\+hamming (\begin{DoxyParamCaption}\item[{}]{M}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the Hamming window.

The Hamming window is a taper formed by using a weighted cosine.

Parameters
----------
M : int
    Number of points in the output window. If zero or less, an
    empty array is returned.

Returns
-------
out : ndarray
    The window, with the maximum value normalized to one (the value
    one appears only if the number of samples is odd).

See Also
--------
bartlett, blackman, hanning, kaiser

Notes
-----
The Hamming window is defined as

.. math::  w(n) = 0.54 - 0.46\\cos\\left(\\frac{2\\pi{n}}{M-1}\\right)
           \\qquad 0 \\leq n \\leq M-1

The Hamming was named for R. W. Hamming, an associate of J. W. Tukey
and is described in Blackman and Tukey. It was recommended for
smoothing the truncated autocovariance function in the time domain.
Most references to the Hamming window come from the signal processing
literature, where it is used as one of many windowing functions for
smoothing values.  It is also known as an apodization (which means
"removing the foot", i.e. smoothing discontinuities at the beginning
and end of the sampled signal) or tapering function.

References
----------
.. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power
       spectra, Dover Publications, New York.
.. [2] E.R. Kanasewich, "Time Sequence Analysis in Geophysics", The
       University of Alberta Press, 1975, pp. 109-110.
.. [3] Wikipedia, "Window function",
       https://en.wikipedia.org/wiki/Window_function
.. [4] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,
       "Numerical Recipes", Cambridge University Press, 1986, page 425.

Examples
--------
>>> np.hamming(12)
array([ 0.08      ,  0.15302337,  0.34890909,  0.60546483,  0.84123594, # may vary
        0.98136677,  0.98136677,  0.84123594,  0.60546483,  0.34890909,
        0.15302337,  0.08      ])

Plot the window and the frequency response:

>>> import matplotlib.pyplot as plt
>>> from numpy.fft import fft, fftshift
>>> window = np.hamming(51)
>>> plt.plot(window)
[<matplotlib.lines.Line2D object at 0x...>]
>>> plt.title("Hamming window")
Text(0.5, 1.0, 'Hamming window')
>>> plt.ylabel("Amplitude")
Text(0, 0.5, 'Amplitude')
>>> plt.xlabel("Sample")
Text(0.5, 0, 'Sample')
>>> plt.show()

>>> plt.figure()
<Figure size 640x480 with 0 Axes>
>>> A = fft(window, 2048) / 25.5
>>> mag = np.abs(fftshift(A))
>>> freq = np.linspace(-0.5, 0.5, len(A))
>>> response = 20 * np.log10(mag)
>>> response = np.clip(response, -100, 100)
>>> plt.plot(freq, response)
[<matplotlib.lines.Line2D object at 0x...>]
>>> plt.title("Frequency response of Hamming window")
Text(0.5, 1.0, 'Frequency response of Hamming window')
>>> plt.ylabel("Magnitude [dB]")
Text(0, 0.5, 'Magnitude [dB]')
>>> plt.xlabel("Normalized frequency [cycles per sample]")
Text(0.5, 0, 'Normalized frequency [cycles per sample]')
>>> plt.axis('tight')
...
>>> plt.show()
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l03238}{3238}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.



References \mbox{\hyperlink{numpy_2core_2numeric_8py_source_l00138}{numpy.\+core.\+numeric.\+ones()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a5485a32d8c4e900a028bf62da520be04}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!hanning@{hanning}}
\index{hanning@{hanning}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{hanning()}{hanning()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a5485a32d8c4e900a028bf62da520be04} 
numpy.\+lib.\+function\+\_\+base.\+hanning (\begin{DoxyParamCaption}\item[{}]{M}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the Hanning window.

The Hanning window is a taper formed by using a weighted cosine.

Parameters
----------
M : int
    Number of points in the output window. If zero or less, an
    empty array is returned.

Returns
-------
out : ndarray, shape(M,)
    The window, with the maximum value normalized to one (the value
    one appears only if `M` is odd).

See Also
--------
bartlett, blackman, hamming, kaiser

Notes
-----
The Hanning window is defined as

.. math::  w(n) = 0.5 - 0.5\\cos\\left(\\frac{2\\pi{n}}{M-1}\\right)
           \\qquad 0 \\leq n \\leq M-1

The Hanning was named for Julius von Hann, an Austrian meteorologist.
It is also known as the Cosine Bell. Some authors prefer that it be
called a Hann window, to help avoid confusion with the very similar
Hamming window.

Most references to the Hanning window come from the signal processing
literature, where it is used as one of many windowing functions for
smoothing values.  It is also known as an apodization (which means
"removing the foot", i.e. smoothing discontinuities at the beginning
and end of the sampled signal) or tapering function.

References
----------
.. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power
       spectra, Dover Publications, New York.
.. [2] E.R. Kanasewich, "Time Sequence Analysis in Geophysics",
       The University of Alberta Press, 1975, pp. 106-108.
.. [3] Wikipedia, "Window function",
       https://en.wikipedia.org/wiki/Window_function
.. [4] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,
       "Numerical Recipes", Cambridge University Press, 1986, page 425.

Examples
--------
>>> np.hanning(12)
array([0.        , 0.07937323, 0.29229249, 0.57115742, 0.82743037,
       0.97974649, 0.97974649, 0.82743037, 0.57115742, 0.29229249,
       0.07937323, 0.        ])

Plot the window and its frequency response:

>>> import matplotlib.pyplot as plt
>>> from numpy.fft import fft, fftshift
>>> window = np.hanning(51)
>>> plt.plot(window)
[<matplotlib.lines.Line2D object at 0x...>]
>>> plt.title("Hann window")
Text(0.5, 1.0, 'Hann window')
>>> plt.ylabel("Amplitude")
Text(0, 0.5, 'Amplitude')
>>> plt.xlabel("Sample")
Text(0.5, 0, 'Sample')
>>> plt.show()

>>> plt.figure()
<Figure size 640x480 with 0 Axes>
>>> A = fft(window, 2048) / 25.5
>>> mag = np.abs(fftshift(A))
>>> freq = np.linspace(-0.5, 0.5, len(A))
>>> with np.errstate(divide='ignore', invalid='ignore'):
...     response = 20 * np.log10(mag)
...
>>> response = np.clip(response, -100, 100)
>>> plt.plot(freq, response)
[<matplotlib.lines.Line2D object at 0x...>]
>>> plt.title("Frequency response of the Hann window")
Text(0.5, 1.0, 'Frequency response of the Hann window')
>>> plt.ylabel("Magnitude [dB]")
Text(0, 0.5, 'Magnitude [dB]')
>>> plt.xlabel("Normalized frequency [cycles per sample]")
Text(0.5, 0, 'Normalized frequency [cycles per sample]')
>>> plt.axis('tight')
...
>>> plt.show()
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l03129}{3129}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.



References \mbox{\hyperlink{numpy_2core_2numeric_8py_source_l00138}{numpy.\+core.\+numeric.\+ones()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a56c6f434b7fb3ba18363854522256b98}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!i0@{i0}}
\index{i0@{i0}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{i0()}{i0()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a56c6f434b7fb3ba18363854522256b98} 
numpy.\+lib.\+function\+\_\+base.\+i0 (\begin{DoxyParamCaption}\item[{}]{x}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Modified Bessel function of the first kind, order 0.

Usually denoted :math:`I_0`.

Parameters
----------
x : array_like of float
    Argument of the Bessel function.

Returns
-------
out : ndarray, shape = x.shape, dtype = float
    The modified Bessel function evaluated at each of the elements of `x`.

See Also
--------
scipy.special.i0, scipy.special.iv, scipy.special.ive

Notes
-----
The scipy implementation is recommended over this function: it is a
proper ufunc written in C, and more than an order of magnitude faster.

We use the algorithm published by Clenshaw [1]_ and referenced by
Abramowitz and Stegun [2]_, for which the function domain is
partitioned into the two intervals [0,8] and (8,inf), and Chebyshev
polynomial expansions are employed in each interval. Relative error on
the domain [0,30] using IEEE arithmetic is documented [3]_ as having a
peak of 5.8e-16 with an rms of 1.4e-16 (n = 30000).

References
----------
.. [1] C. W. Clenshaw, "Chebyshev series for mathematical functions", in
       *National Physical Laboratory Mathematical Tables*, vol. 5, London:
       Her Majesty's Stationery Office, 1962.
.. [2] M. Abramowitz and I. A. Stegun, *Handbook of Mathematical
       Functions*, 10th printing, New York: Dover, 1964, pp. 379.
       https://personal.math.ubc.ca/~cbm/aands/page_379.htm
.. [3] https://metacpan.org/pod/distribution/Math-Cephes/lib/Math/Cephes.pod#i0:-Modified-Bessel-function-of-order-zero

Examples
--------
>>> np.i0(0.)
array(1.0)
>>> np.i0([0, 1, 2, 3])
array([1.        , 1.26606588, 2.2795853 , 4.88079259])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l03431}{3431}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.



References \mbox{\hyperlink{lib_2function__base_8py_source_l00643}{piecewise()}}.



Referenced by \mbox{\hyperlink{lib_2function__base_8py_source_l03493}{kaiser()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_ae0b6af9b1d56f8f1d7d88ffcc050bed3}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!insert@{insert}}
\index{insert@{insert}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{insert()}{insert()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_ae0b6af9b1d56f8f1d7d88ffcc050bed3} 
numpy.\+lib.\+function\+\_\+base.\+insert (\begin{DoxyParamCaption}\item[{}]{arr}{, }\item[{}]{obj}{, }\item[{}]{values}{, }\item[{}]{axis}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Insert values along the given axis before the given indices.

Parameters
----------
arr : array_like
    Input array.
obj : int, slice or sequence of ints
    Object that defines the index or indices before which `values` is
    inserted.

    .. versionadded:: 1.8.0

    Support for multiple insertions when `obj` is a single scalar or a
    sequence with one element (similar to calling insert multiple
    times).
values : array_like
    Values to insert into `arr`. If the type of `values` is different
    from that of `arr`, `values` is converted to the type of `arr`.
    `values` should be shaped so that ``arr[...,obj,...] = values``
    is legal.
axis : int, optional
    Axis along which to insert `values`.  If `axis` is None then `arr`
    is flattened first.

Returns
-------
out : ndarray
    A copy of `arr` with `values` inserted.  Note that `insert`
    does not occur in-place: a new array is returned. If
    `axis` is None, `out` is a flattened array.

See Also
--------
append : Append elements at the end of an array.
concatenate : Join a sequence of arrays along an existing axis.
delete : Delete elements from an array.

Notes
-----
Note that for higher dimensional inserts ``obj=0`` behaves very different
from ``obj=[0]`` just like ``arr[:,0,:] = values`` is different from
``arr[:,[0],:] = values``.

Examples
--------
>>> a = np.array([[1, 1], [2, 2], [3, 3]])
>>> a
array([[1, 1],
       [2, 2],
       [3, 3]])
>>> np.insert(a, 1, 5)
array([1, 5, 1, ..., 2, 3, 3])
>>> np.insert(a, 1, 5, axis=1)
array([[1, 5, 1],
       [2, 5, 2],
       [3, 5, 3]])

Difference between sequence and scalars:

>>> np.insert(a, [1], [[1],[2],[3]], axis=1)
array([[1, 1, 1],
       [2, 2, 2],
       [3, 3, 3]])
>>> np.array_equal(np.insert(a, 1, [1, 2, 3], axis=1),
...                np.insert(a, [1], [[1],[2],[3]], axis=1))
True

>>> b = a.flatten()
>>> b
array([1, 1, 2, 2, 3, 3])
>>> np.insert(b, [2, 2], [5, 6])
array([1, 1, 5, ..., 2, 3, 3])

>>> np.insert(b, slice(2, 4), [5, 6])
array([1, 1, 5, ..., 2, 3, 3])

>>> np.insert(b, [2, 2], [7.13, False]) # type casting
array([1, 1, 7, ..., 2, 3, 3])

>>> x = np.arange(8).reshape(2, 4)
>>> idx = (1, 3)
>>> np.insert(x, idx, 999, axis=1)
array([[  0, 999,   1,   2, 999,   3],
       [  4, 999,   5,   6, 999,   7]])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l05370}{5370}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.



References \mbox{\hyperlink{numpy_2core_2numeric_8py_source_l00138}{numpy.\+core.\+numeric.\+ones()}}.



Referenced by \mbox{\hyperlink{__type__aliases_8py_source_l00058}{numpy.\+core.\+\_\+type\+\_\+aliases.\+bitname()}}, and \mbox{\hyperlink{__iotools_8py_source_l00543}{numpy.\+lib.\+\_\+iotools.\+String\+Converter.\+upgrade\+\_\+mapper()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_ab5b0bfb8023fc47d9991cb3429af814f}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!interp@{interp}}
\index{interp@{interp}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{interp()}{interp()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_ab5b0bfb8023fc47d9991cb3429af814f} 
numpy.\+lib.\+function\+\_\+base.\+interp (\begin{DoxyParamCaption}\item[{}]{x}{, }\item[{}]{xp}{, }\item[{}]{fp}{, }\item[{}]{left}{ = {\ttfamily None}, }\item[{}]{right}{ = {\ttfamily None}, }\item[{}]{period}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}One-dimensional linear interpolation for monotonically increasing sample points.

Returns the one-dimensional piecewise linear interpolant to a function
with given discrete data points (`xp`, `fp`), evaluated at `x`.

Parameters
----------
x : array_like
    The x-coordinates at which to evaluate the interpolated values.

xp : 1-D sequence of floats
    The x-coordinates of the data points, must be increasing if argument
    `period` is not specified. Otherwise, `xp` is internally sorted after
    normalizing the periodic boundaries with ``xp = xp % period``.

fp : 1-D sequence of float or complex
    The y-coordinates of the data points, same length as `xp`.

left : optional float or complex corresponding to fp
    Value to return for `x < xp[0]`, default is `fp[0]`.

right : optional float or complex corresponding to fp
    Value to return for `x > xp[-1]`, default is `fp[-1]`.

period : None or float, optional
    A period for the x-coordinates. This parameter allows the proper
    interpolation of angular x-coordinates. Parameters `left` and `right`
    are ignored if `period` is specified.

    .. versionadded:: 1.10.0

Returns
-------
y : float or complex (corresponding to fp) or ndarray
    The interpolated values, same shape as `x`.

Raises
------
ValueError
    If `xp` and `fp` have different length
    If `xp` or `fp` are not 1-D sequences
    If `period == 0`

See Also
--------
scipy.interpolate

Warnings
--------
The x-coordinate sequence is expected to be increasing, but this is not
explicitly enforced.  However, if the sequence `xp` is non-increasing,
interpolation results are meaningless.

Note that, since NaN is unsortable, `xp` also cannot contain NaNs.

A simple check for `xp` being strictly increasing is::

    np.all(np.diff(xp) > 0)

Examples
--------
>>> xp = [1, 2, 3]
>>> fp = [3, 2, 0]
>>> np.interp(2.5, xp, fp)
1.0
>>> np.interp([0, 1, 1.5, 2.72, 3.14], xp, fp)
array([3.  , 3.  , 2.5 , 0.56, 0.  ])
>>> UNDEF = -99.0
>>> np.interp(3.14, xp, fp, right=UNDEF)
-99.0

Plot an interpolant to the sine function:

>>> x = np.linspace(0, 2*np.pi, 10)
>>> y = np.sin(x)
>>> xvals = np.linspace(0, 2*np.pi, 50)
>>> yinterp = np.interp(xvals, x, y)
>>> import matplotlib.pyplot as plt
>>> plt.plot(x, y, 'o')
[<matplotlib.lines.Line2D object at 0x...>]
>>> plt.plot(xvals, yinterp, '-x')
[<matplotlib.lines.Line2D object at 0x...>]
>>> plt.show()

Interpolation with periodic x-coordinates:

>>> x = [-180, -170, -185, 185, -10, -5, 0, 365]
>>> xp = [190, -190, 350, -350]
>>> fp = [5, 10, 3, 4]
>>> np.interp(x, xp, fp, period=360)
array([7.5 , 5.  , 8.75, 6.25, 3.  , 3.25, 3.5 , 3.75])

Complex interpolation:

>>> x = [1.5, 4.0]
>>> xp = [2,3,5]
>>> fp = [1.0j, 0, 2+3j]
>>> np.interp(x, xp, fp)
array([0.+1.j , 1.+1.5j])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l01462}{1462}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a531c572a52ebfaba6055e1d1b7c88ba2}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!iterable@{iterable}}
\index{iterable@{iterable}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{iterable()}{iterable()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a531c572a52ebfaba6055e1d1b7c88ba2} 
numpy.\+lib.\+function\+\_\+base.\+iterable (\begin{DoxyParamCaption}\item[{}]{y}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Check whether or not an object can be iterated over.

Parameters
----------
y : object
  Input object.

Returns
-------
b : bool
  Return ``True`` if the object has an iterator method or is a
  sequence and ``False`` otherwise.


Examples
--------
>>> np.iterable([1, 2, 3])
True
>>> np.iterable(2)
False

Notes
-----
In most cases, the results of ``np.iterable(obj)`` are consistent with
``isinstance(obj, collections.abc.Iterable)``. One notable exception is
the treatment of 0-dimensional arrays::

    >>> from collections.abc import Iterable
    >>> a = np.array(1.0)  # 0-dimensional numpy array
    >>> isinstance(a, Iterable)
    True
    >>> np.iterable(a)
    False
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l00349}{349}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a3c484a36cce93348651a5fe19e2ac5e8}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!kaiser@{kaiser}}
\index{kaiser@{kaiser}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{kaiser()}{kaiser()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a3c484a36cce93348651a5fe19e2ac5e8} 
numpy.\+lib.\+function\+\_\+base.\+kaiser (\begin{DoxyParamCaption}\item[{}]{M}{, }\item[{}]{beta}{}\end{DoxyParamCaption})}



End of cephes code for i0. 

\begin{DoxyVerb}Return the Kaiser window.

The Kaiser window is a taper formed by using a Bessel function.

Parameters
----------
M : int
    Number of points in the output window. If zero or less, an
    empty array is returned.
beta : float
    Shape parameter for window.

Returns
-------
out : array
    The window, with the maximum value normalized to one (the value
    one appears only if the number of samples is odd).

See Also
--------
bartlett, blackman, hamming, hanning

Notes
-----
The Kaiser window is defined as

.. math::  w(n) = I_0\\left( \\beta \\sqrt{1-\\frac{4n^2}{(M-1)^2}}
           \\right)/I_0(\\beta)

with

.. math:: \\quad -\\frac{M-1}{2} \\leq n \\leq \\frac{M-1}{2},

where :math:`I_0` is the modified zeroth-order Bessel function.

The Kaiser was named for Jim Kaiser, who discovered a simple
approximation to the DPSS window based on Bessel functions.  The Kaiser
window is a very good approximation to the Digital Prolate Spheroidal
Sequence, or Slepian window, which is the transform which maximizes the
energy in the main lobe of the window relative to total energy.

The Kaiser can approximate many other windows by varying the beta
parameter.

====  =======================
beta  Window shape
====  =======================
0     Rectangular
5     Similar to a Hamming
6     Similar to a Hanning
8.6   Similar to a Blackman
====  =======================

A beta value of 14 is probably a good starting point. Note that as beta
gets large, the window narrows, and so the number of samples needs to be
large enough to sample the increasingly narrow spike, otherwise NaNs will
get returned.

Most references to the Kaiser window come from the signal processing
literature, where it is used as one of many windowing functions for
smoothing values.  It is also known as an apodization (which means
"removing the foot", i.e. smoothing discontinuities at the beginning
and end of the sampled signal) or tapering function.

References
----------
.. [1] J. F. Kaiser, "Digital Filters" - Ch 7 in "Systems analysis by
       digital computer", Editors: F.F. Kuo and J.F. Kaiser, p 218-285.
       John Wiley and Sons, New York, (1966).
.. [2] E.R. Kanasewich, "Time Sequence Analysis in Geophysics", The
       University of Alberta Press, 1975, pp. 177-178.
.. [3] Wikipedia, "Window function",
       https://en.wikipedia.org/wiki/Window_function

Examples
--------
>>> import matplotlib.pyplot as plt
>>> np.kaiser(12, 14)
 array([7.72686684e-06, 3.46009194e-03, 4.65200189e-02, # may vary
        2.29737120e-01, 5.99885316e-01, 9.45674898e-01,
        9.45674898e-01, 5.99885316e-01, 2.29737120e-01,
        4.65200189e-02, 3.46009194e-03, 7.72686684e-06])


Plot the window and the frequency response:

>>> from numpy.fft import fft, fftshift
>>> window = np.kaiser(51, 14)
>>> plt.plot(window)
[<matplotlib.lines.Line2D object at 0x...>]
>>> plt.title("Kaiser window")
Text(0.5, 1.0, 'Kaiser window')
>>> plt.ylabel("Amplitude")
Text(0, 0.5, 'Amplitude')
>>> plt.xlabel("Sample")
Text(0.5, 0, 'Sample')
>>> plt.show()

>>> plt.figure()
<Figure size 640x480 with 0 Axes>
>>> A = fft(window, 2048) / 25.5
>>> mag = np.abs(fftshift(A))
>>> freq = np.linspace(-0.5, 0.5, len(A))
>>> response = 20 * np.log10(mag)
>>> response = np.clip(response, -100, 100)
>>> plt.plot(freq, response)
[<matplotlib.lines.Line2D object at 0x...>]
>>> plt.title("Frequency response of Kaiser window")
Text(0.5, 1.0, 'Frequency response of Kaiser window')
>>> plt.ylabel("Magnitude [dB]")
Text(0, 0.5, 'Magnitude [dB]')
>>> plt.xlabel("Normalized frequency [cycles per sample]")
Text(0.5, 0, 'Normalized frequency [cycles per sample]')
>>> plt.axis('tight')
(-0.5, 0.5, -100.0, ...) # may vary
>>> plt.show()
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l03493}{3493}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.



References \mbox{\hyperlink{lib_2function__base_8py_source_l03431}{i0()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a862b8d45a444babe7129725541b2e8bb}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!median@{median}}
\index{median@{median}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{median()}{median()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a862b8d45a444babe7129725541b2e8bb} 
numpy.\+lib.\+function\+\_\+base.\+median (\begin{DoxyParamCaption}\item[{}]{a}{, }\item[{}]{axis}{ = {\ttfamily None}, }\item[{}]{out}{ = {\ttfamily None}, }\item[{}]{overwrite\+\_\+input}{ = {\ttfamily False}, }\item[{}]{keepdims}{ = {\ttfamily False}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute the median along the specified axis.

Returns the median of the array elements.

Parameters
----------
a : array_like
    Input array or object that can be converted to an array.
axis : {int, sequence of int, None}, optional
    Axis or axes along which the medians are computed. The default
    is to compute the median along a flattened version of the array.
    A sequence of axes is supported since version 1.9.0.
out : ndarray, optional
    Alternative output array in which to place the result. It must
    have the same shape and buffer length as the expected output,
    but the type (of the output) will be cast if necessary.
overwrite_input : bool, optional
   If True, then allow use of memory of input array `a` for
   calculations. The input array will be modified by the call to
   `median`. This will save memory when you do not need to preserve
   the contents of the input array. Treat the input as undefined,
   but it will probably be fully or partially sorted. Default is
   False. If `overwrite_input` is ``True`` and `a` is not already an
   `ndarray`, an error will be raised.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the original `arr`.

    .. versionadded:: 1.9.0

Returns
-------
median : ndarray
    A new array holding the result. If the input contains integers
    or floats smaller than ``float64``, then the output data-type is
    ``np.float64``.  Otherwise, the data-type of the output is the
    same as that of the input. If `out` is specified, that array is
    returned instead.

See Also
--------
mean, percentile

Notes
-----
Given a vector ``V`` of length ``N``, the median of ``V`` is the
middle value of a sorted copy of ``V``, ``V_sorted`` - i
e., ``V_sorted[(N-1)/2]``, when ``N`` is odd, and the average of the
two middle values of ``V_sorted`` when ``N`` is even.

Examples
--------
>>> a = np.array([[10, 7, 4], [3, 2, 1]])
>>> a
array([[10,  7,  4],
       [ 3,  2,  1]])
>>> np.median(a)
3.5
>>> np.median(a, axis=0)
array([6.5, 4.5, 2.5])
>>> np.median(a, axis=1)
array([7.,  2.])
>>> m = np.median(a, axis=0)
>>> out = np.zeros_like(m)
>>> np.median(a, axis=0, out=m)
array([6.5,  4.5,  2.5])
>>> m
array([6.5,  4.5,  2.5])
>>> b = a.copy()
>>> np.median(b, axis=1, overwrite_input=True)
array([7.,  2.])
>>> assert not np.all(a==b)
>>> b = a.copy()
>>> np.median(b, axis=None, overwrite_input=True)
3.5
>>> assert not np.all(a==b)
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l03846}{3846}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.



References \mbox{\hyperlink{lib_2function__base_8py_source_l03763}{\+\_\+ureduce()}}, \mbox{\hyperlink{core_2fromnumeric_8py_source_l03387}{numpy.\+core.\+fromnumeric.\+mean()}}, and \mbox{\hyperlink{core_2fromnumeric_8py_source_l00663}{numpy.\+core.\+fromnumeric.\+partition()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a6d88bc97622504e8818d631de5e3e3b9}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!meshgrid@{meshgrid}}
\index{meshgrid@{meshgrid}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{meshgrid()}{meshgrid()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a6d88bc97622504e8818d631de5e3e3b9} 
numpy.\+lib.\+function\+\_\+base.\+meshgrid (\begin{DoxyParamCaption}\item[{\texorpdfstring{$\ast$}{*}}]{xi}{, }\item[{}]{copy}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}, }\item[{}]{sparse}{ = {\ttfamily False}, }\item[{}]{indexing}{ = {\ttfamily \textquotesingle{}xy\textquotesingle{}}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Return a list of coordinate matrices from coordinate vectors.

Make N-D coordinate arrays for vectorized evaluations of
N-D scalar/vector fields over N-D grids, given
one-dimensional coordinate arrays x1, x2,..., xn.

.. versionchanged:: 1.9
   1-D and 0-D cases are allowed.

Parameters
----------
x1, x2,..., xn : array_like
    1-D arrays representing the coordinates of a grid.
indexing : {'xy', 'ij'}, optional
    Cartesian ('xy', default) or matrix ('ij') indexing of output.
    See Notes for more details.

    .. versionadded:: 1.7.0
sparse : bool, optional
    If True the shape of the returned coordinate array for dimension *i*
    is reduced from ``(N1, ..., Ni, ... Nn)`` to
    ``(1, ..., 1, Ni, 1, ..., 1)``.  These sparse coordinate grids are
    intended to be use with :ref:`basics.broadcasting`.  When all
    coordinates are used in an expression, broadcasting still leads to a
    fully-dimensonal result array.

    Default is False.

    .. versionadded:: 1.7.0
copy : bool, optional
    If False, a view into the original arrays are returned in order to
    conserve memory.  Default is True.  Please note that
    ``sparse=False, copy=False`` will likely return non-contiguous
    arrays.  Furthermore, more than one element of a broadcast array
    may refer to a single memory location.  If you need to write to the
    arrays, make copies first.

    .. versionadded:: 1.7.0

Returns
-------
X1, X2,..., XN : list of ndarrays
    For vectors `x1`, `x2`,..., `xn` with lengths ``Ni=len(xi)``,
    returns ``(N1, N2, N3,..., Nn)`` shaped arrays if indexing='ij'
    or ``(N2, N1, N3,..., Nn)`` shaped arrays if indexing='xy'
    with the elements of `xi` repeated to fill the matrix along
    the first dimension for `x1`, the second for `x2` and so on.

Notes
-----
This function supports both indexing conventions through the indexing
keyword argument.  Giving the string 'ij' returns a meshgrid with
matrix indexing, while 'xy' returns a meshgrid with Cartesian indexing.
In the 2-D case with inputs of length M and N, the outputs are of shape
(N, M) for 'xy' indexing and (M, N) for 'ij' indexing.  In the 3-D case
with inputs of length M, N and P, outputs are of shape (N, M, P) for
'xy' indexing and (M, N, P) for 'ij' indexing.  The difference is
illustrated by the following code snippet::

    xv, yv = np.meshgrid(x, y, indexing='ij')
    for i in range(nx):
        for j in range(ny):
            # treat xv[i,j], yv[i,j]

    xv, yv = np.meshgrid(x, y, indexing='xy')
    for i in range(nx):
        for j in range(ny):
            # treat xv[j,i], yv[j,i]

In the 1-D and 0-D case, the indexing and sparse keywords have no effect.

See Also
--------
mgrid : Construct a multi-dimensional "meshgrid" using indexing notation.
ogrid : Construct an open multi-dimensional "meshgrid" using indexing
        notation.
how-to-index

Examples
--------
>>> nx, ny = (3, 2)
>>> x = np.linspace(0, 1, nx)
>>> y = np.linspace(0, 1, ny)
>>> xv, yv = np.meshgrid(x, y)
>>> xv
array([[0. , 0.5, 1. ],
       [0. , 0.5, 1. ]])
>>> yv
array([[0.,  0.,  0.],
       [1.,  1.,  1.]])

The result of `meshgrid` is a coordinate grid:

>>> import matplotlib.pyplot as plt
>>> plt.plot(xv, yv, marker='o', color='k', linestyle='none')
>>> plt.show()

You can create sparse output arrays to save memory and computation time.

>>> xv, yv = np.meshgrid(x, y, sparse=True)
>>> xv
array([[0. ,  0.5,  1. ]])
>>> yv
array([[0.],
       [1.]])

`meshgrid` is very useful to evaluate functions on a grid. If the
function depends on all coordinates, both dense and sparse outputs can be
used.

>>> x = np.linspace(-5, 5, 101)
>>> y = np.linspace(-5, 5, 101)
>>> # full coordinate arrays
>>> xx, yy = np.meshgrid(x, y)
>>> zz = np.sqrt(xx**2 + yy**2)
>>> xx.shape, yy.shape, zz.shape
((101, 101), (101, 101), (101, 101))
>>> # sparse coordinate arrays
>>> xs, ys = np.meshgrid(x, y, sparse=True)
>>> zs = np.sqrt(xs**2 + ys**2)
>>> xs.shape, ys.shape, zs.shape
((1, 101), (101, 1), (101, 101))
>>> np.array_equal(zz, zs)
True

>>> h = plt.contourf(x, y, zs)
>>> plt.axis('scaled')
>>> plt.colorbar()
>>> plt.show()
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l05012}{5012}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.



References \mbox{\hyperlink{core_2fromnumeric_8py_source_l00201}{numpy.\+core.\+fromnumeric.\+reshape()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a95c594f2c56716496924f9606f7751cd}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!msort@{msort}}
\index{msort@{msort}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{msort()}{msort()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a95c594f2c56716496924f9606f7751cd} 
numpy.\+lib.\+function\+\_\+base.\+msort (\begin{DoxyParamCaption}\item[{}]{a}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Return a copy of an array sorted along the first axis.

.. deprecated:: 1.24

   msort is deprecated, use ``np.sort(a, axis=0)`` instead.

Parameters
----------
a : array_like
    Array to be sorted.

Returns
-------
sorted_array : ndarray
    Array of the same type and shape as `a`.

See Also
--------
sort

Notes
-----
``np.msort(a)`` is equivalent to  ``np.sort(a, axis=0)``.

Examples
--------
>>> a = np.array([[1, 4], [3, 1]])
>>> np.msort(a)  # sort along the first axis
array([[1, 1],
       [3, 4]])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l03718}{3718}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_ac3ae5ac7471a713865dd2dc26700da81}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!percentile@{percentile}}
\index{percentile@{percentile}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{percentile()}{percentile()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_ac3ae5ac7471a713865dd2dc26700da81} 
numpy.\+lib.\+function\+\_\+base.\+percentile (\begin{DoxyParamCaption}\item[{}]{a}{, }\item[{}]{q}{, }\item[{}]{axis}{ = {\ttfamily None}, }\item[{}]{out}{ = {\ttfamily None}, }\item[{}]{overwrite\+\_\+input}{ = {\ttfamily False}, }\item[{}]{method}{ = {\ttfamily "{}linear"{}}, }\item[{}]{keepdims}{ = {\ttfamily False}, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{interpolation}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute the q-th percentile of the data along the specified axis.

Returns the q-th percentile(s) of the array elements.

Parameters
----------
a : array_like of real numbers
    Input array or object that can be converted to an array.
q : array_like of float
    Percentage or sequence of percentages for the percentiles to compute.
    Values must be between 0 and 100 inclusive.
axis : {int, tuple of int, None}, optional
    Axis or axes along which the percentiles are computed. The
    default is to compute the percentile(s) along a flattened
    version of the array.

    .. versionchanged:: 1.9.0
        A tuple of axes is supported
out : ndarray, optional
    Alternative output array in which to place the result. It must
    have the same shape and buffer length as the expected output,
    but the type (of the output) will be cast if necessary.
overwrite_input : bool, optional
    If True, then allow the input array `a` to be modified by intermediate
    calculations, to save memory. In this case, the contents of the input
    `a` after this function completes is undefined.
method : str, optional
    This parameter specifies the method to use for estimating the
    percentile.  There are many different methods, some unique to NumPy.
    See the notes for explanation.  The options sorted by their R type
    as summarized in the H&F paper [1]_ are:

    1. 'inverted_cdf'
    2. 'averaged_inverted_cdf'
    3. 'closest_observation'
    4. 'interpolated_inverted_cdf'
    5. 'hazen'
    6. 'weibull'
    7. 'linear'  (default)
    8. 'median_unbiased'
    9. 'normal_unbiased'

    The first three methods are discontinuous.  NumPy further defines the
    following discontinuous variations of the default 'linear' (7.) option:

    * 'lower'
    * 'higher',
    * 'midpoint'
    * 'nearest'

    .. versionchanged:: 1.22.0
        This argument was previously called "interpolation" and only
        offered the "linear" default and last four options.

keepdims : bool, optional
    If this is set to True, the axes which are reduced are left in
    the result as dimensions with size one. With this option, the
    result will broadcast correctly against the original array `a`.

    .. versionadded:: 1.9.0

interpolation : str, optional
    Deprecated name for the method keyword argument.

    .. deprecated:: 1.22.0

Returns
-------
percentile : scalar or ndarray
    If `q` is a single percentile and `axis=None`, then the result
    is a scalar. If multiple percentiles are given, first axis of
    the result corresponds to the percentiles. The other axes are
    the axes that remain after the reduction of `a`. If the input
    contains integers or floats smaller than ``float64``, the output
    data-type is ``float64``. Otherwise, the output data-type is the
    same as that of the input. If `out` is specified, that array is
    returned instead.

See Also
--------
mean
median : equivalent to ``percentile(..., 50)``
nanpercentile
quantile : equivalent to percentile, except q in the range [0, 1].

Notes
-----
Given a vector ``V`` of length ``n``, the q-th percentile of ``V`` is
the value ``q/100`` of the way from the minimum to the maximum in a
sorted copy of ``V``. The values and distances of the two nearest
neighbors as well as the `method` parameter will determine the
percentile if the normalized ranking does not match the location of
``q`` exactly. This function is the same as the median if ``q=50``, the
same as the minimum if ``q=0`` and the same as the maximum if
``q=100``.

The optional `method` parameter specifies the method to use when the
desired percentile lies between two indexes ``i`` and ``j = i + 1``.
In that case, we first determine ``i + g``, a virtual index that lies
between ``i`` and ``j``, where  ``i`` is the floor and ``g`` is the
fractional part of the index. The final result is, then, an interpolation
of ``a[i]`` and ``a[j]`` based on ``g``. During the computation of ``g``,
``i`` and ``j`` are modified using correction constants ``alpha`` and
``beta`` whose choices depend on the ``method`` used. Finally, note that
since Python uses 0-based indexing, the code subtracts another 1 from the
index internally.

The following formula determines the virtual index ``i + g``, the location
of the percentile in the sorted sample:

.. math::
    i + g = (q / 100) * ( n - alpha - beta + 1 ) + alpha

The different methods then work as follows

inverted_cdf:
    method 1 of H&F [1]_.
    This method gives discontinuous results:

    * if g > 0 ; then take j
    * if g = 0 ; then take i

averaged_inverted_cdf:
    method 2 of H&F [1]_.
    This method give discontinuous results:

    * if g > 0 ; then take j
    * if g = 0 ; then average between bounds

closest_observation:
    method 3 of H&F [1]_.
    This method give discontinuous results:

    * if g > 0 ; then take j
    * if g = 0 and index is odd ; then take j
    * if g = 0 and index is even ; then take i

interpolated_inverted_cdf:
    method 4 of H&F [1]_.
    This method give continuous results using:

    * alpha = 0
    * beta = 1

hazen:
    method 5 of H&F [1]_.
    This method give continuous results using:

    * alpha = 1/2
    * beta = 1/2

weibull:
    method 6 of H&F [1]_.
    This method give continuous results using:

    * alpha = 0
    * beta = 0

linear:
    method 7 of H&F [1]_.
    This method give continuous results using:

    * alpha = 1
    * beta = 1

median_unbiased:
    method 8 of H&F [1]_.
    This method is probably the best method if the sample
    distribution function is unknown (see reference).
    This method give continuous results using:

    * alpha = 1/3
    * beta = 1/3

normal_unbiased:
    method 9 of H&F [1]_.
    This method is probably the best method if the sample
    distribution function is known to be normal.
    This method give continuous results using:

    * alpha = 3/8
    * beta = 3/8

lower:
    NumPy method kept for backwards compatibility.
    Takes ``i`` as the interpolation point.

higher:
    NumPy method kept for backwards compatibility.
    Takes ``j`` as the interpolation point.

nearest:
    NumPy method kept for backwards compatibility.
    Takes ``i`` or ``j``, whichever is nearest.

midpoint:
    NumPy method kept for backwards compatibility.
    Uses ``(i + j) / 2``.

Examples
--------
>>> a = np.array([[10, 7, 4], [3, 2, 1]])
>>> a
array([[10,  7,  4],
       [ 3,  2,  1]])
>>> np.percentile(a, 50)
3.5
>>> np.percentile(a, 50, axis=0)
array([6.5, 4.5, 2.5])
>>> np.percentile(a, 50, axis=1)
array([7.,  2.])
>>> np.percentile(a, 50, axis=1, keepdims=True)
array([[7.],
       [2.]])

>>> m = np.percentile(a, 50, axis=0)
>>> out = np.zeros_like(m)
>>> np.percentile(a, 50, axis=0, out=out)
array([6.5, 4.5, 2.5])
>>> m
array([6.5, 4.5, 2.5])

>>> b = a.copy()
>>> np.percentile(b, 50, axis=1, overwrite_input=True)
array([7.,  2.])
>>> assert not np.all(a == b)

The different methods can be visualized graphically:

.. plot::

    import matplotlib.pyplot as plt

    a = np.arange(4)
    p = np.linspace(0, 100, 6001)
    ax = plt.gca()
    lines = [
        ('linear', '-', 'C0'),
        ('inverted_cdf', ':', 'C1'),
        # Almost the same as `inverted_cdf`:
        ('averaged_inverted_cdf', '-.', 'C1'),
        ('closest_observation', ':', 'C2'),
        ('interpolated_inverted_cdf', '--', 'C1'),
        ('hazen', '--', 'C3'),
        ('weibull', '-.', 'C4'),
        ('median_unbiased', '--', 'C5'),
        ('normal_unbiased', '-.', 'C6'),
        ]
    for method, style, color in lines:
        ax.plot(
            p, np.percentile(a, p, method=method),
            label=method, linestyle=style, color=color)
    ax.set(
        title='Percentiles for different methods and data: ' + str(a),
        xlabel='Percentile',
        ylabel='Estimated percentile value',
        yticks=a)
    ax.legend(bbox_to_anchor=(1.03, 1))
    plt.tight_layout()
    plt.show()

References
----------
.. [1] R. J. Hyndman and Y. Fan,
   "Sample quantiles in statistical packages,"
   The American Statistician, 50(4), pp. 361-365, 1996
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l03993}{3993}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.



References \mbox{\hyperlink{lib_2function__base_8py_source_l04553}{\+\_\+quantile\+\_\+unchecked()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a1cd513d50354ad3bf31cdf9a39773dbf}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!piecewise@{piecewise}}
\index{piecewise@{piecewise}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{piecewise()}{piecewise()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a1cd513d50354ad3bf31cdf9a39773dbf} 
numpy.\+lib.\+function\+\_\+base.\+piecewise (\begin{DoxyParamCaption}\item[{}]{x}{, }\item[{}]{condlist}{, }\item[{}]{funclist}{, }\item[{\texorpdfstring{$\ast$}{*}}]{args}{, }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{kw}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Evaluate a piecewise-defined function.

Given a set of conditions and corresponding functions, evaluate each
function on the input data wherever its condition is true.

Parameters
----------
x : ndarray or scalar
    The input domain.
condlist : list of bool arrays or bool scalars
    Each boolean array corresponds to a function in `funclist`.  Wherever
    `condlist[i]` is True, `funclist[i](x)` is used as the output value.

    Each boolean array in `condlist` selects a piece of `x`,
    and should therefore be of the same shape as `x`.

    The length of `condlist` must correspond to that of `funclist`.
    If one extra function is given, i.e. if
    ``len(funclist) == len(condlist) + 1``, then that extra function
    is the default value, used wherever all conditions are false.
funclist : list of callables, f(x,*args,**kw), or scalars
    Each function is evaluated over `x` wherever its corresponding
    condition is True.  It should take a 1d array as input and give an 1d
    array or a scalar value as output.  If, instead of a callable,
    a scalar is provided then a constant function (``lambda x: scalar``) is
    assumed.
args : tuple, optional
    Any further arguments given to `piecewise` are passed to the functions
    upon execution, i.e., if called ``piecewise(..., ..., 1, 'a')``, then
    each function is called as ``f(x, 1, 'a')``.
kw : dict, optional
    Keyword arguments used in calling `piecewise` are passed to the
    functions upon execution, i.e., if called
    ``piecewise(..., ..., alpha=1)``, then each function is called as
    ``f(x, alpha=1)``.

Returns
-------
out : ndarray
    The output is the same shape and type as x and is found by
    calling the functions in `funclist` on the appropriate portions of `x`,
    as defined by the boolean arrays in `condlist`.  Portions not covered
    by any condition have a default value of 0.


See Also
--------
choose, select, where

Notes
-----
This is similar to choose or select, except that functions are
evaluated on elements of `x` that satisfy the corresponding condition from
`condlist`.

The result is::

        |--
        |funclist[0](x[condlist[0]])
  out = |funclist[1](x[condlist[1]])
        |...
        |funclist[n2](x[condlist[n2]])
        |--

Examples
--------
Define the sigma function, which is -1 for ``x < 0`` and +1 for ``x >= 0``.

>>> x = np.linspace(-2.5, 2.5, 6)
>>> np.piecewise(x, [x < 0, x >= 0], [-1, 1])
array([-1., -1., -1.,  1.,  1.,  1.])

Define the absolute value, which is ``-x`` for ``x <0`` and ``x`` for
``x >= 0``.

>>> np.piecewise(x, [x < 0, x >= 0], [lambda x: -x, lambda x: x])
array([2.5,  1.5,  0.5,  0.5,  1.5,  2.5])

Apply the same function to a scalar value.

>>> y = -2
>>> np.piecewise(y, [y < 0, y >= 0], [lambda x: -x, lambda x: x])
array(2)
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l00643}{643}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.



References \mbox{\hyperlink{numpy_2core_2numeric_8py_source_l01856}{numpy.\+core.\+numeric.\+isscalar()}}, and \mbox{\hyperlink{numpy_2core_2numeric_8py_source_l00068}{numpy.\+core.\+numeric.\+zeros\+\_\+like()}}.



Referenced by \mbox{\hyperlink{lib_2function__base_8py_source_l03431}{i0()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_ae4e851f1e69da703565e781dc75ba601}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!place@{place}}
\index{place@{place}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{place()}{place()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_ae4e851f1e69da703565e781dc75ba601} 
numpy.\+lib.\+function\+\_\+base.\+place (\begin{DoxyParamCaption}\item[{}]{arr}{, }\item[{}]{mask}{, }\item[{}]{vals}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Change elements of an array based on conditional and input values.

Similar to ``np.copyto(arr, vals, where=mask)``, the difference is that
`place` uses the first N elements of `vals`, where N is the number of
True values in `mask`, while `copyto` uses the elements where `mask`
is True.

Note that `extract` does the exact opposite of `place`.

Parameters
----------
arr : ndarray
    Array to put data into.
mask : array_like
    Boolean mask array. Must have the same size as `a`.
vals : 1-D sequence
    Values to put into `a`. Only the first N elements are used, where
    N is the number of True values in `mask`. If `vals` is smaller
    than N, it will be repeated, and if elements of `a` are to be masked,
    this sequence must be non-empty.

See Also
--------
copyto, put, take, extract

Examples
--------
>>> arr = np.arange(6).reshape(2, 3)
>>> np.place(arr, arr>2, [44, 55])
>>> arr
array([[ 0,  1,  2],
       [44, 55, 44]])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l01918}{1918}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_ac6d144dd2bec66f30d731e55572eeda4}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!quantile@{quantile}}
\index{quantile@{quantile}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{quantile()}{quantile()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_ac6d144dd2bec66f30d731e55572eeda4} 
numpy.\+lib.\+function\+\_\+base.\+quantile (\begin{DoxyParamCaption}\item[{}]{a}{, }\item[{}]{q}{, }\item[{}]{axis}{ = {\ttfamily None}, }\item[{}]{out}{ = {\ttfamily None}, }\item[{}]{overwrite\+\_\+input}{ = {\ttfamily False}, }\item[{}]{method}{ = {\ttfamily "{}linear"{}}, }\item[{}]{keepdims}{ = {\ttfamily False}, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{interpolation}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute the q-th quantile of the data along the specified axis.

.. versionadded:: 1.15.0

Parameters
----------
a : array_like of real numbers
    Input array or object that can be converted to an array.
q : array_like of float
    Probability or sequence of probabilities for the quantiles to compute.
    Values must be between 0 and 1 inclusive.
axis : {int, tuple of int, None}, optional
    Axis or axes along which the quantiles are computed. The default is
    to compute the quantile(s) along a flattened version of the array.
out : ndarray, optional
    Alternative output array in which to place the result. It must have
    the same shape and buffer length as the expected output, but the
    type (of the output) will be cast if necessary.
overwrite_input : bool, optional
    If True, then allow the input array `a` to be modified by
    intermediate calculations, to save memory. In this case, the
    contents of the input `a` after this function completes is
    undefined.
method : str, optional
    This parameter specifies the method to use for estimating the
    quantile.  There are many different methods, some unique to NumPy.
    See the notes for explanation.  The options sorted by their R type
    as summarized in the H&F paper [1]_ are:

    1. 'inverted_cdf'
    2. 'averaged_inverted_cdf'
    3. 'closest_observation'
    4. 'interpolated_inverted_cdf'
    5. 'hazen'
    6. 'weibull'
    7. 'linear'  (default)
    8. 'median_unbiased'
    9. 'normal_unbiased'

    The first three methods are discontinuous.  NumPy further defines the
    following discontinuous variations of the default 'linear' (7.) option:

    * 'lower'
    * 'higher',
    * 'midpoint'
    * 'nearest'

    .. versionchanged:: 1.22.0
        This argument was previously called "interpolation" and only
        offered the "linear" default and last four options.

keepdims : bool, optional
    If this is set to True, the axes which are reduced are left in
    the result as dimensions with size one. With this option, the
    result will broadcast correctly against the original array `a`.

interpolation : str, optional
    Deprecated name for the method keyword argument.

    .. deprecated:: 1.22.0

Returns
-------
quantile : scalar or ndarray
    If `q` is a single probability and `axis=None`, then the result
    is a scalar. If multiple probabilies levels are given, first axis of
    the result corresponds to the quantiles. The other axes are
    the axes that remain after the reduction of `a`. If the input
    contains integers or floats smaller than ``float64``, the output
    data-type is ``float64``. Otherwise, the output data-type is the
    same as that of the input. If `out` is specified, that array is
    returned instead.

See Also
--------
mean
percentile : equivalent to quantile, but with q in the range [0, 100].
median : equivalent to ``quantile(..., 0.5)``
nanquantile

Notes
-----
Given a vector ``V`` of length ``n``, the q-th quantile of ``V`` is
the value ``q`` of the way from the minimum to the maximum in a
sorted copy of ``V``. The values and distances of the two nearest
neighbors as well as the `method` parameter will determine the
quantile if the normalized ranking does not match the location of
``q`` exactly. This function is the same as the median if ``q=0.5``, the
same as the minimum if ``q=0.0`` and the same as the maximum if
``q=1.0``.

The optional `method` parameter specifies the method to use when the
desired quantile lies between two indexes ``i`` and ``j = i + 1``.
In that case, we first determine ``i + g``, a virtual index that lies
between ``i`` and ``j``, where  ``i`` is the floor and ``g`` is the
fractional part of the index. The final result is, then, an interpolation
of ``a[i]`` and ``a[j]`` based on ``g``. During the computation of ``g``,
``i`` and ``j`` are modified using correction constants ``alpha`` and
``beta`` whose choices depend on the ``method`` used. Finally, note that
since Python uses 0-based indexing, the code subtracts another 1 from the
index internally.

The following formula determines the virtual index ``i + g``, the location
of the quantile in the sorted sample:

.. math::
    i + g = q * ( n - alpha - beta + 1 ) + alpha

The different methods then work as follows

inverted_cdf:
    method 1 of H&F [1]_.
    This method gives discontinuous results:

    * if g > 0 ; then take j
    * if g = 0 ; then take i

averaged_inverted_cdf:
    method 2 of H&F [1]_.
    This method gives discontinuous results:

    * if g > 0 ; then take j
    * if g = 0 ; then average between bounds

closest_observation:
    method 3 of H&F [1]_.
    This method gives discontinuous results:

    * if g > 0 ; then take j
    * if g = 0 and index is odd ; then take j
    * if g = 0 and index is even ; then take i

interpolated_inverted_cdf:
    method 4 of H&F [1]_.
    This method gives continuous results using:

    * alpha = 0
    * beta = 1

hazen:
    method 5 of H&F [1]_.
    This method gives continuous results using:

    * alpha = 1/2
    * beta = 1/2

weibull:
    method 6 of H&F [1]_.
    This method gives continuous results using:

    * alpha = 0
    * beta = 0

linear:
    method 7 of H&F [1]_.
    This method gives continuous results using:

    * alpha = 1
    * beta = 1

median_unbiased:
    method 8 of H&F [1]_.
    This method is probably the best method if the sample
    distribution function is unknown (see reference).
    This method gives continuous results using:

    * alpha = 1/3
    * beta = 1/3

normal_unbiased:
    method 9 of H&F [1]_.
    This method is probably the best method if the sample
    distribution function is known to be normal.
    This method gives continuous results using:

    * alpha = 3/8
    * beta = 3/8

lower:
    NumPy method kept for backwards compatibility.
    Takes ``i`` as the interpolation point.

higher:
    NumPy method kept for backwards compatibility.
    Takes ``j`` as the interpolation point.

nearest:
    NumPy method kept for backwards compatibility.
    Takes ``i`` or ``j``, whichever is nearest.

midpoint:
    NumPy method kept for backwards compatibility.
    Uses ``(i + j) / 2``.

Examples
--------
>>> a = np.array([[10, 7, 4], [3, 2, 1]])
>>> a
array([[10,  7,  4],
       [ 3,  2,  1]])
>>> np.quantile(a, 0.5)
3.5
>>> np.quantile(a, 0.5, axis=0)
array([6.5, 4.5, 2.5])
>>> np.quantile(a, 0.5, axis=1)
array([7.,  2.])
>>> np.quantile(a, 0.5, axis=1, keepdims=True)
array([[7.],
       [2.]])
>>> m = np.quantile(a, 0.5, axis=0)
>>> out = np.zeros_like(m)
>>> np.quantile(a, 0.5, axis=0, out=out)
array([6.5, 4.5, 2.5])
>>> m
array([6.5, 4.5, 2.5])
>>> b = a.copy()
>>> np.quantile(b, 0.5, axis=1, overwrite_input=True)
array([7.,  2.])
>>> assert not np.all(a == b)

See also `numpy.percentile` for a visualization of most methods.

References
----------
.. [1] R. J. Hyndman and Y. Fan,
   "Sample quantiles in statistical packages,"
   The American Statistician, 50(4), pp. 361-365, 1996
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l04293}{4293}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.



References \mbox{\hyperlink{lib_2function__base_8py_source_l04553}{\+\_\+quantile\+\_\+unchecked()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a5374f6a2d928557250c44f626ee930ba}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!rot90@{rot90}}
\index{rot90@{rot90}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{rot90()}{rot90()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a5374f6a2d928557250c44f626ee930ba} 
numpy.\+lib.\+function\+\_\+base.\+rot90 (\begin{DoxyParamCaption}\item[{}]{m}{, }\item[{}]{k}{ = {\ttfamily 1}, }\item[{}]{axes}{ = {\ttfamily (0,~1)}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Rotate an array by 90 degrees in the plane specified by axes.

Rotation direction is from the first towards the second axis.
This means for a 2D array with the default `k` and `axes`, the
rotation will be counterclockwise.

Parameters
----------
m : array_like
    Array of two or more dimensions.
k : integer
    Number of times the array is rotated by 90 degrees.
axes : (2,) array_like
    The array is rotated in the plane defined by the axes.
    Axes must be different.

    .. versionadded:: 1.12.0

Returns
-------
y : ndarray
    A rotated view of `m`.

See Also
--------
flip : Reverse the order of elements in an array along the given axis.
fliplr : Flip an array horizontally.
flipud : Flip an array vertically.

Notes
-----
``rot90(m, k=1, axes=(1,0))``  is the reverse of
``rot90(m, k=1, axes=(0,1))``

``rot90(m, k=1, axes=(1,0))`` is equivalent to
``rot90(m, k=-1, axes=(0,1))``

Examples
--------
>>> m = np.array([[1,2],[3,4]], int)
>>> m
array([[1, 2],
       [3, 4]])
>>> np.rot90(m)
array([[2, 4],
       [1, 3]])
>>> np.rot90(m, 2)
array([[4, 3],
       [2, 1]])
>>> m = np.arange(8).reshape((2,2,2))
>>> np.rot90(m, 1, (1,2))
array([[[1, 3],
        [0, 2]],
       [[5, 7],
        [4, 6]]])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l00159}{159}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.



References \mbox{\hyperlink{lib_2function__base_8py_source_l00255}{flip()}}, and \mbox{\hyperlink{core_2fromnumeric_8py_source_l00589}{numpy.\+core.\+fromnumeric.\+transpose()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a5593cdafb52222befa97feaabb012c44}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!select@{select}}
\index{select@{select}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{select()}{select()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a5593cdafb52222befa97feaabb012c44} 
numpy.\+lib.\+function\+\_\+base.\+select (\begin{DoxyParamCaption}\item[{}]{condlist}{, }\item[{}]{choicelist}{, }\item[{}]{default}{ = {\ttfamily 0}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Return an array drawn from elements in choicelist, depending on conditions.

Parameters
----------
condlist : list of bool ndarrays
    The list of conditions which determine from which array in `choicelist`
    the output elements are taken. When multiple conditions are satisfied,
    the first one encountered in `condlist` is used.
choicelist : list of ndarrays
    The list of arrays from which the output elements are taken. It has
    to be of the same length as `condlist`.
default : scalar, optional
    The element inserted in `output` when all conditions evaluate to False.

Returns
-------
output : ndarray
    The output at position m is the m-th element of the array in
    `choicelist` where the m-th element of the corresponding array in
    `condlist` is True.

See Also
--------
where : Return elements from one of two arrays depending on condition.
take, choose, compress, diag, diagonal

Examples
--------
>>> x = np.arange(6)
>>> condlist = [x<3, x>3]
>>> choicelist = [x, x**2]
>>> np.select(condlist, choicelist, 42)
array([ 0,  1,  2, 42, 16, 25])

>>> condlist = [x<=4, x>3]
>>> choicelist = [x, x**2]
>>> np.select(condlist, choicelist, 55)
array([ 0,  1,  2,  3,  4, 25])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l00769}{769}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a1037c45a8411f2e3cd9dcf9a9ed7c75c}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!sinc@{sinc}}
\index{sinc@{sinc}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{sinc()}{sinc()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a1037c45a8411f2e3cd9dcf9a9ed7c75c} 
numpy.\+lib.\+function\+\_\+base.\+sinc (\begin{DoxyParamCaption}\item[{}]{x}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the normalized sinc function.

The sinc function is equal to :math:`\sin(\pi x)/(\pi x)` for any argument
:math:`x\ne 0`. ``sinc(0)`` takes the limit value 1, making ``sinc`` not
only everywhere continuous but also infinitely differentiable.

.. note::

    Note the normalization factor of ``pi`` used in the definition.
    This is the most commonly used definition in signal processing.
    Use ``sinc(x / np.pi)`` to obtain the unnormalized sinc function
    :math:`\sin(x)/x` that is more common in mathematics.

Parameters
----------
x : ndarray
    Array (possibly multi-dimensional) of values for which to calculate
    ``sinc(x)``.

Returns
-------
out : ndarray
    ``sinc(x)``, which has the same shape as the input.

Notes
-----
The name sinc is short for "sine cardinal" or "sinus cardinalis".

The sinc function is used in various signal processing applications,
including in anti-aliasing, in the construction of a Lanczos resampling
filter, and in interpolation.

For bandlimited interpolation of discrete-time signals, the ideal
interpolation kernel is proportional to the sinc function.

References
----------
.. [1] Weisstein, Eric W. "Sinc Function." From MathWorld--A Wolfram Web
       Resource. http://mathworld.wolfram.com/SincFunction.html
.. [2] Wikipedia, "Sinc function",
       https://en.wikipedia.org/wiki/Sinc_function

Examples
--------
>>> import matplotlib.pyplot as plt
>>> x = np.linspace(-4, 4, 41)
>>> np.sinc(x)
 array([-3.89804309e-17,  -4.92362781e-02,  -8.40918587e-02, # may vary
        -8.90384387e-02,  -5.84680802e-02,   3.89804309e-17,
        6.68206631e-02,   1.16434881e-01,   1.26137788e-01,
        8.50444803e-02,  -3.89804309e-17,  -1.03943254e-01,
        -1.89206682e-01,  -2.16236208e-01,  -1.55914881e-01,
        3.89804309e-17,   2.33872321e-01,   5.04551152e-01,
        7.56826729e-01,   9.35489284e-01,   1.00000000e+00,
        9.35489284e-01,   7.56826729e-01,   5.04551152e-01,
        2.33872321e-01,   3.89804309e-17,  -1.55914881e-01,
       -2.16236208e-01,  -1.89206682e-01,  -1.03943254e-01,
       -3.89804309e-17,   8.50444803e-02,   1.26137788e-01,
        1.16434881e-01,   6.68206631e-02,   3.89804309e-17,
        -5.84680802e-02,  -8.90384387e-02,  -8.40918587e-02,
        -4.92362781e-02,  -3.89804309e-17])

>>> plt.plot(x, np.sinc(x))
[<matplotlib.lines.Line2D object at 0x...>]
>>> plt.title("Sinc Function")
Text(0.5, 1.0, 'Sinc Function')
>>> plt.ylabel("Amplitude")
Text(0, 0.5, 'Amplitude')
>>> plt.xlabel("X")
Text(0.5, 0, 'X')
>>> plt.show()
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l03633}{3633}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a12184eaf5717d61a52570d93c2dfc98f}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!sort\_complex@{sort\_complex}}
\index{sort\_complex@{sort\_complex}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{sort\_complex()}{sort\_complex()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a12184eaf5717d61a52570d93c2dfc98f} 
numpy.\+lib.\+function\+\_\+base.\+sort\+\_\+complex (\begin{DoxyParamCaption}\item[{}]{a}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Sort a complex array using the real part first, then the imaginary part.

Parameters
----------
a : array_like
    Input array

Returns
-------
out : complex ndarray
    Always returns a sorted complex array.

Examples
--------
>>> np.sort_complex([5, 3, 6, 2, 1])
array([1.+0.j, 2.+0.j, 3.+0.j, 5.+0.j, 6.+0.j])

>>> np.sort_complex([1 + 2j, 2 - 1j, 3 - 2j, 3 - 3j, 3 + 5j])
array([1.+2.j,  2.-1.j,  3.-3.j,  3.-2.j,  3.+5.j])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l01764}{1764}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a78a1f30ec367d053bf4eee0cf62e3007}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!trapz@{trapz}}
\index{trapz@{trapz}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{trapz()}{trapz()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a78a1f30ec367d053bf4eee0cf62e3007} 
numpy.\+lib.\+function\+\_\+base.\+trapz (\begin{DoxyParamCaption}\item[{}]{y}{, }\item[{}]{x}{ = {\ttfamily None}, }\item[{}]{dx}{ = {\ttfamily 1.0}, }\item[{}]{axis}{ = {\ttfamily -\/1}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Integrate along the given axis using the composite trapezoidal rule.

If `x` is provided, the integration happens in sequence along its
elements - they are not sorted.

Integrate `y` (`x`) along each 1d slice on the given axis, compute
:math:`\int y(x) dx`.
When `x` is specified, this integrates along the parametric curve,
computing :math:`\int_t y(t) dt =
\int_t y(t) \left.\frac{dx}{dt}\right|_{x=x(t)} dt`.

Parameters
----------
y : array_like
Input array to integrate.
x : array_like, optional
The sample points corresponding to the `y` values. If `x` is None,
the sample points are assumed to be evenly spaced `dx` apart. The
default is None.
dx : scalar, optional
The spacing between sample points when `x` is None. The default is 1.
axis : int, optional
The axis along which to integrate.

Returns
-------
trapz : float or ndarray
Definite integral of `y` = n-dimensional array as approximated along
a single axis by the trapezoidal rule. If `y` is a 1-dimensional array,
then the result is a float. If `n` is greater than 1, then the result
is an `n`-1 dimensional array.

See Also
--------
sum, cumsum

Notes
-----
Image [2]_ illustrates trapezoidal rule -- y-axis locations of points
will be taken from `y` array, by default x-axis distances between
points will be 1.0, alternatively they can be provided with `x` array
or with `dx` scalar.  Return value will be equal to combined area under
the red lines.


References
----------
.. [1] Wikipedia page: https://en.wikipedia.org/wiki/Trapezoidal_rule

.. [2] Illustration image:
https://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png

Examples
--------
Use the trapezoidal rule on evenly spaced points:

>>> np.trapz([1, 2, 3])
4.0

The spacing between sample points can be selected by either the
``x`` or ``dx`` arguments:

>>> np.trapz([1, 2, 3], x=[4, 6, 8])
8.0
>>> np.trapz([1, 2, 3], dx=2)
8.0

Using a decreasing ``x`` corresponds to integrating in reverse:

>>> np.trapz([1, 2, 3], x=[8, 6, 4])
-8.0

More generally ``x`` is used to integrate along a parametric curve. We can
estimate the integral :math:`\int_0^1 x^2 = 1/3` using:

>>> x = np.linspace(0, 1, num=50)
>>> y = x**2
>>> np.trapz(y, x)
0.33340274885464394

Or estimate the area of a circle, noting we repeat the sample which closes
the curve:

>>> theta = np.linspace(0, 2 * np.pi, num=1000, endpoint=True)
>>> np.trapz(np.cos(theta), x=np.sin(theta))
3.141571941375841

``np.trapz`` can be applied along a specified axis to do multiple
computations in one call:

>>> a = np.arange(6).reshape(2, 3)
>>> a
array([[0, 1, 2],
[3, 4, 5]])
>>> np.trapz(a, axis=0)
array([1.5, 2.5, 3.5])
>>> np.trapz(a, axis=1)
array([2.,  8.])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l04859}{4859}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.



References \mbox{\hyperlink{lib_2function__base_8py_source_l01325}{diff()}}, \mbox{\hyperlink{core_2fromnumeric_8py_source_l02179}{numpy.\+core.\+fromnumeric.\+sum()}}, and \mbox{\hyperlink{lib_2function__base_8py_source_l04859}{trapz()}}.



Referenced by \mbox{\hyperlink{lib_2function__base_8py_source_l04859}{trapz()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_adcdbca2c84c981abdf7f356dbf3c66bc}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!trim\_zeros@{trim\_zeros}}
\index{trim\_zeros@{trim\_zeros}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{trim\_zeros()}{trim\_zeros()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_adcdbca2c84c981abdf7f356dbf3c66bc} 
numpy.\+lib.\+function\+\_\+base.\+trim\+\_\+zeros (\begin{DoxyParamCaption}\item[{}]{filt}{, }\item[{}]{trim}{ = {\ttfamily \textquotesingle{}fb\textquotesingle{}}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Trim the leading and/or trailing zeros from a 1-D array or sequence.

Parameters
----------
filt : 1-D array or sequence
    Input array.
trim : str, optional
    A string with 'f' representing trim from front and 'b' to trim from
    back. Default is 'fb', trim zeros from both front and back of the
    array.

Returns
-------
trimmed : 1-D array or sequence
    The result of trimming the input. The input data type is preserved.

Examples
--------
>>> a = np.array((0, 0, 0, 1, 2, 3, 0, 2, 1, 0))
>>> np.trim_zeros(a)
array([1, 2, 3, 0, 2, 1])

>>> np.trim_zeros(a, 'b')
array([0, 0, 0, ..., 0, 2, 1])

The input data type is preserved, list/tuple in means list/tuple out.

>>> np.trim_zeros([0, 1, 2, 0])
[1, 2]
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l01805}{1805}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.



Referenced by \mbox{\hyperlink{lib_2polynomial_8py_source_l01209}{numpy.\+lib.\+polynomial.\+poly1d.\+roots()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_af51a9341b1e9e575ac795009f0c38a96}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!unwrap@{unwrap}}
\index{unwrap@{unwrap}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{unwrap()}{unwrap()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_af51a9341b1e9e575ac795009f0c38a96} 
numpy.\+lib.\+function\+\_\+base.\+unwrap (\begin{DoxyParamCaption}\item[{}]{p}{, }\item[{}]{discont}{ = {\ttfamily None}, }\item[{}]{axis}{ = {\ttfamily -\/1}, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{period}{ = {\ttfamily 2\texorpdfstring{$\ast$}{*}pi}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Unwrap by taking the complement of large deltas with respect to the period.

This unwraps a signal `p` by changing elements which have an absolute
difference from their predecessor of more than ``max(discont, period/2)``
to their `period`-complementary values.

For the default case where `period` is :math:`2\pi` and `discont` is
:math:`\pi`, this unwraps a radian phase `p` such that adjacent differences
are never greater than :math:`\pi` by adding :math:`2k\pi` for some
integer :math:`k`.

Parameters
----------
p : array_like
    Input array.
discont : float, optional
    Maximum discontinuity between values, default is ``period/2``.
    Values below ``period/2`` are treated as if they were ``period/2``.
    To have an effect different from the default, `discont` should be
    larger than ``period/2``.
axis : int, optional
    Axis along which unwrap will operate, default is the last axis.
period : float, optional
    Size of the range over which the input wraps. By default, it is
    ``2 pi``.

    .. versionadded:: 1.21.0

Returns
-------
out : ndarray
    Output array.

See Also
--------
rad2deg, deg2rad

Notes
-----
If the discontinuity in `p` is smaller than ``period/2``,
but larger than `discont`, no unwrapping is done because taking
the complement would only make the discontinuity larger.

Examples
--------
>>> phase = np.linspace(0, np.pi, num=5)
>>> phase[3:] += np.pi
>>> phase
array([ 0.        ,  0.78539816,  1.57079633,  5.49778714,  6.28318531]) # may vary
>>> np.unwrap(phase)
array([ 0.        ,  0.78539816,  1.57079633, -0.78539816,  0.        ]) # may vary
>>> np.unwrap([0, 1, 2, -1, 0], period=4)
array([0, 1, 2, 3, 4])
>>> np.unwrap([ 1, 2, 3, 4, 5, 6, 1, 2, 3], period=6)
array([1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> np.unwrap([2, 3, 4, 5, 2, 3, 4, 5], period=4)
array([2, 3, 4, 5, 6, 7, 8, 9])
>>> phase_deg = np.mod(np.linspace(0 ,720, 19), 360) - 180
>>> np.unwrap(phase_deg, period=360)
array([-180., -140., -100.,  -60.,  -20.,   20.,   60.,  100.,  140.,
        180.,  220.,  260.,  300.,  340.,  380.,  420.,  460.,  500.,
        540.])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l01664}{1664}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.



References \mbox{\hyperlink{lib_2function__base_8py_source_l01325}{diff()}}.



\doxysubsection{Variable Documentation}
\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a4589dbd0ee958d024d654ddc8118f8fd}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_\_all\_\_@{\_\_all\_\_}}
\index{\_\_all\_\_@{\_\_all\_\_}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_\_all\_\_}{\_\_all\_\_}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a4589dbd0ee958d024d654ddc8118f8fd} 
list numpy.\+lib.\+function\+\_\+base.\+\_\+\+\_\+all\+\_\+\+\_\+\hspace{0.3cm}{\ttfamily [private]}}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ [}
\DoxyCodeLine{00002\ \ \ \ \ \textcolor{stringliteral}{'select'},\ \textcolor{stringliteral}{'piecewise'},\ \textcolor{stringliteral}{'trim\_zeros'},\ \textcolor{stringliteral}{'copy'},\ \textcolor{stringliteral}{'iterable'},\ \textcolor{stringliteral}{'percentile'},}
\DoxyCodeLine{00003\ \ \ \ \ \textcolor{stringliteral}{'diff'},\ \textcolor{stringliteral}{'gradient'},\ \textcolor{stringliteral}{'angle'},\ \textcolor{stringliteral}{'unwrap'},\ \textcolor{stringliteral}{'sort\_complex'},\ \textcolor{stringliteral}{'disp'},\ \textcolor{stringliteral}{'flip'},}
\DoxyCodeLine{00004\ \ \ \ \ \textcolor{stringliteral}{'rot90'},\ \textcolor{stringliteral}{'extract'},\ \textcolor{stringliteral}{'place'},\ \textcolor{stringliteral}{'vectorize'},\ \textcolor{stringliteral}{'asarray\_chkfinite'},\ \textcolor{stringliteral}{'average'},}
\DoxyCodeLine{00005\ \ \ \ \ \textcolor{stringliteral}{'bincount'},\ \textcolor{stringliteral}{'digitize'},\ \textcolor{stringliteral}{'cov'},\ \textcolor{stringliteral}{'corrcoef'},}
\DoxyCodeLine{00006\ \ \ \ \ \textcolor{stringliteral}{'msort'},\ \textcolor{stringliteral}{'median'},\ \textcolor{stringliteral}{'sinc'},\ \textcolor{stringliteral}{'hamming'},\ \textcolor{stringliteral}{'hanning'},\ \textcolor{stringliteral}{'bartlett'},}
\DoxyCodeLine{00007\ \ \ \ \ \textcolor{stringliteral}{'blackman'},\ \textcolor{stringliteral}{'kaiser'},\ \textcolor{stringliteral}{'trapz'},\ \textcolor{stringliteral}{'i0'},\ \textcolor{stringliteral}{'add\_newdoc'},\ \textcolor{stringliteral}{'add\_docstring'},}
\DoxyCodeLine{00008\ \ \ \ \ \textcolor{stringliteral}{'meshgrid'},\ \textcolor{stringliteral}{'delete'},\ \textcolor{stringliteral}{'insert'},\ \textcolor{stringliteral}{'append'},\ \textcolor{stringliteral}{'interp'},\ \textcolor{stringliteral}{'add\_newdoc\_ufunc'},}
\DoxyCodeLine{00009\ \ \ \ \ \textcolor{stringliteral}{'quantile'}}
\DoxyCodeLine{00010\ \ \ \ \ ]}

\end{DoxyCode}


Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l00042}{42}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a995c0544cdd6d939b1e3021f5cd0e17b}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_\_closure\_\_@{\_\_closure\_\_}}
\index{\_\_closure\_\_@{\_\_closure\_\_}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_\_closure\_\_}{\_\_closure\_\_}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a995c0544cdd6d939b1e3021f5cd0e17b} 
numpy.\+lib.\+function\+\_\+base.\+\_\+\+\_\+closure\+\_\+\+\_\+\hspace{0.3cm}{\ttfamily [private]}}



Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l05002}{5002}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a8c9b90c4dd4cd3412883c837417e9d76}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_\_code\_\_@{\_\_code\_\_}}
\index{\_\_code\_\_@{\_\_code\_\_}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_\_code\_\_}{\_\_code\_\_}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a8c9b90c4dd4cd3412883c837417e9d76} 
numpy.\+lib.\+function\+\_\+base.\+\_\+\+\_\+code\+\_\+\+\_\+\hspace{0.3cm}{\ttfamily [private]}}



Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l04999}{4999}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a7c359e77276e077a31f8131fa90dca65}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_\_defaults\_\_@{\_\_defaults\_\_}}
\index{\_\_defaults\_\_@{\_\_defaults\_\_}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_\_defaults\_\_}{\_\_defaults\_\_}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a7c359e77276e077a31f8131fa90dca65} 
numpy.\+lib.\+function\+\_\+base.\+\_\+\+\_\+defaults\+\_\+\+\_\+\hspace{0.3cm}{\ttfamily [private]}}



Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l05001}{5001}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_aceb4c8da1b6a4c7f663a9bec83d64ced}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_\_globals\_\_@{\_\_globals\_\_}}
\index{\_\_globals\_\_@{\_\_globals\_\_}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_\_globals\_\_}{\_\_globals\_\_}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_aceb4c8da1b6a4c7f663a9bec83d64ced} 
numpy.\+lib.\+function\+\_\+base.\+\_\+\+\_\+globals\+\_\+\+\_\+\hspace{0.3cm}{\ttfamily [private]}}



Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l05000}{5000}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a919e4237f38755bcc68f7005b82952cd}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_\_kwdefaults\_\_@{\_\_kwdefaults\_\_}}
\index{\_\_kwdefaults\_\_@{\_\_kwdefaults\_\_}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_\_kwdefaults\_\_}{\_\_kwdefaults\_\_}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a919e4237f38755bcc68f7005b82952cd} 
numpy.\+lib.\+function\+\_\+base.\+\_\+\+\_\+kwdefaults\+\_\+\+\_\+\hspace{0.3cm}{\ttfamily [private]}}



Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l05003}{5003}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a6cdf3ca9d1e59a41d35ff1fe635d91c7}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_ARGUMENT@{\_ARGUMENT}}
\index{\_ARGUMENT@{\_ARGUMENT}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_ARGUMENT}{\_ARGUMENT}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a6cdf3ca9d1e59a41d35ff1fe635d91c7} 
str numpy.\+lib.\+function\+\_\+base.\+\_\+\+ARGUMENT = r\textquotesingle{}\textbackslash{}(\{\}\textbackslash{})\textquotesingle{}.format(\+\_\+\+CORE\+\_\+\+DIMENSION\+\_\+\+LIST)\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l02002}{2002}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a504fea436affc23ee55663f83ad378ea}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_ARGUMENT\_LIST@{\_ARGUMENT\_LIST}}
\index{\_ARGUMENT\_LIST@{\_ARGUMENT\_LIST}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_ARGUMENT\_LIST}{\_ARGUMENT\_LIST}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a504fea436affc23ee55663f83ad378ea} 
str numpy.\+lib.\+function\+\_\+base.\+\_\+\+ARGUMENT\+\_\+\+LIST = \textquotesingle{}\{0\+:\}(?\+:,\{0\+:\})\texorpdfstring{$\ast$}{*}\textquotesingle{}.format(\+\_\+\+ARGUMENT)\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l02003}{2003}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a58631ca9768a039f025fec3bcdbe50ed}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_CORE\_DIMENSION\_LIST@{\_CORE\_DIMENSION\_LIST}}
\index{\_CORE\_DIMENSION\_LIST@{\_CORE\_DIMENSION\_LIST}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_CORE\_DIMENSION\_LIST}{\_CORE\_DIMENSION\_LIST}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a58631ca9768a039f025fec3bcdbe50ed} 
str numpy.\+lib.\+function\+\_\+base.\+\_\+\+CORE\+\_\+\+DIMENSION\+\_\+\+LIST = \textquotesingle{}(?\+:\{0\+:\}(?\+:,\{0\+:\})\texorpdfstring{$\ast$}{*})?\textquotesingle{}.format(\+\_\+\+DIMENSION\+\_\+\+NAME)\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l02001}{2001}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a85d9035d2b11bf7f5b20a6e4b4c51f45}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_DIMENSION\_NAME@{\_DIMENSION\_NAME}}
\index{\_DIMENSION\_NAME@{\_DIMENSION\_NAME}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_DIMENSION\_NAME}{\_DIMENSION\_NAME}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a85d9035d2b11bf7f5b20a6e4b4c51f45} 
str numpy.\+lib.\+function\+\_\+base.\+\_\+\+DIMENSION\+\_\+\+NAME = r\textquotesingle{}\textbackslash{}w+\textquotesingle{}\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l02000}{2000}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_ada1d6d9089e5008cba16f91bac09e8d7}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_i0A@{\_i0A}}
\index{\_i0A@{\_i0A}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_i0A}{\_i0A}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_ada1d6d9089e5008cba16f91bac09e8d7} 
list numpy.\+lib.\+function\+\_\+base.\+\_\+i0A\hspace{0.3cm}{\ttfamily [protected]}}



Code from cephes for i0. 



Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l03344}{3344}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a25cc2115172d1dffd8ffb230438df384}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_i0B@{\_i0B}}
\index{\_i0B@{\_i0B}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_i0B}{\_i0B}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a25cc2115172d1dffd8ffb230438df384} 
list numpy.\+lib.\+function\+\_\+base.\+\_\+i0B\hspace{0.3cm}{\ttfamily [protected]}}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ [}
\DoxyCodeLine{00002\ \ \ \ \ -\/7.23318048787475395456E-\/18,}
\DoxyCodeLine{00003\ \ \ \ \ -\/4.83050448594418207126E-\/18,}
\DoxyCodeLine{00004\ \ \ \ \ 4.46562142029675999901E-\/17,}
\DoxyCodeLine{00005\ \ \ \ \ 3.46122286769746109310E-\/17,}
\DoxyCodeLine{00006\ \ \ \ \ -\/2.82762398051658348494E-\/16,}
\DoxyCodeLine{00007\ \ \ \ \ -\/3.42548561967721913462E-\/16,}
\DoxyCodeLine{00008\ \ \ \ \ 1.77256013305652638360E-\/15,}
\DoxyCodeLine{00009\ \ \ \ \ 3.81168066935262242075E-\/15,}
\DoxyCodeLine{00010\ \ \ \ \ -\/9.55484669882830764870E-\/15,}
\DoxyCodeLine{00011\ \ \ \ \ -\/4.15056934728722208663E-\/14,}
\DoxyCodeLine{00012\ \ \ \ \ 1.54008621752140982691E-\/14,}
\DoxyCodeLine{00013\ \ \ \ \ 3.85277838274214270114E-\/13,}
\DoxyCodeLine{00014\ \ \ \ \ 7.18012445138366623367E-\/13,}
\DoxyCodeLine{00015\ \ \ \ \ -\/1.79417853150680611778E-\/12,}
\DoxyCodeLine{00016\ \ \ \ \ -\/1.32158118404477131188E-\/11,}
\DoxyCodeLine{00017\ \ \ \ \ -\/3.14991652796324136454E-\/11,}
\DoxyCodeLine{00018\ \ \ \ \ 1.18891471078464383424E-\/11,}
\DoxyCodeLine{00019\ \ \ \ \ 4.94060238822496958910E-\/10,}
\DoxyCodeLine{00020\ \ \ \ \ 3.39623202570838634515E-\/9,}
\DoxyCodeLine{00021\ \ \ \ \ 2.26666899049817806459E-\/8,}
\DoxyCodeLine{00022\ \ \ \ \ 2.04891858946906374183E-\/7,}
\DoxyCodeLine{00023\ \ \ \ \ 2.89137052083475648297E-\/6,}
\DoxyCodeLine{00024\ \ \ \ \ 6.88975834691682398426E-\/5,}
\DoxyCodeLine{00025\ \ \ \ \ 3.36911647825569408990E-\/3,}
\DoxyCodeLine{00026\ \ \ \ \ 8.04490411014108831608E-\/1}
\DoxyCodeLine{00027\ \ \ \ \ ]}

\end{DoxyCode}


Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l03377}{3377}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_abef37d5da5475303548c0d850c3ca93d}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_QuantileMethods@{\_QuantileMethods}}
\index{\_QuantileMethods@{\_QuantileMethods}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_QuantileMethods}{\_QuantileMethods}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_abef37d5da5475303548c0d850c3ca93d} 
numpy.\+lib.\+function\+\_\+base.\+\_\+\+Quantile\+Methods\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l00069}{69}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_a2960f69f383be4a34e3432599f93d8d7}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!\_SIGNATURE@{\_SIGNATURE}}
\index{\_SIGNATURE@{\_SIGNATURE}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{\_SIGNATURE}{\_SIGNATURE}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_a2960f69f383be4a34e3432599f93d8d7} 
str numpy.\+lib.\+function\+\_\+base.\+\_\+\+SIGNATURE = \textquotesingle{}\texorpdfstring{$^\wedge$}{\string^}\{0\+:\}-\/$>$\{0\+:\}\$\textquotesingle{}.format(\+\_\+\+ARGUMENT\+\_\+\+LIST)\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l02004}{2004}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1function__base_ad03f4b858ee9cb78b9adf3cbb4465b1d}\index{numpy.lib.function\_base@{numpy.lib.function\_base}!array\_function\_dispatch@{array\_function\_dispatch}}
\index{array\_function\_dispatch@{array\_function\_dispatch}!numpy.lib.function\_base@{numpy.lib.function\_base}}
\doxysubsubsection{\texorpdfstring{array\_function\_dispatch}{array\_function\_dispatch}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1function__base_ad03f4b858ee9cb78b9adf3cbb4465b1d} 
numpy.\+lib.\+function\+\_\+base.\+array\+\_\+function\+\_\+dispatch}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ functools.partial(}
\DoxyCodeLine{00002\ \ \ \ \ overrides.array\_function\_dispatch,\ module=\textcolor{stringliteral}{'numpy'})}

\end{DoxyCode}


Definition at line \mbox{\hyperlink{lib_2function__base_8py_source_l00038}{38}} of file \mbox{\hyperlink{lib_2function__base_8py_source}{function\+\_\+base.\+py}}.

