\doxysection{sklearn.\+utils.\+extmath Namespace Reference}
\hypertarget{namespacesklearn_1_1utils_1_1extmath}{}\label{namespacesklearn_1_1utils_1_1extmath}\index{sklearn.utils.extmath@{sklearn.utils.extmath}}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1extmath_a6a39b4b4b5f631c8f0652304fda26a54}{squared\+\_\+norm}} (x)
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1extmath_ac3d9849e3c602ac89b59603797d8042c}{row\+\_\+norms}} (X, squared=False)
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1extmath_a9839591c7220d735c3bebc11d4ad603b}{fast\+\_\+logdet}} (A)
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1extmath_a9b7d337fff48876bbf09f62c68f186a9}{density}} (w)
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1extmath_aa17653afca24a9fc1bbcc619cf0a2448}{safe\+\_\+sparse\+\_\+dot}} (a, b, \texorpdfstring{$\ast$}{*}, dense\+\_\+output=False)
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1extmath_a0af255d472410836f61a4135797f63f6}{randomized\+\_\+range\+\_\+finder}} (A, \texorpdfstring{$\ast$}{*}, size, n\+\_\+iter, power\+\_\+iteration\+\_\+normalizer="{}auto"{}, random\+\_\+state=None)
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1extmath_a907807ccc2c5802a4708b5139e037bca}{\+\_\+randomized\+\_\+range\+\_\+finder}} (A, \texorpdfstring{$\ast$}{*}, size, n\+\_\+iter, power\+\_\+iteration\+\_\+normalizer="{}auto"{}, random\+\_\+state=None)
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1extmath_a73c744c7c6071db052edf0453545228e}{randomized\+\_\+svd}} (M, n\+\_\+components, \texorpdfstring{$\ast$}{*}, n\+\_\+oversamples=10, n\+\_\+iter="{}auto"{}, power\+\_\+iteration\+\_\+normalizer="{}auto"{}, transpose="{}auto"{}, flip\+\_\+sign=\mbox{\hyperlink{classTrue}{True}}, random\+\_\+state=None, svd\+\_\+lapack\+\_\+driver="{}gesdd"{})
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1extmath_ab18bf68b74a698fcd7b87b6d7d09c317}{\+\_\+randomized\+\_\+svd}} (M, n\+\_\+components, \texorpdfstring{$\ast$}{*}, n\+\_\+oversamples=10, n\+\_\+iter="{}auto"{}, power\+\_\+iteration\+\_\+normalizer="{}auto"{}, transpose="{}auto"{}, flip\+\_\+sign=\mbox{\hyperlink{classTrue}{True}}, random\+\_\+state=None, svd\+\_\+lapack\+\_\+driver="{}gesdd"{})
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1extmath_a7597a3ab8e72e1c52467cc1a389043bd}{\+\_\+randomized\+\_\+eigsh}} (M, n\+\_\+components, \texorpdfstring{$\ast$}{*}, n\+\_\+oversamples=10, n\+\_\+iter="{}auto"{}, power\+\_\+iteration\+\_\+normalizer="{}auto"{}, selection="{}module"{}, random\+\_\+state=None)
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1extmath_aa5545b350d5b9606fd2a385b70ca5d2a}{weighted\+\_\+mode}} (a, w, \texorpdfstring{$\ast$}{*}, axis=0)
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1extmath_ad2780457312fed7f3b34ff7ad32210e6}{cartesian}} (arrays, out=None)
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1extmath_aeb7d1817c732296d017ee3ebd9c9ded7}{svd\+\_\+flip}} (u, v, u\+\_\+based\+\_\+decision=\mbox{\hyperlink{classTrue}{True}})
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1extmath_a5a030f453adb35a00f5f860b31cd3f3e}{softmax}} (X, copy=\mbox{\hyperlink{classTrue}{True}})
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1extmath_a6effd449b565544a97f4d5a301c09ccb}{make\+\_\+nonnegative}} (X, min\+\_\+value=0)
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1extmath_a19939f2804ad89d9a563a53f0af59ab6}{\+\_\+safe\+\_\+accumulator\+\_\+op}} (op, x, \texorpdfstring{$\ast$}{*}args, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}kwargs)
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1extmath_a9b2e4e0420df17e13899235c82352c70}{\+\_\+incremental\+\_\+mean\+\_\+and\+\_\+var}} (X, last\+\_\+mean, last\+\_\+variance, last\+\_\+sample\+\_\+count, sample\+\_\+weight=None)
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1extmath_a71ca8363822cbe4ae7cfc7c0efd20d01}{\+\_\+deterministic\+\_\+vector\+\_\+sign\+\_\+flip}} (u)
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1extmath_a7c2292c77ff1021f1f2c33dc369da054}{stable\+\_\+cumsum}} (arr, axis=None, rtol=1e-\/05, atol=1e-\/08)
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1extmath_aaf039c05451705a9d2fb5306128d422b}{\+\_\+nanaverage}} (a, weights=None)
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1extmath_a0ee7c6b49635b7c7a7721162f864ad64}{safe\+\_\+sqr}} (X, \texorpdfstring{$\ast$}{*}, copy=\mbox{\hyperlink{classTrue}{True}})
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1extmath_ae42de26bf5a2acfdc906615160673bfd}{\+\_\+approximate\+\_\+mode}} (class\+\_\+counts, n\+\_\+draws, rng)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\begin{DoxyVerb}Utilities to perform optimal mathematical operations in scikit-learn.\end{DoxyVerb}
 

\doxysubsection{Function Documentation}
\Hypertarget{namespacesklearn_1_1utils_1_1extmath_ae42de26bf5a2acfdc906615160673bfd}\index{sklearn.utils.extmath@{sklearn.utils.extmath}!\_approximate\_mode@{\_approximate\_mode}}
\index{\_approximate\_mode@{\_approximate\_mode}!sklearn.utils.extmath@{sklearn.utils.extmath}}
\doxysubsubsection{\texorpdfstring{\_approximate\_mode()}{\_approximate\_mode()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1extmath_ae42de26bf5a2acfdc906615160673bfd} 
sklearn.\+utils.\+extmath.\+\_\+approximate\+\_\+mode (\begin{DoxyParamCaption}\item[{}]{class\+\_\+counts}{, }\item[{}]{n\+\_\+draws}{, }\item[{}]{rng}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Computes approximate mode of multivariate hypergeometric.

This is an approximation to the mode of the multivariate
hypergeometric given by class_counts and n_draws.
It shouldn't be off by more than one.

It is the mostly likely outcome of drawing n_draws many
samples from the population given by class_counts.

Parameters
----------
class_counts : ndarray of int
    Population per class.
n_draws : int
    Number of draws (samples to draw) from the overall population.
rng : random state
    Used to break ties.

Returns
-------
sampled_classes : ndarray of int
    Number of samples drawn from each class.
    np.sum(sampled_classes) == n_draws

Examples
--------
>>> import numpy as np
>>> from sklearn.utils.extmath import _approximate_mode
>>> _approximate_mode(class_counts=np.array([4, 2]), n_draws=3, rng=0)
array([2, 1])
>>> _approximate_mode(class_counts=np.array([5, 2]), n_draws=4, rng=0)
array([3, 1])
>>> _approximate_mode(class_counts=np.array([2, 2, 2, 1]),
...                   n_draws=2, rng=0)
array([0, 1, 1, 0])
>>> _approximate_mode(class_counts=np.array([2, 2, 2, 1]),
...                   n_draws=2, rng=42)
array([1, 1, 0, 0])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{extmath_8py_source_l01329}{1329}} of file \mbox{\hyperlink{extmath_8py_source}{extmath.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1extmath_a71ca8363822cbe4ae7cfc7c0efd20d01}\index{sklearn.utils.extmath@{sklearn.utils.extmath}!\_deterministic\_vector\_sign\_flip@{\_deterministic\_vector\_sign\_flip}}
\index{\_deterministic\_vector\_sign\_flip@{\_deterministic\_vector\_sign\_flip}!sklearn.utils.extmath@{sklearn.utils.extmath}}
\doxysubsubsection{\texorpdfstring{\_deterministic\_vector\_sign\_flip()}{\_deterministic\_vector\_sign\_flip()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1extmath_a71ca8363822cbe4ae7cfc7c0efd20d01} 
sklearn.\+utils.\+extmath.\+\_\+deterministic\+\_\+vector\+\_\+sign\+\_\+flip (\begin{DoxyParamCaption}\item[{}]{u}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Modify the sign of vectors for reproducibility.

Flips the sign of elements of all the vectors (rows of u) such that
the absolute maximum element of each vector is positive.

Parameters
----------
u : ndarray
    Array with vectors as its rows.

Returns
-------
u_flipped : ndarray with same shape as u
    Array with the sign flipped vectors as its rows.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{extmath_8py_source_l01190}{1190}} of file \mbox{\hyperlink{extmath_8py_source}{extmath.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1extmath_a9b2e4e0420df17e13899235c82352c70}\index{sklearn.utils.extmath@{sklearn.utils.extmath}!\_incremental\_mean\_and\_var@{\_incremental\_mean\_and\_var}}
\index{\_incremental\_mean\_and\_var@{\_incremental\_mean\_and\_var}!sklearn.utils.extmath@{sklearn.utils.extmath}}
\doxysubsubsection{\texorpdfstring{\_incremental\_mean\_and\_var()}{\_incremental\_mean\_and\_var()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1extmath_a9b2e4e0420df17e13899235c82352c70} 
sklearn.\+utils.\+extmath.\+\_\+incremental\+\_\+mean\+\_\+and\+\_\+var (\begin{DoxyParamCaption}\item[{}]{X}{, }\item[{}]{last\+\_\+mean}{, }\item[{}]{last\+\_\+variance}{, }\item[{}]{last\+\_\+sample\+\_\+count}{, }\item[{}]{sample\+\_\+weight}{ = {\ttfamily None}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Calculate mean update and a Youngs and Cramer variance update.

If sample_weight is given, the weighted mean and variance is computed.

Update a given mean and (possibly) variance according to new data given
in X. last_mean is always required to compute the new mean.
If last_variance is None, no variance is computed and None return for
updated_variance.

From the paper "Algorithms for computing the sample variance: analysis and
recommendations", by Chan, Golub, and LeVeque.

Parameters
----------
X : array-like of shape (n_samples, n_features)
    Data to use for variance update.

last_mean : array-like of shape (n_features,)

last_variance : array-like of shape (n_features,)

last_sample_count : array-like of shape (n_features,)
    The number of samples encountered until now if sample_weight is None.
    If sample_weight is not None, this is the sum of sample_weight
    encountered.

sample_weight : array-like of shape (n_samples,) or None
    Sample weights. If None, compute the unweighted mean/variance.

Returns
-------
updated_mean : ndarray of shape (n_features,)

updated_variance : ndarray of shape (n_features,)
    None if last_variance was None.

updated_sample_count : ndarray of shape (n_features,)

Notes
-----
NaNs are ignored during the algorithm.

References
----------
T. Chan, G. Golub, R. LeVeque. Algorithms for computing the sample
    variance: recommendations, The American Statistician, Vol. 37, No. 3,
    pp. 242-247

Also, see the sparse implementation of this in
`utils.sparsefuncs.incr_mean_variance_axis` and
`utils.sparsefuncs_fast.incr_mean_variance_axis0`
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{extmath_8py_source_l01064}{1064}} of file \mbox{\hyperlink{extmath_8py_source}{extmath.\+py}}.



References \mbox{\hyperlink{extmath_8py_source_l01034}{\+\_\+safe\+\_\+accumulator\+\_\+op()}}.

\Hypertarget{namespacesklearn_1_1utils_1_1extmath_aaf039c05451705a9d2fb5306128d422b}\index{sklearn.utils.extmath@{sklearn.utils.extmath}!\_nanaverage@{\_nanaverage}}
\index{\_nanaverage@{\_nanaverage}!sklearn.utils.extmath@{sklearn.utils.extmath}}
\doxysubsubsection{\texorpdfstring{\_nanaverage()}{\_nanaverage()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1extmath_aaf039c05451705a9d2fb5306128d422b} 
sklearn.\+utils.\+extmath.\+\_\+nanaverage (\begin{DoxyParamCaption}\item[{}]{a}{, }\item[{}]{weights}{ = {\ttfamily None}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Compute the weighted average, ignoring NaNs.

Parameters
----------
a : ndarray
    Array containing data to be averaged.
weights : array-like, default=None
    An array of weights associated with the values in a. Each value in a
    contributes to the average according to its associated weight. The
    weights array can either be 1-D of the same shape as a. If `weights=None`,
    then all data in a are assumed to have a weight equal to one.

Returns
-------
weighted_average : float
    The weighted average.

Notes
-----
This wrapper to combine :func:`numpy.average` and :func:`numpy.nanmean`, so
that :func:`np.nan` values are ignored from the average and weights can
be passed. Note that when possible, we delegate to the prime methods.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{extmath_8py_source_l01250}{1250}} of file \mbox{\hyperlink{extmath_8py_source}{extmath.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1extmath_a7597a3ab8e72e1c52467cc1a389043bd}\index{sklearn.utils.extmath@{sklearn.utils.extmath}!\_randomized\_eigsh@{\_randomized\_eigsh}}
\index{\_randomized\_eigsh@{\_randomized\_eigsh}!sklearn.utils.extmath@{sklearn.utils.extmath}}
\doxysubsubsection{\texorpdfstring{\_randomized\_eigsh()}{\_randomized\_eigsh()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1extmath_a7597a3ab8e72e1c52467cc1a389043bd} 
sklearn.\+utils.\+extmath.\+\_\+randomized\+\_\+eigsh (\begin{DoxyParamCaption}\item[{}]{M}{, }\item[{}]{n\+\_\+components}{, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{n\+\_\+oversamples}{ = {\ttfamily 10}, }\item[{}]{n\+\_\+iter}{ = {\ttfamily "{}auto"{}}, }\item[{}]{power\+\_\+iteration\+\_\+normalizer}{ = {\ttfamily "{}auto"{}}, }\item[{}]{selection}{ = {\ttfamily "{}module"{}}, }\item[{}]{random\+\_\+state}{ = {\ttfamily None}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Computes a truncated eigendecomposition using randomized methods

This method solves the fixed-rank approximation problem described in the
Halko et al paper.

The choice of which components to select can be tuned with the `selection`
parameter.

.. versionadded:: 0.24

Parameters
----------
M : ndarray or sparse matrix
    Matrix to decompose, it should be real symmetric square or complex
    hermitian

n_components : int
    Number of eigenvalues and vectors to extract.

n_oversamples : int, default=10
    Additional number of random vectors to sample the range of M so as
    to ensure proper conditioning. The total number of random vectors
    used to find the range of M is n_components + n_oversamples. Smaller
    number can improve speed but can negatively impact the quality of
    approximation of eigenvectors and eigenvalues. Users might wish
    to increase this parameter up to `2*k - n_components` where k is the
    effective rank, for large matrices, noisy problems, matrices with
    slowly decaying spectrums, or to increase precision accuracy. See Halko
    et al (pages 5, 23 and 26).

n_iter : int or 'auto', default='auto'
    Number of power iterations. It can be used to deal with very noisy
    problems. When 'auto', it is set to 4, unless `n_components` is small
    (< .1 * min(X.shape)) in which case `n_iter` is set to 7.
    This improves precision with few components. Note that in general
    users should rather increase `n_oversamples` before increasing `n_iter`
    as the principle of the randomized method is to avoid usage of these
    more costly power iterations steps. When `n_components` is equal
    or greater to the effective matrix rank and the spectrum does not
    present a slow decay, `n_iter=0` or `1` should even work fine in theory
    (see Halko et al paper, page 9).

power_iteration_normalizer : {'auto', 'QR', 'LU', 'none'}, default='auto'
    Whether the power iterations are normalized with step-by-step
    QR factorization (the slowest but most accurate), 'none'
    (the fastest but numerically unstable when `n_iter` is large, e.g.
    typically 5 or larger), or 'LU' factorization (numerically stable
    but can lose slightly in accuracy). The 'auto' mode applies no
    normalization if `n_iter` <= 2 and switches to LU otherwise.

selection : {'value', 'module'}, default='module'
    Strategy used to select the n components. When `selection` is `'value'`
    (not yet implemented, will become the default when implemented), the
    components corresponding to the n largest eigenvalues are returned.
    When `selection` is `'module'`, the components corresponding to the n
    eigenvalues with largest modules are returned.

random_state : int, RandomState instance, default=None
    The seed of the pseudo random number generator to use when shuffling
    the data, i.e. getting the random vectors to initialize the algorithm.
    Pass an int for reproducible results across multiple function calls.
    See :term:`Glossary <random_state>`.

Notes
-----
This algorithm finds a (usually very good) approximate truncated
eigendecomposition using randomized methods to speed up the computations.

This method is particularly fast on large matrices on which
you wish to extract only a small number of components. In order to
obtain further speed up, `n_iter` can be set <=2 (at the cost of
loss of precision). To increase the precision it is recommended to
increase `n_oversamples`, up to `2*k-n_components` where k is the
effective rank. Usually, `n_components` is chosen to be greater than k
so increasing `n_oversamples` up to `n_components` should be enough.

Strategy 'value': not implemented yet.
Algorithms 5.3, 5.4 and 5.5 in the Halko et al paper should provide good
candidates for a future implementation.

Strategy 'module':
The principle is that for diagonalizable matrices, the singular values and
eigenvalues are related: if t is an eigenvalue of A, then :math:`|t|` is a
singular value of A. This method relies on a randomized SVD to find the n
singular components corresponding to the n singular values with largest
modules, and then uses the signs of the singular vectors to find the true
sign of t: if the sign of left and right singular vectors are different
then the corresponding eigenvalue is negative.

Returns
-------
eigvals : 1D array of shape (n_components,) containing the `n_components`
    eigenvalues selected (see ``selection`` parameter).
eigvecs : 2D array of shape (M.shape[0], n_components) containing the
    `n_components` eigenvectors corresponding to the `eigvals`, in the
    corresponding order. Note that this follows the `scipy.linalg.eigh`
    convention.

See Also
--------
:func:`randomized_svd`

References
----------
* :arxiv:`"Finding structure with randomness:
  Stochastic algorithms for constructing approximate matrix decompositions"
  (Algorithm 4.3 for strategy 'module') <0909.4061>`
  Halko, et al. (2009)
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{extmath_8py_source_l00607}{607}} of file \mbox{\hyperlink{extmath_8py_source}{extmath.\+py}}.



References \mbox{\hyperlink{extmath_8py_source_l00385}{randomized\+\_\+svd()}}.

\Hypertarget{namespacesklearn_1_1utils_1_1extmath_a907807ccc2c5802a4708b5139e037bca}\index{sklearn.utils.extmath@{sklearn.utils.extmath}!\_randomized\_range\_finder@{\_randomized\_range\_finder}}
\index{\_randomized\_range\_finder@{\_randomized\_range\_finder}!sklearn.utils.extmath@{sklearn.utils.extmath}}
\doxysubsubsection{\texorpdfstring{\_randomized\_range\_finder()}{\_randomized\_range\_finder()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1extmath_a907807ccc2c5802a4708b5139e037bca} 
sklearn.\+utils.\+extmath.\+\_\+randomized\+\_\+range\+\_\+finder (\begin{DoxyParamCaption}\item[{}]{A}{, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{size}{, }\item[{}]{n\+\_\+iter}{, }\item[{}]{power\+\_\+iteration\+\_\+normalizer}{ = {\ttfamily "{}auto"{}}, }\item[{}]{random\+\_\+state}{ = {\ttfamily None}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Body of randomized_range_finder without input validation.\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{extmath_8py_source_l00287}{287}} of file \mbox{\hyperlink{extmath_8py_source}{extmath.\+py}}.



Referenced by \mbox{\hyperlink{extmath_8py_source_l00542}{\+\_\+randomized\+\_\+svd()}}, and \mbox{\hyperlink{extmath_8py_source_l00217}{randomized\+\_\+range\+\_\+finder()}}.

\Hypertarget{namespacesklearn_1_1utils_1_1extmath_ab18bf68b74a698fcd7b87b6d7d09c317}\index{sklearn.utils.extmath@{sklearn.utils.extmath}!\_randomized\_svd@{\_randomized\_svd}}
\index{\_randomized\_svd@{\_randomized\_svd}!sklearn.utils.extmath@{sklearn.utils.extmath}}
\doxysubsubsection{\texorpdfstring{\_randomized\_svd()}{\_randomized\_svd()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1extmath_ab18bf68b74a698fcd7b87b6d7d09c317} 
sklearn.\+utils.\+extmath.\+\_\+randomized\+\_\+svd (\begin{DoxyParamCaption}\item[{}]{M}{, }\item[{}]{n\+\_\+components}{, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{n\+\_\+oversamples}{ = {\ttfamily 10}, }\item[{}]{n\+\_\+iter}{ = {\ttfamily "{}auto"{}}, }\item[{}]{power\+\_\+iteration\+\_\+normalizer}{ = {\ttfamily "{}auto"{}}, }\item[{}]{transpose}{ = {\ttfamily "{}auto"{}}, }\item[{}]{flip\+\_\+sign}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}, }\item[{}]{random\+\_\+state}{ = {\ttfamily None}, }\item[{}]{svd\+\_\+lapack\+\_\+driver}{ = {\ttfamily "{}gesdd"{}}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Body of randomized_svd without input validation.\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{extmath_8py_source_l00531}{531}} of file \mbox{\hyperlink{extmath_8py_source}{extmath.\+py}}.



References \mbox{\hyperlink{extmath_8py_source_l00289}{\+\_\+randomized\+\_\+range\+\_\+finder()}}, and \mbox{\hyperlink{extmath_8py_source_l00895}{svd\+\_\+flip()}}.



Referenced by \mbox{\hyperlink{extmath_8py_source_l00385}{randomized\+\_\+svd()}}.

\Hypertarget{namespacesklearn_1_1utils_1_1extmath_a19939f2804ad89d9a563a53f0af59ab6}\index{sklearn.utils.extmath@{sklearn.utils.extmath}!\_safe\_accumulator\_op@{\_safe\_accumulator\_op}}
\index{\_safe\_accumulator\_op@{\_safe\_accumulator\_op}!sklearn.utils.extmath@{sklearn.utils.extmath}}
\doxysubsubsection{\texorpdfstring{\_safe\_accumulator\_op()}{\_safe\_accumulator\_op()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1extmath_a19939f2804ad89d9a563a53f0af59ab6} 
sklearn.\+utils.\+extmath.\+\_\+safe\+\_\+accumulator\+\_\+op (\begin{DoxyParamCaption}\item[{}]{op}{, }\item[{}]{x}{, }\item[{\texorpdfstring{$\ast$}{*}}]{args}{, }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{kwargs}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}This function provides numpy accumulator functions with a float64 dtype
when used on a floating point input. This prevents accumulator overflow on
smaller floating point dtypes.

Parameters
----------
op : function
    A numpy accumulator function such as np.mean or np.sum.
x : ndarray
    A numpy array to apply the accumulator function.
*args : positional arguments
    Positional arguments passed to the accumulator function after the
    input x.
**kwargs : keyword arguments
    Keyword arguments passed to the accumulator function.

Returns
-------
result
    The output of the accumulator function passed to this function.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{extmath_8py_source_l01034}{1034}} of file \mbox{\hyperlink{extmath_8py_source}{extmath.\+py}}.



Referenced by \mbox{\hyperlink{extmath_8py_source_l01066}{\+\_\+incremental\+\_\+mean\+\_\+and\+\_\+var()}}.

\Hypertarget{namespacesklearn_1_1utils_1_1extmath_ad2780457312fed7f3b34ff7ad32210e6}\index{sklearn.utils.extmath@{sklearn.utils.extmath}!cartesian@{cartesian}}
\index{cartesian@{cartesian}!sklearn.utils.extmath@{sklearn.utils.extmath}}
\doxysubsubsection{\texorpdfstring{cartesian()}{cartesian()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1extmath_ad2780457312fed7f3b34ff7ad32210e6} 
sklearn.\+utils.\+extmath.\+cartesian (\begin{DoxyParamCaption}\item[{}]{arrays}{, }\item[{}]{out}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Generate a cartesian product of input arrays.

Parameters
----------
arrays : list of array-like
    1-D arrays to form the cartesian product of.
out : ndarray of shape (M, len(arrays)), default=None
    Array to place the cartesian product in.

Returns
-------
out : ndarray of shape (M, len(arrays))
    Array containing the cartesian products formed of input arrays.
    If not provided, the `dtype` of the output array is set to the most
    permissive `dtype` of the input arrays, according to NumPy type
    promotion.

    .. versionadded:: 1.2
       Add support for arrays of different types.

Notes
-----
This function may not be used on more than 32 arrays
because the underlying numpy functions do not support it.

Examples
--------
>>> from sklearn.utils.extmath import cartesian
>>> cartesian(([1, 2, 3], [4, 5], [6, 7]))
array([[1, 4, 6],
       [1, 4, 7],
       [1, 5, 6],
       [1, 5, 7],
       [2, 4, 6],
       [2, 4, 7],
       [2, 5, 6],
       [2, 5, 7],
       [3, 4, 6],
       [3, 4, 7],
       [3, 5, 6],
       [3, 5, 7]])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{extmath_8py_source_l00836}{836}} of file \mbox{\hyperlink{extmath_8py_source}{extmath.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1extmath_a9b7d337fff48876bbf09f62c68f186a9}\index{sklearn.utils.extmath@{sklearn.utils.extmath}!density@{density}}
\index{density@{density}!sklearn.utils.extmath@{sklearn.utils.extmath}}
\doxysubsubsection{\texorpdfstring{density()}{density()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1extmath_a9b7d337fff48876bbf09f62c68f186a9} 
sklearn.\+utils.\+extmath.\+density (\begin{DoxyParamCaption}\item[{}]{w}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute density of a sparse vector.

Parameters
----------
w : {ndarray, sparse matrix}
    The input data can be numpy ndarray or a sparse matrix.

Returns
-------
float
    The density of w, between 0 and 1.

Examples
--------
>>> from scipy import sparse
>>> from sklearn.utils.extmath import density
>>> X = sparse.random(10, 10, density=0.25, random_state=0)
>>> density(X)
0.25
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{extmath_8py_source_l00125}{125}} of file \mbox{\hyperlink{extmath_8py_source}{extmath.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1extmath_a9839591c7220d735c3bebc11d4ad603b}\index{sklearn.utils.extmath@{sklearn.utils.extmath}!fast\_logdet@{fast\_logdet}}
\index{fast\_logdet@{fast\_logdet}!sklearn.utils.extmath@{sklearn.utils.extmath}}
\doxysubsubsection{\texorpdfstring{fast\_logdet()}{fast\_logdet()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1extmath_a9839591c7220d735c3bebc11d4ad603b} 
sklearn.\+utils.\+extmath.\+fast\+\_\+logdet (\begin{DoxyParamCaption}\item[{}]{A}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute logarithm of determinant of a square matrix.

The (natural) logarithm of the determinant of a square matrix
is returned if det(A) is non-negative and well defined.
If the determinant is zero or negative returns -Inf.

Equivalent to : np.log(np.det(A)) but more robust.

Parameters
----------
A : array_like of shape (n, n)
    The square matrix.

Returns
-------
logdet : float
    When det(A) is strictly positive, log(det(A)) is returned.
    When det(A) is non-positive or not defined, then -inf is returned.

See Also
--------
numpy.linalg.slogdet : Compute the sign and (natural) logarithm of the determinant
    of an array.

Examples
--------
>>> import numpy as np
>>> from sklearn.utils.extmath import fast_logdet
>>> a = np.array([[5, 1], [2, 8]])
>>> fast_logdet(a)
np.float64(3.6375861597263857)
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{extmath_8py_source_l00085}{85}} of file \mbox{\hyperlink{extmath_8py_source}{extmath.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1extmath_a6effd449b565544a97f4d5a301c09ccb}\index{sklearn.utils.extmath@{sklearn.utils.extmath}!make\_nonnegative@{make\_nonnegative}}
\index{make\_nonnegative@{make\_nonnegative}!sklearn.utils.extmath@{sklearn.utils.extmath}}
\doxysubsubsection{\texorpdfstring{make\_nonnegative()}{make\_nonnegative()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1extmath_a6effd449b565544a97f4d5a301c09ccb} 
sklearn.\+utils.\+extmath.\+make\+\_\+nonnegative (\begin{DoxyParamCaption}\item[{}]{X}{, }\item[{}]{min\+\_\+value}{ = {\ttfamily 0}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Ensure `X.min()` >= `min_value`.

Parameters
----------
X : array-like
    The matrix to make non-negative.
min_value : float, default=0
    The threshold value.

Returns
-------
array-like
    The thresholded array.

Raises
------
ValueError
    When X is sparse.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{extmath_8py_source_l00998}{998}} of file \mbox{\hyperlink{extmath_8py_source}{extmath.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1extmath_a0af255d472410836f61a4135797f63f6}\index{sklearn.utils.extmath@{sklearn.utils.extmath}!randomized\_range\_finder@{randomized\_range\_finder}}
\index{randomized\_range\_finder@{randomized\_range\_finder}!sklearn.utils.extmath@{sklearn.utils.extmath}}
\doxysubsubsection{\texorpdfstring{randomized\_range\_finder()}{randomized\_range\_finder()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1extmath_a0af255d472410836f61a4135797f63f6} 
sklearn.\+utils.\+extmath.\+randomized\+\_\+range\+\_\+finder (\begin{DoxyParamCaption}\item[{}]{A}{, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{size}{, }\item[{}]{n\+\_\+iter}{, }\item[{}]{power\+\_\+iteration\+\_\+normalizer}{ = {\ttfamily "{}auto"{}}, }\item[{}]{random\+\_\+state}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute an orthonormal matrix whose range approximates the range of A.

Parameters
----------
A : {array-like, sparse matrix} of shape (n_samples, n_features)
    The input data matrix.

size : int
    Size of the return array.

n_iter : int
    Number of power iterations used to stabilize the result.

power_iteration_normalizer : {'auto', 'QR', 'LU', 'none'}, default='auto'
    Whether the power iterations are normalized with step-by-step
    QR factorization (the slowest but most accurate), 'none'
    (the fastest but numerically unstable when `n_iter` is large, e.g.
    typically 5 or larger), or 'LU' factorization (numerically stable
    but can lose slightly in accuracy). The 'auto' mode applies no
    normalization if `n_iter` <= 2 and switches to LU otherwise.

    .. versionadded:: 0.18

random_state : int, RandomState instance or None, default=None
    The seed of the pseudo random number generator to use when shuffling
    the data, i.e. getting the random vectors to initialize the algorithm.
    Pass an int for reproducible results across multiple function calls.
    See :term:`Glossary <random_state>`.

Returns
-------
Q : ndarray of shape (size, size)
    A projection matrix, the range of which approximates well the range of the
    input matrix A.

Notes
-----

Follows Algorithm 4.3 of
:arxiv:`"Finding structure with randomness:
Stochastic algorithms for constructing approximate matrix decompositions"
<0909.4061>`
Halko, et al. (2009)

An implementation of a randomized algorithm for principal component
analysis
A. Szlam et al. 2014

Examples
--------
>>> import numpy as np
>>> from sklearn.utils.extmath import randomized_range_finder
>>> A = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
>>> randomized_range_finder(A, size=2, n_iter=2, random_state=42)
array([[-0.214,  0.887],
       [-0.521,  0.249],
       [-0.826, -0.388]])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{extmath_8py_source_l00215}{215}} of file \mbox{\hyperlink{extmath_8py_source}{extmath.\+py}}.



References \mbox{\hyperlink{extmath_8py_source_l00289}{\+\_\+randomized\+\_\+range\+\_\+finder()}}.

\Hypertarget{namespacesklearn_1_1utils_1_1extmath_a73c744c7c6071db052edf0453545228e}\index{sklearn.utils.extmath@{sklearn.utils.extmath}!randomized\_svd@{randomized\_svd}}
\index{randomized\_svd@{randomized\_svd}!sklearn.utils.extmath@{sklearn.utils.extmath}}
\doxysubsubsection{\texorpdfstring{randomized\_svd()}{randomized\_svd()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1extmath_a73c744c7c6071db052edf0453545228e} 
sklearn.\+utils.\+extmath.\+randomized\+\_\+svd (\begin{DoxyParamCaption}\item[{}]{M}{, }\item[{}]{n\+\_\+components}{, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{n\+\_\+oversamples}{ = {\ttfamily 10}, }\item[{}]{n\+\_\+iter}{ = {\ttfamily "{}auto"{}}, }\item[{}]{power\+\_\+iteration\+\_\+normalizer}{ = {\ttfamily "{}auto"{}}, }\item[{}]{transpose}{ = {\ttfamily "{}auto"{}}, }\item[{}]{flip\+\_\+sign}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}, }\item[{}]{random\+\_\+state}{ = {\ttfamily None}, }\item[{}]{svd\+\_\+lapack\+\_\+driver}{ = {\ttfamily "{}gesdd"{}}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute a truncated randomized SVD.

This method solves the fixed-rank approximation problem described in [1]_
(problem (1.5), p5).

Refer to
:ref:`sphx_glr_auto_examples_applications_wikipedia_principal_eigenvector.py`
for a typical example where the power iteration algorithm is used to rank web pages.
This algorithm is also known to be used as a building block in Google's PageRank
algorithm.

Parameters
----------
M : {array-like, sparse matrix} of shape (n_samples, n_features)
    Matrix to decompose.

n_components : int
    Number of singular values and vectors to extract.

n_oversamples : int, default=10
    Additional number of random vectors to sample the range of `M` so as
    to ensure proper conditioning. The total number of random vectors
    used to find the range of `M` is `n_components + n_oversamples`. Smaller
    number can improve speed but can negatively impact the quality of
    approximation of singular vectors and singular values. Users might wish
    to increase this parameter up to `2*k - n_components` where k is the
    effective rank, for large matrices, noisy problems, matrices with
    slowly decaying spectrums, or to increase precision accuracy. See [1]_
    (pages 5, 23 and 26).

n_iter : int or 'auto', default='auto'
    Number of power iterations. It can be used to deal with very noisy
    problems. When 'auto', it is set to 4, unless `n_components` is small
    (< .1 * min(X.shape)) in which case `n_iter` is set to 7.
    This improves precision with few components. Note that in general
    users should rather increase `n_oversamples` before increasing `n_iter`
    as the principle of the randomized method is to avoid usage of these
    more costly power iterations steps. When `n_components` is equal
    or greater to the effective matrix rank and the spectrum does not
    present a slow decay, `n_iter=0` or `1` should even work fine in theory
    (see [1]_ page 9).

    .. versionchanged:: 0.18

power_iteration_normalizer : {'auto', 'QR', 'LU', 'none'}, default='auto'
    Whether the power iterations are normalized with step-by-step
    QR factorization (the slowest but most accurate), 'none'
    (the fastest but numerically unstable when `n_iter` is large, e.g.
    typically 5 or larger), or 'LU' factorization (numerically stable
    but can lose slightly in accuracy). The 'auto' mode applies no
    normalization if `n_iter` <= 2 and switches to LU otherwise.

    .. versionadded:: 0.18

transpose : bool or 'auto', default='auto'
    Whether the algorithm should be applied to M.T instead of M. The
    result should approximately be the same. The 'auto' mode will
    trigger the transposition if M.shape[1] > M.shape[0] since this
    implementation of randomized SVD tend to be a little faster in that
    case.

    .. versionchanged:: 0.18

flip_sign : bool, default=True
    The output of a singular value decomposition is only unique up to a
    permutation of the signs of the singular vectors. If `flip_sign` is
    set to `True`, the sign ambiguity is resolved by making the largest
    loadings for each component in the left singular vectors positive.

random_state : int, RandomState instance or None, default='warn'
    The seed of the pseudo random number generator to use when
    shuffling the data, i.e. getting the random vectors to initialize
    the algorithm. Pass an int for reproducible results across multiple
    function calls. See :term:`Glossary <random_state>`.

    .. versionchanged:: 1.2
        The default value changed from 0 to None.

svd_lapack_driver : {"gesdd", "gesvd"}, default="gesdd"
    Whether to use the more efficient divide-and-conquer approach
    (`"gesdd"`) or more general rectangular approach (`"gesvd"`) to compute
    the SVD of the matrix B, which is the projection of M into a low
    dimensional subspace, as described in [1]_.

    .. versionadded:: 1.2

Returns
-------
u : ndarray of shape (n_samples, n_components)
    Unitary matrix having left singular vectors with signs flipped as columns.
s : ndarray of shape (n_components,)
    The singular values, sorted in non-increasing order.
vh : ndarray of shape (n_components, n_features)
    Unitary matrix having right singular vectors with signs flipped as rows.

Notes
-----
This algorithm finds a (usually very good) approximate truncated
singular value decomposition using randomization to speed up the
computations. It is particularly fast on large matrices on which
you wish to extract only a small number of components. In order to
obtain further speed up, `n_iter` can be set <=2 (at the cost of
loss of precision). To increase the precision it is recommended to
increase `n_oversamples`, up to `2*k-n_components` where k is the
effective rank. Usually, `n_components` is chosen to be greater than k
so increasing `n_oversamples` up to `n_components` should be enough.

References
----------
.. [1] :arxiv:`"Finding structure with randomness:
  Stochastic algorithms for constructing approximate matrix decompositions"
  <0909.4061>`
  Halko, et al. (2009)

.. [2] A randomized algorithm for the decomposition of matrices
  Per-Gunnar Martinsson, Vladimir Rokhlin and Mark Tygert

.. [3] An implementation of a randomized algorithm for principal component
  analysis A. Szlam et al. 2014

Examples
--------
>>> import numpy as np
>>> from sklearn.utils.extmath import randomized_svd
>>> a = np.array([[1, 2, 3, 5],
...               [3, 4, 5, 6],
...               [7, 8, 9, 10]])
>>> U, s, Vh = randomized_svd(a, n_components=2, random_state=0)
>>> U.shape, s.shape, Vh.shape
((3, 2), (2,), (2, 4))
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{extmath_8py_source_l00374}{374}} of file \mbox{\hyperlink{extmath_8py_source}{extmath.\+py}}.



References \mbox{\hyperlink{extmath_8py_source_l00542}{\+\_\+randomized\+\_\+svd()}}.



Referenced by \mbox{\hyperlink{extmath_8py_source_l00616}{\+\_\+randomized\+\_\+eigsh()}}.

\Hypertarget{namespacesklearn_1_1utils_1_1extmath_ac3d9849e3c602ac89b59603797d8042c}\index{sklearn.utils.extmath@{sklearn.utils.extmath}!row\_norms@{row\_norms}}
\index{row\_norms@{row\_norms}!sklearn.utils.extmath@{sklearn.utils.extmath}}
\doxysubsubsection{\texorpdfstring{row\_norms()}{row\_norms()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1extmath_ac3d9849e3c602ac89b59603797d8042c} 
sklearn.\+utils.\+extmath.\+row\+\_\+norms (\begin{DoxyParamCaption}\item[{}]{X}{, }\item[{}]{squared}{ = {\ttfamily False}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Row-wise (squared) Euclidean norm of X.

Equivalent to np.sqrt((X * X).sum(axis=1)), but also supports sparse
matrices and does not create an X.shape-sized temporary.

Performs no input validation.

Parameters
----------
X : array-like
    The input array.
squared : bool, default=False
    If True, return squared norms.

Returns
-------
array-like
    The row-wise (squared) Euclidean norm of X.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{extmath_8py_source_l00047}{47}} of file \mbox{\hyperlink{extmath_8py_source}{extmath.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1extmath_aa17653afca24a9fc1bbcc619cf0a2448}\index{sklearn.utils.extmath@{sklearn.utils.extmath}!safe\_sparse\_dot@{safe\_sparse\_dot}}
\index{safe\_sparse\_dot@{safe\_sparse\_dot}!sklearn.utils.extmath@{sklearn.utils.extmath}}
\doxysubsubsection{\texorpdfstring{safe\_sparse\_dot()}{safe\_sparse\_dot()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1extmath_aa17653afca24a9fc1bbcc619cf0a2448} 
sklearn.\+utils.\+extmath.\+safe\+\_\+sparse\+\_\+dot (\begin{DoxyParamCaption}\item[{}]{a}{, }\item[{}]{b}{, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{dense\+\_\+output}{ = {\ttfamily False}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Dot product that handle the sparse matrix case correctly.

Parameters
----------
a : {ndarray, sparse matrix}
b : {ndarray, sparse matrix}
dense_output : bool, default=False
    When False, ``a`` and ``b`` both being sparse will yield sparse output.
    When True, output will always be a dense array.

Returns
-------
dot_product : {ndarray, sparse matrix}
    Sparse if ``a`` and ``b`` are sparse and ``dense_output=False``.

Examples
--------
>>> from scipy.sparse import csr_matrix
>>> from sklearn.utils.extmath import safe_sparse_dot
>>> X = csr_matrix([[1, 2], [3, 4], [5, 6]])
>>> dot_product = safe_sparse_dot(X, X.T)
>>> dot_product.toarray()
array([[ 5, 11, 17],
       [11, 25, 39],
       [17, 39, 61]])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{extmath_8py_source_l00153}{153}} of file \mbox{\hyperlink{extmath_8py_source}{extmath.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1extmath_a0ee7c6b49635b7c7a7721162f864ad64}\index{sklearn.utils.extmath@{sklearn.utils.extmath}!safe\_sqr@{safe\_sqr}}
\index{safe\_sqr@{safe\_sqr}!sklearn.utils.extmath@{sklearn.utils.extmath}}
\doxysubsubsection{\texorpdfstring{safe\_sqr()}{safe\_sqr()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1extmath_a0ee7c6b49635b7c7a7721162f864ad64} 
sklearn.\+utils.\+extmath.\+safe\+\_\+sqr (\begin{DoxyParamCaption}\item[{}]{X}{, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{copy}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Element wise squaring of array-likes and sparse matrices.

Parameters
----------
X : {array-like, ndarray, sparse matrix}

copy : bool, default=True
    Whether to create a copy of X and operate on it or to perform
    inplace computation (default behaviour).

Returns
-------
X ** 2 : element wise square
     Return the element-wise square of the input.

Examples
--------
>>> from sklearn.utils import safe_sqr
>>> safe_sqr([1, 2, 3])
array([1, 4, 9])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{extmath_8py_source_l01294}{1294}} of file \mbox{\hyperlink{extmath_8py_source}{extmath.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1extmath_a5a030f453adb35a00f5f860b31cd3f3e}\index{sklearn.utils.extmath@{sklearn.utils.extmath}!softmax@{softmax}}
\index{softmax@{softmax}!sklearn.utils.extmath@{sklearn.utils.extmath}}
\doxysubsubsection{\texorpdfstring{softmax()}{softmax()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1extmath_a5a030f453adb35a00f5f860b31cd3f3e} 
sklearn.\+utils.\+extmath.\+softmax (\begin{DoxyParamCaption}\item[{}]{X}{, }\item[{}]{copy}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Calculate the softmax function.

The softmax function is calculated by
np.exp(X) / np.sum(np.exp(X), axis=1)

This will cause overflow when large values are exponentiated.
Hence the largest value in each row is subtracted from each data
point to prevent this.

Parameters
----------
X : array-like of float of shape (M, N)
    Argument to the logistic function.

copy : bool, default=True
    Copy X or not.

Returns
-------
out : ndarray of shape (M, N)
    Softmax function evaluated at every point in x.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{extmath_8py_source_l00956}{956}} of file \mbox{\hyperlink{extmath_8py_source}{extmath.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1extmath_a6a39b4b4b5f631c8f0652304fda26a54}\index{sklearn.utils.extmath@{sklearn.utils.extmath}!squared\_norm@{squared\_norm}}
\index{squared\_norm@{squared\_norm}!sklearn.utils.extmath@{sklearn.utils.extmath}}
\doxysubsubsection{\texorpdfstring{squared\_norm()}{squared\_norm()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1extmath_a6a39b4b4b5f631c8f0652304fda26a54} 
sklearn.\+utils.\+extmath.\+squared\+\_\+norm (\begin{DoxyParamCaption}\item[{}]{x}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Squared Euclidean or Frobenius norm of x.

Faster than norm(x) ** 2.

Parameters
----------
x : array-like
    The input array which could be either be a vector or a 2 dimensional array.

Returns
-------
float
    The Euclidean norm when x is a vector, the Frobenius norm when x
    is a matrix (2-d array).
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{extmath_8py_source_l00019}{19}} of file \mbox{\hyperlink{extmath_8py_source}{extmath.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1extmath_a7c2292c77ff1021f1f2c33dc369da054}\index{sklearn.utils.extmath@{sklearn.utils.extmath}!stable\_cumsum@{stable\_cumsum}}
\index{stable\_cumsum@{stable\_cumsum}!sklearn.utils.extmath@{sklearn.utils.extmath}}
\doxysubsubsection{\texorpdfstring{stable\_cumsum()}{stable\_cumsum()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1extmath_a7c2292c77ff1021f1f2c33dc369da054} 
sklearn.\+utils.\+extmath.\+stable\+\_\+cumsum (\begin{DoxyParamCaption}\item[{}]{arr}{, }\item[{}]{axis}{ = {\ttfamily None}, }\item[{}]{rtol}{ = {\ttfamily 1e-\/05}, }\item[{}]{atol}{ = {\ttfamily 1e-\/08}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Use high precision for cumsum and check that final value matches sum.

Warns if the final cumulative sum does not match the sum (up to the chosen
tolerance).

Parameters
----------
arr : array-like
    To be cumulatively summed as flat.
axis : int, default=None
    Axis along which the cumulative sum is computed.
    The default (None) is to compute the cumsum over the flattened array.
rtol : float, default=1e-05
    Relative tolerance, see ``np.allclose``.
atol : float, default=1e-08
    Absolute tolerance, see ``np.allclose``.

Returns
-------
out : ndarray
    Array with the cumulative sums along the chosen axis.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{extmath_8py_source_l01212}{1212}} of file \mbox{\hyperlink{extmath_8py_source}{extmath.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1extmath_aeb7d1817c732296d017ee3ebd9c9ded7}\index{sklearn.utils.extmath@{sklearn.utils.extmath}!svd\_flip@{svd\_flip}}
\index{svd\_flip@{svd\_flip}!sklearn.utils.extmath@{sklearn.utils.extmath}}
\doxysubsubsection{\texorpdfstring{svd\_flip()}{svd\_flip()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1extmath_aeb7d1817c732296d017ee3ebd9c9ded7} 
sklearn.\+utils.\+extmath.\+svd\+\_\+flip (\begin{DoxyParamCaption}\item[{}]{u}{, }\item[{}]{v}{, }\item[{}]{u\+\_\+based\+\_\+decision}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Sign correction to ensure deterministic output from SVD.

Adjusts the columns of u and the rows of v such that the loadings in the
columns in u that are largest in absolute value are always positive.

If u_based_decision is False, then the same sign correction is applied to
so that the rows in v that are largest in absolute value are always
positive.

Parameters
----------
u : ndarray
    Parameters u and v are the output of `linalg.svd` or
    :func:`~sklearn.utils.extmath.randomized_svd`, with matching inner
    dimensions so one can compute `np.dot(u * s, v)`.
    u can be None if `u_based_decision` is False.

v : ndarray
    Parameters u and v are the output of `linalg.svd` or
    :func:`~sklearn.utils.extmath.randomized_svd`, with matching inner
    dimensions so one can compute `np.dot(u * s, v)`. The input v should
    really be called vt to be consistent with scipy's output.
    v can be None if `u_based_decision` is True.

u_based_decision : bool, default=True
    If True, use the columns of u as the basis for sign flipping.
    Otherwise, use the rows of v. The choice of which variable to base the
    decision on is generally algorithm dependent.

Returns
-------
u_adjusted : ndarray
    Array u with adjusted columns and the same dimensions as u.

v_adjusted : ndarray
    Array v with adjusted rows and the same dimensions as v.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{extmath_8py_source_l00895}{895}} of file \mbox{\hyperlink{extmath_8py_source}{extmath.\+py}}.



Referenced by \mbox{\hyperlink{extmath_8py_source_l00542}{\+\_\+randomized\+\_\+svd()}}.

\Hypertarget{namespacesklearn_1_1utils_1_1extmath_aa5545b350d5b9606fd2a385b70ca5d2a}\index{sklearn.utils.extmath@{sklearn.utils.extmath}!weighted\_mode@{weighted\_mode}}
\index{weighted\_mode@{weighted\_mode}!sklearn.utils.extmath@{sklearn.utils.extmath}}
\doxysubsubsection{\texorpdfstring{weighted\_mode()}{weighted\_mode()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1extmath_aa5545b350d5b9606fd2a385b70ca5d2a} 
sklearn.\+utils.\+extmath.\+weighted\+\_\+mode (\begin{DoxyParamCaption}\item[{}]{a}{, }\item[{}]{w}{, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{axis}{ = {\ttfamily 0}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Return an array of the weighted modal (most common) value in the passed array.

If there is more than one such value, only the first is returned.
The bin-count for the modal bins is also returned.

This is an extension of the algorithm in scipy.stats.mode.

Parameters
----------
a : array-like of shape (n_samples,)
    Array of which values to find mode(s).
w : array-like of shape (n_samples,)
    Array of weights for each value.
axis : int, default=0
    Axis along which to operate. Default is 0, i.e. the first axis.

Returns
-------
vals : ndarray
    Array of modal values.
score : ndarray
    Array of weighted counts for each mode.

See Also
--------
scipy.stats.mode: Calculates the Modal (most common) value of array elements
    along specified axis.

Examples
--------
>>> from sklearn.utils.extmath import weighted_mode
>>> x = [4, 1, 4, 2, 4, 2]
>>> weights = [1, 1, 1, 1, 1, 1]
>>> weighted_mode(x, weights)
(array([4.]), array([3.]))

The value 4 appears three times: with uniform weights, the result is
simply the mode of the distribution.

>>> weights = [1, 3, 0.5, 1.5, 1, 2]  # deweight the 4's
>>> weighted_mode(x, weights)
(array([2.]), array([3.5]))

The value 2 has the highest score: it appears twice with weights of
1.5 and 2: the sum of these is 3.5.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{extmath_8py_source_l00762}{762}} of file \mbox{\hyperlink{extmath_8py_source}{extmath.\+py}}.

