\doxysection{scipy.\+signal.\+\_\+waveforms Namespace Reference}
\hypertarget{namespacescipy_1_1signal_1_1__waveforms}{}\label{namespacescipy_1_1signal_1_1__waveforms}\index{scipy.signal.\_waveforms@{scipy.signal.\_waveforms}}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__waveforms_aacb8ce38bba0042740fff01beb9cf890}{sawtooth}} (t, width=1)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__waveforms_a182fa8b44771b6a618eb53e44d337a19}{square}} (t, duty=0.\+5)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__waveforms_a9da85d63820f00d17096b4699c42001b}{gausspulse}} (t, fc=1000, bw=0.\+5, bwr=-\/6, tpr=-\/60, retquad=False, retenv=False)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__waveforms_a11a79adfb8ac3f64d9516e912c3e2885}{chirp}} (t, f0, t1, f1, method=\textquotesingle{}linear\textquotesingle{}, phi=0, vertex\+\_\+zero=\mbox{\hyperlink{classTrue}{True}})
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__waveforms_ac79b68fc37e9d3b625e9bc1cb200991c}{\+\_\+chirp\+\_\+phase}} (t, f0, t1, f1, method=\textquotesingle{}linear\textquotesingle{}, vertex\+\_\+zero=\mbox{\hyperlink{classTrue}{True}})
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__waveforms_a2f5d7880b85b7df933539865ab611a4e}{sweep\+\_\+poly}} (t, poly, phi=0)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__waveforms_add86ffa68fa6a23bfda8a34922a4abf3}{\+\_\+sweep\+\_\+poly\+\_\+phase}} (t, poly)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__waveforms_a1db00e42ece6d24202f590c40591135e}{unit\+\_\+impulse}} (shape, idx=None, dtype=float)
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
list \mbox{\hyperlink{namespacescipy_1_1signal_1_1__waveforms_a67f3eb59ed5afaf9357a88992d366ee0}{\+\_\+\+\_\+all\+\_\+\+\_\+}}
\end{DoxyCompactItemize}


\doxysubsection{Function Documentation}
\Hypertarget{namespacescipy_1_1signal_1_1__waveforms_ac79b68fc37e9d3b625e9bc1cb200991c}\index{scipy.signal.\_waveforms@{scipy.signal.\_waveforms}!\_chirp\_phase@{\_chirp\_phase}}
\index{\_chirp\_phase@{\_chirp\_phase}!scipy.signal.\_waveforms@{scipy.signal.\_waveforms}}
\doxysubsubsection{\texorpdfstring{\_chirp\_phase()}{\_chirp\_phase()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__waveforms_ac79b68fc37e9d3b625e9bc1cb200991c} 
scipy.\+signal.\+\_\+waveforms.\+\_\+chirp\+\_\+phase (\begin{DoxyParamCaption}\item[{}]{t}{, }\item[{}]{f0}{, }\item[{}]{t1}{, }\item[{}]{f1}{, }\item[{}]{method}{ = {\ttfamily \textquotesingle{}linear\textquotesingle{}}, }\item[{}]{vertex\+\_\+zero}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Calculate the phase used by `chirp` to generate its output.

See `chirp` for a description of the arguments.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__waveforms_8py_source_l00422}{422}} of file \mbox{\hyperlink{__waveforms_8py_source}{\+\_\+waveforms.\+py}}.



Referenced by \mbox{\hyperlink{__waveforms_8py_source_l00264}{chirp()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__waveforms_add86ffa68fa6a23bfda8a34922a4abf3}\index{scipy.signal.\_waveforms@{scipy.signal.\_waveforms}!\_sweep\_poly\_phase@{\_sweep\_poly\_phase}}
\index{\_sweep\_poly\_phase@{\_sweep\_poly\_phase}!scipy.signal.\_waveforms@{scipy.signal.\_waveforms}}
\doxysubsubsection{\texorpdfstring{\_sweep\_poly\_phase()}{\_sweep\_poly\_phase()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__waveforms_add86ffa68fa6a23bfda8a34922a4abf3} 
scipy.\+signal.\+\_\+waveforms.\+\_\+sweep\+\_\+poly\+\_\+phase (\begin{DoxyParamCaption}\item[{}]{t}{, }\item[{}]{poly}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Calculate the phase used by sweep_poly to generate its output.

See `sweep_poly` for a description of the arguments.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__waveforms_8py_source_l00573}{573}} of file \mbox{\hyperlink{__waveforms_8py_source}{\+\_\+waveforms.\+py}}.



Referenced by \mbox{\hyperlink{__waveforms_8py_source_l00475}{sweep\+\_\+poly()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__waveforms_a11a79adfb8ac3f64d9516e912c3e2885}\index{scipy.signal.\_waveforms@{scipy.signal.\_waveforms}!chirp@{chirp}}
\index{chirp@{chirp}!scipy.signal.\_waveforms@{scipy.signal.\_waveforms}}
\doxysubsubsection{\texorpdfstring{chirp()}{chirp()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__waveforms_a11a79adfb8ac3f64d9516e912c3e2885} 
scipy.\+signal.\+\_\+waveforms.\+chirp (\begin{DoxyParamCaption}\item[{}]{t}{, }\item[{}]{f0}{, }\item[{}]{t1}{, }\item[{}]{f1}{, }\item[{}]{method}{ = {\ttfamily \textquotesingle{}linear\textquotesingle{}}, }\item[{}]{phi}{ = {\ttfamily 0}, }\item[{}]{vertex\+\_\+zero}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Frequency-swept cosine generator.

In the following, 'Hz' should be interpreted as 'cycles per unit';
there is no requirement here that the unit is one second.  The
important distinction is that the units of rotation are cycles, not
radians. Likewise, `t` could be a measurement of space instead of time.

Parameters
----------
t : array_like
    Times at which to evaluate the waveform.
f0 : float
    Frequency (e.g. Hz) at time t=0.
t1 : float
    Time at which `f1` is specified.
f1 : float
    Frequency (e.g. Hz) of the waveform at time `t1`.
method : {'linear', 'quadratic', 'logarithmic', 'hyperbolic'}, optional
    Kind of frequency sweep.  If not given, `linear` is assumed.  See
    Notes below for more details.
phi : float, optional
    Phase offset, in degrees. Default is 0.
vertex_zero : bool, optional
    This parameter is only used when `method` is 'quadratic'.
    It determines whether the vertex of the parabola that is the graph
    of the frequency is at t=0 or t=t1.

Returns
-------
y : ndarray
    A numpy array containing the signal evaluated at `t` with the
    requested time-varying frequency.  More precisely, the function
    returns ``cos(phase + (pi/180)*phi)`` where `phase` is the integral
    (from 0 to `t`) of ``2*pi*f(t)``. ``f(t)`` is defined below.

See Also
--------
sweep_poly

Notes
-----
There are four options for the `method`.  The following formulas give
the instantaneous frequency (in Hz) of the signal generated by
`chirp()`.  For convenience, the shorter names shown below may also be
used.

linear, lin, li:

    ``f(t) = f0 + (f1 - f0) * t / t1``

quadratic, quad, q:

    The graph of the frequency f(t) is a parabola through (0, f0) and
    (t1, f1).  By default, the vertex of the parabola is at (0, f0).
    If `vertex_zero` is False, then the vertex is at (t1, f1).  The
    formula is:

    if vertex_zero is True:

        ``f(t) = f0 + (f1 - f0) * t**2 / t1**2``

    else:

        ``f(t) = f1 - (f1 - f0) * (t1 - t)**2 / t1**2``

    To use a more general quadratic function, or an arbitrary
    polynomial, use the function `scipy.signal.sweep_poly`.

logarithmic, log, lo:

    ``f(t) = f0 * (f1/f0)**(t/t1)``

    f0 and f1 must be nonzero and have the same sign.

    This signal is also known as a geometric or exponential chirp.

hyperbolic, hyp:

    ``f(t) = f0*f1*t1 / ((f0 - f1)*t + f1*t1)``

    f0 and f1 must be nonzero.

Examples
--------
The following will be used in the examples:

>>> import numpy as np
>>> from scipy.signal import chirp, spectrogram
>>> import matplotlib.pyplot as plt

For the first example, we'll plot the waveform for a linear chirp
from 6 Hz to 1 Hz over 10 seconds:

>>> t = np.linspace(0, 10, 1500)
>>> w = chirp(t, f0=6, f1=1, t1=10, method='linear')
>>> plt.plot(t, w)
>>> plt.title("Linear Chirp, f(0)=6, f(10)=1")
>>> plt.xlabel('t (sec)')
>>> plt.show()

For the remaining examples, we'll use higher frequency ranges,
and demonstrate the result using `scipy.signal.spectrogram`.
We'll use a 4 second interval sampled at 7200 Hz.

>>> fs = 7200
>>> T = 4
>>> t = np.arange(0, int(T*fs)) / fs

We'll use this function to plot the spectrogram in each example.

>>> def plot_spectrogram(title, w, fs):
...     ff, tt, Sxx = spectrogram(w, fs=fs, nperseg=256, nfft=576)
...     fig, ax = plt.subplots()
...     ax.pcolormesh(tt, ff[:145], Sxx[:145], cmap='gray_r',
...                   shading='gouraud')
...     ax.set_title(title)
...     ax.set_xlabel('t (sec)')
...     ax.set_ylabel('Frequency (Hz)')
...     ax.grid(True)
...

Quadratic chirp from 1500 Hz to 250 Hz
(vertex of the parabolic curve of the frequency is at t=0):

>>> w = chirp(t, f0=1500, f1=250, t1=T, method='quadratic')
>>> plot_spectrogram(f'Quadratic Chirp, f(0)=1500, f({T})=250', w, fs)
>>> plt.show()

Quadratic chirp from 1500 Hz to 250 Hz
(vertex of the parabolic curve of the frequency is at t=T):

>>> w = chirp(t, f0=1500, f1=250, t1=T, method='quadratic',
...           vertex_zero=False)
>>> plot_spectrogram(f'Quadratic Chirp, f(0)=1500, f({T})=250\\n' +
...                  '(vertex_zero=False)', w, fs)
>>> plt.show()

Logarithmic chirp from 1500 Hz to 250 Hz:

>>> w = chirp(t, f0=1500, f1=250, t1=T, method='logarithmic')
>>> plot_spectrogram(f'Logarithmic Chirp, f(0)=1500, f({T})=250', w, fs)
>>> plt.show()

Hyperbolic chirp from 1500 Hz to 250 Hz:

>>> w = chirp(t, f0=1500, f1=250, t1=T, method='hyperbolic')
>>> plot_spectrogram(f'Hyperbolic Chirp, f(0)=1500, f({T})=250', w, fs)
>>> plt.show()
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__waveforms_8py_source_l00264}{264}} of file \mbox{\hyperlink{__waveforms_8py_source}{\+\_\+waveforms.\+py}}.



References \mbox{\hyperlink{__waveforms_8py_source_l00422}{\+\_\+chirp\+\_\+phase()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__waveforms_a9da85d63820f00d17096b4699c42001b}\index{scipy.signal.\_waveforms@{scipy.signal.\_waveforms}!gausspulse@{gausspulse}}
\index{gausspulse@{gausspulse}!scipy.signal.\_waveforms@{scipy.signal.\_waveforms}}
\doxysubsubsection{\texorpdfstring{gausspulse()}{gausspulse()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__waveforms_a9da85d63820f00d17096b4699c42001b} 
scipy.\+signal.\+\_\+waveforms.\+gausspulse (\begin{DoxyParamCaption}\item[{}]{t}{, }\item[{}]{fc}{ = {\ttfamily 1000}, }\item[{}]{bw}{ = {\ttfamily 0.5}, }\item[{}]{bwr}{ = {\ttfamily -\/6}, }\item[{}]{tpr}{ = {\ttfamily -\/60}, }\item[{}]{retquad}{ = {\ttfamily False}, }\item[{}]{retenv}{ = {\ttfamily False}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Return a Gaussian modulated sinusoid:

    ``exp(-a t^2) exp(1j*2*pi*fc*t).``

If `retquad` is True, then return the real and imaginary parts
(in-phase and quadrature).
If `retenv` is True, then return the envelope (unmodulated signal).
Otherwise, return the real part of the modulated sinusoid.

Parameters
----------
t : ndarray or the string 'cutoff'
    Input array.
fc : float, optional
    Center frequency (e.g. Hz).  Default is 1000.
bw : float, optional
    Fractional bandwidth in frequency domain of pulse (e.g. Hz).
    Default is 0.5.
bwr : float, optional
    Reference level at which fractional bandwidth is calculated (dB).
    Default is -6.
tpr : float, optional
    If `t` is 'cutoff', then the function returns the cutoff
    time for when the pulse amplitude falls below `tpr` (in dB).
    Default is -60.
retquad : bool, optional
    If True, return the quadrature (imaginary) as well as the real part
    of the signal.  Default is False.
retenv : bool, optional
    If True, return the envelope of the signal.  Default is False.

Returns
-------
yI : ndarray
    Real part of signal.  Always returned.
yQ : ndarray
    Imaginary part of signal.  Only returned if `retquad` is True.
yenv : ndarray
    Envelope of signal.  Only returned if `retenv` is True.

See Also
--------
scipy.signal.morlet

Examples
--------
Plot real component, imaginary component, and envelope for a 5 Hz pulse,
sampled at 100 Hz for 2 seconds:

>>> import numpy as np
>>> from scipy import signal
>>> import matplotlib.pyplot as plt
>>> t = np.linspace(-1, 1, 2 * 100, endpoint=False)
>>> i, q, e = signal.gausspulse(t, fc=5, retquad=True, retenv=True)
>>> plt.plot(t, i, t, q, t, e, '--')
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__waveforms_8py_source_l00163}{163}} of file \mbox{\hyperlink{__waveforms_8py_source}{\+\_\+waveforms.\+py}}.

\Hypertarget{namespacescipy_1_1signal_1_1__waveforms_aacb8ce38bba0042740fff01beb9cf890}\index{scipy.signal.\_waveforms@{scipy.signal.\_waveforms}!sawtooth@{sawtooth}}
\index{sawtooth@{sawtooth}!scipy.signal.\_waveforms@{scipy.signal.\_waveforms}}
\doxysubsubsection{\texorpdfstring{sawtooth()}{sawtooth()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__waveforms_aacb8ce38bba0042740fff01beb9cf890} 
scipy.\+signal.\+\_\+waveforms.\+sawtooth (\begin{DoxyParamCaption}\item[{}]{t}{, }\item[{}]{width}{ = {\ttfamily 1}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Return a periodic sawtooth or triangle waveform.

The sawtooth waveform has a period ``2*pi``, rises from -1 to 1 on the
interval 0 to ``width*2*pi``, then drops from 1 to -1 on the interval
``width*2*pi`` to ``2*pi``. `width` must be in the interval [0, 1].

Note that this is not band-limited.  It produces an infinite number
of harmonics, which are aliased back and forth across the frequency
spectrum.

Parameters
----------
t : array_like
    Time.
width : array_like, optional
    Width of the rising ramp as a proportion of the total cycle.
    Default is 1, producing a rising ramp, while 0 produces a falling
    ramp.  `width` = 0.5 produces a triangle wave.
    If an array, causes wave shape to change over time, and must be the
    same length as t.

Returns
-------
y : ndarray
    Output array containing the sawtooth waveform.

Examples
--------
A 5 Hz waveform sampled at 500 Hz for 1 second:

>>> import numpy as np
>>> from scipy import signal
>>> import matplotlib.pyplot as plt
>>> t = np.linspace(0, 1, 500)
>>> plt.plot(t, signal.sawtooth(2 * np.pi * 5 * t))
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__waveforms_8py_source_l00016}{16}} of file \mbox{\hyperlink{__waveforms_8py_source}{\+\_\+waveforms.\+py}}.

\Hypertarget{namespacescipy_1_1signal_1_1__waveforms_a182fa8b44771b6a618eb53e44d337a19}\index{scipy.signal.\_waveforms@{scipy.signal.\_waveforms}!square@{square}}
\index{square@{square}!scipy.signal.\_waveforms@{scipy.signal.\_waveforms}}
\doxysubsubsection{\texorpdfstring{square()}{square()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__waveforms_a182fa8b44771b6a618eb53e44d337a19} 
scipy.\+signal.\+\_\+waveforms.\+square (\begin{DoxyParamCaption}\item[{}]{t}{, }\item[{}]{duty}{ = {\ttfamily 0.5}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Return a periodic square-wave waveform.

The square wave has a period ``2*pi``, has value +1 from 0 to
``2*pi*duty`` and -1 from ``2*pi*duty`` to ``2*pi``. `duty` must be in
the interval [0,1].

Note that this is not band-limited.  It produces an infinite number
of harmonics, which are aliased back and forth across the frequency
spectrum.

Parameters
----------
t : array_like
    The input time array.
duty : array_like, optional
    Duty cycle.  Default is 0.5 (50% duty cycle).
    If an array, causes wave shape to change over time, and must be the
    same length as t.

Returns
-------
y : ndarray
    Output array containing the square waveform.

Examples
--------
A 5 Hz waveform sampled at 500 Hz for 1 second:

>>> import numpy as np
>>> from scipy import signal
>>> import matplotlib.pyplot as plt
>>> t = np.linspace(0, 1, 500, endpoint=False)
>>> plt.plot(t, signal.square(2 * np.pi * 5 * t))
>>> plt.ylim(-2, 2)

A pulse-width modulated sine wave:

>>> plt.figure()
>>> sig = np.sin(2 * np.pi * t)
>>> pwm = signal.square(2 * np.pi * 30 * t, duty=(sig + 1)/2)
>>> plt.subplot(2, 1, 1)
>>> plt.plot(t, sig)
>>> plt.subplot(2, 1, 2)
>>> plt.plot(t, pwm)
>>> plt.ylim(-1.5, 1.5)
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__waveforms_8py_source_l00088}{88}} of file \mbox{\hyperlink{__waveforms_8py_source}{\+\_\+waveforms.\+py}}.

\Hypertarget{namespacescipy_1_1signal_1_1__waveforms_a2f5d7880b85b7df933539865ab611a4e}\index{scipy.signal.\_waveforms@{scipy.signal.\_waveforms}!sweep\_poly@{sweep\_poly}}
\index{sweep\_poly@{sweep\_poly}!scipy.signal.\_waveforms@{scipy.signal.\_waveforms}}
\doxysubsubsection{\texorpdfstring{sweep\_poly()}{sweep\_poly()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__waveforms_a2f5d7880b85b7df933539865ab611a4e} 
scipy.\+signal.\+\_\+waveforms.\+sweep\+\_\+poly (\begin{DoxyParamCaption}\item[{}]{t}{, }\item[{}]{poly}{, }\item[{}]{phi}{ = {\ttfamily 0}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Frequency-swept cosine generator, with a time-dependent frequency.

This function generates a sinusoidal function whose instantaneous
frequency varies with time.  The frequency at time `t` is given by
the polynomial `poly`.

Parameters
----------
t : ndarray
    Times at which to evaluate the waveform.
poly : 1-D array_like or instance of numpy.poly1d
    The desired frequency expressed as a polynomial.  If `poly` is
    a list or ndarray of length n, then the elements of `poly` are
    the coefficients of the polynomial, and the instantaneous
    frequency is

      ``f(t) = poly[0]*t**(n-1) + poly[1]*t**(n-2) + ... + poly[n-1]``

    If `poly` is an instance of numpy.poly1d, then the
    instantaneous frequency is

      ``f(t) = poly(t)``

phi : float, optional
    Phase offset, in degrees, Default: 0.

Returns
-------
sweep_poly : ndarray
    A numpy array containing the signal evaluated at `t` with the
    requested time-varying frequency.  More precisely, the function
    returns ``cos(phase + (pi/180)*phi)``, where `phase` is the integral
    (from 0 to t) of ``2 * pi * f(t)``; ``f(t)`` is defined above.

See Also
--------
chirp

Notes
-----
.. versionadded:: 0.8.0

If `poly` is a list or ndarray of length `n`, then the elements of
`poly` are the coefficients of the polynomial, and the instantaneous
frequency is:

    ``f(t) = poly[0]*t**(n-1) + poly[1]*t**(n-2) + ... + poly[n-1]``

If `poly` is an instance of `numpy.poly1d`, then the instantaneous
frequency is:

      ``f(t) = poly(t)``

Finally, the output `s` is:

    ``cos(phase + (pi/180)*phi)``

where `phase` is the integral from 0 to `t` of ``2 * pi * f(t)``,
``f(t)`` as defined above.

Examples
--------
Compute the waveform with instantaneous frequency::

    f(t) = 0.025*t**3 - 0.36*t**2 + 1.25*t + 2

over the interval 0 <= t <= 10.

>>> import numpy as np
>>> from scipy.signal import sweep_poly
>>> p = np.poly1d([0.025, -0.36, 1.25, 2.0])
>>> t = np.linspace(0, 10, 5001)
>>> w = sweep_poly(t, p)

Plot it:

>>> import matplotlib.pyplot as plt
>>> plt.subplot(2, 1, 1)
>>> plt.plot(t, w)
>>> plt.title("Sweep Poly\\nwith frequency " +
...           "$f(t) = 0.025t^3 - 0.36t^2 + 1.25t + 2$")
>>> plt.subplot(2, 1, 2)
>>> plt.plot(t, p(t), 'r', label='f(t)')
>>> plt.legend()
>>> plt.xlabel('t')
>>> plt.tight_layout()
>>> plt.show()
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__waveforms_8py_source_l00475}{475}} of file \mbox{\hyperlink{__waveforms_8py_source}{\+\_\+waveforms.\+py}}.



References \mbox{\hyperlink{__waveforms_8py_source_l00573}{\+\_\+sweep\+\_\+poly\+\_\+phase()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__waveforms_a1db00e42ece6d24202f590c40591135e}\index{scipy.signal.\_waveforms@{scipy.signal.\_waveforms}!unit\_impulse@{unit\_impulse}}
\index{unit\_impulse@{unit\_impulse}!scipy.signal.\_waveforms@{scipy.signal.\_waveforms}}
\doxysubsubsection{\texorpdfstring{unit\_impulse()}{unit\_impulse()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__waveforms_a1db00e42ece6d24202f590c40591135e} 
scipy.\+signal.\+\_\+waveforms.\+unit\+\_\+impulse (\begin{DoxyParamCaption}\item[{}]{shape}{, }\item[{}]{idx}{ = {\ttfamily None}, }\item[{}]{dtype}{ = {\ttfamily float}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Unit impulse signal (discrete delta function) or unit basis vector.

Parameters
----------
shape : int or tuple of int
    Number of samples in the output (1-D), or a tuple that represents the
    shape of the output (N-D).
idx : None or int or tuple of int or 'mid', optional
    Index at which the value is 1.  If None, defaults to the 0th element.
    If ``idx='mid'``, the impulse will be centered at ``shape // 2`` in
    all dimensions.  If an int, the impulse will be at `idx` in all
    dimensions.
dtype : data-type, optional
    The desired data-type for the array, e.g., ``numpy.int8``.  Default is
    ``numpy.float64``.

Returns
-------
y : ndarray
    Output array containing an impulse signal.

Notes
-----
The 1D case is also known as the Kronecker delta.

.. versionadded:: 0.19.0

Examples
--------
An impulse at the 0th element (:math:`\\delta[n]`):

>>> from scipy import signal
>>> signal.unit_impulse(8)
array([ 1.,  0.,  0.,  0.,  0.,  0.,  0.,  0.])

Impulse offset by 2 samples (:math:`\\delta[n-2]`):

>>> signal.unit_impulse(7, 2)
array([ 0.,  0.,  1.,  0.,  0.,  0.,  0.])

2-dimensional impulse, centered:

>>> signal.unit_impulse((3, 3), 'mid')
array([[ 0.,  0.,  0.],
       [ 0.,  1.,  0.],
       [ 0.,  0.,  0.]])

Impulse at (2, 2), using broadcasting:

>>> signal.unit_impulse((4, 4), 2)
array([[ 0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.],
       [ 0.,  0.,  1.,  0.],
       [ 0.,  0.,  0.,  0.]])

Plot the impulse response of a 4th-order Butterworth lowpass filter:

>>> imp = signal.unit_impulse(100, 'mid')
>>> b, a = signal.butter(4, 0.2)
>>> response = signal.lfilter(b, a, imp)

>>> import numpy as np
>>> import matplotlib.pyplot as plt
>>> plt.plot(np.arange(-50, 50), imp)
>>> plt.plot(np.arange(-50, 50), response)
>>> plt.margins(0.1, 0.1)
>>> plt.xlabel('Time [samples]')
>>> plt.ylabel('Amplitude')
>>> plt.grid(True)
>>> plt.show()
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__waveforms_8py_source_l00586}{586}} of file \mbox{\hyperlink{__waveforms_8py_source}{\+\_\+waveforms.\+py}}.



\doxysubsection{Variable Documentation}
\Hypertarget{namespacescipy_1_1signal_1_1__waveforms_a67f3eb59ed5afaf9357a88992d366ee0}\index{scipy.signal.\_waveforms@{scipy.signal.\_waveforms}!\_\_all\_\_@{\_\_all\_\_}}
\index{\_\_all\_\_@{\_\_all\_\_}!scipy.signal.\_waveforms@{scipy.signal.\_waveforms}}
\doxysubsubsection{\texorpdfstring{\_\_all\_\_}{\_\_all\_\_}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__waveforms_a67f3eb59ed5afaf9357a88992d366ee0} 
list scipy.\+signal.\+\_\+waveforms.\+\_\+\+\_\+all\+\_\+\+\_\+\hspace{0.3cm}{\ttfamily [private]}}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ [\textcolor{stringliteral}{'sawtooth'},\ \textcolor{stringliteral}{'square'},\ \textcolor{stringliteral}{'gausspulse'},\ \textcolor{stringliteral}{'chirp'},\ \textcolor{stringliteral}{'sweep\_poly'},}
\DoxyCodeLine{00002\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'unit\_impulse'}]}

\end{DoxyCode}


Definition at line \mbox{\hyperlink{__waveforms_8py_source_l00012}{12}} of file \mbox{\hyperlink{__waveforms_8py_source}{\+\_\+waveforms.\+py}}.

