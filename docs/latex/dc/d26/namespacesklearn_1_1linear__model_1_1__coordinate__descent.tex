\doxysection{sklearn.\+linear\+\_\+model.\+\_\+coordinate\+\_\+descent Namespace Reference}
\hypertarget{namespacesklearn_1_1linear__model_1_1__coordinate__descent}{}\label{namespacesklearn_1_1linear__model_1_1__coordinate__descent}\index{sklearn.linear\_model.\_coordinate\_descent@{sklearn.linear\_model.\_coordinate\_descent}}
\doxysubsubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classsklearn_1_1linear__model_1_1__coordinate__descent_1_1ElasticNet}{Elastic\+Net}}
\begin{DoxyCompactList}\small\item\em \doxylink{classsklearn_1_1linear__model_1_1__coordinate__descent_1_1ElasticNet}{Elastic\+Net} model. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classsklearn_1_1linear__model_1_1__coordinate__descent_1_1ElasticNetCV}{Elastic\+Net\+CV}}
\item 
class \mbox{\hyperlink{classsklearn_1_1linear__model_1_1__coordinate__descent_1_1Lasso}{Lasso}}
\item 
class \mbox{\hyperlink{classsklearn_1_1linear__model_1_1__coordinate__descent_1_1LassoCV}{Lasso\+CV}}
\item 
class \mbox{\hyperlink{classsklearn_1_1linear__model_1_1__coordinate__descent_1_1LinearModelCV}{Linear\+Model\+CV}}
\item 
class \mbox{\hyperlink{classsklearn_1_1linear__model_1_1__coordinate__descent_1_1MultiTaskElasticNet}{Multi\+Task\+Elastic\+Net}}
\item 
class \mbox{\hyperlink{classsklearn_1_1linear__model_1_1__coordinate__descent_1_1MultiTaskElasticNetCV}{Multi\+Task\+Elastic\+Net\+CV}}
\item 
class \mbox{\hyperlink{classsklearn_1_1linear__model_1_1__coordinate__descent_1_1MultiTaskLasso}{Multi\+Task\+Lasso}}
\item 
class \mbox{\hyperlink{classsklearn_1_1linear__model_1_1__coordinate__descent_1_1MultiTaskLassoCV}{Multi\+Task\+Lasso\+CV}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacesklearn_1_1linear__model_1_1__coordinate__descent_a401cd9902c04b523954361538181394a}{\+\_\+set\+\_\+order}} (X, y, order="{}C"{})
\item 
\mbox{\hyperlink{namespacesklearn_1_1linear__model_1_1__coordinate__descent_a1fd870009a68b7647caa340276cd8130}{\+\_\+alpha\+\_\+grid}} (X, y, Xy=None, l1\+\_\+ratio=1.\+0, fit\+\_\+intercept=\mbox{\hyperlink{classTrue}{True}}, eps=1e-\/3, n\+\_\+alphas=100, copy\+\_\+X=\mbox{\hyperlink{classTrue}{True}}, sample\+\_\+weight=None)
\begin{DoxyCompactList}\small\item\em Paths functions. \end{DoxyCompactList}\item 
\mbox{\hyperlink{namespacesklearn_1_1linear__model_1_1__coordinate__descent_abb33a827fc742e6cae15ebe2af3d40bc}{lasso\+\_\+path}} (X, y, \texorpdfstring{$\ast$}{*}, eps=1e-\/3, n\+\_\+alphas=100, alphas=None, precompute="{}auto"{}, Xy=None, copy\+\_\+X=\mbox{\hyperlink{classTrue}{True}}, coef\+\_\+init=None, verbose=False, return\+\_\+n\+\_\+iter=False, positive=False, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}params)
\item 
\mbox{\hyperlink{namespacesklearn_1_1linear__model_1_1__coordinate__descent_a355d76614a959aacd293a313d025a4e3}{enet\+\_\+path}} (X, y, \texorpdfstring{$\ast$}{*}, l1\+\_\+ratio=0.\+5, eps=1e-\/3, n\+\_\+alphas=100, alphas=None, precompute="{}auto"{}, Xy=None, copy\+\_\+X=\mbox{\hyperlink{classTrue}{True}}, coef\+\_\+init=None, verbose=False, return\+\_\+n\+\_\+iter=False, positive=False, check\+\_\+input=\mbox{\hyperlink{classTrue}{True}}, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}params)
\item 
\mbox{\hyperlink{namespacesklearn_1_1linear__model_1_1__coordinate__descent_a7896f61f556a9b3bb8a26402303001fb}{\+\_\+path\+\_\+residuals}} (X, y, sample\+\_\+weight, train, test, fit\+\_\+intercept, path, path\+\_\+params, alphas=None, l1\+\_\+ratio=1, X\+\_\+order=None, dtype=None)
\end{DoxyCompactItemize}


\doxysubsection{Function Documentation}
\Hypertarget{namespacesklearn_1_1linear__model_1_1__coordinate__descent_a1fd870009a68b7647caa340276cd8130}\index{sklearn.linear\_model.\_coordinate\_descent@{sklearn.linear\_model.\_coordinate\_descent}!\_alpha\_grid@{\_alpha\_grid}}
\index{\_alpha\_grid@{\_alpha\_grid}!sklearn.linear\_model.\_coordinate\_descent@{sklearn.linear\_model.\_coordinate\_descent}}
\doxysubsubsection{\texorpdfstring{\_alpha\_grid()}{\_alpha\_grid()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1linear__model_1_1__coordinate__descent_a1fd870009a68b7647caa340276cd8130} 
sklearn.\+linear\+\_\+model.\+\_\+coordinate\+\_\+descent.\+\_\+alpha\+\_\+grid (\begin{DoxyParamCaption}\item[{}]{X}{, }\item[{}]{y}{, }\item[{}]{Xy}{ = {\ttfamily None}, }\item[{}]{l1\+\_\+ratio}{ = {\ttfamily 1.0}, }\item[{}]{fit\+\_\+intercept}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}, }\item[{}]{eps}{ = {\ttfamily 1e-\/3}, }\item[{}]{n\+\_\+alphas}{ = {\ttfamily 100}, }\item[{}]{copy\+\_\+X}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}, }\item[{}]{sample\+\_\+weight}{ = {\ttfamily None}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Paths functions. 

\begin{DoxyVerb}Compute the grid of alpha values for elastic net parameter search

Parameters
----------
X : {array-like, sparse matrix} of shape (n_samples, n_features)
    Training data. Pass directly as Fortran-contiguous data to avoid
    unnecessary memory duplication

y : ndarray of shape (n_samples,) or (n_samples, n_outputs)
    Target values

Xy : array-like of shape (n_features,) or (n_features, n_outputs),\
     default=None
    Xy = np.dot(X.T, y) that can be precomputed.

l1_ratio : float, default=1.0
    The elastic net mixing parameter, with ``0 < l1_ratio <= 1``.
    For ``l1_ratio = 0`` the penalty is an L2 penalty. (currently not
    supported) ``For l1_ratio = 1`` it is an L1 penalty. For
    ``0 < l1_ratio <1``, the penalty is a combination of L1 and L2.

eps : float, default=1e-3
    Length of the path. ``eps=1e-3`` means that
    ``alpha_min / alpha_max = 1e-3``

n_alphas : int, default=100
    Number of alphas along the regularization path

fit_intercept : bool, default=True
    Whether to fit an intercept or not

copy_X : bool, default=True
    If ``True``, X will be copied; else, it may be overwritten.

sample_weight : ndarray of shape (n_samples,), default=None
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__coordinate__descent_8py_source_l00095}{95}} of file \mbox{\hyperlink{__coordinate__descent_8py_source}{\+\_\+coordinate\+\_\+descent.\+py}}.



Referenced by \mbox{\hyperlink{__coordinate__descent_8py_source_l00413}{enet\+\_\+path()}}, and \mbox{\hyperlink{__coordinate__descent_8py_source_l01576}{sklearn.\+linear\+\_\+model.\+\_\+coordinate\+\_\+descent.\+Linear\+Model\+CV.\+fit()}}.

\Hypertarget{namespacesklearn_1_1linear__model_1_1__coordinate__descent_a7896f61f556a9b3bb8a26402303001fb}\index{sklearn.linear\_model.\_coordinate\_descent@{sklearn.linear\_model.\_coordinate\_descent}!\_path\_residuals@{\_path\_residuals}}
\index{\_path\_residuals@{\_path\_residuals}!sklearn.linear\_model.\_coordinate\_descent@{sklearn.linear\_model.\_coordinate\_descent}}
\doxysubsubsection{\texorpdfstring{\_path\_residuals()}{\_path\_residuals()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1linear__model_1_1__coordinate__descent_a7896f61f556a9b3bb8a26402303001fb} 
sklearn.\+linear\+\_\+model.\+\_\+coordinate\+\_\+descent.\+\_\+path\+\_\+residuals (\begin{DoxyParamCaption}\item[{}]{X}{, }\item[{}]{y}{, }\item[{}]{sample\+\_\+weight}{, }\item[{}]{train}{, }\item[{}]{test}{, }\item[{}]{fit\+\_\+intercept}{, }\item[{}]{path}{, }\item[{}]{path\+\_\+params}{, }\item[{}]{alphas}{ = {\ttfamily None}, }\item[{}]{l1\+\_\+ratio}{ = {\ttfamily 1}, }\item[{}]{X\+\_\+order}{ = {\ttfamily None}, }\item[{}]{dtype}{ = {\ttfamily None}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Returns the MSE for the models computed by 'path'.

Parameters
----------
X : {array-like, sparse matrix} of shape (n_samples, n_features)
    Training data.

y : array-like of shape (n_samples,) or (n_samples, n_targets)
    Target values.

sample_weight : None or array-like of shape (n_samples,)
    Sample weights.

train : list of indices
    The indices of the train set.

test : list of indices
    The indices of the test set.

path : callable
    Function returning a list of models on the path. See
    enet_path for an example of signature.

path_params : dictionary
    Parameters passed to the path function.

alphas : array-like, default=None
    Array of float that is used for cross-validation. If not
    provided, computed using 'path'.

l1_ratio : float, default=1
    float between 0 and 1 passed to ElasticNet (scaling between
    l1 and l2 penalties). For ``l1_ratio = 0`` the penalty is an
    L2 penalty. For ``l1_ratio = 1`` it is an L1 penalty. For ``0
    < l1_ratio < 1``, the penalty is a combination of L1 and L2.

X_order : {'F', 'C'}, default=None
    The order of the arrays expected by the path function to
    avoid memory copies.

dtype : a numpy dtype, default=None
    The dtype of the arrays expected by the path function to
    avoid memory copies.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__coordinate__descent_8py_source_l01358}{1358}} of file \mbox{\hyperlink{__coordinate__descent_8py_source}{\+\_\+coordinate\+\_\+descent.\+py}}.

\Hypertarget{namespacesklearn_1_1linear__model_1_1__coordinate__descent_a401cd9902c04b523954361538181394a}\index{sklearn.linear\_model.\_coordinate\_descent@{sklearn.linear\_model.\_coordinate\_descent}!\_set\_order@{\_set\_order}}
\index{\_set\_order@{\_set\_order}!sklearn.linear\_model.\_coordinate\_descent@{sklearn.linear\_model.\_coordinate\_descent}}
\doxysubsubsection{\texorpdfstring{\_set\_order()}{\_set\_order()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1linear__model_1_1__coordinate__descent_a401cd9902c04b523954361538181394a} 
sklearn.\+linear\+\_\+model.\+\_\+coordinate\+\_\+descent.\+\_\+set\+\_\+order (\begin{DoxyParamCaption}\item[{}]{X}{, }\item[{}]{y}{, }\item[{}]{order}{ = {\ttfamily "{}C"{}}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Change the order of X and y if necessary.

Parameters
----------
X : {array-like, sparse matrix} of shape (n_samples, n_features)
    Training data.

y : ndarray of shape (n_samples,)
    Target values.

order : {None, 'C', 'F'}
    If 'C', dense arrays are returned as C-ordered, sparse matrices in csr
    format. If 'F', dense arrays are return as F-ordered, sparse matrices
    in csc format.

Returns
-------
X : {array-like, sparse matrix} of shape (n_samples, n_features)
    Training data with guaranteed order.

y : ndarray of shape (n_samples,)
    Target values with guaranteed order.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__coordinate__descent_8py_source_l00048}{48}} of file \mbox{\hyperlink{__coordinate__descent_8py_source}{\+\_\+coordinate\+\_\+descent.\+py}}.



Referenced by \mbox{\hyperlink{__coordinate__descent_8py_source_l00932}{sklearn.\+linear\+\_\+model.\+\_\+coordinate\+\_\+descent.\+Elastic\+Net.\+fit()}}.

\Hypertarget{namespacesklearn_1_1linear__model_1_1__coordinate__descent_a355d76614a959aacd293a313d025a4e3}\index{sklearn.linear\_model.\_coordinate\_descent@{sklearn.linear\_model.\_coordinate\_descent}!enet\_path@{enet\_path}}
\index{enet\_path@{enet\_path}!sklearn.linear\_model.\_coordinate\_descent@{sklearn.linear\_model.\_coordinate\_descent}}
\doxysubsubsection{\texorpdfstring{enet\_path()}{enet\_path()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1linear__model_1_1__coordinate__descent_a355d76614a959aacd293a313d025a4e3} 
sklearn.\+linear\+\_\+model.\+\_\+coordinate\+\_\+descent.\+enet\+\_\+path (\begin{DoxyParamCaption}\item[{}]{X}{, }\item[{}]{y}{, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{l1\+\_\+ratio}{ = {\ttfamily 0.5}, }\item[{}]{eps}{ = {\ttfamily 1e-\/3}, }\item[{}]{n\+\_\+alphas}{ = {\ttfamily 100}, }\item[{}]{alphas}{ = {\ttfamily None}, }\item[{}]{precompute}{ = {\ttfamily "{}auto"{}}, }\item[{}]{Xy}{ = {\ttfamily None}, }\item[{}]{copy\+\_\+X}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}, }\item[{}]{coef\+\_\+init}{ = {\ttfamily None}, }\item[{}]{verbose}{ = {\ttfamily False}, }\item[{}]{return\+\_\+n\+\_\+iter}{ = {\ttfamily False}, }\item[{}]{positive}{ = {\ttfamily False}, }\item[{}]{check\+\_\+input}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}, }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{params}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute elastic net path with coordinate descent.

The elastic net optimization function varies for mono and multi-outputs.

For mono-output tasks it is::

    1 / (2 * n_samples) * ||y - Xw||^2_2
    + alpha * l1_ratio * ||w||_1
    + 0.5 * alpha * (1 - l1_ratio) * ||w||^2_2

For multi-output tasks it is::

    (1 / (2 * n_samples)) * ||Y - XW||_Fro^2
    + alpha * l1_ratio * ||W||_21
    + 0.5 * alpha * (1 - l1_ratio) * ||W||_Fro^2

Where::

    ||W||_21 = \\sum_i \\sqrt{\\sum_j w_{ij}^2}

i.e. the sum of norm of each row.

Read more in the :ref:`User Guide <elastic_net>`.

Parameters
----------
X : {array-like, sparse matrix} of shape (n_samples, n_features)
    Training data. Pass directly as Fortran-contiguous data to avoid
    unnecessary memory duplication. If ``y`` is mono-output then ``X``
    can be sparse.

y : {array-like, sparse matrix} of shape (n_samples,) or \
    (n_samples, n_targets)
    Target values.

l1_ratio : float, default=0.5
    Number between 0 and 1 passed to elastic net (scaling between
    l1 and l2 penalties). ``l1_ratio=1`` corresponds to the Lasso.

eps : float, default=1e-3
    Length of the path. ``eps=1e-3`` means that
    ``alpha_min / alpha_max = 1e-3``.

n_alphas : int, default=100
    Number of alphas along the regularization path.

alphas : array-like, default=None
    List of alphas where to compute the models.
    If None alphas are set automatically.

precompute : 'auto', bool or array-like of shape \
        (n_features, n_features), default='auto'
    Whether to use a precomputed Gram matrix to speed up
    calculations. If set to ``'auto'`` let us decide. The Gram
    matrix can also be passed as argument.

Xy : array-like of shape (n_features,) or (n_features, n_targets),\
     default=None
    Xy = np.dot(X.T, y) that can be precomputed. It is useful
    only when the Gram matrix is precomputed.

copy_X : bool, default=True
    If ``True``, X will be copied; else, it may be overwritten.

coef_init : array-like of shape (n_features, ), default=None
    The initial values of the coefficients.

verbose : bool or int, default=False
    Amount of verbosity.

return_n_iter : bool, default=False
    Whether to return the number of iterations or not.

positive : bool, default=False
    If set to True, forces coefficients to be positive.
    (Only allowed when ``y.ndim == 1``).

check_input : bool, default=True
    If set to False, the input validation checks are skipped (including the
    Gram matrix when provided). It is assumed that they are handled
    by the caller.

**params : kwargs
    Keyword arguments passed to the coordinate descent solver.

Returns
-------
alphas : ndarray of shape (n_alphas,)
    The alphas along the path where models are computed.

coefs : ndarray of shape (n_features, n_alphas) or \
        (n_targets, n_features, n_alphas)
    Coefficients along the path.

dual_gaps : ndarray of shape (n_alphas,)
    The dual gaps at the end of the optimization for each alpha.

n_iters : list of int
    The number of iterations taken by the coordinate descent optimizer to
    reach the specified tolerance for each alpha.
    (Is returned when ``return_n_iter`` is set to True).

See Also
--------
MultiTaskElasticNet : Multi-task ElasticNet model trained with L1/L2 mixed-norm \
as regularizer.
MultiTaskElasticNetCV : Multi-task L1/L2 ElasticNet with built-in cross-validation.
ElasticNet : Linear regression with combined L1 and L2 priors as regularizer.
ElasticNetCV : Elastic Net model with iterative fitting along a regularization path.

Notes
-----
For an example, see
:ref:`examples/linear_model/plot_lasso_lasso_lars_elasticnet_path.py
<sphx_glr_auto_examples_linear_model_plot_lasso_lasso_lars_elasticnet_path.py>`.

Examples
--------
>>> from sklearn.linear_model import enet_path
>>> from sklearn.datasets import make_regression
>>> X, y, true_coef = make_regression(
...    n_samples=100, n_features=5, n_informative=2, coef=True, random_state=0
... )
>>> true_coef
array([ 0.        ,  0.        ,  0.        , 97.9, 45.7])
>>> alphas, estimated_coef, _ = enet_path(X, y, n_alphas=3)
>>> alphas.shape
(3,)
>>> estimated_coef
 array([[ 0.,  0.787,  0.568],
        [ 0.,  1.120,  0.620],
        [-0., -2.129, -1.128],
        [ 0., 23.046, 88.939],
        [ 0., 10.637, 41.566]])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__coordinate__descent_8py_source_l00396}{396}} of file \mbox{\hyperlink{__coordinate__descent_8py_source}{\+\_\+coordinate\+\_\+descent.\+py}}.



References \mbox{\hyperlink{__coordinate__descent_8py_source_l00105}{\+\_\+alpha\+\_\+grid()}}.



Referenced by \mbox{\hyperlink{__coordinate__descent_8py_source_l00218}{lasso\+\_\+path()}}.

\Hypertarget{namespacesklearn_1_1linear__model_1_1__coordinate__descent_abb33a827fc742e6cae15ebe2af3d40bc}\index{sklearn.linear\_model.\_coordinate\_descent@{sklearn.linear\_model.\_coordinate\_descent}!lasso\_path@{lasso\_path}}
\index{lasso\_path@{lasso\_path}!sklearn.linear\_model.\_coordinate\_descent@{sklearn.linear\_model.\_coordinate\_descent}}
\doxysubsubsection{\texorpdfstring{lasso\_path()}{lasso\_path()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1linear__model_1_1__coordinate__descent_abb33a827fc742e6cae15ebe2af3d40bc} 
sklearn.\+linear\+\_\+model.\+\_\+coordinate\+\_\+descent.\+lasso\+\_\+path (\begin{DoxyParamCaption}\item[{}]{X}{, }\item[{}]{y}{, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{eps}{ = {\ttfamily 1e-\/3}, }\item[{}]{n\+\_\+alphas}{ = {\ttfamily 100}, }\item[{}]{alphas}{ = {\ttfamily None}, }\item[{}]{precompute}{ = {\ttfamily "{}auto"{}}, }\item[{}]{Xy}{ = {\ttfamily None}, }\item[{}]{copy\+\_\+X}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}, }\item[{}]{coef\+\_\+init}{ = {\ttfamily None}, }\item[{}]{verbose}{ = {\ttfamily False}, }\item[{}]{return\+\_\+n\+\_\+iter}{ = {\ttfamily False}, }\item[{}]{positive}{ = {\ttfamily False}, }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{params}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute Lasso path with coordinate descent.

The Lasso optimization function varies for mono and multi-outputs.

For mono-output tasks it is::

    (1 / (2 * n_samples)) * ||y - Xw||^2_2 + alpha * ||w||_1

For multi-output tasks it is::

    (1 / (2 * n_samples)) * ||Y - XW||^2_Fro + alpha * ||W||_21

Where::

    ||W||_21 = \\sum_i \\sqrt{\\sum_j w_{ij}^2}

i.e. the sum of norm of each row.

Read more in the :ref:`User Guide <lasso>`.

Parameters
----------
X : {array-like, sparse matrix} of shape (n_samples, n_features)
    Training data. Pass directly as Fortran-contiguous data to avoid
    unnecessary memory duplication. If ``y`` is mono-output then ``X``
    can be sparse.

y : {array-like, sparse matrix} of shape (n_samples,) or \
    (n_samples, n_targets)
    Target values.

eps : float, default=1e-3
    Length of the path. ``eps=1e-3`` means that
    ``alpha_min / alpha_max = 1e-3``.

n_alphas : int, default=100
    Number of alphas along the regularization path.

alphas : array-like, default=None
    List of alphas where to compute the models.
    If ``None`` alphas are set automatically.

precompute : 'auto', bool or array-like of shape \
        (n_features, n_features), default='auto'
    Whether to use a precomputed Gram matrix to speed up
    calculations. If set to ``'auto'`` let us decide. The Gram
    matrix can also be passed as argument.

Xy : array-like of shape (n_features,) or (n_features, n_targets),\
     default=None
    Xy = np.dot(X.T, y) that can be precomputed. It is useful
    only when the Gram matrix is precomputed.

copy_X : bool, default=True
    If ``True``, X will be copied; else, it may be overwritten.

coef_init : array-like of shape (n_features, ), default=None
    The initial values of the coefficients.

verbose : bool or int, default=False
    Amount of verbosity.

return_n_iter : bool, default=False
    Whether to return the number of iterations or not.

positive : bool, default=False
    If set to True, forces coefficients to be positive.
    (Only allowed when ``y.ndim == 1``).

**params : kwargs
    Keyword arguments passed to the coordinate descent solver.

Returns
-------
alphas : ndarray of shape (n_alphas,)
    The alphas along the path where models are computed.

coefs : ndarray of shape (n_features, n_alphas) or \
        (n_targets, n_features, n_alphas)
    Coefficients along the path.

dual_gaps : ndarray of shape (n_alphas,)
    The dual gaps at the end of the optimization for each alpha.

n_iters : list of int
    The number of iterations taken by the coordinate descent optimizer to
    reach the specified tolerance for each alpha.

See Also
--------
lars_path : Compute Least Angle Regression or Lasso path using LARS
    algorithm.
Lasso : The Lasso is a linear model that estimates sparse coefficients.
LassoLars : Lasso model fit with Least Angle Regression a.k.a. Lars.
LassoCV : Lasso linear model with iterative fitting along a regularization
    path.
LassoLarsCV : Cross-validated Lasso using the LARS algorithm.
sklearn.decomposition.sparse_encode : Estimator that can be used to
    transform signals into sparse linear combination of atoms from a fixed.

Notes
-----
For an example, see
:ref:`examples/linear_model/plot_lasso_lasso_lars_elasticnet_path.py
<sphx_glr_auto_examples_linear_model_plot_lasso_lasso_lars_elasticnet_path.py>`.

To avoid unnecessary memory duplication the X argument of the fit method
should be directly passed as a Fortran-contiguous numpy array.

Note that in certain cases, the Lars solver may be significantly
faster to implement this functionality. In particular, linear
interpolation can be used to retrieve model coefficients between the
values output by lars_path

Examples
--------

Comparing lasso_path and lars_path with interpolation:

>>> import numpy as np
>>> from sklearn.linear_model import lasso_path
>>> X = np.array([[1, 2, 3.1], [2.3, 5.4, 4.3]]).T
>>> y = np.array([1, 2, 3.1])
>>> # Use lasso_path to compute a coefficient path
>>> _, coef_path, _ = lasso_path(X, y, alphas=[5., 1., .5])
>>> print(coef_path)
[[0.         0.         0.46874778]
 [0.2159048  0.4425765  0.23689075]]

>>> # Now use lars_path and 1D linear interpolation to compute the
>>> # same path
>>> from sklearn.linear_model import lars_path
>>> alphas, active, coef_path_lars = lars_path(X, y, method='lasso')
>>> from scipy import interpolate
>>> coef_path_continuous = interpolate.interp1d(alphas[::-1],
...                                             coef_path_lars[:, ::-1])
>>> print(coef_path_continuous([5., 1., .5]))
[[0.         0.         0.46915237]
 [0.2159048  0.4425765  0.23668876]]
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__coordinate__descent_8py_source_l00203}{203}} of file \mbox{\hyperlink{__coordinate__descent_8py_source}{\+\_\+coordinate\+\_\+descent.\+py}}.



References \mbox{\hyperlink{__coordinate__descent_8py_source_l00413}{enet\+\_\+path()}}.

