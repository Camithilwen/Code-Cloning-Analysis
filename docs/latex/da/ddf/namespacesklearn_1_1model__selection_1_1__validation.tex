\doxysection{sklearn.\+model\+\_\+selection.\+\_\+validation Namespace Reference}
\hypertarget{namespacesklearn_1_1model__selection_1_1__validation}{}\label{namespacesklearn_1_1model__selection_1_1__validation}\index{sklearn.model\_selection.\_validation@{sklearn.model\_selection.\_validation}}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacesklearn_1_1model__selection_1_1__validation_ab041ea278be97c8ecb7108f290c1a9ab}{\+\_\+check\+\_\+params\+\_\+groups\+\_\+deprecation}} (fit\+\_\+params, params, groups, version)
\item 
\mbox{\hyperlink{namespacesklearn_1_1model__selection_1_1__validation_ab110b89cb0fc7b2c18af4cb6affbb72e}{\+\_\+check\+\_\+groups\+\_\+routing\+\_\+disabled}} (groups)
\item 
\mbox{\hyperlink{namespacesklearn_1_1model__selection_1_1__validation_a707be5df473fe7b18a2e77e11b32fcb4}{cross\+\_\+validate}} (estimator, X, y=None, \texorpdfstring{$\ast$}{*}, groups=None, scoring=None, cv=None, n\+\_\+jobs=None, verbose=0, params=None, pre\+\_\+dispatch="{}2\texorpdfstring{$\ast$}{*}n\+\_\+jobs"{}, return\+\_\+train\+\_\+score=False, return\+\_\+estimator=False, return\+\_\+indices=False, error\+\_\+score=np.\+nan)
\item 
\mbox{\hyperlink{namespacesklearn_1_1model__selection_1_1__validation_afb095e3fc436fbe882f7d5f58dea3777}{\+\_\+insert\+\_\+error\+\_\+scores}} (results, error\+\_\+score)
\item 
\mbox{\hyperlink{namespacesklearn_1_1model__selection_1_1__validation_ac6b53705a88d7217c3361b4463b272f2}{\+\_\+normalize\+\_\+score\+\_\+results}} (scores, scaler\+\_\+score\+\_\+key="{}score"{})
\item 
\mbox{\hyperlink{namespacesklearn_1_1model__selection_1_1__validation_aea8db1f680a2824ad71a404d074b3014}{\+\_\+warn\+\_\+or\+\_\+raise\+\_\+about\+\_\+fit\+\_\+failures}} (results, error\+\_\+score)
\item 
\mbox{\hyperlink{namespacesklearn_1_1model__selection_1_1__validation_a0c8543ce3043b69c6c80abe81f1b2a6a}{cross\+\_\+val\+\_\+score}} (estimator, X, y=None, \texorpdfstring{$\ast$}{*}, groups=None, scoring=None, cv=None, n\+\_\+jobs=None, verbose=0, params=None, pre\+\_\+dispatch="{}2\texorpdfstring{$\ast$}{*}n\+\_\+jobs"{}, error\+\_\+score=np.\+nan)
\item 
\mbox{\hyperlink{namespacesklearn_1_1model__selection_1_1__validation_ad8150207029eb7d25e77674442c0ed13}{\+\_\+fit\+\_\+and\+\_\+score}} (estimator, X, y, \texorpdfstring{$\ast$}{*}, scorer, train, test, verbose, parameters, fit\+\_\+params, score\+\_\+params, return\+\_\+train\+\_\+score=False, return\+\_\+parameters=False, return\+\_\+n\+\_\+test\+\_\+samples=False, return\+\_\+times=False, return\+\_\+estimator=False, split\+\_\+progress=None, candidate\+\_\+progress=None, error\+\_\+score=np.\+nan)
\item 
\mbox{\hyperlink{namespacesklearn_1_1model__selection_1_1__validation_a8828b7dfb9020061390fe183b97a6b0a}{\+\_\+score}} (estimator, X\+\_\+test, y\+\_\+test, scorer, score\+\_\+params, error\+\_\+score="{}raise"{})
\item 
\mbox{\hyperlink{namespacesklearn_1_1model__selection_1_1__validation_a51768cd061680860cb274d88d36547af}{cross\+\_\+val\+\_\+predict}} (estimator, X, y=None, \texorpdfstring{$\ast$}{*}, groups=None, cv=None, n\+\_\+jobs=None, verbose=0, params=None, pre\+\_\+dispatch="{}2\texorpdfstring{$\ast$}{*}n\+\_\+jobs"{}, method="{}predict"{})
\item 
\mbox{\hyperlink{namespacesklearn_1_1model__selection_1_1__validation_a55e8d0bdd8efc3a22e15790914725271}{\+\_\+fit\+\_\+and\+\_\+predict}} (estimator, X, y, train, test, fit\+\_\+params, method)
\item 
\mbox{\hyperlink{namespacesklearn_1_1model__selection_1_1__validation_ab4dad997de888c9b75367c1811edde5f}{\+\_\+enforce\+\_\+prediction\+\_\+order}} (classes, predictions, n\+\_\+classes, method)
\item 
\mbox{\hyperlink{namespacesklearn_1_1model__selection_1_1__validation_ab18d7a0f7b368c77188df1b2c1bac143}{\+\_\+check\+\_\+is\+\_\+permutation}} (indices, n\+\_\+samples)
\item 
\mbox{\hyperlink{namespacesklearn_1_1model__selection_1_1__validation_a5a308e3613bc2c4f0a38add7635b0c35}{permutation\+\_\+test\+\_\+score}} (estimator, X, y, \texorpdfstring{$\ast$}{*}, groups=None, cv=None, n\+\_\+permutations=100, n\+\_\+jobs=None, random\+\_\+state=0, verbose=0, scoring=None, fit\+\_\+params=None, params=None)
\item 
\mbox{\hyperlink{namespacesklearn_1_1model__selection_1_1__validation_a5e3ac94adf53e4612ce07205e7adfdaf}{\+\_\+permutation\+\_\+test\+\_\+score}} (estimator, X, y, cv, scorer, split\+\_\+params, fit\+\_\+params, score\+\_\+params)
\item 
\mbox{\hyperlink{namespacesklearn_1_1model__selection_1_1__validation_aac7587f06b6fe652b5aed5965f1ab58e}{\+\_\+shuffle}} (y, groups, random\+\_\+state)
\item 
\mbox{\hyperlink{namespacesklearn_1_1model__selection_1_1__validation_ae34dd63d73da496d8acbc2c2b9872e70}{learning\+\_\+curve}} (estimator, X, y, \texorpdfstring{$\ast$}{*}, groups=None, train\+\_\+sizes=np.\+linspace(0.\+1, 1.\+0, 5), cv=None, scoring=None, exploit\+\_\+incremental\+\_\+learning=False, n\+\_\+jobs=None, pre\+\_\+dispatch="{}all"{}, verbose=0, shuffle=False, random\+\_\+state=None, error\+\_\+score=np.\+nan, return\+\_\+times=False, fit\+\_\+params=None, params=None)
\item 
\mbox{\hyperlink{namespacesklearn_1_1model__selection_1_1__validation_a7a1d0424033b9fae7c4c661d594f32c3}{\+\_\+translate\+\_\+train\+\_\+sizes}} (train\+\_\+sizes, n\+\_\+max\+\_\+training\+\_\+samples)
\item 
\mbox{\hyperlink{namespacesklearn_1_1model__selection_1_1__validation_a0eb86036c7c81eec5a5ef81fe786362d}{\+\_\+incremental\+\_\+fit\+\_\+estimator}} (estimator, X, y, classes, train, test, train\+\_\+sizes, scorer, return\+\_\+times, error\+\_\+score, fit\+\_\+params, score\+\_\+params)
\item 
\mbox{\hyperlink{namespacesklearn_1_1model__selection_1_1__validation_af22f5c88c240298733598466868c0f58}{validation\+\_\+curve}} (estimator, X, y, \texorpdfstring{$\ast$}{*}, param\+\_\+name, param\+\_\+range, groups=None, cv=None, scoring=None, n\+\_\+jobs=None, pre\+\_\+dispatch="{}all"{}, verbose=0, error\+\_\+score=np.\+nan, fit\+\_\+params=None, params=None)
\item 
\mbox{\hyperlink{namespacesklearn_1_1model__selection_1_1__validation_a7374b604b129763978eb18b1ac2b1c9c}{\+\_\+aggregate\+\_\+score\+\_\+dicts}} (scores)
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
list \mbox{\hyperlink{namespacesklearn_1_1model__selection_1_1__validation_a2b0816d638ef3e4088b1e244920b218e}{\+\_\+\+\_\+all\+\_\+\+\_\+}}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\begin{DoxyVerb}The :mod:`sklearn.model_selection._validation` module includes classes and
functions to validate the model.
\end{DoxyVerb}
 

\doxysubsection{Function Documentation}
\Hypertarget{namespacesklearn_1_1model__selection_1_1__validation_a7374b604b129763978eb18b1ac2b1c9c}\index{sklearn.model\_selection.\_validation@{sklearn.model\_selection.\_validation}!\_aggregate\_score\_dicts@{\_aggregate\_score\_dicts}}
\index{\_aggregate\_score\_dicts@{\_aggregate\_score\_dicts}!sklearn.model\_selection.\_validation@{sklearn.model\_selection.\_validation}}
\doxysubsubsection{\texorpdfstring{\_aggregate\_score\_dicts()}{\_aggregate\_score\_dicts()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1model__selection_1_1__validation_a7374b604b129763978eb18b1ac2b1c9c} 
sklearn.\+model\+\_\+selection.\+\_\+validation.\+\_\+aggregate\+\_\+score\+\_\+dicts (\begin{DoxyParamCaption}\item[{}]{scores}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Aggregate the list of dict to dict of np ndarray

The aggregated output of _aggregate_score_dicts will be a list of dict
of form [{'prec': 0.1, 'acc':1.0}, {'prec': 0.1, 'acc':1.0}, ...]
Convert it to a dict of array {'prec': np.array([0.1 ...]), ...}

Parameters
----------

scores : list of dict
    List of dicts of the scores for all scorers. This is a flat list,
    assumed originally to be of row major order.

Example
-------

>>> scores = [{'a': 1, 'b':10}, {'a': 2, 'b':2}, {'a': 3, 'b':3},
...           {'a': 10, 'b': 10}]                         # doctest: +SKIP
>>> _aggregate_score_dicts(scores)                        # doctest: +SKIP
{'a': array([1, 2, 3, 10]),
 'b': array([10, 2, 3, 10])}
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source_l02500}{2500}} of file \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source}{\+\_\+validation.\+py}}.



Referenced by \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source_l00475}{\+\_\+normalize\+\_\+score\+\_\+results()}}, \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source_l00140}{cross\+\_\+validate()}}, \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source_l01778}{learning\+\_\+curve()}}, and \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source_l02279}{validation\+\_\+curve()}}.

\Hypertarget{namespacesklearn_1_1model__selection_1_1__validation_ab110b89cb0fc7b2c18af4cb6affbb72e}\index{sklearn.model\_selection.\_validation@{sklearn.model\_selection.\_validation}!\_check\_groups\_routing\_disabled@{\_check\_groups\_routing\_disabled}}
\index{\_check\_groups\_routing\_disabled@{\_check\_groups\_routing\_disabled}!sklearn.model\_selection.\_validation@{sklearn.model\_selection.\_validation}}
\doxysubsubsection{\texorpdfstring{\_check\_groups\_routing\_disabled()}{\_check\_groups\_routing\_disabled()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1model__selection_1_1__validation_ab110b89cb0fc7b2c18af4cb6affbb72e} 
sklearn.\+model\+\_\+selection.\+\_\+validation.\+\_\+check\+\_\+groups\+\_\+routing\+\_\+disabled (\begin{DoxyParamCaption}\item[{}]{groups}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source_l00088}{88}} of file \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source}{\+\_\+validation.\+py}}.

\Hypertarget{namespacesklearn_1_1model__selection_1_1__validation_ab18d7a0f7b368c77188df1b2c1bac143}\index{sklearn.model\_selection.\_validation@{sklearn.model\_selection.\_validation}!\_check\_is\_permutation@{\_check\_is\_permutation}}
\index{\_check\_is\_permutation@{\_check\_is\_permutation}!sklearn.model\_selection.\_validation@{sklearn.model\_selection.\_validation}}
\doxysubsubsection{\texorpdfstring{\_check\_is\_permutation()}{\_check\_is\_permutation()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1model__selection_1_1__validation_ab18d7a0f7b368c77188df1b2c1bac143} 
sklearn.\+model\+\_\+selection.\+\_\+validation.\+\_\+check\+\_\+is\+\_\+permutation (\begin{DoxyParamCaption}\item[{}]{indices}{, }\item[{}]{n\+\_\+samples}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Check whether indices is a reordering of the array np.arange(n_samples)

Parameters
----------
indices : ndarray
    int array to test
n_samples : int
    number of expected elements

Returns
-------
is_partition : bool
    True iff sorted(indices) is np.arange(n)
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source_l01414}{1414}} of file \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source}{\+\_\+validation.\+py}}.



Referenced by \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source_l01036}{cross\+\_\+val\+\_\+predict()}}.

\Hypertarget{namespacesklearn_1_1model__selection_1_1__validation_ab041ea278be97c8ecb7108f290c1a9ab}\index{sklearn.model\_selection.\_validation@{sklearn.model\_selection.\_validation}!\_check\_params\_groups\_deprecation@{\_check\_params\_groups\_deprecation}}
\index{\_check\_params\_groups\_deprecation@{\_check\_params\_groups\_deprecation}!sklearn.model\_selection.\_validation@{sklearn.model\_selection.\_validation}}
\doxysubsubsection{\texorpdfstring{\_check\_params\_groups\_deprecation()}{\_check\_params\_groups\_deprecation()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1model__selection_1_1__validation_ab041ea278be97c8ecb7108f290c1a9ab} 
sklearn.\+model\+\_\+selection.\+\_\+validation.\+\_\+check\+\_\+params\+\_\+groups\+\_\+deprecation (\begin{DoxyParamCaption}\item[{}]{fit\+\_\+params}{, }\item[{}]{params}{, }\item[{}]{groups}{, }\item[{}]{version}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}A helper function to check deprecations on `groups` and `fit_params`.

# TODO(SLEP6): To be removed when set_config(enable_metadata_routing=False) is not
# possible.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source_l00057}{57}} of file \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source}{\+\_\+validation.\+py}}.



Referenced by \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source_l01778}{learning\+\_\+curve()}}, \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source_l01469}{permutation\+\_\+test\+\_\+score()}}, and \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source_l02279}{validation\+\_\+curve()}}.

\Hypertarget{namespacesklearn_1_1model__selection_1_1__validation_ab4dad997de888c9b75367c1811edde5f}\index{sklearn.model\_selection.\_validation@{sklearn.model\_selection.\_validation}!\_enforce\_prediction\_order@{\_enforce\_prediction\_order}}
\index{\_enforce\_prediction\_order@{\_enforce\_prediction\_order}!sklearn.model\_selection.\_validation@{sklearn.model\_selection.\_validation}}
\doxysubsubsection{\texorpdfstring{\_enforce\_prediction\_order()}{\_enforce\_prediction\_order()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1model__selection_1_1__validation_ab4dad997de888c9b75367c1811edde5f} 
sklearn.\+model\+\_\+selection.\+\_\+validation.\+\_\+enforce\+\_\+prediction\+\_\+order (\begin{DoxyParamCaption}\item[{}]{classes}{, }\item[{}]{predictions}{, }\item[{}]{n\+\_\+classes}{, }\item[{}]{method}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Ensure that prediction arrays have correct column order

When doing cross-validation, if one or more classes are
not present in the subset of data used for training,
then the output prediction array might not have the same
columns as other folds. Use the list of class names
(assumed to be ints) to enforce the correct column order.

Note that `classes` is the list of classes in this fold
(a subset of the classes in the full training set)
and `n_classes` is the number of classes in the full training set.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source_l01348}{1348}} of file \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source}{\+\_\+validation.\+py}}.



Referenced by \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source_l01272}{\+\_\+fit\+\_\+and\+\_\+predict()}}.

\Hypertarget{namespacesklearn_1_1model__selection_1_1__validation_a55e8d0bdd8efc3a22e15790914725271}\index{sklearn.model\_selection.\_validation@{sklearn.model\_selection.\_validation}!\_fit\_and\_predict@{\_fit\_and\_predict}}
\index{\_fit\_and\_predict@{\_fit\_and\_predict}!sklearn.model\_selection.\_validation@{sklearn.model\_selection.\_validation}}
\doxysubsubsection{\texorpdfstring{\_fit\_and\_predict()}{\_fit\_and\_predict()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1model__selection_1_1__validation_a55e8d0bdd8efc3a22e15790914725271} 
sklearn.\+model\+\_\+selection.\+\_\+validation.\+\_\+fit\+\_\+and\+\_\+predict (\begin{DoxyParamCaption}\item[{}]{estimator}{, }\item[{}]{X}{, }\item[{}]{y}{, }\item[{}]{train}{, }\item[{}]{test}{, }\item[{}]{fit\+\_\+params}{, }\item[{}]{method}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Fit estimator and predict values for a given dataset split.

Read more in the :ref:`User Guide <cross_validation>`.

Parameters
----------
estimator : estimator object implementing 'fit' and 'predict'
    The object to use to fit the data.

X : array-like of shape (n_samples, n_features)
    The data to fit.

    .. versionchanged:: 0.20
        X is only required to be an object with finite length or shape now

y : array-like of shape (n_samples,) or (n_samples, n_outputs) or None
    The target variable to try to predict in the case of
    supervised learning.

train : array-like of shape (n_train_samples,)
    Indices of training samples.

test : array-like of shape (n_test_samples,)
    Indices of test samples.

fit_params : dict or None
    Parameters that will be passed to ``estimator.fit``.

method : str
    Invokes the passed method name of the passed estimator.

Returns
-------
predictions : sequence
    Result of calling 'estimator.method'
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source_l01272}{1272}} of file \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source}{\+\_\+validation.\+py}}.



References \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source_l01348}{\+\_\+enforce\+\_\+prediction\+\_\+order()}}.

\Hypertarget{namespacesklearn_1_1model__selection_1_1__validation_ad8150207029eb7d25e77674442c0ed13}\index{sklearn.model\_selection.\_validation@{sklearn.model\_selection.\_validation}!\_fit\_and\_score@{\_fit\_and\_score}}
\index{\_fit\_and\_score@{\_fit\_and\_score}!sklearn.model\_selection.\_validation@{sklearn.model\_selection.\_validation}}
\doxysubsubsection{\texorpdfstring{\_fit\_and\_score()}{\_fit\_and\_score()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1model__selection_1_1__validation_ad8150207029eb7d25e77674442c0ed13} 
sklearn.\+model\+\_\+selection.\+\_\+validation.\+\_\+fit\+\_\+and\+\_\+score (\begin{DoxyParamCaption}\item[{}]{estimator}{, }\item[{}]{X}{, }\item[{}]{y}{, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{scorer}{, }\item[{}]{train}{, }\item[{}]{test}{, }\item[{}]{verbose}{, }\item[{}]{parameters}{, }\item[{}]{fit\+\_\+params}{, }\item[{}]{score\+\_\+params}{, }\item[{}]{return\+\_\+train\+\_\+score}{ = {\ttfamily False}, }\item[{}]{return\+\_\+parameters}{ = {\ttfamily False}, }\item[{}]{return\+\_\+n\+\_\+test\+\_\+samples}{ = {\ttfamily False}, }\item[{}]{return\+\_\+times}{ = {\ttfamily False}, }\item[{}]{return\+\_\+estimator}{ = {\ttfamily False}, }\item[{}]{split\+\_\+progress}{ = {\ttfamily None}, }\item[{}]{candidate\+\_\+progress}{ = {\ttfamily None}, }\item[{}]{error\+\_\+score}{ = {\ttfamily np.nan}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Fit estimator and compute scores for a given dataset split.

Parameters
----------
estimator : estimator object implementing 'fit'
    The object to use to fit the data.

X : array-like of shape (n_samples, n_features)
    The data to fit.

y : array-like of shape (n_samples,) or (n_samples, n_outputs) or None
    The target variable to try to predict in the case of
    supervised learning.

scorer : A single callable or dict mapping scorer name to the callable
    If it is a single callable, the return value for ``train_scores`` and
    ``test_scores`` is a single float.

    For a dict, it should be one mapping the scorer name to the scorer
    callable object / function.

    The callable object / fn should have signature
    ``scorer(estimator, X, y)``.

train : array-like of shape (n_train_samples,)
    Indices of training samples.

test : array-like of shape (n_test_samples,)
    Indices of test samples.

verbose : int
    The verbosity level.

error_score : 'raise' or numeric, default=np.nan
    Value to assign to the score if an error occurs in estimator fitting.
    If set to 'raise', the error is raised.
    If a numeric value is given, FitFailedWarning is raised.

parameters : dict or None
    Parameters to be set on the estimator.

fit_params : dict or None
    Parameters that will be passed to ``estimator.fit``.

score_params : dict or None
    Parameters that will be passed to the scorer.

return_train_score : bool, default=False
    Compute and return score on training set.

return_parameters : bool, default=False
    Return parameters that has been used for the estimator.

split_progress : {list, tuple} of int, default=None
    A list or tuple of format (<current_split_id>, <total_num_of_splits>).

candidate_progress : {list, tuple} of int, default=None
    A list or tuple of format
    (<current_candidate_id>, <total_number_of_candidates>).

return_n_test_samples : bool, default=False
    Whether to return the ``n_test_samples``.

return_times : bool, default=False
    Whether to return the fit/score times.

return_estimator : bool, default=False
    Whether to return the fitted estimator.

Returns
-------
result : dict with the following attributes
    train_scores : dict of scorer name -> float
        Score on training set (for all the scorers),
        returned only if `return_train_score` is `True`.
    test_scores : dict of scorer name -> float
        Score on testing set (for all the scorers).
    n_test_samples : int
        Number of test samples.
    fit_time : float
        Time spent for fitting in seconds.
    score_time : float
        Time spent for scoring in seconds.
    parameters : dict or None
        The parameters that have been evaluated.
    estimator : estimator object
        The fitted estimator.
    fit_error : str or None
        Traceback str if the fit failed, None if the fit succeeded.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source_l00693}{693}} of file \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source}{\+\_\+validation.\+py}}.



References \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source_l00930}{\+\_\+score()}}.

\Hypertarget{namespacesklearn_1_1model__selection_1_1__validation_a0eb86036c7c81eec5a5ef81fe786362d}\index{sklearn.model\_selection.\_validation@{sklearn.model\_selection.\_validation}!\_incremental\_fit\_estimator@{\_incremental\_fit\_estimator}}
\index{\_incremental\_fit\_estimator@{\_incremental\_fit\_estimator}!sklearn.model\_selection.\_validation@{sklearn.model\_selection.\_validation}}
\doxysubsubsection{\texorpdfstring{\_incremental\_fit\_estimator()}{\_incremental\_fit\_estimator()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1model__selection_1_1__validation_a0eb86036c7c81eec5a5ef81fe786362d} 
sklearn.\+model\+\_\+selection.\+\_\+validation.\+\_\+incremental\+\_\+fit\+\_\+estimator (\begin{DoxyParamCaption}\item[{}]{estimator}{, }\item[{}]{X}{, }\item[{}]{y}{, }\item[{}]{classes}{, }\item[{}]{train}{, }\item[{}]{test}{, }\item[{}]{train\+\_\+sizes}{, }\item[{}]{scorer}{, }\item[{}]{return\+\_\+times}{, }\item[{}]{error\+\_\+score}{, }\item[{}]{fit\+\_\+params}{, }\item[{}]{score\+\_\+params}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Train estimator on training subsets incrementally and compute scores.\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source_l02170}{2170}} of file \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source}{\+\_\+validation.\+py}}.



References \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source_l00930}{\+\_\+score()}}.

\Hypertarget{namespacesklearn_1_1model__selection_1_1__validation_afb095e3fc436fbe882f7d5f58dea3777}\index{sklearn.model\_selection.\_validation@{sklearn.model\_selection.\_validation}!\_insert\_error\_scores@{\_insert\_error\_scores}}
\index{\_insert\_error\_scores@{\_insert\_error\_scores}!sklearn.model\_selection.\_validation@{sklearn.model\_selection.\_validation}}
\doxysubsubsection{\texorpdfstring{\_insert\_error\_scores()}{\_insert\_error\_scores()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1model__selection_1_1__validation_afb095e3fc436fbe882f7d5f58dea3777} 
sklearn.\+model\+\_\+selection.\+\_\+validation.\+\_\+insert\+\_\+error\+\_\+scores (\begin{DoxyParamCaption}\item[{}]{results}{, }\item[{}]{error\+\_\+score}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Insert error in `results` by replacing them inplace with `error_score`.

This only applies to multimetric scores because `_fit_and_score` will
handle the single metric case.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source_l00453}{453}} of file \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source}{\+\_\+validation.\+py}}.



Referenced by \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source_l00140}{cross\+\_\+validate()}}.

\Hypertarget{namespacesklearn_1_1model__selection_1_1__validation_ac6b53705a88d7217c3361b4463b272f2}\index{sklearn.model\_selection.\_validation@{sklearn.model\_selection.\_validation}!\_normalize\_score\_results@{\_normalize\_score\_results}}
\index{\_normalize\_score\_results@{\_normalize\_score\_results}!sklearn.model\_selection.\_validation@{sklearn.model\_selection.\_validation}}
\doxysubsubsection{\texorpdfstring{\_normalize\_score\_results()}{\_normalize\_score\_results()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1model__selection_1_1__validation_ac6b53705a88d7217c3361b4463b272f2} 
sklearn.\+model\+\_\+selection.\+\_\+validation.\+\_\+normalize\+\_\+score\+\_\+results (\begin{DoxyParamCaption}\item[{}]{scores}{, }\item[{}]{scaler\+\_\+score\+\_\+key}{ = {\ttfamily "{}score"{}}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Creates a scoring dictionary based on the type of `scores`\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source_l00475}{475}} of file \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source}{\+\_\+validation.\+py}}.



References \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source_l02500}{\+\_\+aggregate\+\_\+score\+\_\+dicts()}}.



Referenced by \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source_l00140}{cross\+\_\+validate()}}.

\Hypertarget{namespacesklearn_1_1model__selection_1_1__validation_a5e3ac94adf53e4612ce07205e7adfdaf}\index{sklearn.model\_selection.\_validation@{sklearn.model\_selection.\_validation}!\_permutation\_test\_score@{\_permutation\_test\_score}}
\index{\_permutation\_test\_score@{\_permutation\_test\_score}!sklearn.model\_selection.\_validation@{sklearn.model\_selection.\_validation}}
\doxysubsubsection{\texorpdfstring{\_permutation\_test\_score()}{\_permutation\_test\_score()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1model__selection_1_1__validation_a5e3ac94adf53e4612ce07205e7adfdaf} 
sklearn.\+model\+\_\+selection.\+\_\+validation.\+\_\+permutation\+\_\+test\+\_\+score (\begin{DoxyParamCaption}\item[{}]{estimator}{, }\item[{}]{X}{, }\item[{}]{y}{, }\item[{}]{cv}{, }\item[{}]{scorer}{, }\item[{}]{split\+\_\+params}{, }\item[{}]{fit\+\_\+params}{, }\item[{}]{score\+\_\+params}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Auxiliary function for permutation_test_score\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source_l01706}{1706}} of file \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source}{\+\_\+validation.\+py}}.



Referenced by \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source_l01469}{permutation\+\_\+test\+\_\+score()}}.

\Hypertarget{namespacesklearn_1_1model__selection_1_1__validation_a8828b7dfb9020061390fe183b97a6b0a}\index{sklearn.model\_selection.\_validation@{sklearn.model\_selection.\_validation}!\_score@{\_score}}
\index{\_score@{\_score}!sklearn.model\_selection.\_validation@{sklearn.model\_selection.\_validation}}
\doxysubsubsection{\texorpdfstring{\_score()}{\_score()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1model__selection_1_1__validation_a8828b7dfb9020061390fe183b97a6b0a} 
sklearn.\+model\+\_\+selection.\+\_\+validation.\+\_\+score (\begin{DoxyParamCaption}\item[{}]{estimator}{, }\item[{}]{X\+\_\+test}{, }\item[{}]{y\+\_\+test}{, }\item[{}]{scorer}{, }\item[{}]{score\+\_\+params}{, }\item[{}]{error\+\_\+score}{ = {\ttfamily "{}raise"{}}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Compute the score(s) of an estimator on a given test set.

Will return a dict of floats if `scorer` is a _MultiMetricScorer, otherwise a single
float is returned.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source_l00930}{930}} of file \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source}{\+\_\+validation.\+py}}.



Referenced by \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source_l00713}{\+\_\+fit\+\_\+and\+\_\+score()}}, and \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source_l02183}{\+\_\+incremental\+\_\+fit\+\_\+estimator()}}.

\Hypertarget{namespacesklearn_1_1model__selection_1_1__validation_aac7587f06b6fe652b5aed5965f1ab58e}\index{sklearn.model\_selection.\_validation@{sklearn.model\_selection.\_validation}!\_shuffle@{\_shuffle}}
\index{\_shuffle@{\_shuffle}!sklearn.model\_selection.\_validation@{sklearn.model\_selection.\_validation}}
\doxysubsubsection{\texorpdfstring{\_shuffle()}{\_shuffle()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1model__selection_1_1__validation_aac7587f06b6fe652b5aed5965f1ab58e} 
sklearn.\+model\+\_\+selection.\+\_\+validation.\+\_\+shuffle (\begin{DoxyParamCaption}\item[{}]{y}{, }\item[{}]{groups}{, }\item[{}]{random\+\_\+state}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Return a shuffled copy of y eventually shuffle among same groups.\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source_l01725}{1725}} of file \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source}{\+\_\+validation.\+py}}.



Referenced by \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source_l01469}{permutation\+\_\+test\+\_\+score()}}.

\Hypertarget{namespacesklearn_1_1model__selection_1_1__validation_a7a1d0424033b9fae7c4c661d594f32c3}\index{sklearn.model\_selection.\_validation@{sklearn.model\_selection.\_validation}!\_translate\_train\_sizes@{\_translate\_train\_sizes}}
\index{\_translate\_train\_sizes@{\_translate\_train\_sizes}!sklearn.model\_selection.\_validation@{sklearn.model\_selection.\_validation}}
\doxysubsubsection{\texorpdfstring{\_translate\_train\_sizes()}{\_translate\_train\_sizes()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1model__selection_1_1__validation_a7a1d0424033b9fae7c4c661d594f32c3} 
sklearn.\+model\+\_\+selection.\+\_\+validation.\+\_\+translate\+\_\+train\+\_\+sizes (\begin{DoxyParamCaption}\item[{}]{train\+\_\+sizes}{, }\item[{}]{n\+\_\+max\+\_\+training\+\_\+samples}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Determine absolute sizes of training subsets and validate 'train_sizes'.

Examples:
    _translate_train_sizes([0.5, 1.0], 10) -> [5, 10]
    _translate_train_sizes([5, 10], 10) -> [5, 10]

Parameters
----------
train_sizes : array-like of shape (n_ticks,)
    Numbers of training examples that will be used to generate the
    learning curve. If the dtype is float, it is regarded as a
    fraction of 'n_max_training_samples', i.e. it has to be within (0, 1].

n_max_training_samples : int
    Maximum number of training samples (upper bound of 'train_sizes').

Returns
-------
train_sizes_abs : array of shape (n_unique_ticks,)
    Numbers of training examples that will be used to generate the
    learning curve. Note that the number of ticks might be less
    than n_ticks because duplicate entries will be removed.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source_l02102}{2102}} of file \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source}{\+\_\+validation.\+py}}.



Referenced by \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source_l01778}{learning\+\_\+curve()}}.

\Hypertarget{namespacesklearn_1_1model__selection_1_1__validation_aea8db1f680a2824ad71a404d074b3014}\index{sklearn.model\_selection.\_validation@{sklearn.model\_selection.\_validation}!\_warn\_or\_raise\_about\_fit\_failures@{\_warn\_or\_raise\_about\_fit\_failures}}
\index{\_warn\_or\_raise\_about\_fit\_failures@{\_warn\_or\_raise\_about\_fit\_failures}!sklearn.model\_selection.\_validation@{sklearn.model\_selection.\_validation}}
\doxysubsubsection{\texorpdfstring{\_warn\_or\_raise\_about\_fit\_failures()}{\_warn\_or\_raise\_about\_fit\_failures()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1model__selection_1_1__validation_aea8db1f680a2824ad71a404d074b3014} 
sklearn.\+model\+\_\+selection.\+\_\+validation.\+\_\+warn\+\_\+or\+\_\+raise\+\_\+about\+\_\+fit\+\_\+failures (\begin{DoxyParamCaption}\item[{}]{results}{, }\item[{}]{error\+\_\+score}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source_l00484}{484}} of file \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source}{\+\_\+validation.\+py}}.

\Hypertarget{namespacesklearn_1_1model__selection_1_1__validation_a51768cd061680860cb274d88d36547af}\index{sklearn.model\_selection.\_validation@{sklearn.model\_selection.\_validation}!cross\_val\_predict@{cross\_val\_predict}}
\index{cross\_val\_predict@{cross\_val\_predict}!sklearn.model\_selection.\_validation@{sklearn.model\_selection.\_validation}}
\doxysubsubsection{\texorpdfstring{cross\_val\_predict()}{cross\_val\_predict()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1model__selection_1_1__validation_a51768cd061680860cb274d88d36547af} 
sklearn.\+model\+\_\+selection.\+\_\+validation.\+cross\+\_\+val\+\_\+predict (\begin{DoxyParamCaption}\item[{}]{estimator}{, }\item[{}]{X}{, }\item[{}]{y}{ = {\ttfamily None}, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{groups}{ = {\ttfamily None}, }\item[{}]{cv}{ = {\ttfamily None}, }\item[{}]{n\+\_\+jobs}{ = {\ttfamily None}, }\item[{}]{verbose}{ = {\ttfamily 0}, }\item[{}]{params}{ = {\ttfamily None}, }\item[{}]{pre\+\_\+dispatch}{ = {\ttfamily "{}2\texorpdfstring{$\ast$}{*}n\+\_\+jobs"{}}, }\item[{}]{method}{ = {\ttfamily "{}predict"{}}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Generate cross-validated estimates for each input data point.

The data is split according to the cv parameter. Each sample belongs
to exactly one test set, and its prediction is computed with an
estimator fitted on the corresponding training set.

Passing these predictions into an evaluation metric may not be a valid
way to measure generalization performance. Results can differ from
:func:`cross_validate` and :func:`cross_val_score` unless all tests sets
have equal size and the metric decomposes over samples.

Read more in the :ref:`User Guide <cross_validation>`.

Parameters
----------
estimator : estimator
    The estimator instance to use to fit the data. It must implement a `fit`
    method and the method given by the `method` parameter.

X : {array-like, sparse matrix} of shape (n_samples, n_features)
    The data to fit. Can be, for example a list, or an array at least 2d.

y : {array-like, sparse matrix} of shape (n_samples,) or (n_samples, n_outputs), \
        default=None
    The target variable to try to predict in the case of
    supervised learning.

groups : array-like of shape (n_samples,), default=None
    Group labels for the samples used while splitting the dataset into
    train/test set. Only used in conjunction with a "Group" :term:`cv`
    instance (e.g., :class:`GroupKFold`).

    .. versionchanged:: 1.4
        ``groups`` can only be passed if metadata routing is not enabled
        via ``sklearn.set_config(enable_metadata_routing=True)``. When routing
        is enabled, pass ``groups`` alongside other metadata via the ``params``
        argument instead. E.g.:
        ``cross_val_predict(..., params={'groups': groups})``.

cv : int, cross-validation generator or an iterable, default=None
    Determines the cross-validation splitting strategy.
    Possible inputs for cv are:

    - None, to use the default 5-fold cross validation,
    - int, to specify the number of folds in a `(Stratified)KFold`,
    - :term:`CV splitter`,
    - An iterable that generates (train, test) splits as arrays of indices.

    For int/None inputs, if the estimator is a classifier and ``y`` is
    either binary or multiclass, :class:`StratifiedKFold` is used. In all
    other cases, :class:`KFold` is used. These splitters are instantiated
    with `shuffle=False` so the splits will be the same across calls.

    Refer :ref:`User Guide <cross_validation>` for the various
    cross-validation strategies that can be used here.

    .. versionchanged:: 0.22
        ``cv`` default value if None changed from 3-fold to 5-fold.

n_jobs : int, default=None
    Number of jobs to run in parallel. Training the estimator and
    predicting are parallelized over the cross-validation splits.
    ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.
    ``-1`` means using all processors. See :term:`Glossary <n_jobs>`
    for more details.

verbose : int, default=0
    The verbosity level.

params : dict, default=None
    Parameters to pass to the underlying estimator's ``fit`` and the CV
    splitter.

    .. versionadded:: 1.4

pre_dispatch : int or str, default='2*n_jobs'
    Controls the number of jobs that get dispatched during parallel
    execution. Reducing this number can be useful to avoid an
    explosion of memory consumption when more jobs get dispatched
    than CPUs can process. This parameter can be:

    - None, in which case all the jobs are immediately created and spawned. Use
      this for lightweight and fast-running jobs, to avoid delays due to on-demand
      spawning of the jobs
    - An int, giving the exact number of total jobs that are spawned
    - A str, giving an expression as a function of n_jobs, as in '2*n_jobs'

method : {'predict', 'predict_proba', 'predict_log_proba', \
          'decision_function'}, default='predict'
    The method to be invoked by `estimator`.

Returns
-------
predictions : ndarray
    This is the result of calling `method`. Shape:

    - When `method` is 'predict' and in special case where `method` is
      'decision_function' and the target is binary: (n_samples,)
    - When `method` is one of {'predict_proba', 'predict_log_proba',
      'decision_function'} (unless special case above):
      (n_samples, n_classes)
    - If `estimator` is :term:`multioutput`, an extra dimension
      'n_outputs' is added to the end of each shape above.

See Also
--------
cross_val_score : Calculate score for each CV split.
cross_validate : Calculate one or more scores and timings for each CV
    split.

Notes
-----
In the case that one or more classes are absent in a training portion, a
default score needs to be assigned to all instances for that class if
``method`` produces columns per class, as in {'decision_function',
'predict_proba', 'predict_log_proba'}.  For ``predict_proba`` this value is
0.  In order to ensure finite output, we approximate negative infinity by
the minimum finite float value for the dtype in other cases.

Examples
--------
>>> from sklearn import datasets, linear_model
>>> from sklearn.model_selection import cross_val_predict
>>> diabetes = datasets.load_diabetes()
>>> X = diabetes.data[:150]
>>> y = diabetes.target[:150]
>>> lasso = linear_model.Lasso()
>>> y_pred = cross_val_predict(lasso, X, y, cv=3)

For a detailed example of using ``cross_val_predict`` to visualize
prediction errors, please see
:ref:`sphx_glr_auto_examples_model_selection_plot_cv_predict.py`.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source_l01024}{1024}} of file \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source}{\+\_\+validation.\+py}}.



References \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source_l01414}{\+\_\+check\+\_\+is\+\_\+permutation()}}.

\Hypertarget{namespacesklearn_1_1model__selection_1_1__validation_a0c8543ce3043b69c6c80abe81f1b2a6a}\index{sklearn.model\_selection.\_validation@{sklearn.model\_selection.\_validation}!cross\_val\_score@{cross\_val\_score}}
\index{cross\_val\_score@{cross\_val\_score}!sklearn.model\_selection.\_validation@{sklearn.model\_selection.\_validation}}
\doxysubsubsection{\texorpdfstring{cross\_val\_score()}{cross\_val\_score()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1model__selection_1_1__validation_a0c8543ce3043b69c6c80abe81f1b2a6a} 
sklearn.\+model\+\_\+selection.\+\_\+validation.\+cross\+\_\+val\+\_\+score (\begin{DoxyParamCaption}\item[{}]{estimator}{, }\item[{}]{X}{, }\item[{}]{y}{ = {\ttfamily None}, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{groups}{ = {\ttfamily None}, }\item[{}]{scoring}{ = {\ttfamily None}, }\item[{}]{cv}{ = {\ttfamily None}, }\item[{}]{n\+\_\+jobs}{ = {\ttfamily None}, }\item[{}]{verbose}{ = {\ttfamily 0}, }\item[{}]{params}{ = {\ttfamily None}, }\item[{}]{pre\+\_\+dispatch}{ = {\ttfamily "{}2\texorpdfstring{$\ast$}{*}n\+\_\+jobs"{}}, }\item[{}]{error\+\_\+score}{ = {\ttfamily np.nan}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Evaluate a score by cross-validation.

Read more in the :ref:`User Guide <cross_validation>`.

Parameters
----------
estimator : estimator object implementing 'fit'
    The object to use to fit the data.

X : {array-like, sparse matrix} of shape (n_samples, n_features)
    The data to fit. Can be for example a list, or an array.

y : array-like of shape (n_samples,) or (n_samples, n_outputs), \
        default=None
    The target variable to try to predict in the case of
    supervised learning.

groups : array-like of shape (n_samples,), default=None
    Group labels for the samples used while splitting the dataset into
    train/test set. Only used in conjunction with a "Group" :term:`cv`
    instance (e.g., :class:`GroupKFold`).

    .. versionchanged:: 1.4
        ``groups`` can only be passed if metadata routing is not enabled
        via ``sklearn.set_config(enable_metadata_routing=True)``. When routing
        is enabled, pass ``groups`` alongside other metadata via the ``params``
        argument instead. E.g.:
        ``cross_val_score(..., params={'groups': groups})``.

scoring : str or callable, default=None
    Strategy to evaluate the performance of the `estimator` across cross-validation
    splits.

    - str: see :ref:`scoring_string_names` for options.
    - callable: a scorer callable object (e.g., function) with signature
      ``scorer(estimator, X, y)``, which should return only a single value.
      See :ref:`scoring_callable` for details.
    - `None`: the `estimator`'s
      :ref:`default evaluation criterion <scoring_api_overview>` is used.

    Similar to the use of `scoring` in :func:`cross_validate` but only a
    single metric is permitted.

cv : int, cross-validation generator or an iterable, default=None
    Determines the cross-validation splitting strategy.
    Possible inputs for cv are:

    - `None`, to use the default 5-fold cross validation,
    - int, to specify the number of folds in a `(Stratified)KFold`,
    - :term:`CV splitter`,
    - An iterable that generates (train, test) splits as arrays of indices.

    For `int`/`None` inputs, if the estimator is a classifier and `y` is
    either binary or multiclass, :class:`StratifiedKFold` is used. In all
    other cases, :class:`KFold` is used. These splitters are instantiated
    with `shuffle=False` so the splits will be the same across calls.

    Refer :ref:`User Guide <cross_validation>` for the various
    cross-validation strategies that can be used here.

    .. versionchanged:: 0.22
        `cv` default value if `None` changed from 3-fold to 5-fold.

n_jobs : int, default=None
    Number of jobs to run in parallel. Training the estimator and computing
    the score are parallelized over the cross-validation splits.
    ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.
    ``-1`` means using all processors. See :term:`Glossary <n_jobs>`
    for more details.

verbose : int, default=0
    The verbosity level.

params : dict, default=None
    Parameters to pass to the underlying estimator's ``fit``, the scorer,
    and the CV splitter.

    .. versionadded:: 1.4

pre_dispatch : int or str, default='2*n_jobs'
    Controls the number of jobs that get dispatched during parallel
    execution. Reducing this number can be useful to avoid an
    explosion of memory consumption when more jobs get dispatched
    than CPUs can process. This parameter can be:

    - ``None``, in which case all the jobs are immediately created and spawned. Use
      this for lightweight and fast-running jobs, to avoid delays due to on-demand
      spawning of the jobs
    - An int, giving the exact number of total jobs that are spawned
    - A str, giving an expression as a function of n_jobs, as in '2*n_jobs'

error_score : 'raise' or numeric, default=np.nan
    Value to assign to the score if an error occurs in estimator fitting.
    If set to 'raise', the error is raised.
    If a numeric value is given, FitFailedWarning is raised.

    .. versionadded:: 0.20

Returns
-------
scores : ndarray of float of shape=(len(list(cv)),)
    Array of scores of the estimator for each run of the cross validation.

See Also
--------
cross_validate : To run cross-validation on multiple metrics and also to
    return train scores, fit times and score times.

cross_val_predict : Get predictions from each split of cross-validation for
    diagnostic purposes.

sklearn.metrics.make_scorer : Make a scorer from a performance metric or
    loss function.

Examples
--------
>>> from sklearn import datasets, linear_model
>>> from sklearn.model_selection import cross_val_score
>>> diabetes = datasets.load_diabetes()
>>> X = diabetes.data[:150]
>>> y = diabetes.target[:150]
>>> lasso = linear_model.Lasso()
>>> print(cross_val_score(lasso, X, y, cv=3))
[0.3315057  0.08022103 0.03531816]
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source_l00535}{535}} of file \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source}{\+\_\+validation.\+py}}.



References \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source_l00140}{cross\+\_\+validate()}}.

\Hypertarget{namespacesklearn_1_1model__selection_1_1__validation_a707be5df473fe7b18a2e77e11b32fcb4}\index{sklearn.model\_selection.\_validation@{sklearn.model\_selection.\_validation}!cross\_validate@{cross\_validate}}
\index{cross\_validate@{cross\_validate}!sklearn.model\_selection.\_validation@{sklearn.model\_selection.\_validation}}
\doxysubsubsection{\texorpdfstring{cross\_validate()}{cross\_validate()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1model__selection_1_1__validation_a707be5df473fe7b18a2e77e11b32fcb4} 
sklearn.\+model\+\_\+selection.\+\_\+validation.\+cross\+\_\+validate (\begin{DoxyParamCaption}\item[{}]{estimator}{, }\item[{}]{X}{, }\item[{}]{y}{ = {\ttfamily None}, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{groups}{ = {\ttfamily None}, }\item[{}]{scoring}{ = {\ttfamily None}, }\item[{}]{cv}{ = {\ttfamily None}, }\item[{}]{n\+\_\+jobs}{ = {\ttfamily None}, }\item[{}]{verbose}{ = {\ttfamily 0}, }\item[{}]{params}{ = {\ttfamily None}, }\item[{}]{pre\+\_\+dispatch}{ = {\ttfamily "{}2\texorpdfstring{$\ast$}{*}n\+\_\+jobs"{}}, }\item[{}]{return\+\_\+train\+\_\+score}{ = {\ttfamily False}, }\item[{}]{return\+\_\+estimator}{ = {\ttfamily False}, }\item[{}]{return\+\_\+indices}{ = {\ttfamily False}, }\item[{}]{error\+\_\+score}{ = {\ttfamily np.nan}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Evaluate metric(s) by cross-validation and also record fit/score times.

Read more in the :ref:`User Guide <multimetric_cross_validation>`.

Parameters
----------
estimator : estimator object implementing 'fit'
    The object to use to fit the data.

X : {array-like, sparse matrix} of shape (n_samples, n_features)
    The data to fit. Can be for example a list, or an array.

y : array-like of shape (n_samples,) or (n_samples, n_outputs), default=None
    The target variable to try to predict in the case of
    supervised learning.

groups : array-like of shape (n_samples,), default=None
    Group labels for the samples used while splitting the dataset into
    train/test set. Only used in conjunction with a "Group" :term:`cv`
    instance (e.g., :class:`GroupKFold`).

    .. versionchanged:: 1.4
        ``groups`` can only be passed if metadata routing is not enabled
        via ``sklearn.set_config(enable_metadata_routing=True)``. When routing
        is enabled, pass ``groups`` alongside other metadata via the ``params``
        argument instead. E.g.:
        ``cross_validate(..., params={'groups': groups})``.

scoring : str, callable, list, tuple, or dict, default=None
    Strategy to evaluate the performance of the `estimator` across cross-validation
    splits.

    If `scoring` represents a single score, one can use:

    - a single string (see :ref:`scoring_string_names`);
    - a callable (see :ref:`scoring_callable`) that returns a single value.
    - `None`, the `estimator`'s
      :ref:`default evaluation criterion <scoring_api_overview>` is used.

    If `scoring` represents multiple scores, one can use:

    - a list or tuple of unique strings;
    - a callable returning a dictionary where the keys are the metric
      names and the values are the metric scores;
    - a dictionary with metric names as keys and callables a values.

    See :ref:`multimetric_grid_search` for an example.

cv : int, cross-validation generator or an iterable, default=None
    Determines the cross-validation splitting strategy.
    Possible inputs for cv are:

    - None, to use the default 5-fold cross validation,
    - int, to specify the number of folds in a `(Stratified)KFold`,
    - :term:`CV splitter`,
    - An iterable yielding (train, test) splits as arrays of indices.

    For int/None inputs, if the estimator is a classifier and ``y`` is
    either binary or multiclass, :class:`StratifiedKFold` is used. In all
    other cases, :class:`KFold` is used. These splitters are instantiated
    with `shuffle=False` so the splits will be the same across calls.

    Refer :ref:`User Guide <cross_validation>` for the various
    cross-validation strategies that can be used here.

    .. versionchanged:: 0.22
        ``cv`` default value if None changed from 3-fold to 5-fold.

n_jobs : int, default=None
    Number of jobs to run in parallel. Training the estimator and computing
    the score are parallelized over the cross-validation splits.
    ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.
    ``-1`` means using all processors. See :term:`Glossary <n_jobs>`
    for more details.

verbose : int, default=0
    The verbosity level.

params : dict, default=None
    Parameters to pass to the underlying estimator's ``fit``, the scorer,
    and the CV splitter.

    .. versionadded:: 1.4

pre_dispatch : int or str, default='2*n_jobs'
    Controls the number of jobs that get dispatched during parallel
    execution. Reducing this number can be useful to avoid an
    explosion of memory consumption when more jobs get dispatched
    than CPUs can process. This parameter can be:

    - An int, giving the exact number of total jobs that are spawned
    - A str, giving an expression as a function of n_jobs, as in '2*n_jobs'

return_train_score : bool, default=False
    Whether to include train scores.
    Computing training scores is used to get insights on how different
    parameter settings impact the overfitting/underfitting trade-off.
    However computing the scores on the training set can be computationally
    expensive and is not strictly required to select the parameters that
    yield the best generalization performance.

    .. versionadded:: 0.19

    .. versionchanged:: 0.21
        Default value was changed from ``True`` to ``False``

return_estimator : bool, default=False
    Whether to return the estimators fitted on each split.

    .. versionadded:: 0.20

return_indices : bool, default=False
    Whether to return the train-test indices selected for each split.

    .. versionadded:: 1.3

error_score : 'raise' or numeric, default=np.nan
    Value to assign to the score if an error occurs in estimator fitting.
    If set to 'raise', the error is raised.
    If a numeric value is given, FitFailedWarning is raised.

    .. versionadded:: 0.20

Returns
-------
scores : dict of float arrays of shape (n_splits,)
    Array of scores of the estimator for each run of the cross validation.

    A dict of arrays containing the score/time arrays for each scorer is
    returned. The possible keys for this ``dict`` are:

    ``test_score``
        The score array for test scores on each cv split.
        Suffix ``_score`` in ``test_score`` changes to a specific
        metric like ``test_r2`` or ``test_auc`` if there are
        multiple scoring metrics in the scoring parameter.
    ``train_score``
        The score array for train scores on each cv split.
        Suffix ``_score`` in ``train_score`` changes to a specific
        metric like ``train_r2`` or ``train_auc`` if there are
        multiple scoring metrics in the scoring parameter.
        This is available only if ``return_train_score`` parameter
        is ``True``.
    ``fit_time``
        The time for fitting the estimator on the train
        set for each cv split.
    ``score_time``
        The time for scoring the estimator on the test set for each
        cv split. (Note: time for scoring on the train set is not
        included even if ``return_train_score`` is set to ``True``).
    ``estimator``
        The estimator objects for each cv split.
        This is available only if ``return_estimator`` parameter
        is set to ``True``.
    ``indices``
        The train/test positional indices for each cv split. A dictionary
        is returned where the keys are either `"train"` or `"test"`
        and the associated values are a list of integer-dtyped NumPy
        arrays with the indices. Available only if `return_indices=True`.

See Also
--------
cross_val_score : Run cross-validation for single metric evaluation.

cross_val_predict : Get predictions from each split of cross-validation for
    diagnostic purposes.

sklearn.metrics.make_scorer : Make a scorer from a performance metric or
    loss function.

Examples
--------
>>> from sklearn import datasets, linear_model
>>> from sklearn.model_selection import cross_validate
>>> from sklearn.metrics import make_scorer
>>> from sklearn.metrics import confusion_matrix
>>> from sklearn.svm import LinearSVC
>>> diabetes = datasets.load_diabetes()
>>> X = diabetes.data[:150]
>>> y = diabetes.target[:150]
>>> lasso = linear_model.Lasso()

Single metric evaluation using ``cross_validate``

>>> cv_results = cross_validate(lasso, X, y, cv=3)
>>> sorted(cv_results.keys())
['fit_time', 'score_time', 'test_score']
>>> cv_results['test_score']
array([0.3315057 , 0.08022103, 0.03531816])

Multiple metric evaluation using ``cross_validate``
(please refer the ``scoring`` parameter doc for more information)

>>> scores = cross_validate(lasso, X, y, cv=3,
...                         scoring=('r2', 'neg_mean_squared_error'),
...                         return_train_score=True)
>>> print(scores['test_neg_mean_squared_error'])
[-3635.5 -3573.3 -6114.7]
>>> print(scores['train_r2'])
[0.28009951 0.3908844  0.22784907]
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source_l00124}{124}} of file \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source}{\+\_\+validation.\+py}}.



References \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source_l02500}{\+\_\+aggregate\+\_\+score\+\_\+dicts()}}, \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source_l00453}{\+\_\+insert\+\_\+error\+\_\+scores()}}, and \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source_l00475}{\+\_\+normalize\+\_\+score\+\_\+results()}}.



Referenced by \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source_l00548}{cross\+\_\+val\+\_\+score()}}.

\Hypertarget{namespacesklearn_1_1model__selection_1_1__validation_ae34dd63d73da496d8acbc2c2b9872e70}\index{sklearn.model\_selection.\_validation@{sklearn.model\_selection.\_validation}!learning\_curve@{learning\_curve}}
\index{learning\_curve@{learning\_curve}!sklearn.model\_selection.\_validation@{sklearn.model\_selection.\_validation}}
\doxysubsubsection{\texorpdfstring{learning\_curve()}{learning\_curve()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1model__selection_1_1__validation_ae34dd63d73da496d8acbc2c2b9872e70} 
sklearn.\+model\+\_\+selection.\+\_\+validation.\+learning\+\_\+curve (\begin{DoxyParamCaption}\item[{}]{estimator}{, }\item[{}]{X}{, }\item[{}]{y}{, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{groups}{ = {\ttfamily None}, }\item[{}]{train\+\_\+sizes}{ = {\ttfamily np.linspace(0.1,~1.0,~5)}, }\item[{}]{cv}{ = {\ttfamily None}, }\item[{}]{scoring}{ = {\ttfamily None}, }\item[{}]{exploit\+\_\+incremental\+\_\+learning}{ = {\ttfamily False}, }\item[{}]{n\+\_\+jobs}{ = {\ttfamily None}, }\item[{}]{pre\+\_\+dispatch}{ = {\ttfamily "{}all"{}}, }\item[{}]{verbose}{ = {\ttfamily 0}, }\item[{}]{shuffle}{ = {\ttfamily False}, }\item[{}]{random\+\_\+state}{ = {\ttfamily None}, }\item[{}]{error\+\_\+score}{ = {\ttfamily np.nan}, }\item[{}]{return\+\_\+times}{ = {\ttfamily False}, }\item[{}]{fit\+\_\+params}{ = {\ttfamily None}, }\item[{}]{params}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Learning curve.

Determines cross-validated training and test scores for different training
set sizes.

A cross-validation generator splits the whole dataset k times in training
and test data. Subsets of the training set with varying sizes will be used
to train the estimator and a score for each training subset size and the
test set will be computed. Afterwards, the scores will be averaged over
all k runs for each training subset size.

Read more in the :ref:`User Guide <learning_curve>`.

Parameters
----------
estimator : object type that implements the "fit" method
    An object of that type which is cloned for each validation. It must
    also implement "predict" unless `scoring` is a callable that doesn't
    rely on "predict" to compute a score.

X : {array-like, sparse matrix} of shape (n_samples, n_features)
    Training vector, where `n_samples` is the number of samples and
    `n_features` is the number of features.

y : array-like of shape (n_samples,) or (n_samples, n_outputs) or None
    Target relative to X for classification or regression;
    None for unsupervised learning.

groups : array-like of shape (n_samples,), default=None
    Group labels for the samples used while splitting the dataset into
    train/test set. Only used in conjunction with a "Group" :term:`cv`
    instance (e.g., :class:`GroupKFold`).

    .. versionchanged:: 1.6
        ``groups`` can only be passed if metadata routing is not enabled
        via ``sklearn.set_config(enable_metadata_routing=True)``. When routing
        is enabled, pass ``groups`` alongside other metadata via the ``params``
        argument instead. E.g.:
        ``learning_curve(..., params={'groups': groups})``.

train_sizes : array-like of shape (n_ticks,), \
        default=np.linspace(0.1, 1.0, 5)
    Relative or absolute numbers of training examples that will be used to
    generate the learning curve. If the dtype is float, it is regarded as a
    fraction of the maximum size of the training set (that is determined
    by the selected validation method), i.e. it has to be within (0, 1].
    Otherwise it is interpreted as absolute sizes of the training sets.
    Note that for classification the number of samples usually has to
    be big enough to contain at least one sample from each class.

cv : int, cross-validation generator or an iterable, default=None
    Determines the cross-validation splitting strategy.
    Possible inputs for cv are:

    - None, to use the default 5-fold cross validation,
    - int, to specify the number of folds in a `(Stratified)KFold`,
    - :term:`CV splitter`,
    - An iterable yielding (train, test) splits as arrays of indices.

    For int/None inputs, if the estimator is a classifier and ``y`` is
    either binary or multiclass, :class:`StratifiedKFold` is used. In all
    other cases, :class:`KFold` is used. These splitters are instantiated
    with `shuffle=False` so the splits will be the same across calls.

    Refer :ref:`User Guide <cross_validation>` for the various
    cross-validation strategies that can be used here.

    .. versionchanged:: 0.22
        ``cv`` default value if None changed from 3-fold to 5-fold.

scoring : str or callable, default=None
    Scoring method to use to evaluate the training and test sets.

    - str: see :ref:`scoring_string_names` for options.
    - callable: a scorer callable object (e.g., function) with signature
      ``scorer(estimator, X, y)``. See :ref:`scoring_callable` for details.
    - `None`: the `estimator`'s
      :ref:`default evaluation criterion <scoring_api_overview>` is used.

exploit_incremental_learning : bool, default=False
    If the estimator supports incremental learning, this will be
    used to speed up fitting for different training set sizes.

n_jobs : int, default=None
    Number of jobs to run in parallel. Training the estimator and computing
    the score are parallelized over the different training and test sets.
    ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.
    ``-1`` means using all processors. See :term:`Glossary <n_jobs>`
    for more details.

pre_dispatch : int or str, default='all'
    Number of predispatched jobs for parallel execution (default is
    all). The option can reduce the allocated memory. The str can
    be an expression like '2*n_jobs'.

verbose : int, default=0
    Controls the verbosity: the higher, the more messages.

shuffle : bool, default=False
    Whether to shuffle training data before taking prefixes of it
    based on``train_sizes``.

random_state : int, RandomState instance or None, default=None
    Used when ``shuffle`` is True. Pass an int for reproducible
    output across multiple function calls.
    See :term:`Glossary <random_state>`.

error_score : 'raise' or numeric, default=np.nan
    Value to assign to the score if an error occurs in estimator fitting.
    If set to 'raise', the error is raised.
    If a numeric value is given, FitFailedWarning is raised.

    .. versionadded:: 0.20

return_times : bool, default=False
    Whether to return the fit and score times.

fit_params : dict, default=None
    Parameters to pass to the fit method of the estimator.

    .. deprecated:: 1.6
        This parameter is deprecated and will be removed in version 1.8. Use
        ``params`` instead.

params : dict, default=None
    Parameters to pass to the `fit` method of the estimator and to the scorer.

    - If `enable_metadata_routing=False` (default): Parameters directly passed to
      the `fit` method of the estimator.

    - If `enable_metadata_routing=True`: Parameters safely routed to the `fit`
      method of the estimator. See :ref:`Metadata Routing User Guide
      <metadata_routing>` for more details.

    .. versionadded:: 1.6

Returns
-------
train_sizes_abs : array of shape (n_unique_ticks,)
    Numbers of training examples that has been used to generate the
    learning curve. Note that the number of ticks might be less
    than n_ticks because duplicate entries will be removed.

train_scores : array of shape (n_ticks, n_cv_folds)
    Scores on training sets.

test_scores : array of shape (n_ticks, n_cv_folds)
    Scores on test set.

fit_times : array of shape (n_ticks, n_cv_folds)
    Times spent for fitting in seconds. Only present if ``return_times``
    is True.

score_times : array of shape (n_ticks, n_cv_folds)
    Times spent for scoring in seconds. Only present if ``return_times``
    is True.

See Also
--------
LearningCurveDisplay.from_estimator : Plot a learning curve using an
    estimator and data.

Examples
--------
>>> from sklearn.datasets import make_classification
>>> from sklearn.tree import DecisionTreeClassifier
>>> from sklearn.model_selection import learning_curve
>>> X, y = make_classification(n_samples=100, n_features=10, random_state=42)
>>> tree = DecisionTreeClassifier(max_depth=4, random_state=42)
>>> train_size_abs, train_scores, test_scores = learning_curve(
...     tree, X, y, train_sizes=[0.3, 0.6, 0.9]
... )
>>> for train_size, cv_train_scores, cv_test_scores in zip(
...     train_size_abs, train_scores, test_scores
... ):
...     print(f"{train_size} samples were used to train the model")
...     print(f"The average train accuracy is {cv_train_scores.mean():.2f}")
...     print(f"The average test accuracy is {cv_test_scores.mean():.2f}")
24 samples were used to train the model
The average train accuracy is 1.00
The average test accuracy is 0.85
48 samples were used to train the model
The average train accuracy is 1.00
The average test accuracy is 0.90
72 samples were used to train the model
The average train accuracy is 1.00
The average test accuracy is 0.93
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source_l01759}{1759}} of file \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source}{\+\_\+validation.\+py}}.



References \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source_l02500}{\+\_\+aggregate\+\_\+score\+\_\+dicts()}}, \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source_l00057}{\+\_\+check\+\_\+params\+\_\+groups\+\_\+deprecation()}}, and \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source_l02102}{\+\_\+translate\+\_\+train\+\_\+sizes()}}.

\Hypertarget{namespacesklearn_1_1model__selection_1_1__validation_a5a308e3613bc2c4f0a38add7635b0c35}\index{sklearn.model\_selection.\_validation@{sklearn.model\_selection.\_validation}!permutation\_test\_score@{permutation\_test\_score}}
\index{permutation\_test\_score@{permutation\_test\_score}!sklearn.model\_selection.\_validation@{sklearn.model\_selection.\_validation}}
\doxysubsubsection{\texorpdfstring{permutation\_test\_score()}{permutation\_test\_score()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1model__selection_1_1__validation_a5a308e3613bc2c4f0a38add7635b0c35} 
sklearn.\+model\+\_\+selection.\+\_\+validation.\+permutation\+\_\+test\+\_\+score (\begin{DoxyParamCaption}\item[{}]{estimator}{, }\item[{}]{X}{, }\item[{}]{y}{, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{groups}{ = {\ttfamily None}, }\item[{}]{cv}{ = {\ttfamily None}, }\item[{}]{n\+\_\+permutations}{ = {\ttfamily 100}, }\item[{}]{n\+\_\+jobs}{ = {\ttfamily None}, }\item[{}]{random\+\_\+state}{ = {\ttfamily 0}, }\item[{}]{verbose}{ = {\ttfamily 0}, }\item[{}]{scoring}{ = {\ttfamily None}, }\item[{}]{fit\+\_\+params}{ = {\ttfamily None}, }\item[{}]{params}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Evaluate the significance of a cross-validated score with permutations.

Permutes targets to generate 'randomized data' and compute the empirical
p-value against the null hypothesis that features and targets are
independent.

The p-value represents the fraction of randomized data sets where the
estimator performed as well or better than on the original data. A small
p-value suggests that there is a real dependency between features and
targets which has been used by the estimator to give good predictions.
A large p-value may be due to lack of real dependency between features
and targets or the estimator was not able to use the dependency to
give good predictions.

Read more in the :ref:`User Guide <permutation_test_score>`.

Parameters
----------
estimator : estimator object implementing 'fit'
    The object to use to fit the data.

X : array-like of shape at least 2D
    The data to fit.

y : array-like of shape (n_samples,) or (n_samples, n_outputs) or None
    The target variable to try to predict in the case of
    supervised learning.

groups : array-like of shape (n_samples,), default=None
    Labels to constrain permutation within groups, i.e. ``y`` values
    are permuted among samples with the same group identifier.
    When not specified, ``y`` values are permuted among all samples.

    When a grouped cross-validator is used, the group labels are
    also passed on to the ``split`` method of the cross-validator. The
    cross-validator uses them for grouping the samples  while splitting
    the dataset into train/test set.

    .. versionchanged:: 1.6
        ``groups`` can only be passed if metadata routing is not enabled
        via ``sklearn.set_config(enable_metadata_routing=True)``. When routing
        is enabled, pass ``groups`` alongside other metadata via the ``params``
        argument instead. E.g.:
        ``permutation_test_score(..., params={'groups': groups})``.

cv : int, cross-validation generator or an iterable, default=None
    Determines the cross-validation splitting strategy.
    Possible inputs for cv are:

    - `None`, to use the default 5-fold cross validation,
    - int, to specify the number of folds in a `(Stratified)KFold`,
    - :term:`CV splitter`,
    - An iterable yielding (train, test) splits as arrays of indices.

    For `int`/`None` inputs, if the estimator is a classifier and `y` is
    either binary or multiclass, :class:`StratifiedKFold` is used. In all
    other cases, :class:`KFold` is used. These splitters are instantiated
    with `shuffle=False` so the splits will be the same across calls.

    Refer :ref:`User Guide <cross_validation>` for the various
    cross-validation strategies that can be used here.

    .. versionchanged:: 0.22
        `cv` default value if `None` changed from 3-fold to 5-fold.

n_permutations : int, default=100
    Number of times to permute ``y``.

n_jobs : int, default=None
    Number of jobs to run in parallel. Training the estimator and computing
    the cross-validated score are parallelized over the permutations.
    ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.
    ``-1`` means using all processors. See :term:`Glossary <n_jobs>`
    for more details.

random_state : int, RandomState instance or None, default=0
    Pass an int for reproducible output for permutation of
    ``y`` values among samples. See :term:`Glossary <random_state>`.

verbose : int, default=0
    The verbosity level.

scoring : str or callable, default=None
    Scoring method to use to evaluate the predictions on the validation set.

    - str: see :ref:`scoring_string_names` for options.
    - callable: a scorer callable object (e.g., function) with signature
      ``scorer(estimator, X, y)``, which should return only a single value.
      See :ref:`scoring_callable` for details.
    - `None`: the `estimator`'s
      :ref:`default evaluation criterion <scoring_api_overview>` is used.

fit_params : dict, default=None
    Parameters to pass to the fit method of the estimator.

    .. deprecated:: 1.6
        This parameter is deprecated and will be removed in version 1.6. Use
        ``params`` instead.

params : dict, default=None
    Parameters to pass to the `fit` method of the estimator, the scorer
    and the cv splitter.

    - If `enable_metadata_routing=False` (default): Parameters directly passed to
      the `fit` method of the estimator.

    - If `enable_metadata_routing=True`: Parameters safely routed to the `fit`
      method of the estimator, `cv` object and `scorer`. See :ref:`Metadata Routing
      User Guide <metadata_routing>` for more details.

    .. versionadded:: 1.6

Returns
-------
score : float
    The true score without permuting targets.

permutation_scores : array of shape (n_permutations,)
    The scores obtained for each permutations.

pvalue : float
    The p-value, which approximates the probability that the score would
    be obtained by chance. This is calculated as:

    `(C + 1) / (n_permutations + 1)`

    Where C is the number of permutations whose score >= the true score.

    The best possible p-value is 1/(n_permutations + 1), the worst is 1.0.

Notes
-----
This function implements Test 1 in:

Ojala and Garriga. `Permutation Tests for Studying Classifier Performance
<http://www.jmlr.org/papers/volume11/ojala10a/ojala10a.pdf>`_. The
Journal of Machine Learning Research (2010) vol. 11

Examples
--------
>>> from sklearn.datasets import make_classification
>>> from sklearn.linear_model import LogisticRegression
>>> from sklearn.model_selection import permutation_test_score
>>> X, y = make_classification(random_state=0)
>>> estimator = LogisticRegression()
>>> score, permutation_scores, pvalue = permutation_test_score(
...     estimator, X, y, random_state=0
... )
>>> print(f"Original Score: {score:.3f}")
Original Score: 0.810
>>> print(
...     f"Permutation Scores: {permutation_scores.mean():.3f} +/- "
...     f"{permutation_scores.std():.3f}"
... )
Permutation Scores: 0.505 +/- 0.057
>>> print(f"P-value: {pvalue:.3f}")
P-value: 0.010
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source_l01455}{1455}} of file \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source}{\+\_\+validation.\+py}}.



References \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source_l00057}{\+\_\+check\+\_\+params\+\_\+groups\+\_\+deprecation()}}, \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source_l01708}{\+\_\+permutation\+\_\+test\+\_\+score()}}, and \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source_l01725}{\+\_\+shuffle()}}.

\Hypertarget{namespacesklearn_1_1model__selection_1_1__validation_af22f5c88c240298733598466868c0f58}\index{sklearn.model\_selection.\_validation@{sklearn.model\_selection.\_validation}!validation\_curve@{validation\_curve}}
\index{validation\_curve@{validation\_curve}!sklearn.model\_selection.\_validation@{sklearn.model\_selection.\_validation}}
\doxysubsubsection{\texorpdfstring{validation\_curve()}{validation\_curve()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1model__selection_1_1__validation_af22f5c88c240298733598466868c0f58} 
sklearn.\+model\+\_\+selection.\+\_\+validation.\+validation\+\_\+curve (\begin{DoxyParamCaption}\item[{}]{estimator}{, }\item[{}]{X}{, }\item[{}]{y}{, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{param\+\_\+name}{, }\item[{}]{param\+\_\+range}{, }\item[{}]{groups}{ = {\ttfamily None}, }\item[{}]{cv}{ = {\ttfamily None}, }\item[{}]{scoring}{ = {\ttfamily None}, }\item[{}]{n\+\_\+jobs}{ = {\ttfamily None}, }\item[{}]{pre\+\_\+dispatch}{ = {\ttfamily "{}all"{}}, }\item[{}]{verbose}{ = {\ttfamily 0}, }\item[{}]{error\+\_\+score}{ = {\ttfamily np.nan}, }\item[{}]{fit\+\_\+params}{ = {\ttfamily None}, }\item[{}]{params}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Validation curve.

Determine training and test scores for varying parameter values.

Compute scores for an estimator with different values of a specified
parameter. This is similar to grid search with one parameter. However, this
will also compute training scores and is merely a utility for plotting the
results.

Read more in the :ref:`User Guide <validation_curve>`.

Parameters
----------
estimator : object type that implements the "fit" method
    An object of that type which is cloned for each validation. It must
    also implement "predict" unless `scoring` is a callable that doesn't
    rely on "predict" to compute a score.

X : {array-like, sparse matrix} of shape (n_samples, n_features)
    Training vector, where `n_samples` is the number of samples and
    `n_features` is the number of features.

y : array-like of shape (n_samples,) or (n_samples, n_outputs) or None
    Target relative to X for classification or regression;
    None for unsupervised learning.

param_name : str
    Name of the parameter that will be varied.

param_range : array-like of shape (n_values,)
    The values of the parameter that will be evaluated.

groups : array-like of shape (n_samples,), default=None
    Group labels for the samples used while splitting the dataset into
    train/test set. Only used in conjunction with a "Group" :term:`cv`
    instance (e.g., :class:`GroupKFold`).

    .. versionchanged:: 1.6
        ``groups`` can only be passed if metadata routing is not enabled
        via ``sklearn.set_config(enable_metadata_routing=True)``. When routing
        is enabled, pass ``groups`` alongside other metadata via the ``params``
        argument instead. E.g.:
        ``validation_curve(..., params={'groups': groups})``.

cv : int, cross-validation generator or an iterable, default=None
    Determines the cross-validation splitting strategy.
    Possible inputs for cv are:

    - None, to use the default 5-fold cross validation,
    - int, to specify the number of folds in a `(Stratified)KFold`,
    - :term:`CV splitter`,
    - An iterable yielding (train, test) splits as arrays of indices.

    For int/None inputs, if the estimator is a classifier and ``y`` is
    either binary or multiclass, :class:`StratifiedKFold` is used. In all
    other cases, :class:`KFold` is used. These splitters are instantiated
    with `shuffle=False` so the splits will be the same across calls.

    Refer :ref:`User Guide <cross_validation>` for the various
    cross-validation strategies that can be used here.

    .. versionchanged:: 0.22
        ``cv`` default value if None changed from 3-fold to 5-fold.

scoring : str or callable, default=None
    Scoring method to use to evaluate the training and test sets.

    - str: see :ref:`scoring_string_names` for options.
    - callable: a scorer callable object (e.g., function) with signature
      ``scorer(estimator, X, y)``. See :ref:`scoring_callable` for details.
    - `None`: the `estimator`'s
      :ref:`default evaluation criterion <scoring_api_overview>` is used.

n_jobs : int, default=None
    Number of jobs to run in parallel. Training the estimator and computing
    the score are parallelized over the combinations of each parameter
    value and each cross-validation split.
    ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.
    ``-1`` means using all processors. See :term:`Glossary <n_jobs>`
    for more details.

pre_dispatch : int or str, default='all'
    Number of predispatched jobs for parallel execution (default is
    all). The option can reduce the allocated memory. The str can
    be an expression like '2*n_jobs'.

verbose : int, default=0
    Controls the verbosity: the higher, the more messages.

error_score : 'raise' or numeric, default=np.nan
    Value to assign to the score if an error occurs in estimator fitting.
    If set to 'raise', the error is raised.
    If a numeric value is given, FitFailedWarning is raised.

    .. versionadded:: 0.20

fit_params : dict, default=None
    Parameters to pass to the fit method of the estimator.

    .. deprecated:: 1.6
        This parameter is deprecated and will be removed in version 1.8. Use
        ``params`` instead.

params : dict, default=None
    Parameters to pass to the estimator, scorer and cross-validation object.

    - If `enable_metadata_routing=False` (default): Parameters directly passed to
      the `fit` method of the estimator.

    - If `enable_metadata_routing=True`: Parameters safely routed to the `fit`
      method of the estimator, to the scorer and to the cross-validation object.
      See :ref:`Metadata Routing User Guide <metadata_routing>` for more details.

    .. versionadded:: 1.6

Returns
-------
train_scores : array of shape (n_ticks, n_cv_folds)
    Scores on training sets.

test_scores : array of shape (n_ticks, n_cv_folds)
    Scores on test set.

See Also
--------
ValidationCurveDisplay.from_estimator : Plot the validation curve
    given an estimator, the data, and the parameter to vary.

Notes
-----
See :ref:`sphx_glr_auto_examples_model_selection_plot_train_error_vs_test_error.py`

Examples
--------
>>> import numpy as np
>>> from sklearn.datasets import make_classification
>>> from sklearn.model_selection import validation_curve
>>> from sklearn.linear_model import LogisticRegression
>>> X, y = make_classification(n_samples=1_000, random_state=0)
>>> logistic_regression = LogisticRegression()
>>> param_name, param_range = "C", np.logspace(-8, 3, 10)
>>> train_scores, test_scores = validation_curve(
...     logistic_regression, X, y, param_name=param_name, param_range=param_range
... )
>>> print(f"The average train accuracy is {train_scores.mean():.2f}")
The average train accuracy is 0.81
>>> print(f"The average test accuracy is {test_scores.mean():.2f}")
The average test accuracy is 0.81
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source_l02263}{2263}} of file \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source}{\+\_\+validation.\+py}}.



References \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source_l02500}{\+\_\+aggregate\+\_\+score\+\_\+dicts()}}, and \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source_l00057}{\+\_\+check\+\_\+params\+\_\+groups\+\_\+deprecation()}}.



\doxysubsection{Variable Documentation}
\Hypertarget{namespacesklearn_1_1model__selection_1_1__validation_a2b0816d638ef3e4088b1e244920b218e}\index{sklearn.model\_selection.\_validation@{sklearn.model\_selection.\_validation}!\_\_all\_\_@{\_\_all\_\_}}
\index{\_\_all\_\_@{\_\_all\_\_}!sklearn.model\_selection.\_validation@{sklearn.model\_selection.\_validation}}
\doxysubsubsection{\texorpdfstring{\_\_all\_\_}{\_\_all\_\_}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1model__selection_1_1__validation_a2b0816d638ef3e4088b1e244920b218e} 
list sklearn.\+model\+\_\+selection.\+\_\+validation.\+\_\+\+\_\+all\+\_\+\+\_\+\hspace{0.3cm}{\ttfamily [private]}}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ [}
\DoxyCodeLine{00002\ \ \ \ \ \textcolor{stringliteral}{"{}cross\_val\_predict"{}},}
\DoxyCodeLine{00003\ \ \ \ \ \textcolor{stringliteral}{"{}cross\_val\_score"{}},}
\DoxyCodeLine{00004\ \ \ \ \ \textcolor{stringliteral}{"{}cross\_validate"{}},}
\DoxyCodeLine{00005\ \ \ \ \ \textcolor{stringliteral}{"{}learning\_curve"{}},}
\DoxyCodeLine{00006\ \ \ \ \ \textcolor{stringliteral}{"{}permutation\_test\_score"{}},}
\DoxyCodeLine{00007\ \ \ \ \ \textcolor{stringliteral}{"{}validation\_curve"{}},}
\DoxyCodeLine{00008\ ]}

\end{DoxyCode}


Definition at line \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source_l00047}{47}} of file \mbox{\hyperlink{sklearn_2model__selection_2__validation_8py_source}{\+\_\+validation.\+py}}.

