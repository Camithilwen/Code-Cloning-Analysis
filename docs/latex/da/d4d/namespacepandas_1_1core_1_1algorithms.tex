\doxysection{pandas.\+core.\+algorithms Namespace Reference}
\hypertarget{namespacepandas_1_1core_1_1algorithms}{}\label{namespacepandas_1_1core_1_1algorithms}\index{pandas.core.algorithms@{pandas.core.algorithms}}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
np.\+ndarray \mbox{\hyperlink{namespacepandas_1_1core_1_1algorithms_a874d39e4200cf44ffe3d92f229ffb058}{\+\_\+ensure\+\_\+data}} (Array\+Like values)
\item 
Array\+Like \mbox{\hyperlink{namespacepandas_1_1core_1_1algorithms_a7cc56a5f7c5c53e4c93b3f64a2be1966}{\+\_\+reconstruct\+\_\+data}} (Array\+Like values, Dtype\+Obj dtype, Any\+Array\+Like original)
\item 
Array\+Like \mbox{\hyperlink{namespacepandas_1_1core_1_1algorithms_a8c63b819e3cf054a44a36ed3cb32916b}{\+\_\+ensure\+\_\+arraylike}} (values, str func\+\_\+name)
\item 
\mbox{\hyperlink{namespacepandas_1_1core_1_1algorithms_a42c1f2997367be47d8e23ab79fb93c98}{\+\_\+get\+\_\+hashtable\+\_\+algo}} (np.\+ndarray values)
\item 
str \mbox{\hyperlink{namespacepandas_1_1core_1_1algorithms_a8703d635d626d874a194d111f277e8fe}{\+\_\+check\+\_\+object\+\_\+for\+\_\+strings}} (np.\+ndarray values)
\item 
\mbox{\hyperlink{namespacepandas_1_1core_1_1algorithms_aaf2a16f208025c0e7ed8cba4fdf45489}{unique}} (values)
\item 
int \mbox{\hyperlink{namespacepandas_1_1core_1_1algorithms_a6be054c00fc334b246a4c07ac28b3639}{nunique\+\_\+ints}} (Array\+Like values)
\item 
\mbox{\hyperlink{namespacepandas_1_1core_1_1algorithms_a9b109d6754b5a73d5d0f048daa50c652}{unique\+\_\+with\+\_\+mask}} (values, npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]}\texorpdfstring{$\vert$}{|}None mask=None)
\item 
npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]} \mbox{\hyperlink{namespacepandas_1_1core_1_1algorithms_a56c2ab8fc716c2bfc0ba0c5cb842fc3a}{isin}} (List\+Like comps, List\+Like values)
\item 
tuple\mbox{[}npt.\+NDArray\mbox{[}np.\+intp\mbox{]}, np.\+ndarray\mbox{]} \mbox{\hyperlink{namespacepandas_1_1core_1_1algorithms_a6096054268032718871ce73cda7b9c2e}{factorize\+\_\+array}} (np.\+ndarray values, bool use\+\_\+na\+\_\+sentinel=\mbox{\hyperlink{classTrue}{True}}, int\texorpdfstring{$\vert$}{|}None size\+\_\+hint=None, object na\+\_\+value=None, npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]}\texorpdfstring{$\vert$}{|}None mask=None)
\item 
tuple\mbox{[}np.\+ndarray, np.\+ndarray\texorpdfstring{$\vert$}{|}Index\mbox{]} \mbox{\hyperlink{namespacepandas_1_1core_1_1algorithms_adbe3e37562bc26a771cda872aaa1f2bd}{factorize}} (values, bool sort=False, bool use\+\_\+na\+\_\+sentinel=\mbox{\hyperlink{classTrue}{True}}, int\texorpdfstring{$\vert$}{|}None size\+\_\+hint=None)
\item 
Series \mbox{\hyperlink{namespacepandas_1_1core_1_1algorithms_ac4e9a411ce11004fdee2f052eb473b21}{value\+\_\+counts}} (values, bool sort=\mbox{\hyperlink{classTrue}{True}}, bool ascending=False, bool normalize=False, bins=None, bool dropna=\mbox{\hyperlink{classTrue}{True}})
\item 
Series \mbox{\hyperlink{namespacepandas_1_1core_1_1algorithms_a839787517de10bac9e7fa9c91a471c5d}{value\+\_\+counts\+\_\+internal}} (values, bool sort=\mbox{\hyperlink{classTrue}{True}}, bool ascending=False, bool normalize=False, bins=None, bool dropna=\mbox{\hyperlink{classTrue}{True}})
\item 
tuple\mbox{[}Array\+Like, npt.\+NDArray\mbox{[}np.\+int64\mbox{]}, int\mbox{]} \mbox{\hyperlink{namespacepandas_1_1core_1_1algorithms_a9bb85a6aa15624399a22bdeb27a16591}{value\+\_\+counts\+\_\+arraylike}} (np.\+ndarray values, bool dropna, npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]}\texorpdfstring{$\vert$}{|}None mask=None)
\item 
npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]} \mbox{\hyperlink{namespacepandas_1_1core_1_1algorithms_ac5fc7d5a4ae51a9a16547336ef4b98a1}{duplicated}} (Array\+Like values, Literal\mbox{[}"{}first"{}, "{}last"{}, False\mbox{]} keep="{}first"{}, npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]}\texorpdfstring{$\vert$}{|}None mask=None)
\item 
Array\+Like \mbox{\hyperlink{namespacepandas_1_1core_1_1algorithms_abce89cf7249e152882399c613f25ff4c}{mode}} (Array\+Like values, bool dropna=\mbox{\hyperlink{classTrue}{True}}, npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]}\texorpdfstring{$\vert$}{|}None mask=None)
\item 
npt.\+NDArray\mbox{[}np.\+float64\mbox{]} \mbox{\hyperlink{namespacepandas_1_1core_1_1algorithms_aa6de261414ddc15b0d07646cfc80eee6}{rank}} (Array\+Like values, Axis\+Int axis=0, str method="{}average"{}, str na\+\_\+option="{}keep"{}, bool ascending=\mbox{\hyperlink{classTrue}{True}}, bool pct=False)
\item 
\mbox{\hyperlink{namespacepandas_1_1core_1_1algorithms_a6d682c6c7a73b1c0f29ec7f55785a730}{take}} (arr, Take\+Indexer indices, Axis\+Int axis=0, bool allow\+\_\+fill=False, fill\+\_\+value=None)
\item 
npt.\+NDArray\mbox{[}np.\+intp\mbox{]}\texorpdfstring{$\vert$}{|}np.\+intp \mbox{\hyperlink{namespacepandas_1_1core_1_1algorithms_a3152971b4ded61ba9abc1896e0240334}{searchsorted}} (Array\+Like arr, Numpy\+Value\+Array\+Like\texorpdfstring{$\vert$}{|}\mbox{\hyperlink{classpandas_1_1core_1_1arrays_1_1base_1_1ExtensionArray}{Extension\+Array}} value, Literal\mbox{[}"{}left"{}, "{}right"{}\mbox{]} side="{}left"{}, Numpy\+Sorter\texorpdfstring{$\vert$}{|}None sorter=None)
\item 
\mbox{\hyperlink{namespacepandas_1_1core_1_1algorithms_aa170537782d742582939007a5381c107}{diff}} (arr, int n, Axis\+Int axis=0)
\item 
Any\+Array\+Like\texorpdfstring{$\vert$}{|}tuple\mbox{[}Any\+Array\+Like, np.\+ndarray\mbox{]} \mbox{\hyperlink{namespacepandas_1_1core_1_1algorithms_aa3884e0c8777c346895692d3c0a815c8}{safe\+\_\+sort}} (Index\texorpdfstring{$\vert$}{|}Array\+Like values, npt.\+NDArray\mbox{[}np.\+intp\mbox{]}\texorpdfstring{$\vert$}{|}None codes=None, bool use\+\_\+na\+\_\+sentinel=\mbox{\hyperlink{classTrue}{True}}, bool assume\+\_\+unique=False, bool verify=\mbox{\hyperlink{classTrue}{True}})
\item 
Any\+Array\+Like \mbox{\hyperlink{namespacepandas_1_1core_1_1algorithms_acc11c0ed2de5b98c23a64bf9be8740d4}{\+\_\+sort\+\_\+mixed}} (values)
\item 
np.\+ndarray \mbox{\hyperlink{namespacepandas_1_1core_1_1algorithms_a6f88e5d9f7af9bfb781a06cfa4b2fbff}{\+\_\+sort\+\_\+tuples}} (np.\+ndarray values)
\item 
Array\+Like\texorpdfstring{$\vert$}{|}Index \mbox{\hyperlink{namespacepandas_1_1core_1_1algorithms_ab6f295332bc708fb24ea229930e711b3}{union\+\_\+with\+\_\+duplicates}} (Array\+Like\texorpdfstring{$\vert$}{|}Index lvals, Array\+Like\texorpdfstring{$\vert$}{|}Index rvals)
\item 
np.\+ndarray\texorpdfstring{$\vert$}{|}\mbox{\hyperlink{classpandas_1_1core_1_1arrays_1_1base_1_1ExtensionArray}{Extension\+Array}}\texorpdfstring{$\vert$}{|}Index \mbox{\hyperlink{namespacepandas_1_1core_1_1algorithms_a90909b006eb314c5e14f993b86001b5f}{map\+\_\+array}} (Array\+Like arr, mapper, Literal\mbox{[}"{}ignore"{}\mbox{]}\texorpdfstring{$\vert$}{|}None na\+\_\+action=None, bool convert=\mbox{\hyperlink{classTrue}{True}})
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
dict \mbox{\hyperlink{namespacepandas_1_1core_1_1algorithms_ae3dfca7af569cdf3704041ed4741359b}{\+\_\+hashtables}}
\item 
\mbox{\hyperlink{namespacepandas_1_1core_1_1algorithms_a2391ef584cb31e63dcc63f95b35de489}{unique1d}} = \mbox{\hyperlink{namespacepandas_1_1core_1_1algorithms_aaf2a16f208025c0e7ed8cba4fdf45489}{unique}}
\item 
int \mbox{\hyperlink{namespacepandas_1_1core_1_1algorithms_aee99013131814ff6b9816e6f4f2bc78a}{\+\_\+\+MINIMUM\+\_\+\+COMP\+\_\+\+ARR\+\_\+\+LEN}} = 1\+\_\+000\+\_\+000
\item 
dict \mbox{\hyperlink{namespacepandas_1_1core_1_1algorithms_abdeb5f0661eb264df858024a3e0de961}{\+\_\+diff\+\_\+special}} = \{"{}float64"{}, "{}float32"{}, "{}int64"{}, "{}int32"{}, "{}int16"{}, "{}int8"{}\}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\begin{DoxyVerb}Generic data algorithms. This module is experimental at the moment and not
intended for public consumption
\end{DoxyVerb}
 

\doxysubsection{Function Documentation}
\Hypertarget{namespacepandas_1_1core_1_1algorithms_a8703d635d626d874a194d111f277e8fe}\index{pandas.core.algorithms@{pandas.core.algorithms}!\_check\_object\_for\_strings@{\_check\_object\_for\_strings}}
\index{\_check\_object\_for\_strings@{\_check\_object\_for\_strings}!pandas.core.algorithms@{pandas.core.algorithms}}
\doxysubsubsection{\texorpdfstring{\_check\_object\_for\_strings()}{\_check\_object\_for\_strings()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1core_1_1algorithms_a8703d635d626d874a194d111f277e8fe} 
 str pandas.\+core.\+algorithms.\+\_\+check\+\_\+object\+\_\+for\+\_\+strings (\begin{DoxyParamCaption}\item[{np.\+ndarray}]{values}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Check if we can use string hashtable instead of object hashtable.

Parameters
----------
values : ndarray

Returns
-------
str
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{algorithms_8py_source_l00280}{280}} of file \mbox{\hyperlink{algorithms_8py_source}{algorithms.\+py}}.



Referenced by \mbox{\hyperlink{algorithms_8py_source_l00262}{\+\_\+get\+\_\+hashtable\+\_\+algo()}}.

\Hypertarget{namespacepandas_1_1core_1_1algorithms_a8c63b819e3cf054a44a36ed3cb32916b}\index{pandas.core.algorithms@{pandas.core.algorithms}!\_ensure\_arraylike@{\_ensure\_arraylike}}
\index{\_ensure\_arraylike@{\_ensure\_arraylike}!pandas.core.algorithms@{pandas.core.algorithms}}
\doxysubsubsection{\texorpdfstring{\_ensure\_arraylike()}{\_ensure\_arraylike()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1core_1_1algorithms_a8c63b819e3cf054a44a36ed3cb32916b} 
 Array\+Like pandas.\+core.\+algorithms.\+\_\+ensure\+\_\+arraylike (\begin{DoxyParamCaption}\item[{}]{values}{, }\item[{str}]{func\+\_\+name}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}ensure that we are arraylike if not already
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{algorithms_8py_source_l00217}{217}} of file \mbox{\hyperlink{algorithms_8py_source}{algorithms.\+py}}.



Referenced by \mbox{\hyperlink{algorithms_8py_source_l00637}{factorize()}}, \mbox{\hyperlink{algorithms_8py_source_l00457}{isin()}}, \mbox{\hyperlink{algorithms_8py_source_l01025}{mode()}}, \mbox{\hyperlink{algorithms_8py_source_l00427}{unique\+\_\+with\+\_\+mask()}}, and \mbox{\hyperlink{algorithms_8py_source_l00822}{value\+\_\+counts()}}.

\Hypertarget{namespacepandas_1_1core_1_1algorithms_a874d39e4200cf44ffe3d92f229ffb058}\index{pandas.core.algorithms@{pandas.core.algorithms}!\_ensure\_data@{\_ensure\_data}}
\index{\_ensure\_data@{\_ensure\_data}!pandas.core.algorithms@{pandas.core.algorithms}}
\doxysubsubsection{\texorpdfstring{\_ensure\_data()}{\_ensure\_data()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1core_1_1algorithms_a874d39e4200cf44ffe3d92f229ffb058} 
 np.\+ndarray pandas.\+core.\+algorithms.\+\_\+ensure\+\_\+data (\begin{DoxyParamCaption}\item[{Array\+Like}]{values}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}routine to ensure that our data is of the correct
input dtype for lower-level routines

This will coerce:
- ints -> int64
- uint -> uint64
- bool -> uint8
- datetimelike -> i8
- datetime64tz -> i8 (in local tz)
- categorical -> codes

Parameters
----------
values : np.ndarray or ExtensionArray

Returns
-------
np.ndarray
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{algorithms_8py_source_l00106}{106}} of file \mbox{\hyperlink{algorithms_8py_source}{algorithms.\+py}}.



References \mbox{\hyperlink{algorithms_8py_source_l00106}{\+\_\+ensure\+\_\+data()}}.



Referenced by \mbox{\hyperlink{algorithms_8py_source_l00106}{\+\_\+ensure\+\_\+data()}}, \mbox{\hyperlink{algorithms_8py_source_l00262}{\+\_\+get\+\_\+hashtable\+\_\+algo()}}, \mbox{\hyperlink{algorithms_8py_source_l00998}{duplicated()}}, \mbox{\hyperlink{algorithms_8py_source_l01025}{mode()}}, \mbox{\hyperlink{algorithms_8py_source_l00404}{nunique\+\_\+ints()}}, \mbox{\hyperlink{algorithms_8py_source_l01074}{rank()}}, and \mbox{\hyperlink{algorithms_8py_source_l00965}{value\+\_\+counts\+\_\+arraylike()}}.

\Hypertarget{namespacepandas_1_1core_1_1algorithms_a42c1f2997367be47d8e23ab79fb93c98}\index{pandas.core.algorithms@{pandas.core.algorithms}!\_get\_hashtable\_algo@{\_get\_hashtable\_algo}}
\index{\_get\_hashtable\_algo@{\_get\_hashtable\_algo}!pandas.core.algorithms@{pandas.core.algorithms}}
\doxysubsubsection{\texorpdfstring{\_get\_hashtable\_algo()}{\_get\_hashtable\_algo()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1core_1_1algorithms_a42c1f2997367be47d8e23ab79fb93c98} 
pandas.\+core.\+algorithms.\+\_\+get\+\_\+hashtable\+\_\+algo (\begin{DoxyParamCaption}\item[{np.\+ndarray}]{values}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Parameters
----------
values : np.ndarray

Returns
-------
htable : HashTable subclass
values : ndarray
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{algorithms_8py_source_l00262}{262}} of file \mbox{\hyperlink{algorithms_8py_source}{algorithms.\+py}}.



References \mbox{\hyperlink{algorithms_8py_source_l00280}{\+\_\+check\+\_\+object\+\_\+for\+\_\+strings()}}, and \mbox{\hyperlink{algorithms_8py_source_l00106}{\+\_\+ensure\+\_\+data()}}.



Referenced by \mbox{\hyperlink{algorithms_8py_source_l00554}{factorize\+\_\+array()}}, \mbox{\hyperlink{algorithms_8py_source_l01458}{safe\+\_\+sort()}}, and \mbox{\hyperlink{algorithms_8py_source_l00427}{unique\+\_\+with\+\_\+mask()}}.

\Hypertarget{namespacepandas_1_1core_1_1algorithms_a7cc56a5f7c5c53e4c93b3f64a2be1966}\index{pandas.core.algorithms@{pandas.core.algorithms}!\_reconstruct\_data@{\_reconstruct\_data}}
\index{\_reconstruct\_data@{\_reconstruct\_data}!pandas.core.algorithms@{pandas.core.algorithms}}
\doxysubsubsection{\texorpdfstring{\_reconstruct\_data()}{\_reconstruct\_data()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1core_1_1algorithms_a7cc56a5f7c5c53e4c93b3f64a2be1966} 
 Array\+Like pandas.\+core.\+algorithms.\+\_\+reconstruct\+\_\+data (\begin{DoxyParamCaption}\item[{Array\+Like}]{values}{, }\item[{Dtype\+Obj}]{dtype}{, }\item[{Any\+Array\+Like }]{original}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}reverse of _ensure_data

Parameters
----------
values : np.ndarray or ExtensionArray
dtype : np.dtype or ExtensionDtype
original : AnyArrayLike

Returns
-------
ExtensionArray or np.ndarray
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{algorithms_8py_source_l00184}{184}} of file \mbox{\hyperlink{algorithms_8py_source}{algorithms.\+py}}.



Referenced by \mbox{\hyperlink{algorithms_8py_source_l00637}{factorize()}}, \mbox{\hyperlink{algorithms_8py_source_l00554}{factorize\+\_\+array()}}, \mbox{\hyperlink{algorithms_8py_source_l01025}{mode()}}, \mbox{\hyperlink{algorithms_8py_source_l00427}{unique\+\_\+with\+\_\+mask()}}, and \mbox{\hyperlink{algorithms_8py_source_l00965}{value\+\_\+counts\+\_\+arraylike()}}.

\Hypertarget{namespacepandas_1_1core_1_1algorithms_acc11c0ed2de5b98c23a64bf9be8740d4}\index{pandas.core.algorithms@{pandas.core.algorithms}!\_sort\_mixed@{\_sort\_mixed}}
\index{\_sort\_mixed@{\_sort\_mixed}!pandas.core.algorithms@{pandas.core.algorithms}}
\doxysubsubsection{\texorpdfstring{\_sort\_mixed()}{\_sort\_mixed()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1core_1_1algorithms_acc11c0ed2de5b98c23a64bf9be8740d4} 
 Any\+Array\+Like pandas.\+core.\+algorithms.\+\_\+sort\+\_\+mixed (\begin{DoxyParamCaption}\item[{}]{values}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}order ints before strings before nulls in 1d arrays\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{algorithms_8py_source_l01582}{1582}} of file \mbox{\hyperlink{algorithms_8py_source}{algorithms.\+py}}.



References \mbox{\hyperlink{algorithms_8py_source_l01137}{take()}}.



Referenced by \mbox{\hyperlink{algorithms_8py_source_l01458}{safe\+\_\+sort()}}.

\Hypertarget{namespacepandas_1_1core_1_1algorithms_a6f88e5d9f7af9bfb781a06cfa4b2fbff}\index{pandas.core.algorithms@{pandas.core.algorithms}!\_sort\_tuples@{\_sort\_tuples}}
\index{\_sort\_tuples@{\_sort\_tuples}!pandas.core.algorithms@{pandas.core.algorithms}}
\doxysubsubsection{\texorpdfstring{\_sort\_tuples()}{\_sort\_tuples()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1core_1_1algorithms_a6f88e5d9f7af9bfb781a06cfa4b2fbff} 
 np.\+ndarray pandas.\+core.\+algorithms.\+\_\+sort\+\_\+tuples (\begin{DoxyParamCaption}\item[{np.\+ndarray}]{values}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Convert array of tuples (1d) to array of arrays (2d).
We need to keep the columns separately as they contain different types and
nans (can't use `np.sort` as it may fail when str and nan are mixed in a
column as types cannot be compared).
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{algorithms_8py_source_l01597}{1597}} of file \mbox{\hyperlink{algorithms_8py_source}{algorithms.\+py}}.



Referenced by \mbox{\hyperlink{algorithms_8py_source_l01458}{safe\+\_\+sort()}}.

\Hypertarget{namespacepandas_1_1core_1_1algorithms_aa170537782d742582939007a5381c107}\index{pandas.core.algorithms@{pandas.core.algorithms}!diff@{diff}}
\index{diff@{diff}!pandas.core.algorithms@{pandas.core.algorithms}}
\doxysubsubsection{\texorpdfstring{diff()}{diff()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1core_1_1algorithms_aa170537782d742582939007a5381c107} 
pandas.\+core.\+algorithms.\+diff (\begin{DoxyParamCaption}\item[{}]{arr}{, }\item[{int}]{n}{, }\item[{Axis\+Int }]{axis}{ = {\ttfamily 0}}\end{DoxyParamCaption})}

\begin{DoxyVerb}difference of n between self,
analogous to s-s.shift(n)

Parameters
----------
arr : ndarray or ExtensionArray
n : int
    number of periods
axis : {0, 1}
    axis to shift on
stacklevel : int, default 3
    The stacklevel for the lost dtype warning.

Returns
-------
shifted
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{algorithms_8py_source_l01339}{1339}} of file \mbox{\hyperlink{algorithms_8py_source}{algorithms.\+py}}.

\Hypertarget{namespacepandas_1_1core_1_1algorithms_ac5fc7d5a4ae51a9a16547336ef4b98a1}\index{pandas.core.algorithms@{pandas.core.algorithms}!duplicated@{duplicated}}
\index{duplicated@{duplicated}!pandas.core.algorithms@{pandas.core.algorithms}}
\doxysubsubsection{\texorpdfstring{duplicated()}{duplicated()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1core_1_1algorithms_ac5fc7d5a4ae51a9a16547336ef4b98a1} 
 npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]} pandas.\+core.\+algorithms.\+duplicated (\begin{DoxyParamCaption}\item[{Array\+Like}]{values}{, }\item[{Literal\mbox{[}"{}first"{}, "{}last"{}, False\mbox{]} }]{keep}{ = {\ttfamily "{}first"{}}, }\item[{npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]} \texorpdfstring{$\vert$}{|} None }]{mask}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Return boolean ndarray denoting duplicate values.

Parameters
----------
values : np.ndarray or ExtensionArray
    Array over which to check for duplicate values.
keep : {'first', 'last', False}, default 'first'
    - ``first`` : Mark duplicates as ``True`` except for the first
      occurrence.
    - ``last`` : Mark duplicates as ``True`` except for the last
      occurrence.
    - False : Mark all duplicates as ``True``.
mask : ndarray[bool], optional
    array indicating which elements to exclude from checking

Returns
-------
duplicated : ndarray[bool]
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{algorithms_8py_source_l00994}{994}} of file \mbox{\hyperlink{algorithms_8py_source}{algorithms.\+py}}.



References \mbox{\hyperlink{algorithms_8py_source_l00106}{\+\_\+ensure\+\_\+data()}}.

\Hypertarget{namespacepandas_1_1core_1_1algorithms_adbe3e37562bc26a771cda872aaa1f2bd}\index{pandas.core.algorithms@{pandas.core.algorithms}!factorize@{factorize}}
\index{factorize@{factorize}!pandas.core.algorithms@{pandas.core.algorithms}}
\doxysubsubsection{\texorpdfstring{factorize()}{factorize()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1core_1_1algorithms_adbe3e37562bc26a771cda872aaa1f2bd} 
 tuple\mbox{[}np.\+ndarray, np.\+ndarray \texorpdfstring{$\vert$}{|} Index\mbox{]} pandas.\+core.\+algorithms.\+factorize (\begin{DoxyParamCaption}\item[{}]{values}{, }\item[{bool }]{sort}{ = {\ttfamily False}, }\item[{bool }]{use\+\_\+na\+\_\+sentinel}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}, }\item[{int \texorpdfstring{$\vert$}{|} None }]{size\+\_\+hint}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Encode the object as an enumerated type or categorical variable.

This method is useful for obtaining a numeric representation of an
array when all that matters is identifying distinct values. `factorize`
is available as both a top-level function :func:`pandas.factorize`,
and as a method :meth:`Series.factorize` and :meth:`Index.factorize`.

Parameters
----------
{values}{sort}
use_na_sentinel : bool, default True
    If True, the sentinel -1 will be used for NaN values. If False,
    NaN values will be encoded as non-negative integers and will not drop the
    NaN from the uniques of the values.

    .. versionadded:: 1.5.0
{size_hint}\

Returns
-------
codes : ndarray
    An integer ndarray that's an indexer into `uniques`.
    ``uniques.take(codes)`` will have the same values as `values`.
uniques : ndarray, Index, or Categorical
    The unique valid values. When `values` is Categorical, `uniques`
    is a Categorical. When `values` is some other pandas object, an
    `Index` is returned. Otherwise, a 1-D ndarray is returned.

    .. note::

       Even if there's a missing value in `values`, `uniques` will
       *not* contain an entry for it.

See Also
--------
cut : Discretize continuous-valued array.
unique : Find the unique value in an array.

Notes
-----
Reference :ref:`the user guide <reshaping.factorize>` for more examples.

Examples
--------
These examples all show factorize as a top-level method like
``pd.factorize(values)``. The results are identical for methods like
:meth:`Series.factorize`.

>>> codes, uniques = pd.factorize(np.array(['b', 'b', 'a', 'c', 'b'], dtype="O"))
>>> codes
array([0, 0, 1, 2, 0])
>>> uniques
array(['b', 'a', 'c'], dtype=object)

With ``sort=True``, the `uniques` will be sorted, and `codes` will be
shuffled so that the relationship is the maintained.

>>> codes, uniques = pd.factorize(np.array(['b', 'b', 'a', 'c', 'b'], dtype="O"),
...                               sort=True)
>>> codes
array([1, 1, 0, 2, 1])
>>> uniques
array(['a', 'b', 'c'], dtype=object)

When ``use_na_sentinel=True`` (the default), missing values are indicated in
the `codes` with the sentinel value ``-1`` and missing values are not
included in `uniques`.

>>> codes, uniques = pd.factorize(np.array(['b', None, 'a', 'c', 'b'], dtype="O"))
>>> codes
array([ 0, -1,  1,  2,  0])
>>> uniques
array(['b', 'a', 'c'], dtype=object)

Thus far, we've only factorized lists (which are internally coerced to
NumPy arrays). When factorizing pandas objects, the type of `uniques`
will differ. For Categoricals, a `Categorical` is returned.

>>> cat = pd.Categorical(['a', 'a', 'c'], categories=['a', 'b', 'c'])
>>> codes, uniques = pd.factorize(cat)
>>> codes
array([0, 0, 1])
>>> uniques
['a', 'c']
Categories (3, object): ['a', 'b', 'c']

Notice that ``'b'`` is in ``uniques.categories``, despite not being
present in ``cat.values``.

For all other pandas objects, an Index of the appropriate type is
returned.

>>> cat = pd.Series(['a', 'a', 'c'])
>>> codes, uniques = pd.factorize(cat)
>>> codes
array([0, 0, 1])
>>> uniques
Index(['a', 'c'], dtype='object')

If NaN is in the values, and we want to include NaN in the uniques of the
values, it can be achieved by setting ``use_na_sentinel=False``.

>>> values = np.array([1, 2, 1, np.nan])
>>> codes, uniques = pd.factorize(values)  # default: use_na_sentinel=True
>>> codes
array([ 0,  1,  0, -1])
>>> uniques
array([1., 2.])

>>> codes, uniques = pd.factorize(values, use_na_sentinel=False)
>>> codes
array([0, 1, 0, 2])
>>> uniques
array([ 1.,  2., nan])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{algorithms_8py_source_l00632}{632}} of file \mbox{\hyperlink{algorithms_8py_source}{algorithms.\+py}}.



References \mbox{\hyperlink{algorithms_8py_source_l00217}{\+\_\+ensure\+\_\+arraylike()}}, \mbox{\hyperlink{algorithms_8py_source_l00186}{\+\_\+reconstruct\+\_\+data()}}, \mbox{\hyperlink{algorithms_8py_source_l00554}{factorize\+\_\+array()}}, and \mbox{\hyperlink{algorithms_8py_source_l01458}{safe\+\_\+sort()}}.

\Hypertarget{namespacepandas_1_1core_1_1algorithms_a6096054268032718871ce73cda7b9c2e}\index{pandas.core.algorithms@{pandas.core.algorithms}!factorize\_array@{factorize\_array}}
\index{factorize\_array@{factorize\_array}!pandas.core.algorithms@{pandas.core.algorithms}}
\doxysubsubsection{\texorpdfstring{factorize\_array()}{factorize\_array()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1core_1_1algorithms_a6096054268032718871ce73cda7b9c2e} 
 tuple\mbox{[}npt.\+NDArray\mbox{[}np.\+intp\mbox{]}, np.\+ndarray\mbox{]} pandas.\+core.\+algorithms.\+factorize\+\_\+array (\begin{DoxyParamCaption}\item[{np.\+ndarray}]{values}{, }\item[{bool }]{use\+\_\+na\+\_\+sentinel}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}, }\item[{int \texorpdfstring{$\vert$}{|} None }]{size\+\_\+hint}{ = {\ttfamily None}, }\item[{object }]{na\+\_\+value}{ = {\ttfamily None}, }\item[{npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]} \texorpdfstring{$\vert$}{|} None }]{mask}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Factorize a numpy array to codes and uniques.

This doesn't do any coercion of types or unboxing before factorization.

Parameters
----------
values : ndarray
use_na_sentinel : bool, default True
    If True, the sentinel -1 will be used for NaN values. If False,
    NaN values will be encoded as non-negative integers and will not drop the
    NaN from the uniques of the values.
size_hint : int, optional
    Passed through to the hashtable's 'get_labels' method
na_value : object, optional
    A value in `values` to consider missing. Note: only use this
    parameter when you know that you don't have any values pandas would
    consider missing in the array (NaN for float data, iNaT for
    datetimes, etc.).
mask : ndarray[bool], optional
    If not None, the mask is used as indicator for missing values
    (True = missing, False = valid) instead of `na_value` or
    condition "val != val".

Returns
-------
codes : ndarray[np.intp]
uniques : ndarray
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{algorithms_8py_source_l00548}{548}} of file \mbox{\hyperlink{algorithms_8py_source}{algorithms.\+py}}.



References \mbox{\hyperlink{algorithms_8py_source_l00262}{\+\_\+get\+\_\+hashtable\+\_\+algo()}}, and \mbox{\hyperlink{algorithms_8py_source_l00186}{\+\_\+reconstruct\+\_\+data()}}.



Referenced by \mbox{\hyperlink{algorithms_8py_source_l00637}{factorize()}}.

\Hypertarget{namespacepandas_1_1core_1_1algorithms_a56c2ab8fc716c2bfc0ba0c5cb842fc3a}\index{pandas.core.algorithms@{pandas.core.algorithms}!isin@{isin}}
\index{isin@{isin}!pandas.core.algorithms@{pandas.core.algorithms}}
\doxysubsubsection{\texorpdfstring{isin()}{isin()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1core_1_1algorithms_a56c2ab8fc716c2bfc0ba0c5cb842fc3a} 
 npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]} pandas.\+core.\+algorithms.\+isin (\begin{DoxyParamCaption}\item[{List\+Like}]{comps}{, }\item[{List\+Like}]{values}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute the isin boolean array.

Parameters
----------
comps : list-like
values : list-like

Returns
-------
ndarray[bool]
    Same length as `comps`.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{algorithms_8py_source_l00457}{457}} of file \mbox{\hyperlink{algorithms_8py_source}{algorithms.\+py}}.



References \mbox{\hyperlink{algorithms_8py_source_l00217}{\+\_\+ensure\+\_\+arraylike()}}, and \mbox{\hyperlink{algorithms_8py_source_l00457}{isin()}}.



Referenced by \mbox{\hyperlink{algorithms_8py_source_l00457}{isin()}}.

\Hypertarget{namespacepandas_1_1core_1_1algorithms_a90909b006eb314c5e14f993b86001b5f}\index{pandas.core.algorithms@{pandas.core.algorithms}!map\_array@{map\_array}}
\index{map\_array@{map\_array}!pandas.core.algorithms@{pandas.core.algorithms}}
\doxysubsubsection{\texorpdfstring{map\_array()}{map\_array()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1core_1_1algorithms_a90909b006eb314c5e14f993b86001b5f} 
 np.\+ndarray \texorpdfstring{$\vert$}{|} \mbox{\hyperlink{classpandas_1_1core_1_1arrays_1_1base_1_1ExtensionArray}{Extension\+Array}} \texorpdfstring{$\vert$}{|} Index pandas.\+core.\+algorithms.\+map\+\_\+array (\begin{DoxyParamCaption}\item[{Array\+Like}]{arr}{, }\item[{}]{mapper}{, }\item[{Literal\mbox{[}"{}ignore"{}\mbox{]} \texorpdfstring{$\vert$}{|} None }]{na\+\_\+action}{ = {\ttfamily None}, }\item[{bool }]{convert}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Map values using an input mapping or function.

Parameters
----------
mapper : function, dict, or Series
    Mapping correspondence.
na_action : {None, 'ignore'}, default None
    If 'ignore', propagate NA values, without passing them to the
    mapping correspondence.
convert : bool, default True
    Try to find better dtype for elementwise function results. If
    False, leave as dtype=object.

Returns
-------
Union[ndarray, Index, ExtensionArray]
    The output of the mapping function applied to the array.
    If the function returns a tuple with more than one element
    a MultiIndex will be returned.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{algorithms_8py_source_l01667}{1667}} of file \mbox{\hyperlink{algorithms_8py_source}{algorithms.\+py}}.

\Hypertarget{namespacepandas_1_1core_1_1algorithms_abce89cf7249e152882399c613f25ff4c}\index{pandas.core.algorithms@{pandas.core.algorithms}!mode@{mode}}
\index{mode@{mode}!pandas.core.algorithms@{pandas.core.algorithms}}
\doxysubsubsection{\texorpdfstring{mode()}{mode()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1core_1_1algorithms_abce89cf7249e152882399c613f25ff4c} 
 Array\+Like pandas.\+core.\+algorithms.\+mode (\begin{DoxyParamCaption}\item[{Array\+Like}]{values}{, }\item[{bool }]{dropna}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}, }\item[{npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]} \texorpdfstring{$\vert$}{|} None }]{mask}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns the mode(s) of an array.

Parameters
----------
values : array-like
    Array over which to check for duplicate values.
dropna : bool, default True
    Don't consider counts of NaN/NaT.

Returns
-------
np.ndarray or ExtensionArray
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{algorithms_8py_source_l01023}{1023}} of file \mbox{\hyperlink{algorithms_8py_source}{algorithms.\+py}}.



References \mbox{\hyperlink{algorithms_8py_source_l00217}{\+\_\+ensure\+\_\+arraylike()}}, \mbox{\hyperlink{algorithms_8py_source_l00106}{\+\_\+ensure\+\_\+data()}}, \mbox{\hyperlink{algorithms_8py_source_l00186}{\+\_\+reconstruct\+\_\+data()}}, and \mbox{\hyperlink{algorithms_8py_source_l01458}{safe\+\_\+sort()}}.

\Hypertarget{namespacepandas_1_1core_1_1algorithms_a6be054c00fc334b246a4c07ac28b3639}\index{pandas.core.algorithms@{pandas.core.algorithms}!nunique\_ints@{nunique\_ints}}
\index{nunique\_ints@{nunique\_ints}!pandas.core.algorithms@{pandas.core.algorithms}}
\doxysubsubsection{\texorpdfstring{nunique\_ints()}{nunique\_ints()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1core_1_1algorithms_a6be054c00fc334b246a4c07ac28b3639} 
 int pandas.\+core.\+algorithms.\+nunique\+\_\+ints (\begin{DoxyParamCaption}\item[{Array\+Like}]{values}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the number of unique values for integer array-likes.

Significantly faster than pandas.unique for long enough sequences.
No checks are done to ensure input is integral.

Parameters
----------
values : 1d array-like

Returns
-------
int : The number of unique values in ``values``
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{algorithms_8py_source_l00404}{404}} of file \mbox{\hyperlink{algorithms_8py_source}{algorithms.\+py}}.



References \mbox{\hyperlink{algorithms_8py_source_l00106}{\+\_\+ensure\+\_\+data()}}.

\Hypertarget{namespacepandas_1_1core_1_1algorithms_aa6de261414ddc15b0d07646cfc80eee6}\index{pandas.core.algorithms@{pandas.core.algorithms}!rank@{rank}}
\index{rank@{rank}!pandas.core.algorithms@{pandas.core.algorithms}}
\doxysubsubsection{\texorpdfstring{rank()}{rank()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1core_1_1algorithms_aa6de261414ddc15b0d07646cfc80eee6} 
 npt.\+NDArray\mbox{[}np.\+float64\mbox{]} pandas.\+core.\+algorithms.\+rank (\begin{DoxyParamCaption}\item[{Array\+Like}]{values}{, }\item[{Axis\+Int }]{axis}{ = {\ttfamily 0}, }\item[{str }]{method}{ = {\ttfamily "{}average"{}}, }\item[{str }]{na\+\_\+option}{ = {\ttfamily "{}keep"{}}, }\item[{bool }]{ascending}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}, }\item[{bool }]{pct}{ = {\ttfamily False}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Rank the values along a given axis.

Parameters
----------
values : np.ndarray or ExtensionArray
    Array whose values will be ranked. The number of dimensions in this
    array must not exceed 2.
axis : int, default 0
    Axis over which to perform rankings.
method : {'average', 'min', 'max', 'first', 'dense'}, default 'average'
    The method by which tiebreaks are broken during the ranking.
na_option : {'keep', 'top'}, default 'keep'
    The method by which NaNs are placed in the ranking.
    - ``keep``: rank each NaN value with a NaN ranking
    - ``top``: replace each NaN with either +/- inf so that they
               there are ranked at the top
ascending : bool, default True
    Whether or not the elements should be ranked in ascending order.
pct : bool, default False
    Whether or not to the display the returned rankings in integer form
    (e.g. 1, 2, 3) or in percentile form (e.g. 0.333..., 0.666..., 1).
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{algorithms_8py_source_l01067}{1067}} of file \mbox{\hyperlink{algorithms_8py_source}{algorithms.\+py}}.



References \mbox{\hyperlink{algorithms_8py_source_l00106}{\+\_\+ensure\+\_\+data()}}.

\Hypertarget{namespacepandas_1_1core_1_1algorithms_aa3884e0c8777c346895692d3c0a815c8}\index{pandas.core.algorithms@{pandas.core.algorithms}!safe\_sort@{safe\_sort}}
\index{safe\_sort@{safe\_sort}!pandas.core.algorithms@{pandas.core.algorithms}}
\doxysubsubsection{\texorpdfstring{safe\_sort()}{safe\_sort()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1core_1_1algorithms_aa3884e0c8777c346895692d3c0a815c8} 
 Any\+Array\+Like \texorpdfstring{$\vert$}{|} tuple\mbox{[}Any\+Array\+Like, np.\+ndarray\mbox{]} pandas.\+core.\+algorithms.\+safe\+\_\+sort (\begin{DoxyParamCaption}\item[{Index \texorpdfstring{$\vert$}{|} Array\+Like}]{values}{, }\item[{npt.\+NDArray\mbox{[}np.\+intp\mbox{]} \texorpdfstring{$\vert$}{|} None }]{codes}{ = {\ttfamily None}, }\item[{bool }]{use\+\_\+na\+\_\+sentinel}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}, }\item[{bool }]{assume\+\_\+unique}{ = {\ttfamily False}, }\item[{bool }]{verify}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Sort ``values`` and reorder corresponding ``codes``.

``values`` should be unique if ``codes`` is not None.
Safe for use with mixed types (int, str), orders ints before strs.

Parameters
----------
values : list-like
    Sequence; must be unique if ``codes`` is not None.
codes : np.ndarray[intp] or None, default None
    Indices to ``values``. All out of bound indices are treated as
    "not found" and will be masked with ``-1``.
use_na_sentinel : bool, default True
    If True, the sentinel -1 will be used for NaN values. If False,
    NaN values will be encoded as non-negative integers and will not drop the
    NaN from the uniques of the values.
assume_unique : bool, default False
    When True, ``values`` are assumed to be unique, which can speed up
    the calculation. Ignored when ``codes`` is None.
verify : bool, default True
    Check if codes are out of bound for the values and put out of bound
    codes equal to ``-1``. If ``verify=False``, it is assumed there
    are no out of bound codes. Ignored when ``codes`` is None.

Returns
-------
ordered : AnyArrayLike
    Sorted ``values``
new_codes : ndarray
    Reordered ``codes``; returned when ``codes`` is not None.

Raises
------
TypeError
    * If ``values`` is not list-like or if ``codes`` is neither None
    nor list-like
    * If ``values`` cannot be sorted
ValueError
    * If ``codes`` is not None and ``values`` contain duplicates.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{algorithms_8py_source_l01452}{1452}} of file \mbox{\hyperlink{algorithms_8py_source}{algorithms.\+py}}.



References \mbox{\hyperlink{algorithms_8py_source_l00262}{\+\_\+get\+\_\+hashtable\+\_\+algo()}}, \mbox{\hyperlink{algorithms_8py_source_l01582}{\+\_\+sort\+\_\+mixed()}}, \mbox{\hyperlink{algorithms_8py_source_l01597}{\+\_\+sort\+\_\+tuples()}}, and \mbox{\hyperlink{algorithms_8py_source_l00307}{unique()}}.



Referenced by \mbox{\hyperlink{algorithms_8py_source_l00637}{factorize()}}, and \mbox{\hyperlink{algorithms_8py_source_l01025}{mode()}}.

\Hypertarget{namespacepandas_1_1core_1_1algorithms_a3152971b4ded61ba9abc1896e0240334}\index{pandas.core.algorithms@{pandas.core.algorithms}!searchsorted@{searchsorted}}
\index{searchsorted@{searchsorted}!pandas.core.algorithms@{pandas.core.algorithms}}
\doxysubsubsection{\texorpdfstring{searchsorted()}{searchsorted()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1core_1_1algorithms_a3152971b4ded61ba9abc1896e0240334} 
 npt.\+NDArray\mbox{[}np.\+intp\mbox{]} \texorpdfstring{$\vert$}{|} np.\+intp pandas.\+core.\+algorithms.\+searchsorted (\begin{DoxyParamCaption}\item[{Array\+Like}]{arr}{, }\item[{Numpy\+Value\+Array\+Like \texorpdfstring{$\vert$}{|} \mbox{\hyperlink{classpandas_1_1core_1_1arrays_1_1base_1_1ExtensionArray}{Extension\+Array}}}]{value}{, }\item[{Literal\mbox{[}"{}left"{}, "{}right"{}\mbox{]} }]{side}{ = {\ttfamily "{}left"{}}, }\item[{Numpy\+Sorter \texorpdfstring{$\vert$}{|} None }]{sorter}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Find indices where elements should be inserted to maintain order.

Find the indices into a sorted array `arr` (a) such that, if the
corresponding elements in `value` were inserted before the indices,
the order of `arr` would be preserved.

Assuming that `arr` is sorted:

======  ================================
`side`  returned index `i` satisfies
======  ================================
left    ``arr[i-1] < value <= self[i]``
right   ``arr[i-1] <= value < self[i]``
======  ================================

Parameters
----------
arr: np.ndarray, ExtensionArray, Series
    Input array. If `sorter` is None, then it must be sorted in
    ascending order, otherwise `sorter` must be an array of indices
    that sort it.
value : array-like or scalar
    Values to insert into `arr`.
side : {'left', 'right'}, optional
    If 'left', the index of the first suitable location found is given.
    If 'right', return the last such index.  If there is no suitable
    index, return either 0 or N (where N is the length of `self`).
sorter : 1-D array-like, optional
    Optional array of integer indices that sort array a into ascending
    order. They are typically the result of argsort.

Returns
-------
array of ints or int
    If value is array-like, array of insertion points.
    If value is scalar, a single integer.

See Also
--------
numpy.searchsorted : Similar method from NumPy.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{algorithms_8py_source_l01248}{1248}} of file \mbox{\hyperlink{algorithms_8py_source}{algorithms.\+py}}.

\Hypertarget{namespacepandas_1_1core_1_1algorithms_a6d682c6c7a73b1c0f29ec7f55785a730}\index{pandas.core.algorithms@{pandas.core.algorithms}!take@{take}}
\index{take@{take}!pandas.core.algorithms@{pandas.core.algorithms}}
\doxysubsubsection{\texorpdfstring{take()}{take()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1core_1_1algorithms_a6d682c6c7a73b1c0f29ec7f55785a730} 
pandas.\+core.\+algorithms.\+take (\begin{DoxyParamCaption}\item[{}]{arr}{, }\item[{Take\+Indexer}]{indices}{, }\item[{Axis\+Int }]{axis}{ = {\ttfamily 0}, }\item[{bool }]{allow\+\_\+fill}{ = {\ttfamily False}, }\item[{}]{fill\+\_\+value}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Take elements from an array.

Parameters
----------
arr : array-like or scalar value
    Non array-likes (sequences/scalars without a dtype) are coerced
    to an ndarray.

    .. deprecated:: 2.1.0
        Passing an argument other than a numpy.ndarray, ExtensionArray,
        Index, or Series is deprecated.

indices : sequence of int or one-dimensional np.ndarray of int
    Indices to be taken.
axis : int, default 0
    The axis over which to select values.
allow_fill : bool, default False
    How to handle negative values in `indices`.

    * False: negative values in `indices` indicate positional indices
      from the right (the default). This is similar to :func:`numpy.take`.

    * True: negative values in `indices` indicate
      missing values. These values are set to `fill_value`. Any other
      negative values raise a ``ValueError``.

fill_value : any, optional
    Fill value to use for NA-indices when `allow_fill` is True.
    This may be ``None``, in which case the default NA value for
    the type (``self.dtype.na_value``) is used.

    For multi-dimensional `arr`, each *element* is filled with
    `fill_value`.

Returns
-------
ndarray or ExtensionArray
    Same type as the input.

Raises
------
IndexError
    When `indices` is out of bounds for the array.
ValueError
    When the indexer contains negative values other than ``-1``
    and `allow_fill` is True.

Notes
-----
When `allow_fill` is False, `indices` may be whatever dimensionality
is accepted by NumPy for `arr`.

When `allow_fill` is True, `indices` should be 1-D.

See Also
--------
numpy.take : Take elements from an array along an axis.

Examples
--------
>>> import pandas as pd

With the default ``allow_fill=False``, negative numbers indicate
positional indices from the right.

>>> pd.api.extensions.take(np.array([10, 20, 30]), [0, 0, -1])
array([10, 10, 30])

Setting ``allow_fill=True`` will place `fill_value` in those positions.

>>> pd.api.extensions.take(np.array([10, 20, 30]), [0, 0, -1], allow_fill=True)
array([10., 10., nan])

>>> pd.api.extensions.take(np.array([10, 20, 30]), [0, 0, -1], allow_fill=True,
...      fill_value=-10)
array([ 10,  10, -10])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{algorithms_8py_source_l01131}{1131}} of file \mbox{\hyperlink{algorithms_8py_source}{algorithms.\+py}}.



Referenced by \mbox{\hyperlink{algorithms_8py_source_l01582}{\+\_\+sort\+\_\+mixed()}}.

\Hypertarget{namespacepandas_1_1core_1_1algorithms_ab6f295332bc708fb24ea229930e711b3}\index{pandas.core.algorithms@{pandas.core.algorithms}!union\_with\_duplicates@{union\_with\_duplicates}}
\index{union\_with\_duplicates@{union\_with\_duplicates}!pandas.core.algorithms@{pandas.core.algorithms}}
\doxysubsubsection{\texorpdfstring{union\_with\_duplicates()}{union\_with\_duplicates()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1core_1_1algorithms_ab6f295332bc708fb24ea229930e711b3} 
 Array\+Like \texorpdfstring{$\vert$}{|} Index pandas.\+core.\+algorithms.\+union\+\_\+with\+\_\+duplicates (\begin{DoxyParamCaption}\item[{Array\+Like \texorpdfstring{$\vert$}{|} Index}]{lvals}{, }\item[{Array\+Like \texorpdfstring{$\vert$}{|} Index }]{rvals}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Extracts the union from lvals and rvals with respect to duplicates and nans in
both arrays.

Parameters
----------
lvals: np.ndarray or ExtensionArray
    left values which is ordered in front.
rvals: np.ndarray or ExtensionArray
    right values ordered after lvals.

Returns
-------
np.ndarray or ExtensionArray
    Containing the unsorted union of both arrays.

Notes
-----
Caller is responsible for ensuring lvals.dtype == rvals.dtype.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{algorithms_8py_source_l01612}{1612}} of file \mbox{\hyperlink{algorithms_8py_source}{algorithms.\+py}}.



References \mbox{\hyperlink{algorithms_8py_source_l00307}{unique()}}.

\Hypertarget{namespacepandas_1_1core_1_1algorithms_aaf2a16f208025c0e7ed8cba4fdf45489}\index{pandas.core.algorithms@{pandas.core.algorithms}!unique@{unique}}
\index{unique@{unique}!pandas.core.algorithms@{pandas.core.algorithms}}
\doxysubsubsection{\texorpdfstring{unique()}{unique()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1core_1_1algorithms_aaf2a16f208025c0e7ed8cba4fdf45489} 
pandas.\+core.\+algorithms.\+unique (\begin{DoxyParamCaption}\item[{}]{values}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Return unique values based on a hash table.

Uniques are returned in order of appearance. This does NOT sort.

Significantly faster than numpy.unique for long enough sequences.
Includes NA values.

Parameters
----------
values : 1d array-like

Returns
-------
numpy.ndarray or ExtensionArray

    The return can be:

    * Index : when the input is an Index
    * Categorical : when the input is a Categorical dtype
    * ndarray : when the input is a Series/ndarray

    Return numpy.ndarray or ExtensionArray.

See Also
--------
Index.unique : Return unique values from an Index.
Series.unique : Return unique values of Series object.

Examples
--------
>>> pd.unique(pd.Series([2, 1, 3, 3]))
array([2, 1, 3])

>>> pd.unique(pd.Series([2] + [1] * 5))
array([2, 1])

>>> pd.unique(pd.Series([pd.Timestamp("20160101"), pd.Timestamp("20160101")]))
array(['2016-01-01T00:00:00.000000000'], dtype='datetime64[ns]')

>>> pd.unique(
...     pd.Series(
...         [
...             pd.Timestamp("20160101", tz="US/Eastern"),
...             pd.Timestamp("20160101", tz="US/Eastern"),
...         ]
...     )
... )
<DatetimeArray>
['2016-01-01 00:00:00-05:00']
Length: 1, dtype: datetime64[ns, US/Eastern]

>>> pd.unique(
...     pd.Index(
...         [
...             pd.Timestamp("20160101", tz="US/Eastern"),
...             pd.Timestamp("20160101", tz="US/Eastern"),
...         ]
...     )
... )
DatetimeIndex(['2016-01-01 00:00:00-05:00'],
        dtype='datetime64[ns, US/Eastern]',
        freq=None)

>>> pd.unique(np.array(list("baabc"), dtype="O"))
array(['b', 'a', 'c'], dtype=object)

An unordered Categorical will return categories in the
order of appearance.

>>> pd.unique(pd.Series(pd.Categorical(list("baabc"))))
['b', 'a', 'c']
Categories (3, object): ['a', 'b', 'c']

>>> pd.unique(pd.Series(pd.Categorical(list("baabc"), categories=list("abc"))))
['b', 'a', 'c']
Categories (3, object): ['a', 'b', 'c']

An ordered Categorical preserves the category ordering.

>>> pd.unique(
...     pd.Series(
...         pd.Categorical(list("baabc"), categories=list("abc"), ordered=True)
...     )
... )
['b', 'a', 'c']
Categories (3, object): ['a' < 'b' < 'c']

An array of tuples

>>> pd.unique(pd.Series([("a", "b"), ("b", "a"), ("a", "c"), ("b", "a")]).values)
array([('a', 'b'), ('b', 'a'), ('a', 'c')], dtype=object)
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{algorithms_8py_source_l00307}{307}} of file \mbox{\hyperlink{algorithms_8py_source}{algorithms.\+py}}.



References \mbox{\hyperlink{algorithms_8py_source_l00427}{unique\+\_\+with\+\_\+mask()}}.



Referenced by \mbox{\hyperlink{algorithms_8py_source_l01458}{safe\+\_\+sort()}}, and \mbox{\hyperlink{algorithms_8py_source_l01614}{union\+\_\+with\+\_\+duplicates()}}.

\Hypertarget{namespacepandas_1_1core_1_1algorithms_a9b109d6754b5a73d5d0f048daa50c652}\index{pandas.core.algorithms@{pandas.core.algorithms}!unique\_with\_mask@{unique\_with\_mask}}
\index{unique\_with\_mask@{unique\_with\_mask}!pandas.core.algorithms@{pandas.core.algorithms}}
\doxysubsubsection{\texorpdfstring{unique\_with\_mask()}{unique\_with\_mask()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1core_1_1algorithms_a9b109d6754b5a73d5d0f048daa50c652} 
pandas.\+core.\+algorithms.\+unique\+\_\+with\+\_\+mask (\begin{DoxyParamCaption}\item[{}]{values}{, }\item[{npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]} \texorpdfstring{$\vert$}{|} None }]{mask}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}See algorithms.unique for docs. Takes a mask for masked arrays.\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{algorithms_8py_source_l00427}{427}} of file \mbox{\hyperlink{algorithms_8py_source}{algorithms.\+py}}.



References \mbox{\hyperlink{algorithms_8py_source_l00217}{\+\_\+ensure\+\_\+arraylike()}}, \mbox{\hyperlink{algorithms_8py_source_l00262}{\+\_\+get\+\_\+hashtable\+\_\+algo()}}, and \mbox{\hyperlink{algorithms_8py_source_l00186}{\+\_\+reconstruct\+\_\+data()}}.



Referenced by \mbox{\hyperlink{algorithms_8py_source_l00307}{unique()}}.

\Hypertarget{namespacepandas_1_1core_1_1algorithms_ac4e9a411ce11004fdee2f052eb473b21}\index{pandas.core.algorithms@{pandas.core.algorithms}!value\_counts@{value\_counts}}
\index{value\_counts@{value\_counts}!pandas.core.algorithms@{pandas.core.algorithms}}
\doxysubsubsection{\texorpdfstring{value\_counts()}{value\_counts()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1core_1_1algorithms_ac4e9a411ce11004fdee2f052eb473b21} 
 Series pandas.\+core.\+algorithms.\+value\+\_\+counts (\begin{DoxyParamCaption}\item[{}]{values}{, }\item[{bool }]{sort}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}, }\item[{bool }]{ascending}{ = {\ttfamily False}, }\item[{bool }]{normalize}{ = {\ttfamily False}, }\item[{}]{bins}{ = {\ttfamily None}, }\item[{bool }]{dropna}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute a histogram of the counts of non-null values.

Parameters
----------
values : ndarray (1-d)
sort : bool, default True
    Sort by values
ascending : bool, default False
    Sort in ascending order
normalize: bool, default False
    If True then compute a relative histogram
bins : integer, optional
    Rather than count values, group them into half-open bins,
    convenience for pd.cut, only works with numeric data
dropna : bool, default True
    Don't include counts of NaN

Returns
-------
Series
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{algorithms_8py_source_l00815}{815}} of file \mbox{\hyperlink{algorithms_8py_source}{algorithms.\+py}}.



References \mbox{\hyperlink{algorithms_8py_source_l00217}{\+\_\+ensure\+\_\+arraylike()}}, and \mbox{\hyperlink{algorithms_8py_source_l00965}{value\+\_\+counts\+\_\+arraylike()}}.

\Hypertarget{namespacepandas_1_1core_1_1algorithms_a9bb85a6aa15624399a22bdeb27a16591}\index{pandas.core.algorithms@{pandas.core.algorithms}!value\_counts\_arraylike@{value\_counts\_arraylike}}
\index{value\_counts\_arraylike@{value\_counts\_arraylike}!pandas.core.algorithms@{pandas.core.algorithms}}
\doxysubsubsection{\texorpdfstring{value\_counts\_arraylike()}{value\_counts\_arraylike()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1core_1_1algorithms_a9bb85a6aa15624399a22bdeb27a16591} 
 tuple\mbox{[}Array\+Like, npt.\+NDArray\mbox{[}np.\+int64\mbox{]}, int\mbox{]} pandas.\+core.\+algorithms.\+value\+\_\+counts\+\_\+arraylike (\begin{DoxyParamCaption}\item[{np.\+ndarray}]{values}{, }\item[{bool}]{dropna}{, }\item[{npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]} \texorpdfstring{$\vert$}{|} None }]{mask}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Parameters
----------
values : np.ndarray
dropna : bool
mask : np.ndarray[bool] or None, default None

Returns
-------
uniques : np.ndarray
counts : np.ndarray[np.int64]
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{algorithms_8py_source_l00963}{963}} of file \mbox{\hyperlink{algorithms_8py_source}{algorithms.\+py}}.



References \mbox{\hyperlink{algorithms_8py_source_l00106}{\+\_\+ensure\+\_\+data()}}, and \mbox{\hyperlink{algorithms_8py_source_l00186}{\+\_\+reconstruct\+\_\+data()}}.



Referenced by \mbox{\hyperlink{algorithms_8py_source_l00822}{value\+\_\+counts()}}.

\Hypertarget{namespacepandas_1_1core_1_1algorithms_a839787517de10bac9e7fa9c91a471c5d}\index{pandas.core.algorithms@{pandas.core.algorithms}!value\_counts\_internal@{value\_counts\_internal}}
\index{value\_counts\_internal@{value\_counts\_internal}!pandas.core.algorithms@{pandas.core.algorithms}}
\doxysubsubsection{\texorpdfstring{value\_counts\_internal()}{value\_counts\_internal()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1core_1_1algorithms_a839787517de10bac9e7fa9c91a471c5d} 
 Series pandas.\+core.\+algorithms.\+value\+\_\+counts\+\_\+internal (\begin{DoxyParamCaption}\item[{}]{values}{, }\item[{bool }]{sort}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}, }\item[{bool }]{ascending}{ = {\ttfamily False}, }\item[{bool }]{normalize}{ = {\ttfamily False}, }\item[{}]{bins}{ = {\ttfamily None}, }\item[{bool }]{dropna}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}}\end{DoxyParamCaption})}



Definition at line \mbox{\hyperlink{algorithms_8py_source_l00862}{862}} of file \mbox{\hyperlink{algorithms_8py_source}{algorithms.\+py}}.



\doxysubsection{Variable Documentation}
\Hypertarget{namespacepandas_1_1core_1_1algorithms_abdeb5f0661eb264df858024a3e0de961}\index{pandas.core.algorithms@{pandas.core.algorithms}!\_diff\_special@{\_diff\_special}}
\index{\_diff\_special@{\_diff\_special}!pandas.core.algorithms@{pandas.core.algorithms}}
\doxysubsubsection{\texorpdfstring{\_diff\_special}{\_diff\_special}}
{\footnotesize\ttfamily \label{namespacepandas_1_1core_1_1algorithms_abdeb5f0661eb264df858024a3e0de961} 
dict pandas.\+core.\+algorithms.\+\_\+diff\+\_\+special = \{"{}float64"{}, "{}float32"{}, "{}int64"{}, "{}int32"{}, "{}int16"{}, "{}int8"{}\}\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{algorithms_8py_source_l01336}{1336}} of file \mbox{\hyperlink{algorithms_8py_source}{algorithms.\+py}}.

\Hypertarget{namespacepandas_1_1core_1_1algorithms_ae3dfca7af569cdf3704041ed4741359b}\index{pandas.core.algorithms@{pandas.core.algorithms}!\_hashtables@{\_hashtables}}
\index{\_hashtables@{\_hashtables}!pandas.core.algorithms@{pandas.core.algorithms}}
\doxysubsubsection{\texorpdfstring{\_hashtables}{\_hashtables}}
{\footnotesize\ttfamily \label{namespacepandas_1_1core_1_1algorithms_ae3dfca7af569cdf3704041ed4741359b} 
dict pandas.\+core.\+algorithms.\+\_\+hashtables\hspace{0.3cm}{\ttfamily [protected]}}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ \{}
\DoxyCodeLine{00002\ \ \ \ \ \textcolor{stringliteral}{"{}complex128"{}}:\ htable.Complex128HashTable,}
\DoxyCodeLine{00003\ \ \ \ \ \textcolor{stringliteral}{"{}complex64"{}}:\ htable.Complex64HashTable,}
\DoxyCodeLine{00004\ \ \ \ \ \textcolor{stringliteral}{"{}float64"{}}:\ htable.Float64HashTable,}
\DoxyCodeLine{00005\ \ \ \ \ \textcolor{stringliteral}{"{}float32"{}}:\ htable.Float32HashTable,}
\DoxyCodeLine{00006\ \ \ \ \ \textcolor{stringliteral}{"{}uint64"{}}:\ htable.UInt64HashTable,}
\DoxyCodeLine{00007\ \ \ \ \ \textcolor{stringliteral}{"{}uint32"{}}:\ htable.UInt32HashTable,}
\DoxyCodeLine{00008\ \ \ \ \ \textcolor{stringliteral}{"{}uint16"{}}:\ htable.UInt16HashTable,}
\DoxyCodeLine{00009\ \ \ \ \ \textcolor{stringliteral}{"{}uint8"{}}:\ htable.UInt8HashTable,}
\DoxyCodeLine{00010\ \ \ \ \ \textcolor{stringliteral}{"{}int64"{}}:\ htable.Int64HashTable,}
\DoxyCodeLine{00011\ \ \ \ \ \textcolor{stringliteral}{"{}int32"{}}:\ htable.Int32HashTable,}
\DoxyCodeLine{00012\ \ \ \ \ \textcolor{stringliteral}{"{}int16"{}}:\ htable.Int16HashTable,}
\DoxyCodeLine{00013\ \ \ \ \ \textcolor{stringliteral}{"{}int8"{}}:\ htable.Int8HashTable,}
\DoxyCodeLine{00014\ \ \ \ \ \textcolor{stringliteral}{"{}string"{}}:\ htable.StringHashTable,}
\DoxyCodeLine{00015\ \ \ \ \ \textcolor{stringliteral}{"{}object"{}}:\ htable.PyObjectHashTable,}
\DoxyCodeLine{00016\ \}}

\end{DoxyCode}


Definition at line \mbox{\hyperlink{algorithms_8py_source_l00244}{244}} of file \mbox{\hyperlink{algorithms_8py_source}{algorithms.\+py}}.

\Hypertarget{namespacepandas_1_1core_1_1algorithms_aee99013131814ff6b9816e6f4f2bc78a}\index{pandas.core.algorithms@{pandas.core.algorithms}!\_MINIMUM\_COMP\_ARR\_LEN@{\_MINIMUM\_COMP\_ARR\_LEN}}
\index{\_MINIMUM\_COMP\_ARR\_LEN@{\_MINIMUM\_COMP\_ARR\_LEN}!pandas.core.algorithms@{pandas.core.algorithms}}
\doxysubsubsection{\texorpdfstring{\_MINIMUM\_COMP\_ARR\_LEN}{\_MINIMUM\_COMP\_ARR\_LEN}}
{\footnotesize\ttfamily \label{namespacepandas_1_1core_1_1algorithms_aee99013131814ff6b9816e6f4f2bc78a} 
int pandas.\+core.\+algorithms.\+\_\+\+MINIMUM\+\_\+\+COMP\+\_\+\+ARR\+\_\+\+LEN = 1\+\_\+000\+\_\+000\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{algorithms_8py_source_l00454}{454}} of file \mbox{\hyperlink{algorithms_8py_source}{algorithms.\+py}}.

\Hypertarget{namespacepandas_1_1core_1_1algorithms_a2391ef584cb31e63dcc63f95b35de489}\index{pandas.core.algorithms@{pandas.core.algorithms}!unique1d@{unique1d}}
\index{unique1d@{unique1d}!pandas.core.algorithms@{pandas.core.algorithms}}
\doxysubsubsection{\texorpdfstring{unique1d}{unique1d}}
{\footnotesize\ttfamily \label{namespacepandas_1_1core_1_1algorithms_a2391ef584cb31e63dcc63f95b35de489} 
pandas.\+core.\+algorithms.\+unique1d = \mbox{\hyperlink{namespacepandas_1_1core_1_1algorithms_aaf2a16f208025c0e7ed8cba4fdf45489}{unique}}}



Definition at line \mbox{\hyperlink{algorithms_8py_source_l00451}{451}} of file \mbox{\hyperlink{algorithms_8py_source}{algorithms.\+py}}.

