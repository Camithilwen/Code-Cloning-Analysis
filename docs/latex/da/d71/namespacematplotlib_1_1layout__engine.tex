\doxysection{matplotlib.\+layout\+\_\+engine Namespace Reference}
\hypertarget{namespacematplotlib_1_1layout__engine}{}\label{namespacematplotlib_1_1layout__engine}\index{matplotlib.layout\_engine@{matplotlib.layout\_engine}}
\doxysubsubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classmatplotlib_1_1layout__engine_1_1ConstrainedLayoutEngine}{Constrained\+Layout\+Engine}}
\item 
class \mbox{\hyperlink{classmatplotlib_1_1layout__engine_1_1LayoutEngine}{Layout\+Engine}}
\item 
class \mbox{\hyperlink{classmatplotlib_1_1layout__engine_1_1PlaceHolderLayoutEngine}{Place\+Holder\+Layout\+Engine}}
\item 
class \mbox{\hyperlink{classmatplotlib_1_1layout__engine_1_1TightLayoutEngine}{Tight\+Layout\+Engine}}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\begin{DoxyVerb}Classes to layout elements in a `.Figure`.

Figures have a ``layout_engine`` property that holds a subclass of
`~.LayoutEngine` defined here (or *None* for no layout).  At draw time
``figure.get_layout_engine().execute()`` is called, the goal of which is
usually to rearrange Axes on the figure to produce a pleasing layout. This is
like a ``draw`` callback but with two differences.  First, when printing we
disable the layout engine for the final draw. Second, it is useful to know the
layout engine while the figure is being created.  In particular, colorbars are
made differently with different layout engines (for historical reasons).

Matplotlib has two built-in layout engines:

- `.TightLayoutEngine` was the first layout engine added to Matplotlib.
  See also :ref:`tight_layout_guide`.
- `.ConstrainedLayoutEngine` is more modern and generally gives better results.
  See also :ref:`constrainedlayout_guide`.

Third parties can create their own layout engine by subclassing `.LayoutEngine`.
\end{DoxyVerb}
 