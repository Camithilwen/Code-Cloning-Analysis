\doxysection{sklearn.\+cluster.\+\_\+optics Namespace Reference}
\hypertarget{namespacesklearn_1_1cluster_1_1__optics}{}\label{namespacesklearn_1_1cluster_1_1__optics}\index{sklearn.cluster.\_optics@{sklearn.cluster.\_optics}}
\doxysubsubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classsklearn_1_1cluster_1_1__optics_1_1OPTICS}{OPTICS}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacesklearn_1_1cluster_1_1__optics_a1a23fd16403b68f90c5a8e94bdd806ff}{\+\_\+validate\+\_\+size}} (size, n\+\_\+samples, param\+\_\+name)
\item 
\mbox{\hyperlink{namespacesklearn_1_1cluster_1_1__optics_afb7f077f478b42dd9770583dafaa7c62}{\+\_\+compute\+\_\+core\+\_\+distances\+\_\+}} (X, neighbors, min\+\_\+samples, working\+\_\+memory)
\item 
\mbox{\hyperlink{namespacesklearn_1_1cluster_1_1__optics_aad0efa601f27d3318be3a5cf12a2c6aa}{compute\+\_\+optics\+\_\+graph}} (X, \texorpdfstring{$\ast$}{*}, min\+\_\+samples, max\+\_\+eps, metric, p, metric\+\_\+params, algorithm, leaf\+\_\+size, n\+\_\+jobs)
\item 
\mbox{\hyperlink{namespacesklearn_1_1cluster_1_1__optics_a3984ecdd3e7f496266936f970febf7cc}{\+\_\+set\+\_\+reach\+\_\+dist}} (core\+\_\+distances\+\_\+, reachability\+\_\+, predecessor\+\_\+, point\+\_\+index, processed, X, nbrs, metric, metric\+\_\+params, p, max\+\_\+eps)
\item 
\mbox{\hyperlink{namespacesklearn_1_1cluster_1_1__optics_a6ae553de42635acf9bd1ca4d8ed12f2c}{cluster\+\_\+optics\+\_\+dbscan}} (\texorpdfstring{$\ast$}{*}, reachability, core\+\_\+distances, ordering, eps)
\item 
\mbox{\hyperlink{namespacesklearn_1_1cluster_1_1__optics_af00fa5eed1925cbb01becac227d90aac}{cluster\+\_\+optics\+\_\+xi}} (\texorpdfstring{$\ast$}{*}, reachability, predecessor, ordering, min\+\_\+samples, min\+\_\+cluster\+\_\+size=None, xi=0.\+05, predecessor\+\_\+correction=\mbox{\hyperlink{classTrue}{True}})
\item 
\mbox{\hyperlink{namespacesklearn_1_1cluster_1_1__optics_ab161ee0866fb871a43881f9228dc10da}{\+\_\+extend\+\_\+region}} (steep\+\_\+point, xward\+\_\+point, start, min\+\_\+samples)
\item 
\mbox{\hyperlink{namespacesklearn_1_1cluster_1_1__optics_a59f52f7066710373e697427ce6891250}{\+\_\+update\+\_\+filter\+\_\+sdas}} (sdas, mib, xi\+\_\+complement, reachability\+\_\+plot)
\item 
\mbox{\hyperlink{namespacesklearn_1_1cluster_1_1__optics_ada463efea84a53b7ea5e103432ed6421}{\+\_\+correct\+\_\+predecessor}} (reachability\+\_\+plot, predecessor\+\_\+plot, ordering, s, e)
\item 
\mbox{\hyperlink{namespacesklearn_1_1cluster_1_1__optics_a9ca4867ed224dee781e1ae63c64f4307}{\+\_\+xi\+\_\+cluster}} (reachability\+\_\+plot, predecessor\+\_\+plot, ordering, xi, min\+\_\+samples, min\+\_\+cluster\+\_\+size, predecessor\+\_\+correction)
\item 
\mbox{\hyperlink{namespacesklearn_1_1cluster_1_1__optics_a9754cc79736a1fd15348c5d32097d5bc}{\+\_\+extract\+\_\+xi\+\_\+labels}} (ordering, clusters)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\begin{DoxyVerb}Ordering Points To Identify the Clustering Structure (OPTICS)

These routines execute the OPTICS algorithm, and implement various
cluster extraction methods of the ordered list.
\end{DoxyVerb}
 

\doxysubsection{Function Documentation}
\Hypertarget{namespacesklearn_1_1cluster_1_1__optics_afb7f077f478b42dd9770583dafaa7c62}\index{sklearn.cluster.\_optics@{sklearn.cluster.\_optics}!\_compute\_core\_distances\_@{\_compute\_core\_distances\_}}
\index{\_compute\_core\_distances\_@{\_compute\_core\_distances\_}!sklearn.cluster.\_optics@{sklearn.cluster.\_optics}}
\doxysubsubsection{\texorpdfstring{\_compute\_core\_distances\_()}{\_compute\_core\_distances\_()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1cluster_1_1__optics_afb7f077f478b42dd9770583dafaa7c62} 
sklearn.\+cluster.\+\_\+optics.\+\_\+compute\+\_\+core\+\_\+distances\+\_\+ (\begin{DoxyParamCaption}\item[{}]{X}{, }\item[{}]{neighbors}{, }\item[{}]{min\+\_\+samples}{, }\item[{}]{working\+\_\+memory}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Compute the k-th nearest neighbor of each sample.

Equivalent to neighbors.kneighbors(X, self.min_samples)[0][:, -1]
but with more memory efficiency.

Parameters
----------
X : array-like of shape (n_samples, n_features)
    The data.
neighbors : NearestNeighbors instance
    The fitted nearest neighbors estimator.
working_memory : int, default=None
    The sought maximum memory for temporary distance matrix chunks.
    When None (default), the value of
    ``sklearn.get_config()['working_memory']`` is used.

Returns
-------
core_distances : ndarray of shape (n_samples,)
    Distance at which each sample becomes a core point.
    Points which will never be core have a distance of inf.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__optics_8py_source_l00406}{406}} of file \mbox{\hyperlink{__optics_8py_source}{\+\_\+optics.\+py}}.



Referenced by \mbox{\hyperlink{__optics_8py_source_l00461}{compute\+\_\+optics\+\_\+graph()}}.

\Hypertarget{namespacesklearn_1_1cluster_1_1__optics_ada463efea84a53b7ea5e103432ed6421}\index{sklearn.cluster.\_optics@{sklearn.cluster.\_optics}!\_correct\_predecessor@{\_correct\_predecessor}}
\index{\_correct\_predecessor@{\_correct\_predecessor}!sklearn.cluster.\_optics@{sklearn.cluster.\_optics}}
\doxysubsubsection{\texorpdfstring{\_correct\_predecessor()}{\_correct\_predecessor()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1cluster_1_1__optics_ada463efea84a53b7ea5e103432ed6421} 
sklearn.\+cluster.\+\_\+optics.\+\_\+correct\+\_\+predecessor (\begin{DoxyParamCaption}\item[{}]{reachability\+\_\+plot}{, }\item[{}]{predecessor\+\_\+plot}{, }\item[{}]{ordering}{, }\item[{}]{s}{, }\item[{}]{e}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Correct for predecessors.

Applies Algorithm 2 of [1]_.

Input parameters are ordered by the computer OPTICS ordering.

.. [1] Schubert, Erich, Michael Gertz.
   "Improving the Cluster Structure Extracted from OPTICS Plots." Proc. of
   the Conference "Lernen, Wissen, Daten, Analysen" (LWDA) (2018): 318-329.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__optics_8py_source_l00999}{999}} of file \mbox{\hyperlink{__optics_8py_source}{\+\_\+optics.\+py}}.



Referenced by \mbox{\hyperlink{__optics_8py_source_l01029}{\+\_\+xi\+\_\+cluster()}}.

\Hypertarget{namespacesklearn_1_1cluster_1_1__optics_ab161ee0866fb871a43881f9228dc10da}\index{sklearn.cluster.\_optics@{sklearn.cluster.\_optics}!\_extend\_region@{\_extend\_region}}
\index{\_extend\_region@{\_extend\_region}!sklearn.cluster.\_optics@{sklearn.cluster.\_optics}}
\doxysubsubsection{\texorpdfstring{\_extend\_region()}{\_extend\_region()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1cluster_1_1__optics_ab161ee0866fb871a43881f9228dc10da} 
sklearn.\+cluster.\+\_\+optics.\+\_\+extend\+\_\+region (\begin{DoxyParamCaption}\item[{}]{steep\+\_\+point}{, }\item[{}]{xward\+\_\+point}{, }\item[{}]{start}{, }\item[{}]{min\+\_\+samples}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Extend the area until it's maximal.

It's the same function for both upward and downward reagions, depending on
the given input parameters. Assuming:

    - steep_{upward/downward}: bool array indicating whether a point is a
      steep {upward/downward};
    - upward/downward: bool array indicating whether a point is
      upward/downward;

To extend an upward reagion, ``steep_point=steep_upward`` and
``xward_point=downward`` are expected, and to extend a downward region,
``steep_point=steep_downward`` and ``xward_point=upward``.

Parameters
----------
steep_point : ndarray of shape (n_samples,), dtype=bool
    True if the point is steep downward (upward).

xward_point : ndarray of shape (n_samples,), dtype=bool
    True if the point is an upward (respectively downward) point.

start : int
    The start of the xward region.

min_samples : int
   The same as the min_samples given to OPTICS. Up and down steep
   regions can't have more then ``min_samples`` consecutive non-steep
   points.

Returns
-------
index : int
    The current index iterating over all the samples, i.e. where we are up
    to in our search.

end : int
    The end of the region, which can be behind the index. The region
    includes the ``end`` index.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__optics_8py_source_l00922}{922}} of file \mbox{\hyperlink{__optics_8py_source}{\+\_\+optics.\+py}}.



Referenced by \mbox{\hyperlink{__optics_8py_source_l01029}{\+\_\+xi\+\_\+cluster()}}.

\Hypertarget{namespacesklearn_1_1cluster_1_1__optics_a9754cc79736a1fd15348c5d32097d5bc}\index{sklearn.cluster.\_optics@{sklearn.cluster.\_optics}!\_extract\_xi\_labels@{\_extract\_xi\_labels}}
\index{\_extract\_xi\_labels@{\_extract\_xi\_labels}!sklearn.cluster.\_optics@{sklearn.cluster.\_optics}}
\doxysubsubsection{\texorpdfstring{\_extract\_xi\_labels()}{\_extract\_xi\_labels()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1cluster_1_1__optics_a9754cc79736a1fd15348c5d32097d5bc} 
sklearn.\+cluster.\+\_\+optics.\+\_\+extract\+\_\+xi\+\_\+labels (\begin{DoxyParamCaption}\item[{}]{ordering}{, }\item[{}]{clusters}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Extracts the labels from the clusters returned by `_xi_cluster`.
We rely on the fact that clusters are stored
with the smaller clusters coming before the larger ones.

Parameters
----------
ordering : array-like of shape (n_samples,)
    The ordering of points calculated by OPTICS

clusters : array-like of shape (n_clusters, 2)
    List of clusters i.e. (start, end) tuples,
    as returned by `_xi_cluster`.

Returns
-------
labels : ndarray of shape (n_samples,)
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__optics_8py_source_l01176}{1176}} of file \mbox{\hyperlink{__optics_8py_source}{\+\_\+optics.\+py}}.



Referenced by \mbox{\hyperlink{__optics_8py_source_l00820}{cluster\+\_\+optics\+\_\+xi()}}.

\Hypertarget{namespacesklearn_1_1cluster_1_1__optics_a3984ecdd3e7f496266936f970febf7cc}\index{sklearn.cluster.\_optics@{sklearn.cluster.\_optics}!\_set\_reach\_dist@{\_set\_reach\_dist}}
\index{\_set\_reach\_dist@{\_set\_reach\_dist}!sklearn.cluster.\_optics@{sklearn.cluster.\_optics}}
\doxysubsubsection{\texorpdfstring{\_set\_reach\_dist()}{\_set\_reach\_dist()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1cluster_1_1__optics_a3984ecdd3e7f496266936f970febf7cc} 
sklearn.\+cluster.\+\_\+optics.\+\_\+set\+\_\+reach\+\_\+dist (\begin{DoxyParamCaption}\item[{}]{core\+\_\+distances\+\_\+}{, }\item[{}]{reachability\+\_\+}{, }\item[{}]{predecessor\+\_\+}{, }\item[{}]{point\+\_\+index}{, }\item[{}]{processed}{, }\item[{}]{X}{, }\item[{}]{nbrs}{, }\item[{}]{metric}{, }\item[{}]{metric\+\_\+params}{, }\item[{}]{p}{, }\item[{}]{max\+\_\+eps}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{__optics_8py_source_l00672}{672}} of file \mbox{\hyperlink{__optics_8py_source}{\+\_\+optics.\+py}}.

\Hypertarget{namespacesklearn_1_1cluster_1_1__optics_a59f52f7066710373e697427ce6891250}\index{sklearn.cluster.\_optics@{sklearn.cluster.\_optics}!\_update\_filter\_sdas@{\_update\_filter\_sdas}}
\index{\_update\_filter\_sdas@{\_update\_filter\_sdas}!sklearn.cluster.\_optics@{sklearn.cluster.\_optics}}
\doxysubsubsection{\texorpdfstring{\_update\_filter\_sdas()}{\_update\_filter\_sdas()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1cluster_1_1__optics_a59f52f7066710373e697427ce6891250} 
sklearn.\+cluster.\+\_\+optics.\+\_\+update\+\_\+filter\+\_\+sdas (\begin{DoxyParamCaption}\item[{}]{sdas}{, }\item[{}]{mib}{, }\item[{}]{xi\+\_\+complement}{, }\item[{}]{reachability\+\_\+plot}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Update steep down areas (SDAs) using the new maximum in between (mib)
value, and the given complement of xi, i.e. ``1 - xi``.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__optics_8py_source_l00985}{985}} of file \mbox{\hyperlink{__optics_8py_source}{\+\_\+optics.\+py}}.



Referenced by \mbox{\hyperlink{__optics_8py_source_l01029}{\+\_\+xi\+\_\+cluster()}}.

\Hypertarget{namespacesklearn_1_1cluster_1_1__optics_a1a23fd16403b68f90c5a8e94bdd806ff}\index{sklearn.cluster.\_optics@{sklearn.cluster.\_optics}!\_validate\_size@{\_validate\_size}}
\index{\_validate\_size@{\_validate\_size}!sklearn.cluster.\_optics@{sklearn.cluster.\_optics}}
\doxysubsubsection{\texorpdfstring{\_validate\_size()}{\_validate\_size()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1cluster_1_1__optics_a1a23fd16403b68f90c5a8e94bdd806ff} 
sklearn.\+cluster.\+\_\+optics.\+\_\+validate\+\_\+size (\begin{DoxyParamCaption}\item[{}]{size}{, }\item[{}]{n\+\_\+samples}{, }\item[{}]{param\+\_\+name}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{__optics_8py_source_l00397}{397}} of file \mbox{\hyperlink{__optics_8py_source}{\+\_\+optics.\+py}}.

\Hypertarget{namespacesklearn_1_1cluster_1_1__optics_a9ca4867ed224dee781e1ae63c64f4307}\index{sklearn.cluster.\_optics@{sklearn.cluster.\_optics}!\_xi\_cluster@{\_xi\_cluster}}
\index{\_xi\_cluster@{\_xi\_cluster}!sklearn.cluster.\_optics@{sklearn.cluster.\_optics}}
\doxysubsubsection{\texorpdfstring{\_xi\_cluster()}{\_xi\_cluster()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1cluster_1_1__optics_a9ca4867ed224dee781e1ae63c64f4307} 
sklearn.\+cluster.\+\_\+optics.\+\_\+xi\+\_\+cluster (\begin{DoxyParamCaption}\item[{}]{reachability\+\_\+plot}{, }\item[{}]{predecessor\+\_\+plot}{, }\item[{}]{ordering}{, }\item[{}]{xi}{, }\item[{}]{min\+\_\+samples}{, }\item[{}]{min\+\_\+cluster\+\_\+size}{, }\item[{}]{predecessor\+\_\+correction}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Automatically extract clusters according to the Xi-steep method.

This is rouphly an implementation of Figure 19 of the OPTICS paper.

Parameters
----------
reachability_plot : array-like of shape (n_samples,)
    The reachability plot, i.e. reachability ordered according to
    the calculated ordering, all computed by OPTICS.

predecessor_plot : array-like of shape (n_samples,)
    Predecessors ordered according to the calculated ordering.

xi : float, between 0 and 1
    Determines the minimum steepness on the reachability plot that
    constitutes a cluster boundary. For example, an upwards point in the
    reachability plot is defined by the ratio from one point to its
    successor being at most 1-xi.

min_samples : int > 1
    The same as the min_samples given to OPTICS. Up and down steep regions
    can't have more then ``min_samples`` consecutive non-steep points.

min_cluster_size : int > 1
    Minimum number of samples in an OPTICS cluster.

predecessor_correction : bool
    Correct clusters based on the calculated predecessors.

Returns
-------
clusters : ndarray of shape (n_clusters, 2)
    The list of clusters in the form of [start, end] in each row, with all
    indices inclusive. The clusters are ordered in a way that larger
    clusters encompassing smaller clusters come after those smaller
    clusters.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__optics_8py_source_l01021}{1021}} of file \mbox{\hyperlink{__optics_8py_source}{\+\_\+optics.\+py}}.



References \mbox{\hyperlink{__optics_8py_source_l00999}{\+\_\+correct\+\_\+predecessor()}}, \mbox{\hyperlink{__optics_8py_source_l00922}{\+\_\+extend\+\_\+region()}}, and \mbox{\hyperlink{__optics_8py_source_l00985}{\+\_\+update\+\_\+filter\+\_\+sdas()}}.



Referenced by \mbox{\hyperlink{__optics_8py_source_l00820}{cluster\+\_\+optics\+\_\+xi()}}.

\Hypertarget{namespacesklearn_1_1cluster_1_1__optics_a6ae553de42635acf9bd1ca4d8ed12f2c}\index{sklearn.cluster.\_optics@{sklearn.cluster.\_optics}!cluster\_optics\_dbscan@{cluster\_optics\_dbscan}}
\index{cluster\_optics\_dbscan@{cluster\_optics\_dbscan}!sklearn.cluster.\_optics@{sklearn.cluster.\_optics}}
\doxysubsubsection{\texorpdfstring{cluster\_optics\_dbscan()}{cluster\_optics\_dbscan()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1cluster_1_1__optics_a6ae553de42635acf9bd1ca4d8ed12f2c} 
sklearn.\+cluster.\+\_\+optics.\+cluster\+\_\+optics\+\_\+dbscan (\begin{DoxyParamCaption}\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{reachability}{, }\item[{}]{core\+\_\+distances}{, }\item[{}]{ordering}{, }\item[{}]{eps}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Perform DBSCAN extraction for an arbitrary epsilon.

Extracting the clusters runs in linear time. Note that this results in
``labels_`` which are close to a :class:`~sklearn.cluster.DBSCAN` with
similar settings and ``eps``, only if ``eps`` is close to ``max_eps``.

Parameters
----------
reachability : ndarray of shape (n_samples,)
    Reachability distances calculated by OPTICS (``reachability_``).

core_distances : ndarray of shape (n_samples,)
    Distances at which points become core (``core_distances_``).

ordering : ndarray of shape (n_samples,)
    OPTICS ordered point indices (``ordering_``).

eps : float
    DBSCAN ``eps`` parameter. Must be set to < ``max_eps``. Results
    will be close to DBSCAN algorithm if ``eps`` and ``max_eps`` are close
    to one another.

Returns
-------
labels_ : array of shape (n_samples,)
    The estimated labels.

Examples
--------
>>> import numpy as np
>>> from sklearn.cluster import cluster_optics_dbscan, compute_optics_graph
>>> X = np.array([[1, 2], [2, 5], [3, 6],
...               [8, 7], [8, 8], [7, 3]])
>>> ordering, core_distances, reachability, predecessor = compute_optics_graph(
...     X,
...     min_samples=2,
...     max_eps=np.inf,
...     metric="minkowski",
...     p=2,
...     metric_params=None,
...     algorithm="auto",
...     leaf_size=30,
...     n_jobs=None,
... )
>>> eps = 4.5
>>> labels = cluster_optics_dbscan(
...     reachability=reachability,
...     core_distances=core_distances,
...     ordering=ordering,
...     eps=eps,
... )
>>> labels
array([0, 0, 0, 1, 1, 1])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__optics_8py_source_l00727}{727}} of file \mbox{\hyperlink{__optics_8py_source}{\+\_\+optics.\+py}}.



Referenced by \mbox{\hyperlink{__optics_8py_source_l00304}{sklearn.\+cluster.\+\_\+optics.\+OPTICS.\+fit()}}.

\Hypertarget{namespacesklearn_1_1cluster_1_1__optics_af00fa5eed1925cbb01becac227d90aac}\index{sklearn.cluster.\_optics@{sklearn.cluster.\_optics}!cluster\_optics\_xi@{cluster\_optics\_xi}}
\index{cluster\_optics\_xi@{cluster\_optics\_xi}!sklearn.cluster.\_optics@{sklearn.cluster.\_optics}}
\doxysubsubsection{\texorpdfstring{cluster\_optics\_xi()}{cluster\_optics\_xi()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1cluster_1_1__optics_af00fa5eed1925cbb01becac227d90aac} 
sklearn.\+cluster.\+\_\+optics.\+cluster\+\_\+optics\+\_\+xi (\begin{DoxyParamCaption}\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{reachability}{, }\item[{}]{predecessor}{, }\item[{}]{ordering}{, }\item[{}]{min\+\_\+samples}{, }\item[{}]{min\+\_\+cluster\+\_\+size}{ = {\ttfamily None}, }\item[{}]{xi}{ = {\ttfamily 0.05}, }\item[{}]{predecessor\+\_\+correction}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Automatically extract clusters according to the Xi-steep method.

Parameters
----------
reachability : ndarray of shape (n_samples,)
    Reachability distances calculated by OPTICS (`reachability_`).

predecessor : ndarray of shape (n_samples,)
    Predecessors calculated by OPTICS.

ordering : ndarray of shape (n_samples,)
    OPTICS ordered point indices (`ordering_`).

min_samples : int > 1 or float between 0 and 1
    The same as the min_samples given to OPTICS. Up and down steep regions
    can't have more then ``min_samples`` consecutive non-steep points.
    Expressed as an absolute number or a fraction of the number of samples
    (rounded to be at least 2).

min_cluster_size : int > 1 or float between 0 and 1, default=None
    Minimum number of samples in an OPTICS cluster, expressed as an
    absolute number or a fraction of the number of samples (rounded to be
    at least 2). If ``None``, the value of ``min_samples`` is used instead.

xi : float between 0 and 1, default=0.05
    Determines the minimum steepness on the reachability plot that
    constitutes a cluster boundary. For example, an upwards point in the
    reachability plot is defined by the ratio from one point to its
    successor being at most 1-xi.

predecessor_correction : bool, default=True
    Correct clusters based on the calculated predecessors.

Returns
-------
labels : ndarray of shape (n_samples,)
    The labels assigned to samples. Points which are not included
    in any cluster are labeled as -1.

clusters : ndarray of shape (n_clusters, 2)
    The list of clusters in the form of ``[start, end]`` in each row, with
    all indices inclusive. The clusters are ordered according to ``(end,
    -start)`` (ascending) so that larger clusters encompassing smaller
    clusters come after such nested smaller clusters. Since ``labels`` does
    not reflect the hierarchy, usually ``len(clusters) >
    np.unique(labels)``.

Examples
--------
>>> import numpy as np
>>> from sklearn.cluster import cluster_optics_xi, compute_optics_graph
>>> X = np.array([[1, 2], [2, 5], [3, 6],
...               [8, 7], [8, 8], [7, 3]])
>>> ordering, core_distances, reachability, predecessor = compute_optics_graph(
...     X,
...     min_samples=2,
...     max_eps=np.inf,
...     metric="minkowski",
...     p=2,
...     metric_params=None,
...     algorithm="auto",
...     leaf_size=30,
...     n_jobs=None
... )
>>> min_samples = 2
>>> labels, clusters = cluster_optics_xi(
...     reachability=reachability,
...     predecessor=predecessor,
...     ordering=ordering,
...     min_samples=min_samples,
... )
>>> labels
array([0, 0, 0, 1, 1, 1])
>>> clusters
array([[0, 2],
       [3, 5],
       [0, 5]])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__optics_8py_source_l00811}{811}} of file \mbox{\hyperlink{__optics_8py_source}{\+\_\+optics.\+py}}.



References \mbox{\hyperlink{__optics_8py_source_l01176}{\+\_\+extract\+\_\+xi\+\_\+labels()}}, and \mbox{\hyperlink{__optics_8py_source_l01029}{\+\_\+xi\+\_\+cluster()}}.



Referenced by \mbox{\hyperlink{__optics_8py_source_l00304}{sklearn.\+cluster.\+\_\+optics.\+OPTICS.\+fit()}}.

\Hypertarget{namespacesklearn_1_1cluster_1_1__optics_aad0efa601f27d3318be3a5cf12a2c6aa}\index{sklearn.cluster.\_optics@{sklearn.cluster.\_optics}!compute\_optics\_graph@{compute\_optics\_graph}}
\index{compute\_optics\_graph@{compute\_optics\_graph}!sklearn.cluster.\_optics@{sklearn.cluster.\_optics}}
\doxysubsubsection{\texorpdfstring{compute\_optics\_graph()}{compute\_optics\_graph()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1cluster_1_1__optics_aad0efa601f27d3318be3a5cf12a2c6aa} 
sklearn.\+cluster.\+\_\+optics.\+compute\+\_\+optics\+\_\+graph (\begin{DoxyParamCaption}\item[{}]{X}{, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{min\+\_\+samples}{, }\item[{}]{max\+\_\+eps}{, }\item[{}]{metric}{, }\item[{}]{p}{, }\item[{}]{metric\+\_\+params}{, }\item[{}]{algorithm}{, }\item[{}]{leaf\+\_\+size}{, }\item[{}]{n\+\_\+jobs}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute the OPTICS reachability graph.

Read more in the :ref:`User Guide <optics>`.

Parameters
----------
X : {ndarray, sparse matrix} of shape (n_samples, n_features), or \
        (n_samples, n_samples) if metric='precomputed'
    A feature array, or array of distances between samples if
    metric='precomputed'.

min_samples : int > 1 or float between 0 and 1
    The number of samples in a neighborhood for a point to be considered
    as a core point. Expressed as an absolute number or a fraction of the
    number of samples (rounded to be at least 2).

max_eps : float, default=np.inf
    The maximum distance between two samples for one to be considered as
    in the neighborhood of the other. Default value of ``np.inf`` will
    identify clusters across all scales; reducing ``max_eps`` will result
    in shorter run times.

metric : str or callable, default='minkowski'
    Metric to use for distance computation. Any metric from scikit-learn
    or scipy.spatial.distance can be used.

    If metric is a callable function, it is called on each
    pair of instances (rows) and the resulting value recorded. The callable
    should take two arrays as input and return one value indicating the
    distance between them. This works for Scipy's metrics, but is less
    efficient than passing the metric name as a string. If metric is
    "precomputed", X is assumed to be a distance matrix and must be square.

    Valid values for metric are:

    - from scikit-learn: ['cityblock', 'cosine', 'euclidean', 'l1', 'l2',
      'manhattan']

    - from scipy.spatial.distance: ['braycurtis', 'canberra', 'chebyshev',
      'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski',
      'mahalanobis', 'minkowski', 'rogerstanimoto', 'russellrao',
      'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean',
      'yule']

    See the documentation for scipy.spatial.distance for details on these
    metrics.

    .. note::
       `'kulsinski'` is deprecated from SciPy 1.9 and will be removed in SciPy 1.11.

p : float, default=2
    Parameter for the Minkowski metric from
    :class:`~sklearn.metrics.pairwise_distances`. When p = 1, this is
    equivalent to using manhattan_distance (l1), and euclidean_distance
    (l2) for p = 2. For arbitrary p, minkowski_distance (l_p) is used.

metric_params : dict, default=None
    Additional keyword arguments for the metric function.

algorithm : {'auto', 'ball_tree', 'kd_tree', 'brute'}, default='auto'
    Algorithm used to compute the nearest neighbors:

    - 'ball_tree' will use :class:`~sklearn.neighbors.BallTree`.
    - 'kd_tree' will use :class:`~sklearn.neighbors.KDTree`.
    - 'brute' will use a brute-force search.
    - 'auto' will attempt to decide the most appropriate algorithm
      based on the values passed to `fit` method. (default)

    Note: fitting on sparse input will override the setting of
    this parameter, using brute force.

leaf_size : int, default=30
    Leaf size passed to :class:`~sklearn.neighbors.BallTree` or
    :class:`~sklearn.neighbors.KDTree`. This can affect the speed of the
    construction and query, as well as the memory required to store the
    tree. The optimal value depends on the nature of the problem.

n_jobs : int, default=None
    The number of parallel jobs to run for neighbors search.
    ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.
    ``-1`` means using all processors. See :term:`Glossary <n_jobs>`
    for more details.

Returns
-------
ordering_ : array of shape (n_samples,)
    The cluster ordered list of sample indices.

core_distances_ : array of shape (n_samples,)
    Distance at which each sample becomes a core point, indexed by object
    order. Points which will never be core have a distance of inf. Use
    ``clust.core_distances_[clust.ordering_]`` to access in cluster order.

reachability_ : array of shape (n_samples,)
    Reachability distances per sample, indexed by object order. Use
    ``clust.reachability_[clust.ordering_]`` to access in cluster order.

predecessor_ : array of shape (n_samples,)
    Point that a sample was reached from, indexed by object order.
    Seed points have a predecessor of -1.

References
----------
.. [1] Ankerst, Mihael, Markus M. Breunig, Hans-Peter Kriegel,
   and Jörg Sander. "OPTICS: ordering points to identify the clustering
   structure." ACM SIGMOD Record 28, no. 2 (1999): 49-60.

Examples
--------
>>> import numpy as np
>>> from sklearn.cluster import compute_optics_graph
>>> X = np.array([[1, 2], [2, 5], [3, 6],
...               [8, 7], [8, 8], [7, 3]])
>>> ordering, core_distances, reachability, predecessor = compute_optics_graph(
...     X,
...     min_samples=2,
...     max_eps=np.inf,
...     metric="minkowski",
...     p=2,
...     metric_params=None,
...     algorithm="auto",
...     leaf_size=30,
...     n_jobs=None,
... )
>>> ordering
array([0, 1, 2, 5, 3, 4])
>>> core_distances
array([3.16, 1.41, 1.41, 1.        , 1.        ,
       4.12])
>>> reachability
array([       inf, 3.16, 1.41, 4.12, 1.        ,
       5.        ])
>>> predecessor
array([-1,  0,  1,  5,  3,  2])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__optics_8py_source_l00459}{459}} of file \mbox{\hyperlink{__optics_8py_source}{\+\_\+optics.\+py}}.



References \mbox{\hyperlink{__optics_8py_source_l00406}{\+\_\+compute\+\_\+core\+\_\+distances\+\_\+()}}.

