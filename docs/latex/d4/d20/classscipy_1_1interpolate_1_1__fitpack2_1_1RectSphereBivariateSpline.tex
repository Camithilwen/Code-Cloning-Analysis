\doxysection{scipy.\+interpolate.\+\_\+fitpack2.\+Rect\+Sphere\+Bivariate\+Spline Class Reference}
\hypertarget{classscipy_1_1interpolate_1_1__fitpack2_1_1RectSphereBivariateSpline}{}\label{classscipy_1_1interpolate_1_1__fitpack2_1_1RectSphereBivariateSpline}\index{scipy.interpolate.\_fitpack2.RectSphereBivariateSpline@{scipy.interpolate.\_fitpack2.RectSphereBivariateSpline}}


Inheritance diagram for scipy.\+interpolate.\+\_\+fitpack2.\+Rect\+Sphere\+Bivariate\+Spline\+:
% FIG 0


Collaboration diagram for scipy.\+interpolate.\+\_\+fitpack2.\+Rect\+Sphere\+Bivariate\+Spline\+:
% FIG 1
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classscipy_1_1interpolate_1_1__fitpack2_1_1RectSphereBivariateSpline_a63eade56230f7693cae8145f4ac3a419}{\+\_\+\+\_\+init\+\_\+\+\_\+}} (self, u, v, r, s=0., pole\+\_\+continuity=False, pole\+\_\+values=None, pole\+\_\+exact=False, pole\+\_\+flat=False)
\item 
\mbox{\hyperlink{classscipy_1_1interpolate_1_1__fitpack2_1_1RectSphereBivariateSpline_aadb9bc7a26014de757cede0cc1e941db}{\+\_\+\+\_\+call\+\_\+\+\_\+}} (self, theta, phi, dtheta=0, dphi=0, grid=\mbox{\hyperlink{classTrue}{True}})
\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions inherited from \mbox{\hyperlink{classscipy_1_1interpolate_1_1__fitpack2_1_1SphereBivariateSpline}{scipy.\+interpolate.\+\_\+fitpack2.\+Sphere\+Bivariate\+Spline}}}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classscipy_1_1interpolate_1_1__fitpack2_1_1SphereBivariateSpline_ab5593fa68761c401e5756ef4fe5d597b}{\+\_\+\+\_\+call\+\_\+\+\_\+}} (self, theta, phi, dtheta=0, dphi=0, grid=\mbox{\hyperlink{classTrue}{True}})
\item 
\mbox{\hyperlink{classscipy_1_1interpolate_1_1__fitpack2_1_1SphereBivariateSpline_a883ac637eb3d3d16b12b2aaf6adf9b2a}{ev}} (self, theta, phi, dtheta=0, dphi=0)
\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions inherited from \mbox{\hyperlink{classscipy_1_1interpolate_1_1__fitpack2_1_1__BivariateSplineBase}{scipy.\+interpolate.\+\_\+fitpack2.\+\_\+\+Bivariate\+Spline\+Base}}}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classscipy_1_1interpolate_1_1__fitpack2_1_1__BivariateSplineBase_ab1073ecfe33d901087ab6442e759e9c8}{get\+\_\+residual}} (self)
\item 
\mbox{\hyperlink{classscipy_1_1interpolate_1_1__fitpack2_1_1__BivariateSplineBase_a4f23278a6573f1ed2ede779c361f8e97}{get\+\_\+knots}} (self)
\item 
\mbox{\hyperlink{classscipy_1_1interpolate_1_1__fitpack2_1_1__BivariateSplineBase_ad40c468665f503b89ce0c779f818a819}{get\+\_\+coeffs}} (self)
\item 
\mbox{\hyperlink{classscipy_1_1interpolate_1_1__fitpack2_1_1__BivariateSplineBase_a2777cb46da9723ccd4197298c2148b88}{\+\_\+\+\_\+call\+\_\+\+\_\+}} (self, x, y, dx=0, dy=0, grid=\mbox{\hyperlink{classTrue}{True}})
\item 
\mbox{\hyperlink{classscipy_1_1interpolate_1_1__fitpack2_1_1__BivariateSplineBase_adc63f3887d2e8d0f8d97e78c104eb5c2}{partial\+\_\+derivative}} (self, dx, dy)
\end{DoxyCompactItemize}
\doxysubsubsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classscipy_1_1interpolate_1_1__fitpack2_1_1RectSphereBivariateSpline_afbb7f827dc036f38349df20aaf72caa6}{fp}} = fp
\item 
\mbox{\hyperlink{classscipy_1_1interpolate_1_1__fitpack2_1_1RectSphereBivariateSpline_a7d7ab0bb8b10f52dc32e3911e9f3e6df}{v0}} = v\mbox{[}0\mbox{]}
\end{DoxyCompactItemize}
\doxysubsection*{Public Attributes inherited from \mbox{\hyperlink{classscipy_1_1interpolate_1_1__fitpack2_1_1__BivariateSplineBase}{scipy.\+interpolate.\+\_\+fitpack2.\+\_\+\+Bivariate\+Spline\+Base}}}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classscipy_1_1interpolate_1_1__fitpack2_1_1__BivariateSplineBase_a1e158e7409ae374a5fc6ee4f665d8fd3}{tck}} = tck\mbox{[}\+:3\mbox{]}
\item 
\mbox{\hyperlink{classscipy_1_1interpolate_1_1__fitpack2_1_1__BivariateSplineBase_aabc8c6a4b2a5ee93d92863ecbb46b74a}{degrees}} = tck\mbox{[}3\+:\mbox{]}
\end{DoxyCompactItemize}
\doxysubsubsection*{Additional Inherited Members}
\doxysubsection*{Protected Member Functions inherited from \mbox{\hyperlink{classscipy_1_1interpolate_1_1__fitpack2_1_1__BivariateSplineBase}{scipy.\+interpolate.\+\_\+fitpack2.\+\_\+\+Bivariate\+Spline\+Base}}}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classscipy_1_1interpolate_1_1__fitpack2_1_1__BivariateSplineBase_a8691ef70fae71e84accb781afefe4ecc}{\+\_\+from\+\_\+tck}} (cls, tck)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\begin{DoxyVerb}Bivariate spline approximation over a rectangular mesh on a sphere.

Can be used for smoothing data.

.. versionadded:: 0.11.0

Parameters
----------
u : array_like
    1-D array of colatitude coordinates in strictly ascending order.
    Coordinates must be given in radians and lie within the open interval
    ``(0, pi)``.
v : array_like
    1-D array of longitude coordinates in strictly ascending order.
    Coordinates must be given in radians. First element (``v[0]``) must lie
    within the interval ``[-pi, pi)``. Last element (``v[-1]``) must satisfy
    ``v[-1] <= v[0] + 2*pi``.
r : array_like
    2-D array of data with shape ``(u.size, v.size)``.
s : float, optional
    Positive smoothing factor defined for estimation condition
    (``s=0`` is for interpolation).
pole_continuity : bool or (bool, bool), optional
    Order of continuity at the poles ``u=0`` (``pole_continuity[0]``) and
    ``u=pi`` (``pole_continuity[1]``).  The order of continuity at the pole
    will be 1 or 0 when this is True or False, respectively.
    Defaults to False.
pole_values : float or (float, float), optional
    Data values at the poles ``u=0`` and ``u=pi``.  Either the whole
    parameter or each individual element can be None.  Defaults to None.
pole_exact : bool or (bool, bool), optional
    Data value exactness at the poles ``u=0`` and ``u=pi``.  If True, the
    value is considered to be the right function value, and it will be
    fitted exactly. If False, the value will be considered to be a data
    value just like the other data values.  Defaults to False.
pole_flat : bool or (bool, bool), optional
    For the poles at ``u=0`` and ``u=pi``, specify whether or not the
    approximation has vanishing derivatives.  Defaults to False.

See Also
--------
BivariateSpline :
    a base class for bivariate splines.
UnivariateSpline :
    a smooth univariate spline to fit a given set of data points.
SmoothBivariateSpline :
    a smoothing bivariate spline through the given points
LSQBivariateSpline :
    a bivariate spline using weighted least-squares fitting
SmoothSphereBivariateSpline :
    a smoothing bivariate spline in spherical coordinates
LSQSphereBivariateSpline :
    a bivariate spline in spherical coordinates using weighted
    least-squares fitting
RectBivariateSpline :
    a bivariate spline over a rectangular mesh.
bisplrep :
    a function to find a bivariate B-spline representation of a surface
bisplev :
    a function to evaluate a bivariate B-spline and its derivatives

Notes
-----
Currently, only the smoothing spline approximation (``iopt[0] = 0`` and
``iopt[0] = 1`` in the FITPACK routine) is supported.  The exact
least-squares spline approximation is not implemented yet.

When actually performing the interpolation, the requested `v` values must
lie within the same length 2pi interval that the original `v` values were
chosen from.

For more information, see the FITPACK_ site about this function.

.. _FITPACK: http://www.netlib.org/dierckx/spgrid.f

Examples
--------
Suppose we have global data on a coarse grid

>>> import numpy as np
>>> lats = np.linspace(10, 170, 9) * np.pi / 180.
>>> lons = np.linspace(0, 350, 18) * np.pi / 180.
>>> data = np.dot(np.atleast_2d(90. - np.linspace(-80., 80., 18)).T,
...               np.atleast_2d(180. - np.abs(np.linspace(0., 350., 9)))).T

We want to interpolate it to a global one-degree grid

>>> new_lats = np.linspace(1, 180, 180) * np.pi / 180
>>> new_lons = np.linspace(1, 360, 360) * np.pi / 180
>>> new_lats, new_lons = np.meshgrid(new_lats, new_lons)

We need to set up the interpolator object

>>> from scipy.interpolate import RectSphereBivariateSpline
>>> lut = RectSphereBivariateSpline(lats, lons, data)

Finally we interpolate the data.  The `RectSphereBivariateSpline` object
only takes 1-D arrays as input, therefore we need to do some reshaping.

>>> data_interp = lut.ev(new_lats.ravel(),
...                      new_lons.ravel()).reshape((360, 180)).T

Looking at the original and the interpolated data, one can see that the
interpolant reproduces the original data very well:

>>> import matplotlib.pyplot as plt
>>> fig = plt.figure()
>>> ax1 = fig.add_subplot(211)
>>> ax1.imshow(data, interpolation='nearest')
>>> ax2 = fig.add_subplot(212)
>>> ax2.imshow(data_interp, interpolation='nearest')
>>> plt.show()

Choosing the optimal value of ``s`` can be a delicate task. Recommended
values for ``s`` depend on the accuracy of the data values.  If the user
has an idea of the statistical errors on the data, she can also find a
proper estimate for ``s``. By assuming that, if she specifies the
right ``s``, the interpolator will use a spline ``f(u,v)`` which exactly
reproduces the function underlying the data, she can evaluate
``sum((r(i,j)-s(u(i),v(j)))**2)`` to find a good estimate for this ``s``.
For example, if she knows that the statistical errors on her
``r(i,j)``-values are not greater than 0.1, she may expect that a good
``s`` should have a value not larger than ``u.size * v.size * (0.1)**2``.

If nothing is known about the statistical error in ``r(i,j)``, ``s`` must
be determined by trial and error.  The best is then to start with a very
large value of ``s`` (to determine the least-squares polynomial and the
corresponding upper bound ``fp0`` for ``s``) and then to progressively
decrease the value of ``s`` (say by a factor 10 in the beginning, i.e.
``s = fp0 / 10, fp0 / 100, ...``  and more carefully as the approximation
shows more detail) to obtain closer fits.

The interpolation results for different values of ``s`` give some insight
into this process:

>>> fig2 = plt.figure()
>>> s = [3e9, 2e9, 1e9, 1e8]
>>> for idx, sval in enumerate(s, 1):
...     lut = RectSphereBivariateSpline(lats, lons, data, s=sval)
...     data_interp = lut.ev(new_lats.ravel(),
...                          new_lons.ravel()).reshape((360, 180)).T
...     ax = fig2.add_subplot(2, 2, idx)
...     ax.imshow(data_interp, interpolation='nearest')
...     ax.set_title(f"s = {sval:g}")
>>> plt.show()
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__fitpack2_8py_source_l02130}{2130}} of file \mbox{\hyperlink{__fitpack2_8py_source}{\+\_\+fitpack2.\+py}}.



\doxysubsection{Constructor \& Destructor Documentation}
\Hypertarget{classscipy_1_1interpolate_1_1__fitpack2_1_1RectSphereBivariateSpline_a63eade56230f7693cae8145f4ac3a419}\index{scipy.interpolate.\_fitpack2.RectSphereBivariateSpline@{scipy.interpolate.\_fitpack2.RectSphereBivariateSpline}!\_\_init\_\_@{\_\_init\_\_}}
\index{\_\_init\_\_@{\_\_init\_\_}!scipy.interpolate.\_fitpack2.RectSphereBivariateSpline@{scipy.interpolate.\_fitpack2.RectSphereBivariateSpline}}
\doxysubsubsection{\texorpdfstring{\_\_init\_\_()}{\_\_init\_\_()}}
{\footnotesize\ttfamily \label{classscipy_1_1interpolate_1_1__fitpack2_1_1RectSphereBivariateSpline_a63eade56230f7693cae8145f4ac3a419} 
scipy.\+interpolate.\+\_\+fitpack2.\+Rect\+Sphere\+Bivariate\+Spline.\+\_\+\+\_\+init\+\_\+\+\_\+ (\begin{DoxyParamCaption}\item[{}]{self}{, }\item[{}]{u}{, }\item[{}]{v}{, }\item[{}]{r}{, }\item[{}]{s}{ = {\ttfamily 0.}, }\item[{}]{pole\+\_\+continuity}{ = {\ttfamily False}, }\item[{}]{pole\+\_\+values}{ = {\ttfamily None}, }\item[{}]{pole\+\_\+exact}{ = {\ttfamily False}, }\item[{}]{pole\+\_\+flat}{ = {\ttfamily False}}\end{DoxyParamCaption})}



Definition at line \mbox{\hyperlink{__fitpack2_8py_source_l02280}{2280}} of file \mbox{\hyperlink{__fitpack2_8py_source}{\+\_\+fitpack2.\+py}}.



Referenced by \mbox{\hyperlink{kernels_8py_source_l00178}{sklearn.\+gaussian\+\_\+process.\+kernels.\+Kernel.\+get\+\_\+params()}}, and \mbox{\hyperlink{__distn__infrastructure_8py_source_l00643}{scipy.\+stats.\+\_\+distn\+\_\+infrastructure.\+rv\+\_\+generic.\+random\+\_\+state()}}.



\doxysubsection{Member Function Documentation}
\Hypertarget{classscipy_1_1interpolate_1_1__fitpack2_1_1RectSphereBivariateSpline_aadb9bc7a26014de757cede0cc1e941db}\index{scipy.interpolate.\_fitpack2.RectSphereBivariateSpline@{scipy.interpolate.\_fitpack2.RectSphereBivariateSpline}!\_\_call\_\_@{\_\_call\_\_}}
\index{\_\_call\_\_@{\_\_call\_\_}!scipy.interpolate.\_fitpack2.RectSphereBivariateSpline@{scipy.interpolate.\_fitpack2.RectSphereBivariateSpline}}
\doxysubsubsection{\texorpdfstring{\_\_call\_\_()}{\_\_call\_\_()}}
{\footnotesize\ttfamily \label{classscipy_1_1interpolate_1_1__fitpack2_1_1RectSphereBivariateSpline_aadb9bc7a26014de757cede0cc1e941db} 
scipy.\+interpolate.\+\_\+fitpack2.\+Rect\+Sphere\+Bivariate\+Spline.\+\_\+\+\_\+call\+\_\+\+\_\+ (\begin{DoxyParamCaption}\item[{}]{self}{, }\item[{}]{theta}{, }\item[{}]{phi}{, }\item[{}]{dtheta}{ = {\ttfamily 0}, }\item[{}]{dphi}{ = {\ttfamily 0}, }\item[{}]{grid}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}}\end{DoxyParamCaption})}



Definition at line \mbox{\hyperlink{__fitpack2_8py_source_l02357}{2357}} of file \mbox{\hyperlink{__fitpack2_8py_source}{\+\_\+fitpack2.\+py}}.



\doxysubsection{Member Data Documentation}
\Hypertarget{classscipy_1_1interpolate_1_1__fitpack2_1_1RectSphereBivariateSpline_afbb7f827dc036f38349df20aaf72caa6}\index{scipy.interpolate.\_fitpack2.RectSphereBivariateSpline@{scipy.interpolate.\_fitpack2.RectSphereBivariateSpline}!fp@{fp}}
\index{fp@{fp}!scipy.interpolate.\_fitpack2.RectSphereBivariateSpline@{scipy.interpolate.\_fitpack2.RectSphereBivariateSpline}}
\doxysubsubsection{\texorpdfstring{fp}{fp}}
{\footnotesize\ttfamily \label{classscipy_1_1interpolate_1_1__fitpack2_1_1RectSphereBivariateSpline_afbb7f827dc036f38349df20aaf72caa6} 
scipy.\+interpolate.\+\_\+fitpack2.\+Rect\+Sphere\+Bivariate\+Spline.\+fp = fp}



Definition at line \mbox{\hyperlink{__fitpack2_8py_source_l02352}{2352}} of file \mbox{\hyperlink{__fitpack2_8py_source}{\+\_\+fitpack2.\+py}}.



Referenced by \mbox{\hyperlink{__netcdf_8py_source_l00231}{scipy.\+io.\+\_\+netcdf.\+netcdf\+\_\+file.\+\_\+\+\_\+init\+\_\+\+\_\+()}}, \mbox{\hyperlink{__netcdf_8py_source_l00289}{scipy.\+io.\+\_\+netcdf.\+netcdf\+\_\+file.\+close()}}, \mbox{\hyperlink{__netcdf_8py_source_l00393}{scipy.\+io.\+\_\+netcdf.\+netcdf\+\_\+file.\+flush()}}, and \mbox{\hyperlink{__fitpack2_8py_source_l00929}{scipy.\+interpolate.\+\_\+fitpack2.\+\_\+\+Bivariate\+Spline\+Base.\+get\+\_\+residual()}}.

\Hypertarget{classscipy_1_1interpolate_1_1__fitpack2_1_1RectSphereBivariateSpline_a7d7ab0bb8b10f52dc32e3911e9f3e6df}\index{scipy.interpolate.\_fitpack2.RectSphereBivariateSpline@{scipy.interpolate.\_fitpack2.RectSphereBivariateSpline}!v0@{v0}}
\index{v0@{v0}!scipy.interpolate.\_fitpack2.RectSphereBivariateSpline@{scipy.interpolate.\_fitpack2.RectSphereBivariateSpline}}
\doxysubsubsection{\texorpdfstring{v0}{v0}}
{\footnotesize\ttfamily \label{classscipy_1_1interpolate_1_1__fitpack2_1_1RectSphereBivariateSpline_a7d7ab0bb8b10f52dc32e3911e9f3e6df} 
scipy.\+interpolate.\+\_\+fitpack2.\+Rect\+Sphere\+Bivariate\+Spline.\+v0 = v\mbox{[}0\mbox{]}}



Definition at line \mbox{\hyperlink{__fitpack2_8py_source_l02355}{2355}} of file \mbox{\hyperlink{__fitpack2_8py_source}{\+\_\+fitpack2.\+py}}.



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/home/jam/\+Research/\+IRES-\/2025/dev/src/llm-\/scripts/testing/hypothesis-\/testing/hyp-\/env/lib/python3.\+12/site-\/packages/scipy/interpolate/\+\_\+fitpack2.\+py\end{DoxyCompactItemize}
