\doxysection{sklearn.\+utils.\+validation Namespace Reference}
\hypertarget{namespacesklearn_1_1utils_1_1validation}{}\label{namespacesklearn_1_1utils_1_1validation}\index{sklearn.utils.validation@{sklearn.utils.validation}}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1validation_abe091bbcfa11dee75d9f09734358ba06}{\+\_\+deprecate\+\_\+positional\+\_\+args}} (func=None, \texorpdfstring{$\ast$}{*}, version="{}1.\+3"{})
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1validation_ad4a62f217416ae84f85f6a057a0e3f23}{\+\_\+assert\+\_\+all\+\_\+finite}} (X, allow\+\_\+nan=False, msg\+\_\+dtype=None, estimator\+\_\+name=None, input\+\_\+name="{}"{})
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1validation_ab585aa164ae54ee1572c9414e70583b6}{\+\_\+assert\+\_\+all\+\_\+finite\+\_\+element\+\_\+wise}} (X, \texorpdfstring{$\ast$}{*}, xp, allow\+\_\+nan, msg\+\_\+dtype=None, estimator\+\_\+name=None, input\+\_\+name="{}"{})
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1validation_a2a054b849a7a3d0305a234790e68bbf9}{assert\+\_\+all\+\_\+finite}} (X, \texorpdfstring{$\ast$}{*}, allow\+\_\+nan=False, estimator\+\_\+name=None, input\+\_\+name="{}"{})
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1validation_a5f02a39543658ecec278249bfd2ff295}{as\+\_\+float\+\_\+array}} (X, \texorpdfstring{$\ast$}{*}, copy=\mbox{\hyperlink{classTrue}{True}}, force\+\_\+all\+\_\+finite="{}deprecated"{}, ensure\+\_\+all\+\_\+finite=None)
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1validation_a7a74c4bdbb9185e056d4db94a4321d4b}{\+\_\+is\+\_\+arraylike}} (x)
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1validation_a4af048955280074c9ef7215354038a2d}{\+\_\+is\+\_\+arraylike\+\_\+not\+\_\+scalar}} (array)
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1validation_af575c1c3759d1f79358f4b6b9351c1a8}{\+\_\+use\+\_\+interchange\+\_\+protocol}} (X)
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1validation_aeac633479b1dc831cf7ed4e7b59ad364}{\+\_\+num\+\_\+features}} (X)
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1validation_a2f819616f9cf7c4a803a684bb783bdfe}{\+\_\+num\+\_\+samples}} (x)
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1validation_ab472519c2e841a2531e0a8dc3b9fbd64}{check\+\_\+memory}} (memory)
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1validation_a3d76ca8a780f1b9df7f975d307e28dc8}{check\+\_\+consistent\+\_\+length}} (\texorpdfstring{$\ast$}{*}arrays)
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1validation_a7550ba455fda84a6ace62242d3b0dc70}{\+\_\+make\+\_\+indexable}} (iterable)
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1validation_a504b868d5db67011bff3ac38f2dbaf4e}{indexable}} (\texorpdfstring{$\ast$}{*}iterables)
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1validation_a7bbd2250a0acc922410c38f391c3183e}{\+\_\+ensure\+\_\+sparse\+\_\+format}} (sparse\+\_\+container, accept\+\_\+sparse, dtype, copy, ensure\+\_\+all\+\_\+finite, accept\+\_\+large\+\_\+sparse, estimator\+\_\+name=None, input\+\_\+name="{}"{})
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1validation_aa634741aed9f3b17aad8a66b5577ec85}{\+\_\+ensure\+\_\+no\+\_\+complex\+\_\+data}} (array)
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1validation_a622220dd6fe3de2a1d211be4e82d25b4}{\+\_\+check\+\_\+estimator\+\_\+name}} (estimator)
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1validation_a0ebca20e325263d762622596fa7b1bac}{\+\_\+pandas\+\_\+dtype\+\_\+needs\+\_\+early\+\_\+conversion}} (pd\+\_\+dtype)
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1validation_a813ca16fbd15d66e3d13413f2b76c6b9}{\+\_\+is\+\_\+extension\+\_\+array\+\_\+dtype}} (array)
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1validation_a828c5472410043c1260586dcc5c2d4af}{check\+\_\+array}} (array, accept\+\_\+sparse=False, \texorpdfstring{$\ast$}{*}, accept\+\_\+large\+\_\+sparse=\mbox{\hyperlink{classTrue}{True}}, dtype="{}numeric"{}, order=None, copy=False, force\+\_\+writeable=False, force\+\_\+all\+\_\+finite="{}deprecated"{}, ensure\+\_\+all\+\_\+finite=None, ensure\+\_\+non\+\_\+negative=False, ensure\+\_\+2d=\mbox{\hyperlink{classTrue}{True}}, allow\+\_\+nd=False, ensure\+\_\+min\+\_\+samples=1, ensure\+\_\+min\+\_\+features=1, estimator=None, input\+\_\+name="{}"{})
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1validation_a66127648643ff52252663b27ccb84278}{\+\_\+check\+\_\+large\+\_\+sparse}} (X, accept\+\_\+large\+\_\+sparse=False)
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1validation_adea0c511b3202afb470713b61d4d1630}{check\+\_\+\+X\+\_\+y}} (X, y, accept\+\_\+sparse=False, \texorpdfstring{$\ast$}{*}, accept\+\_\+large\+\_\+sparse=\mbox{\hyperlink{classTrue}{True}}, dtype="{}numeric"{}, order=None, copy=False, force\+\_\+writeable=False, force\+\_\+all\+\_\+finite="{}deprecated"{}, ensure\+\_\+all\+\_\+finite=None, ensure\+\_\+2d=\mbox{\hyperlink{classTrue}{True}}, allow\+\_\+nd=False, multi\+\_\+output=False, ensure\+\_\+min\+\_\+samples=1, ensure\+\_\+min\+\_\+features=1, y\+\_\+numeric=False, estimator=None)
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1validation_a72d745f985dadefe1bf3a15fb67d5243}{\+\_\+check\+\_\+y}} (y, multi\+\_\+output=False, y\+\_\+numeric=False, estimator=None)
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1validation_a1bdc07fbd258f21f135d665edc151b2f}{column\+\_\+or\+\_\+1d}} (y, \texorpdfstring{$\ast$}{*}, dtype=None, warn=False, device=None)
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1validation_a02e9f59100d50fa74df40218a4de1471}{check\+\_\+random\+\_\+state}} (seed)
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1validation_ac4e26a6139a4438d6cb20d7df8e22627}{has\+\_\+fit\+\_\+parameter}} (estimator, \mbox{\hyperlink{structparameter}{parameter}})
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1validation_a2400c76ab584dbb9176277e186948c96}{check\+\_\+symmetric}} (array, \texorpdfstring{$\ast$}{*}, tol=1e-\/10, raise\+\_\+warning=\mbox{\hyperlink{classTrue}{True}}, raise\+\_\+exception=False)
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1validation_a84937074a30f440ac2c5b3d5b2988a24}{\+\_\+is\+\_\+fitted}} (estimator, attributes=None, all\+\_\+or\+\_\+any=all)
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1validation_a7ac4afdc8943b77f8813c63dd98daf32}{check\+\_\+is\+\_\+fitted}} (estimator, attributes=None, \texorpdfstring{$\ast$}{*}, msg=None, all\+\_\+or\+\_\+any=all)
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1validation_afd6efcaecee86719959c8fbc198d525f}{\+\_\+estimator\+\_\+has}} (attr, \texorpdfstring{$\ast$}{*}, delegates=("{}estimator\+\_\+"{}, "{}estimator"{}))
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1validation_a219a80672df078db2c451d95db8833ee}{check\+\_\+non\+\_\+negative}} (X, whom)
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1validation_ad736b5d420812969b32c65fc0a62ad11}{check\+\_\+scalar}} (x, name, target\+\_\+type, \texorpdfstring{$\ast$}{*}, min\+\_\+val=None, max\+\_\+val=None, include\+\_\+boundaries="{}both"{})
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1validation_addb9557cb2e17288962287ce3c50e4d1}{\+\_\+check\+\_\+psd\+\_\+eigenvalues}} (lambdas, enable\+\_\+warnings=False)
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1validation_ad44df9f942251b5a035fd0198bdeb494}{\+\_\+check\+\_\+sample\+\_\+weight}} (sample\+\_\+weight, X, \texorpdfstring{$\ast$}{*}, dtype=None, ensure\+\_\+non\+\_\+negative=False, copy=False)
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1validation_a53a79b268e62f5ed44d02169fc1adb39}{\+\_\+allclose\+\_\+dense\+\_\+sparse}} (x, y, rtol=1e-\/7, atol=1e-\/9)
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1validation_a9809ac2229fb1943aa1b5ddda2efb07e}{\+\_\+check\+\_\+response\+\_\+method}} (estimator, response\+\_\+method)
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1validation_abd255698be8c67ccccb37b1daf8f73b3}{\+\_\+check\+\_\+method\+\_\+params}} (X, params, indices=None)
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1validation_a956da2cc04560c5662207ecaf6306068}{\+\_\+is\+\_\+pandas\+\_\+df\+\_\+or\+\_\+series}} (X)
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1validation_a79cd19779b80d9bfc5e8a5b48bcdd6a7}{\+\_\+is\+\_\+pandas\+\_\+df}} (X)
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1validation_ab52eb389fd907bf97c7d91cb8d31644b}{\+\_\+is\+\_\+pyarrow\+\_\+data}} (X)
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1validation_a40a86441602757c56accc1fa021ff241}{\+\_\+is\+\_\+polars\+\_\+df\+\_\+or\+\_\+series}} (X)
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1validation_afda1b404469e131a843ce583def0a3cb}{\+\_\+is\+\_\+polars\+\_\+df}} (X)
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1validation_aa403f42854f5a6a64e52a464b347c9f7}{\+\_\+get\+\_\+feature\+\_\+names}} (X)
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1validation_a4b2c400dcb27954b2da6243070acb5bc}{\+\_\+check\+\_\+feature\+\_\+names\+\_\+in}} (estimator, input\+\_\+features=None, \texorpdfstring{$\ast$}{*}, generate\+\_\+names=\mbox{\hyperlink{classTrue}{True}})
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1validation_a64c81bffff5d7bcec77445438cdfaa82}{\+\_\+generate\+\_\+get\+\_\+feature\+\_\+names\+\_\+out}} (estimator, n\+\_\+features\+\_\+out, input\+\_\+features=None)
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1validation_a47dbace05a46d67eb4eb76c35feaed3e}{\+\_\+check\+\_\+monotonic\+\_\+cst}} (estimator, monotonic\+\_\+cst=None)
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1validation_afa4a4f082021f6df5a792c26761f180d}{\+\_\+check\+\_\+pos\+\_\+label\+\_\+consistency}} (pos\+\_\+label, y\+\_\+true)
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1validation_a199e87942398a6087bcf123d40b26e5a}{\+\_\+to\+\_\+object\+\_\+array}} (sequence)
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1validation_ae4c70ed35455f6bd86a72ba2b91dbe7e}{\+\_\+check\+\_\+feature\+\_\+names}} (estimator, X, \texorpdfstring{$\ast$}{*}, reset)
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1validation_ab28adc484147fda16ffae97068b52cfd}{\+\_\+check\+\_\+n\+\_\+features}} (estimator, X, reset)
\item 
\mbox{\hyperlink{namespacesklearn_1_1utils_1_1validation_a46a0db1d6e5148292acc9496f018a83f}{validate\+\_\+data}} (\+\_\+estimator, X="{}no\+\_\+validation"{}, y="{}no\+\_\+validation"{}, reset=\mbox{\hyperlink{classTrue}{True}}, validate\+\_\+separately=False, skip\+\_\+check\+\_\+array=False, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}check\+\_\+params)
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
tuple \mbox{\hyperlink{namespacesklearn_1_1utils_1_1validation_a6f695de28a35eaa5749b3ba2d290d83e}{FLOAT\+\_\+\+DTYPES}} = (np.\+float64, np.\+float32, np.\+float16)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\begin{DoxyVerb}Functions to validate input and parameters within scikit-learn estimators.\end{DoxyVerb}
 

\doxysubsection{Function Documentation}
\Hypertarget{namespacesklearn_1_1utils_1_1validation_a53a79b268e62f5ed44d02169fc1adb39}\index{sklearn.utils.validation@{sklearn.utils.validation}!\_allclose\_dense\_sparse@{\_allclose\_dense\_sparse}}
\index{\_allclose\_dense\_sparse@{\_allclose\_dense\_sparse}!sklearn.utils.validation@{sklearn.utils.validation}}
\doxysubsubsection{\texorpdfstring{\_allclose\_dense\_sparse()}{\_allclose\_dense\_sparse()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1validation_a53a79b268e62f5ed44d02169fc1adb39} 
sklearn.\+utils.\+validation.\+\_\+allclose\+\_\+dense\+\_\+sparse (\begin{DoxyParamCaption}\item[{}]{x}{, }\item[{}]{y}{, }\item[{}]{rtol}{ = {\ttfamily 1e-\/7}, }\item[{}]{atol}{ = {\ttfamily 1e-\/9}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Check allclose for sparse and dense data.

Both x and y need to be either sparse or dense, they
can't be mixed.

Parameters
----------
x : {array-like, sparse matrix}
    First array to compare.

y : {array-like, sparse matrix}
    Second array to compare.

rtol : float, default=1e-7
    Relative tolerance; see numpy.allclose.

atol : float, default=1e-9
    absolute tolerance; see numpy.allclose. Note that the default here is
    more tolerant than the default for numpy.testing.assert_allclose, where
    atol=0.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{validation_8py_source_l02209}{2209}} of file \mbox{\hyperlink{validation_8py_source}{validation.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1validation_ad4a62f217416ae84f85f6a057a0e3f23}\index{sklearn.utils.validation@{sklearn.utils.validation}!\_assert\_all\_finite@{\_assert\_all\_finite}}
\index{\_assert\_all\_finite@{\_assert\_all\_finite}!sklearn.utils.validation@{sklearn.utils.validation}}
\doxysubsubsection{\texorpdfstring{\_assert\_all\_finite()}{\_assert\_all\_finite()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1validation_ad4a62f217416ae84f85f6a057a0e3f23} 
sklearn.\+utils.\+validation.\+\_\+assert\+\_\+all\+\_\+finite (\begin{DoxyParamCaption}\item[{}]{X}{, }\item[{}]{allow\+\_\+nan}{ = {\ttfamily False}, }\item[{}]{msg\+\_\+dtype}{ = {\ttfamily None}, }\item[{}]{estimator\+\_\+name}{ = {\ttfamily None}, }\item[{}]{input\+\_\+name}{ = {\ttfamily "{}"{}}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Like assert_all_finite, but only for ndarray.\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{validation_8py_source_l00090}{90}} of file \mbox{\hyperlink{validation_8py_source}{validation.\+py}}.



Referenced by \mbox{\hyperlink{validation_8py_source_l00178}{assert\+\_\+all\+\_\+finite()}}.

\Hypertarget{namespacesklearn_1_1utils_1_1validation_ab585aa164ae54ee1572c9414e70583b6}\index{sklearn.utils.validation@{sklearn.utils.validation}!\_assert\_all\_finite\_element\_wise@{\_assert\_all\_finite\_element\_wise}}
\index{\_assert\_all\_finite\_element\_wise@{\_assert\_all\_finite\_element\_wise}!sklearn.utils.validation@{sklearn.utils.validation}}
\doxysubsubsection{\texorpdfstring{\_assert\_all\_finite\_element\_wise()}{\_assert\_all\_finite\_element\_wise()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1validation_ab585aa164ae54ee1572c9414e70583b6} 
sklearn.\+utils.\+validation.\+\_\+assert\+\_\+all\+\_\+finite\+\_\+element\+\_\+wise (\begin{DoxyParamCaption}\item[{}]{X}{, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{xp}{, }\item[{}]{allow\+\_\+nan}{, }\item[{}]{msg\+\_\+dtype}{ = {\ttfamily None}, }\item[{}]{estimator\+\_\+name}{ = {\ttfamily None}, }\item[{}]{input\+\_\+name}{ = {\ttfamily "{}"{}}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{validation_8py_source_l00130}{130}} of file \mbox{\hyperlink{validation_8py_source}{validation.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1validation_a622220dd6fe3de2a1d211be4e82d25b4}\index{sklearn.utils.validation@{sklearn.utils.validation}!\_check\_estimator\_name@{\_check\_estimator\_name}}
\index{\_check\_estimator\_name@{\_check\_estimator\_name}!sklearn.utils.validation@{sklearn.utils.validation}}
\doxysubsubsection{\texorpdfstring{\_check\_estimator\_name()}{\_check\_estimator\_name()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1validation_a622220dd6fe3de2a1d211be4e82d25b4} 
sklearn.\+utils.\+validation.\+\_\+check\+\_\+estimator\+\_\+name (\begin{DoxyParamCaption}\item[{}]{estimator}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{validation_8py_source_l00681}{681}} of file \mbox{\hyperlink{validation_8py_source}{validation.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1validation_ae4c70ed35455f6bd86a72ba2b91dbe7e}\index{sklearn.utils.validation@{sklearn.utils.validation}!\_check\_feature\_names@{\_check\_feature\_names}}
\index{\_check\_feature\_names@{\_check\_feature\_names}!sklearn.utils.validation@{sklearn.utils.validation}}
\doxysubsubsection{\texorpdfstring{\_check\_feature\_names()}{\_check\_feature\_names()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1validation_ae4c70ed35455f6bd86a72ba2b91dbe7e} 
sklearn.\+utils.\+validation.\+\_\+check\+\_\+feature\+\_\+names (\begin{DoxyParamCaption}\item[{}]{estimator}{, }\item[{}]{X}{, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{reset}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Set or check the `feature_names_in_` attribute of an estimator.

.. versionadded:: 1.0

.. versionchanged:: 1.6
    Moved from :class:`~sklearn.base.BaseEstimator` to
    :mod:`sklearn.utils.validation`.

Parameters
----------
estimator : estimator instance
    The estimator to validate the input for.

X : {ndarray, dataframe} of shape (n_samples, n_features)
    The input samples.

reset : bool
    Whether to reset the `feature_names_in_` attribute.
    If False, the input will be checked for consistency with
    feature names of data provided when reset was last True.
    .. note::
       It is recommended to call `reset=True` in `fit` and in the first
       call to `partial_fit`. All other methods that validate `X`
       should set `reset=False`.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{validation_8py_source_l02697}{2697}} of file \mbox{\hyperlink{validation_8py_source}{validation.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1validation_a4b2c400dcb27954b2da6243070acb5bc}\index{sklearn.utils.validation@{sklearn.utils.validation}!\_check\_feature\_names\_in@{\_check\_feature\_names\_in}}
\index{\_check\_feature\_names\_in@{\_check\_feature\_names\_in}!sklearn.utils.validation@{sklearn.utils.validation}}
\doxysubsubsection{\texorpdfstring{\_check\_feature\_names\_in()}{\_check\_feature\_names\_in()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1validation_a4b2c400dcb27954b2da6243070acb5bc} 
sklearn.\+utils.\+validation.\+\_\+check\+\_\+feature\+\_\+names\+\_\+in (\begin{DoxyParamCaption}\item[{}]{estimator}{, }\item[{}]{input\+\_\+features}{ = {\ttfamily None}, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{generate\+\_\+names}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Check `input_features` and generate names if needed.

Commonly used in :term:`get_feature_names_out`.

Parameters
----------
input_features : array-like of str or None, default=None
    Input features.

    - If `input_features` is `None`, then `feature_names_in_` is
      used as feature names in. If `feature_names_in_` is not defined,
      then the following input feature names are generated:
      `["x0", "x1", ..., "x(n_features_in_ - 1)"]`.
    - If `input_features` is an array-like, then `input_features` must
      match `feature_names_in_` if `feature_names_in_` is defined.

generate_names : bool, default=True
    Whether to generate names when `input_features` is `None` and
    `estimator.feature_names_in_` is not defined. This is useful for transformers
    that validates `input_features` but do not require them in
    :term:`get_feature_names_out` e.g. `PCA`.

Returns
-------
feature_names_in : ndarray of str or `None`
    Feature names in.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{validation_8py_source_l02441}{2441}} of file \mbox{\hyperlink{validation_8py_source}{validation.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1validation_a66127648643ff52252663b27ccb84278}\index{sklearn.utils.validation@{sklearn.utils.validation}!\_check\_large\_sparse@{\_check\_large\_sparse}}
\index{\_check\_large\_sparse@{\_check\_large\_sparse}!sklearn.utils.validation@{sklearn.utils.validation}}
\doxysubsubsection{\texorpdfstring{\_check\_large\_sparse()}{\_check\_large\_sparse()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1validation_a66127648643ff52252663b27ccb84278} 
sklearn.\+utils.\+validation.\+\_\+check\+\_\+large\+\_\+sparse (\begin{DoxyParamCaption}\item[{}]{X}{, }\item[{}]{accept\+\_\+large\+\_\+sparse}{ = {\ttfamily False}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Raise a ValueError if X has 64bit indices and accept_large_sparse=False\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{validation_8py_source_l01179}{1179}} of file \mbox{\hyperlink{validation_8py_source}{validation.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1validation_abd255698be8c67ccccb37b1daf8f73b3}\index{sklearn.utils.validation@{sklearn.utils.validation}!\_check\_method\_params@{\_check\_method\_params}}
\index{\_check\_method\_params@{\_check\_method\_params}!sklearn.utils.validation@{sklearn.utils.validation}}
\doxysubsubsection{\texorpdfstring{\_check\_method\_params()}{\_check\_method\_params()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1validation_abd255698be8c67ccccb37b1daf8f73b3} 
sklearn.\+utils.\+validation.\+\_\+check\+\_\+method\+\_\+params (\begin{DoxyParamCaption}\item[{}]{X}{, }\item[{}]{params}{, }\item[{}]{indices}{ = {\ttfamily None}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Check and validate the parameters passed to a specific
method like `fit`.

Parameters
----------
X : array-like of shape (n_samples, n_features)
    Data array.

params : dict
    Dictionary containing the parameters passed to the method.

indices : array-like of shape (n_samples,), default=None
    Indices to be selected if the parameter has the same size as `X`.

Returns
-------
method_params_validated : dict
    Validated parameters. We ensure that the values support indexing.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{validation_8py_source_l02294}{2294}} of file \mbox{\hyperlink{validation_8py_source}{validation.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1validation_a47dbace05a46d67eb4eb76c35feaed3e}\index{sklearn.utils.validation@{sklearn.utils.validation}!\_check\_monotonic\_cst@{\_check\_monotonic\_cst}}
\index{\_check\_monotonic\_cst@{\_check\_monotonic\_cst}!sklearn.utils.validation@{sklearn.utils.validation}}
\doxysubsubsection{\texorpdfstring{\_check\_monotonic\_cst()}{\_check\_monotonic\_cst()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1validation_a47dbace05a46d67eb4eb76c35feaed3e} 
sklearn.\+utils.\+validation.\+\_\+check\+\_\+monotonic\+\_\+cst (\begin{DoxyParamCaption}\item[{}]{estimator}{, }\item[{}]{monotonic\+\_\+cst}{ = {\ttfamily None}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Check the monotonic constraints and return the corresponding array.

This helper function should be used in the `fit` method of an estimator
that supports monotonic constraints and called after the estimator has
introspected input data to set the `n_features_in_` and optionally the
`feature_names_in_` attributes.

.. versionadded:: 1.2

Parameters
----------
estimator : estimator instance

monotonic_cst : array-like of int, dict of str or None, default=None
    Monotonic constraints for the features.

    - If array-like, then it should contain only -1, 0 or 1. Each value
        will be checked to be in [-1, 0, 1]. If a value is -1, then the
        corresponding feature is required to be monotonically decreasing.
    - If dict, then it the keys should be the feature names occurring in
        `estimator.feature_names_in_` and the values should be -1, 0 or 1.
    - If None, then an array of 0s will be allocated.

Returns
-------
monotonic_cst : ndarray of int
    Monotonic constraints for each feature.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{validation_8py_source_l02529}{2529}} of file \mbox{\hyperlink{validation_8py_source}{validation.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1validation_ab28adc484147fda16ffae97068b52cfd}\index{sklearn.utils.validation@{sklearn.utils.validation}!\_check\_n\_features@{\_check\_n\_features}}
\index{\_check\_n\_features@{\_check\_n\_features}!sklearn.utils.validation@{sklearn.utils.validation}}
\doxysubsubsection{\texorpdfstring{\_check\_n\_features()}{\_check\_n\_features()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1validation_ab28adc484147fda16ffae97068b52cfd} 
sklearn.\+utils.\+validation.\+\_\+check\+\_\+n\+\_\+features (\begin{DoxyParamCaption}\item[{}]{estimator}{, }\item[{}]{X}{, }\item[{}]{reset}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Set the `n_features_in_` attribute, or check against it on an estimator.

.. versionchanged:: 1.6
    Moved from :class:`~sklearn.base.BaseEstimator` to
    :mod:`~sklearn.utils.validation`.

Parameters
----------
estimator : estimator instance
    The estimator to validate the input for.

X : {ndarray, sparse matrix} of shape (n_samples, n_features)
    The input samples.

reset : bool
    If True, the `n_features_in_` attribute is set to `X.shape[1]`.
    If False and the attribute exists, then check that it is equal to
    `X.shape[1]`. If False and the attribute does *not* exist, then
    the check is skipped.
    .. note::
       It is recommended to call reset=True in `fit` and in the first
       call to `partial_fit`. All other methods that validate `X`
       should set `reset=False`.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{validation_8py_source_l02790}{2790}} of file \mbox{\hyperlink{validation_8py_source}{validation.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1validation_afa4a4f082021f6df5a792c26761f180d}\index{sklearn.utils.validation@{sklearn.utils.validation}!\_check\_pos\_label\_consistency@{\_check\_pos\_label\_consistency}}
\index{\_check\_pos\_label\_consistency@{\_check\_pos\_label\_consistency}!sklearn.utils.validation@{sklearn.utils.validation}}
\doxysubsubsection{\texorpdfstring{\_check\_pos\_label\_consistency()}{\_check\_pos\_label\_consistency()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1validation_afa4a4f082021f6df5a792c26761f180d} 
sklearn.\+utils.\+validation.\+\_\+check\+\_\+pos\+\_\+label\+\_\+consistency (\begin{DoxyParamCaption}\item[{}]{pos\+\_\+label}{, }\item[{}]{y\+\_\+true}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Check if `pos_label` need to be specified or not.

In binary classification, we fix `pos_label=1` if the labels are in the set
{-1, 1} or {0, 1}. Otherwise, we raise an error asking to specify the
`pos_label` parameters.

Parameters
----------
pos_label : int, float, bool, str or None
    The positive label.
y_true : ndarray of shape (n_samples,)
    The target vector.

Returns
-------
pos_label : int, float, bool or str
    If `pos_label` can be inferred, it will be returned.

Raises
------
ValueError
    In the case that `y_true` does not have label in {-1, 1} or {0, 1},
    it will raise a `ValueError`.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{validation_8py_source_l02611}{2611}} of file \mbox{\hyperlink{validation_8py_source}{validation.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1validation_addb9557cb2e17288962287ce3c50e4d1}\index{sklearn.utils.validation@{sklearn.utils.validation}!\_check\_psd\_eigenvalues@{\_check\_psd\_eigenvalues}}
\index{\_check\_psd\_eigenvalues@{\_check\_psd\_eigenvalues}!sklearn.utils.validation@{sklearn.utils.validation}}
\doxysubsubsection{\texorpdfstring{\_check\_psd\_eigenvalues()}{\_check\_psd\_eigenvalues()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1validation_addb9557cb2e17288962287ce3c50e4d1} 
sklearn.\+utils.\+validation.\+\_\+check\+\_\+psd\+\_\+eigenvalues (\begin{DoxyParamCaption}\item[{}]{lambdas}{, }\item[{}]{enable\+\_\+warnings}{ = {\ttfamily False}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Check the eigenvalues of a positive semidefinite (PSD) matrix.

Checks the provided array of PSD matrix eigenvalues for numerical or
conditioning issues and returns a fixed validated version. This method
should typically be used if the PSD matrix is user-provided (e.g. a
Gram matrix) or computed using a user-provided dissimilarity metric
(e.g. kernel function), or if the decomposition process uses approximation
methods (randomized SVD, etc.).

It checks for three things:

- that there are no significant imaginary parts in eigenvalues (more than
  1e-5 times the maximum real part). If this check fails, it raises a
  ``ValueError``. Otherwise all non-significant imaginary parts that may
  remain are set to zero. This operation is traced with a
  ``PositiveSpectrumWarning`` when ``enable_warnings=True``.

- that eigenvalues are not all negative. If this check fails, it raises a
  ``ValueError``

- that there are no significant negative eigenvalues with absolute value
  more than 1e-10 (1e-6) and more than 1e-5 (5e-3) times the largest
  positive eigenvalue in double (simple) precision. If this check fails,
  it raises a ``ValueError``. Otherwise all negative eigenvalues that may
  remain are set to zero. This operation is traced with a
  ``PositiveSpectrumWarning`` when ``enable_warnings=True``.

Finally, all the positive eigenvalues that are too small (with a value
smaller than the maximum eigenvalue multiplied by 1e-12 (2e-7)) are set to
zero. This operation is traced with a ``PositiveSpectrumWarning`` when
``enable_warnings=True``.

Parameters
----------
lambdas : array-like of shape (n_eigenvalues,)
    Array of eigenvalues to check / fix.

enable_warnings : bool, default=False
    When this is set to ``True``, a ``PositiveSpectrumWarning`` will be
    raised when there are imaginary parts, negative eigenvalues, or
    extremely small non-zero eigenvalues. Otherwise no warning will be
    raised. In both cases, imaginary parts, negative eigenvalues, and
    extremely small non-zero eigenvalues will be set to zero.

Returns
-------
lambdas_fixed : ndarray of shape (n_eigenvalues,)
    A fixed validated copy of the array of eigenvalues.

Examples
--------
>>> from sklearn.utils.validation import _check_psd_eigenvalues
>>> _check_psd_eigenvalues([1, 2])      # nominal case
array([1, 2])
>>> _check_psd_eigenvalues([5, 5j])     # significant imag part
Traceback (most recent call last):
    ...
ValueError: There are significant imaginary parts in eigenvalues (1
    of the maximum real part). Either the matrix is not PSD, or there was
    an issue while computing the eigendecomposition of the matrix.
>>> _check_psd_eigenvalues([5, 5e-5j])  # insignificant imag part
array([5., 0.])
>>> _check_psd_eigenvalues([-5, -1])    # all negative
Traceback (most recent call last):
    ...
ValueError: All eigenvalues are negative (maximum is -1). Either the
    matrix is not PSD, or there was an issue while computing the
    eigendecomposition of the matrix.
>>> _check_psd_eigenvalues([5, -1])     # significant negative
Traceback (most recent call last):
    ...
ValueError: There are significant negative eigenvalues (0.2 of the
    maximum positive). Either the matrix is not PSD, or there was an issue
    while computing the eigendecomposition of the matrix.
>>> _check_psd_eigenvalues([5, -5e-5])  # insignificant negative
array([5., 0.])
>>> _check_psd_eigenvalues([5, 4e-12])  # bad conditioning (too small)
array([5., 0.])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{validation_8py_source_l01955}{1955}} of file \mbox{\hyperlink{validation_8py_source}{validation.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1validation_a9809ac2229fb1943aa1b5ddda2efb07e}\index{sklearn.utils.validation@{sklearn.utils.validation}!\_check\_response\_method@{\_check\_response\_method}}
\index{\_check\_response\_method@{\_check\_response\_method}!sklearn.utils.validation@{sklearn.utils.validation}}
\doxysubsubsection{\texorpdfstring{\_check\_response\_method()}{\_check\_response\_method()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1validation_a9809ac2229fb1943aa1b5ddda2efb07e} 
sklearn.\+utils.\+validation.\+\_\+check\+\_\+response\+\_\+method (\begin{DoxyParamCaption}\item[{}]{estimator}{, }\item[{}]{response\+\_\+method}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Check if `response_method` is available in estimator and return it.

.. versionadded:: 1.3

Parameters
----------
estimator : estimator instance
    Classifier or regressor to check.

response_method : {"predict_proba", "predict_log_proba", "decision_function",
        "predict"} or list of such str
    Specifies the response method to use get prediction from an estimator
    (i.e. :term:`predict_proba`, :term:`predict_log_proba`,
    :term:`decision_function` or :term:`predict`). Possible choices are:
    - if `str`, it corresponds to the name to the method to return;
    - if a list of `str`, it provides the method names in order of
      preference. The method returned corresponds to the first method in
      the list and which is implemented by `estimator`.

Returns
-------
prediction_method : callable
    Prediction method of estimator.

Raises
------
AttributeError
    If `response_method` is not available in `estimator`.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{validation_8py_source_l02248}{2248}} of file \mbox{\hyperlink{validation_8py_source}{validation.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1validation_ad44df9f942251b5a035fd0198bdeb494}\index{sklearn.utils.validation@{sklearn.utils.validation}!\_check\_sample\_weight@{\_check\_sample\_weight}}
\index{\_check\_sample\_weight@{\_check\_sample\_weight}!sklearn.utils.validation@{sklearn.utils.validation}}
\doxysubsubsection{\texorpdfstring{\_check\_sample\_weight()}{\_check\_sample\_weight()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1validation_ad44df9f942251b5a035fd0198bdeb494} 
sklearn.\+utils.\+validation.\+\_\+check\+\_\+sample\+\_\+weight (\begin{DoxyParamCaption}\item[{}]{sample\+\_\+weight}{, }\item[{}]{X}{, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{dtype}{ = {\ttfamily None}, }\item[{}]{ensure\+\_\+non\+\_\+negative}{ = {\ttfamily False}, }\item[{}]{copy}{ = {\ttfamily False}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Validate sample weights.

Note that passing sample_weight=None will output an array of ones.
Therefore, in some cases, you may want to protect the call with:
if sample_weight is not None:
    sample_weight = _check_sample_weight(...)

Parameters
----------
sample_weight : {ndarray, Number or None}, shape (n_samples,)
    Input sample weights.

X : {ndarray, list, sparse matrix}
    Input data.

dtype : dtype, default=None
    dtype of the validated `sample_weight`.
    If None, and `sample_weight` is an array:

        - If `sample_weight.dtype` is one of `{np.float64, np.float32}`,
          then the dtype is preserved.
        - Else the output has NumPy's default dtype: `np.float64`.

    If `dtype` is not `{np.float32, np.float64, None}`, then output will
    be `np.float64`.

ensure_non_negative : bool, default=False,
    Whether or not the weights are expected to be non-negative.

    .. versionadded:: 1.0

copy : bool, default=False
    If True, a copy of sample_weight will be created.

Returns
-------
sample_weight : ndarray of shape (n_samples,)
    Validated sample weight. It is guaranteed to be "C" contiguous.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{validation_8py_source_l02128}{2128}} of file \mbox{\hyperlink{validation_8py_source}{validation.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1validation_a72d745f985dadefe1bf3a15fb67d5243}\index{sklearn.utils.validation@{sklearn.utils.validation}!\_check\_y@{\_check\_y}}
\index{\_check\_y@{\_check\_y}!sklearn.utils.validation@{sklearn.utils.validation}}
\doxysubsubsection{\texorpdfstring{\_check\_y()}{\_check\_y()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1validation_a72d745f985dadefe1bf3a15fb67d5243} 
sklearn.\+utils.\+validation.\+\_\+check\+\_\+y (\begin{DoxyParamCaption}\item[{}]{y}{, }\item[{}]{multi\+\_\+output}{ = {\ttfamily False}, }\item[{}]{y\+\_\+numeric}{ = {\ttfamily False}, }\item[{}]{estimator}{ = {\ttfamily None}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Isolated part of check_X_y dedicated to y validation\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{validation_8py_source_l01392}{1392}} of file \mbox{\hyperlink{validation_8py_source}{validation.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1validation_abe091bbcfa11dee75d9f09734358ba06}\index{sklearn.utils.validation@{sklearn.utils.validation}!\_deprecate\_positional\_args@{\_deprecate\_positional\_args}}
\index{\_deprecate\_positional\_args@{\_deprecate\_positional\_args}!sklearn.utils.validation@{sklearn.utils.validation}}
\doxysubsubsection{\texorpdfstring{\_deprecate\_positional\_args()}{\_deprecate\_positional\_args()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1validation_abe091bbcfa11dee75d9f09734358ba06} 
sklearn.\+utils.\+validation.\+\_\+deprecate\+\_\+positional\+\_\+args (\begin{DoxyParamCaption}\item[{}]{func}{ = {\ttfamily None}, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{version}{ = {\ttfamily "{}1.3"{}}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Decorator for methods that issues warnings for positional arguments.

Using the keyword-only argument syntax in pep 3102, arguments after the
* will issue a warning when passed as a positional argument.

Parameters
----------
func : callable, default=None
    Function to check arguments on.
version : callable, default="1.3"
    The version when positional arguments will result in error.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{validation_8py_source_l00034}{34}} of file \mbox{\hyperlink{validation_8py_source}{validation.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1validation_aa634741aed9f3b17aad8a66b5577ec85}\index{sklearn.utils.validation@{sklearn.utils.validation}!\_ensure\_no\_complex\_data@{\_ensure\_no\_complex\_data}}
\index{\_ensure\_no\_complex\_data@{\_ensure\_no\_complex\_data}!sklearn.utils.validation@{sklearn.utils.validation}}
\doxysubsubsection{\texorpdfstring{\_ensure\_no\_complex\_data()}{\_ensure\_no\_complex\_data()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1validation_aa634741aed9f3b17aad8a66b5577ec85} 
sklearn.\+utils.\+validation.\+\_\+ensure\+\_\+no\+\_\+complex\+\_\+data (\begin{DoxyParamCaption}\item[{}]{array}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{validation_8py_source_l00671}{671}} of file \mbox{\hyperlink{validation_8py_source}{validation.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1validation_a7bbd2250a0acc922410c38f391c3183e}\index{sklearn.utils.validation@{sklearn.utils.validation}!\_ensure\_sparse\_format@{\_ensure\_sparse\_format}}
\index{\_ensure\_sparse\_format@{\_ensure\_sparse\_format}!sklearn.utils.validation@{sklearn.utils.validation}}
\doxysubsubsection{\texorpdfstring{\_ensure\_sparse\_format()}{\_ensure\_sparse\_format()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1validation_a7bbd2250a0acc922410c38f391c3183e} 
sklearn.\+utils.\+validation.\+\_\+ensure\+\_\+sparse\+\_\+format (\begin{DoxyParamCaption}\item[{}]{sparse\+\_\+container}{, }\item[{}]{accept\+\_\+sparse}{, }\item[{}]{dtype}{, }\item[{}]{copy}{, }\item[{}]{ensure\+\_\+all\+\_\+finite}{, }\item[{}]{accept\+\_\+large\+\_\+sparse}{, }\item[{}]{estimator\+\_\+name}{ = {\ttfamily None}, }\item[{}]{input\+\_\+name}{ = {\ttfamily "{}"{}}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Convert a sparse container to a given format.

Checks the sparse format of `sparse_container` and converts if necessary.

Parameters
----------
sparse_container : sparse matrix or array
    Input to validate and convert.

accept_sparse : str, bool or list/tuple of str
    String[s] representing allowed sparse matrix formats ('csc',
    'csr', 'coo', 'dok', 'bsr', 'lil', 'dia'). If the input is sparse but
    not in the allowed format, it will be converted to the first listed
    format. True allows the input to be any format. False means
    that a sparse matrix input will raise an error.

dtype : str, type or None
    Data type of result. If None, the dtype of the input is preserved.

copy : bool
    Whether a forced copy will be triggered. If copy=False, a copy might
    be triggered by a conversion.

ensure_all_finite : bool or 'allow-nan'
    Whether to raise an error on np.inf, np.nan, pd.NA in X. The
    possibilities are:

    - True: Force all values of X to be finite.
    - False: accepts np.inf, np.nan, pd.NA in X.
    - 'allow-nan': accepts only np.nan and pd.NA values in X. Values cannot
      be infinite.

    .. versionadded:: 0.20
       ``ensure_all_finite`` accepts the string ``'allow-nan'``.

    .. versionchanged:: 0.23
       Accepts `pd.NA` and converts it into `np.nan`


estimator_name : str, default=None
    The estimator name, used to construct the error message.

input_name : str, default=""
    The data name used to construct the error message. In particular
    if `input_name` is "X" and the data has NaN values and
    allow_nan is False, the error message will link to the imputer
    documentation.

Returns
-------
sparse_container_converted : sparse matrix or array
    Sparse container (matrix/array) that is ensured to have an allowed type.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{validation_8py_source_l00534}{534}} of file \mbox{\hyperlink{validation_8py_source}{validation.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1validation_afd6efcaecee86719959c8fbc198d525f}\index{sklearn.utils.validation@{sklearn.utils.validation}!\_estimator\_has@{\_estimator\_has}}
\index{\_estimator\_has@{\_estimator\_has}!sklearn.utils.validation@{sklearn.utils.validation}}
\doxysubsubsection{\texorpdfstring{\_estimator\_has()}{\_estimator\_has()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1validation_afd6efcaecee86719959c8fbc198d525f} 
sklearn.\+utils.\+validation.\+\_\+estimator\+\_\+has (\begin{DoxyParamCaption}\item[{}]{attr}{, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{delegates}{ = {\ttfamily ("{}estimator\+\_\+"{},~"{}estimator"{})}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Check if we can delegate a method to the underlying estimator.

We check the `delegates` in the order they are passed. By default, we first check
the fitted estimator if available, otherwise we check the unfitted estimator.

Parameters
----------
attr : str
    Name of the attribute the delegate might or might not have.

delegates: tuple of str, default=("estimator_", "estimator")
    A tuple of sub-estimator(s) to check if we can delegate the `attr` method.

Returns
-------
check : function
    Function to check if the delegate has the attribute.

Raises
------
ValueError
    Raised when none of the delegates are present in the object.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{validation_8py_source_l01757}{1757}} of file \mbox{\hyperlink{validation_8py_source}{validation.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1validation_a64c81bffff5d7bcec77445438cdfaa82}\index{sklearn.utils.validation@{sklearn.utils.validation}!\_generate\_get\_feature\_names\_out@{\_generate\_get\_feature\_names\_out}}
\index{\_generate\_get\_feature\_names\_out@{\_generate\_get\_feature\_names\_out}!sklearn.utils.validation@{sklearn.utils.validation}}
\doxysubsubsection{\texorpdfstring{\_generate\_get\_feature\_names\_out()}{\_generate\_get\_feature\_names\_out()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1validation_a64c81bffff5d7bcec77445438cdfaa82} 
sklearn.\+utils.\+validation.\+\_\+generate\+\_\+get\+\_\+feature\+\_\+names\+\_\+out (\begin{DoxyParamCaption}\item[{}]{estimator}{, }\item[{}]{n\+\_\+features\+\_\+out}{, }\item[{}]{input\+\_\+features}{ = {\ttfamily None}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Generate feature names out for estimator using the estimator name as the prefix.

The input_feature names are validated but not used. This function is useful
for estimators that generate their own names based on `n_features_out`, i.e. PCA.

Parameters
----------
estimator : estimator instance
    Estimator producing output feature names.

n_feature_out : int
    Number of feature names out.

input_features : array-like of str or None, default=None
    Only used to validate feature names with `estimator.feature_names_in_`.

Returns
-------
feature_names_in : ndarray of str or `None`
    Feature names in.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{validation_8py_source_l02500}{2500}} of file \mbox{\hyperlink{validation_8py_source}{validation.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1validation_aa403f42854f5a6a64e52a464b347c9f7}\index{sklearn.utils.validation@{sklearn.utils.validation}!\_get\_feature\_names@{\_get\_feature\_names}}
\index{\_get\_feature\_names@{\_get\_feature\_names}!sklearn.utils.validation@{sklearn.utils.validation}}
\doxysubsubsection{\texorpdfstring{\_get\_feature\_names()}{\_get\_feature\_names()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1validation_aa403f42854f5a6a64e52a464b347c9f7} 
sklearn.\+utils.\+validation.\+\_\+get\+\_\+feature\+\_\+names (\begin{DoxyParamCaption}\item[{}]{X}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Get feature names from X.

Support for other array containers should place its implementation here.

Parameters
----------
X : {ndarray, dataframe} of shape (n_samples, n_features)
    Array container to extract feature names.

    - pandas dataframe : The columns will be considered to be feature
      names. If the dataframe contains non-string feature names, `None` is
      returned.
    - All other array containers will return `None`.

Returns
-------
names: ndarray or None
    Feature names of `X`. Unrecognized array containers will return `None`.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{validation_8py_source_l02380}{2380}} of file \mbox{\hyperlink{validation_8py_source}{validation.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1validation_a7a74c4bdbb9185e056d4db94a4321d4b}\index{sklearn.utils.validation@{sklearn.utils.validation}!\_is\_arraylike@{\_is\_arraylike}}
\index{\_is\_arraylike@{\_is\_arraylike}!sklearn.utils.validation@{sklearn.utils.validation}}
\doxysubsubsection{\texorpdfstring{\_is\_arraylike()}{\_is\_arraylike()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1validation_a7a74c4bdbb9185e056d4db94a4321d4b} 
sklearn.\+utils.\+validation.\+\_\+is\+\_\+arraylike (\begin{DoxyParamCaption}\item[{}]{x}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Returns whether the input is array-like.\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{validation_8py_source_l00305}{305}} of file \mbox{\hyperlink{validation_8py_source}{validation.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1validation_a4af048955280074c9ef7215354038a2d}\index{sklearn.utils.validation@{sklearn.utils.validation}!\_is\_arraylike\_not\_scalar@{\_is\_arraylike\_not\_scalar}}
\index{\_is\_arraylike\_not\_scalar@{\_is\_arraylike\_not\_scalar}!sklearn.utils.validation@{sklearn.utils.validation}}
\doxysubsubsection{\texorpdfstring{\_is\_arraylike\_not\_scalar()}{\_is\_arraylike\_not\_scalar()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1validation_a4af048955280074c9ef7215354038a2d} 
sklearn.\+utils.\+validation.\+\_\+is\+\_\+arraylike\+\_\+not\+\_\+scalar (\begin{DoxyParamCaption}\item[{}]{array}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Return True if array is array-like and not a scalar\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{validation_8py_source_l00313}{313}} of file \mbox{\hyperlink{validation_8py_source}{validation.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1validation_a813ca16fbd15d66e3d13413f2b76c6b9}\index{sklearn.utils.validation@{sklearn.utils.validation}!\_is\_extension\_array\_dtype@{\_is\_extension\_array\_dtype}}
\index{\_is\_extension\_array\_dtype@{\_is\_extension\_array\_dtype}!sklearn.utils.validation@{sklearn.utils.validation}}
\doxysubsubsection{\texorpdfstring{\_is\_extension\_array\_dtype()}{\_is\_extension\_array\_dtype()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1validation_a813ca16fbd15d66e3d13413f2b76c6b9} 
sklearn.\+utils.\+validation.\+\_\+is\+\_\+extension\+\_\+array\+\_\+dtype (\begin{DoxyParamCaption}\item[{}]{array}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{validation_8py_source_l00729}{729}} of file \mbox{\hyperlink{validation_8py_source}{validation.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1validation_a84937074a30f440ac2c5b3d5b2988a24}\index{sklearn.utils.validation@{sklearn.utils.validation}!\_is\_fitted@{\_is\_fitted}}
\index{\_is\_fitted@{\_is\_fitted}!sklearn.utils.validation@{sklearn.utils.validation}}
\doxysubsubsection{\texorpdfstring{\_is\_fitted()}{\_is\_fitted()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1validation_a84937074a30f440ac2c5b3d5b2988a24} 
sklearn.\+utils.\+validation.\+\_\+is\+\_\+fitted (\begin{DoxyParamCaption}\item[{}]{estimator}{, }\item[{}]{attributes}{ = {\ttfamily None}, }\item[{}]{all\+\_\+or\+\_\+any}{ = {\ttfamily all}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Determine if an estimator is fitted

Parameters
----------
estimator : estimator instance
    Estimator instance for which the check is performed.

attributes : str, list or tuple of str, default=None
    Attribute name(s) given as string or a list/tuple of strings
    Eg.: ``["coef_", "estimator_", ...], "coef_"``

    If `None`, `estimator` is considered fitted if there exist an
    attribute that ends with a underscore and does not start with double
    underscore.

all_or_any : callable, {all, any}, default=all
    Specify whether all or any of the given attributes must exist.

Returns
-------
fitted : bool
    Whether the estimator is fitted.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{validation_8py_source_l01632}{1632}} of file \mbox{\hyperlink{validation_8py_source}{validation.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1validation_a79cd19779b80d9bfc5e8a5b48bcdd6a7}\index{sklearn.utils.validation@{sklearn.utils.validation}!\_is\_pandas\_df@{\_is\_pandas\_df}}
\index{\_is\_pandas\_df@{\_is\_pandas\_df}!sklearn.utils.validation@{sklearn.utils.validation}}
\doxysubsubsection{\texorpdfstring{\_is\_pandas\_df()}{\_is\_pandas\_df()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1validation_a79cd19779b80d9bfc5e8a5b48bcdd6a7} 
sklearn.\+utils.\+validation.\+\_\+is\+\_\+pandas\+\_\+df (\begin{DoxyParamCaption}\item[{}]{X}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Return True if the X is a pandas dataframe.\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{validation_8py_source_l02344}{2344}} of file \mbox{\hyperlink{validation_8py_source}{validation.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1validation_a956da2cc04560c5662207ecaf6306068}\index{sklearn.utils.validation@{sklearn.utils.validation}!\_is\_pandas\_df\_or\_series@{\_is\_pandas\_df\_or\_series}}
\index{\_is\_pandas\_df\_or\_series@{\_is\_pandas\_df\_or\_series}!sklearn.utils.validation@{sklearn.utils.validation}}
\doxysubsubsection{\texorpdfstring{\_is\_pandas\_df\_or\_series()}{\_is\_pandas\_df\_or\_series()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1validation_a956da2cc04560c5662207ecaf6306068} 
sklearn.\+utils.\+validation.\+\_\+is\+\_\+pandas\+\_\+df\+\_\+or\+\_\+series (\begin{DoxyParamCaption}\item[{}]{X}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Return True if the X is a pandas dataframe or series.\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{validation_8py_source_l02335}{2335}} of file \mbox{\hyperlink{validation_8py_source}{validation.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1validation_afda1b404469e131a843ce583def0a3cb}\index{sklearn.utils.validation@{sklearn.utils.validation}!\_is\_polars\_df@{\_is\_polars\_df}}
\index{\_is\_polars\_df@{\_is\_polars\_df}!sklearn.utils.validation@{sklearn.utils.validation}}
\doxysubsubsection{\texorpdfstring{\_is\_polars\_df()}{\_is\_polars\_df()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1validation_afda1b404469e131a843ce583def0a3cb} 
sklearn.\+utils.\+validation.\+\_\+is\+\_\+polars\+\_\+df (\begin{DoxyParamCaption}\item[{}]{X}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Return True if the X is a polars dataframe.\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{validation_8py_source_l02371}{2371}} of file \mbox{\hyperlink{validation_8py_source}{validation.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1validation_a40a86441602757c56accc1fa021ff241}\index{sklearn.utils.validation@{sklearn.utils.validation}!\_is\_polars\_df\_or\_series@{\_is\_polars\_df\_or\_series}}
\index{\_is\_polars\_df\_or\_series@{\_is\_polars\_df\_or\_series}!sklearn.utils.validation@{sklearn.utils.validation}}
\doxysubsubsection{\texorpdfstring{\_is\_polars\_df\_or\_series()}{\_is\_polars\_df\_or\_series()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1validation_a40a86441602757c56accc1fa021ff241} 
sklearn.\+utils.\+validation.\+\_\+is\+\_\+polars\+\_\+df\+\_\+or\+\_\+series (\begin{DoxyParamCaption}\item[{}]{X}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Return True if the X is a polars dataframe or series.\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{validation_8py_source_l02362}{2362}} of file \mbox{\hyperlink{validation_8py_source}{validation.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1validation_ab52eb389fd907bf97c7d91cb8d31644b}\index{sklearn.utils.validation@{sklearn.utils.validation}!\_is\_pyarrow\_data@{\_is\_pyarrow\_data}}
\index{\_is\_pyarrow\_data@{\_is\_pyarrow\_data}!sklearn.utils.validation@{sklearn.utils.validation}}
\doxysubsubsection{\texorpdfstring{\_is\_pyarrow\_data()}{\_is\_pyarrow\_data()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1validation_ab52eb389fd907bf97c7d91cb8d31644b} 
sklearn.\+utils.\+validation.\+\_\+is\+\_\+pyarrow\+\_\+data (\begin{DoxyParamCaption}\item[{}]{X}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Return True if the X is a pyarrow Table, RecordBatch, Array or ChunkedArray.\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{validation_8py_source_l02353}{2353}} of file \mbox{\hyperlink{validation_8py_source}{validation.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1validation_a7550ba455fda84a6ace62242d3b0dc70}\index{sklearn.utils.validation@{sklearn.utils.validation}!\_make\_indexable@{\_make\_indexable}}
\index{\_make\_indexable@{\_make\_indexable}!sklearn.utils.validation@{sklearn.utils.validation}}
\doxysubsubsection{\texorpdfstring{\_make\_indexable()}{\_make\_indexable()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1validation_a7550ba455fda84a6ace62242d3b0dc70} 
sklearn.\+utils.\+validation.\+\_\+make\+\_\+indexable (\begin{DoxyParamCaption}\item[{}]{iterable}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Ensure iterable supports indexing or convert to an indexable variant.

Convert sparse matrices to csr and other non-indexable iterable to arrays.
Let `None` and indexable objects (e.g. pandas dataframes) pass unchanged.

Parameters
----------
iterable : {list, dataframe, ndarray, sparse matrix} or None
    Object to be converted to an indexable iterable.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{validation_8py_source_l00479}{479}} of file \mbox{\hyperlink{validation_8py_source}{validation.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1validation_aeac633479b1dc831cf7ed4e7b59ad364}\index{sklearn.utils.validation@{sklearn.utils.validation}!\_num\_features@{\_num\_features}}
\index{\_num\_features@{\_num\_features}!sklearn.utils.validation@{sklearn.utils.validation}}
\doxysubsubsection{\texorpdfstring{\_num\_features()}{\_num\_features()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1validation_aeac633479b1dc831cf7ed4e7b59ad364} 
sklearn.\+utils.\+validation.\+\_\+num\+\_\+features (\begin{DoxyParamCaption}\item[{}]{X}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Return the number of features in an array-like X.

This helper function tries hard to avoid to materialize an array version
of X unless necessary. For instance, if X is a list of lists,
this function will return the length of the first element, assuming
that subsequent elements are all lists of the same length without
checking.
Parameters
----------
X : array-like
    array-like to get the number of features.

Returns
-------
features : int
    Number of features
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{validation_8py_source_l00328}{328}} of file \mbox{\hyperlink{validation_8py_source}{validation.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1validation_a2f819616f9cf7c4a803a684bb783bdfe}\index{sklearn.utils.validation@{sklearn.utils.validation}!\_num\_samples@{\_num\_samples}}
\index{\_num\_samples@{\_num\_samples}!sklearn.utils.validation@{sklearn.utils.validation}}
\doxysubsubsection{\texorpdfstring{\_num\_samples()}{\_num\_samples()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1validation_a2f819616f9cf7c4a803a684bb783bdfe} 
sklearn.\+utils.\+validation.\+\_\+num\+\_\+samples (\begin{DoxyParamCaption}\item[{}]{x}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Return number of samples in array-like x.\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{validation_8py_source_l00381}{381}} of file \mbox{\hyperlink{validation_8py_source}{validation.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1validation_a0ebca20e325263d762622596fa7b1bac}\index{sklearn.utils.validation@{sklearn.utils.validation}!\_pandas\_dtype\_needs\_early\_conversion@{\_pandas\_dtype\_needs\_early\_conversion}}
\index{\_pandas\_dtype\_needs\_early\_conversion@{\_pandas\_dtype\_needs\_early\_conversion}!sklearn.utils.validation@{sklearn.utils.validation}}
\doxysubsubsection{\texorpdfstring{\_pandas\_dtype\_needs\_early\_conversion()}{\_pandas\_dtype\_needs\_early\_conversion()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1validation_a0ebca20e325263d762622596fa7b1bac} 
sklearn.\+utils.\+validation.\+\_\+pandas\+\_\+dtype\+\_\+needs\+\_\+early\+\_\+conversion (\begin{DoxyParamCaption}\item[{}]{pd\+\_\+dtype}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Return True if pandas extension pd_dtype need to be converted early.\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{validation_8py_source_l00690}{690}} of file \mbox{\hyperlink{validation_8py_source}{validation.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1validation_a199e87942398a6087bcf123d40b26e5a}\index{sklearn.utils.validation@{sklearn.utils.validation}!\_to\_object\_array@{\_to\_object\_array}}
\index{\_to\_object\_array@{\_to\_object\_array}!sklearn.utils.validation@{sklearn.utils.validation}}
\doxysubsubsection{\texorpdfstring{\_to\_object\_array()}{\_to\_object\_array()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1validation_a199e87942398a6087bcf123d40b26e5a} 
sklearn.\+utils.\+validation.\+\_\+to\+\_\+object\+\_\+array (\begin{DoxyParamCaption}\item[{}]{sequence}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Convert sequence to a 1-D NumPy array of object dtype.

numpy.array constructor has a similar use but it's output
is ambiguous. It can be 1-D NumPy array of object dtype if
the input is a ragged array, but if the input is a list of
equal length arrays, then the output is a 2D numpy.array.
_to_object_array solves this ambiguity by guarantying that
the output is a 1-D NumPy array of objects for any input.

Parameters
----------
sequence : array-like of shape (n_elements,)
    The sequence to be converted.

Returns
-------
out : ndarray of shape (n_elements,), dtype=object
    The converted sequence into a 1-D NumPy array of object dtype.

Examples
--------
>>> import numpy as np
>>> from sklearn.utils.validation import _to_object_array
>>> _to_object_array([np.array([0]), np.array([1])])
array([array([0]), array([1])], dtype=object)
>>> _to_object_array([np.array([0]), np.array([1, 2])])
array([array([0]), array([1, 2])], dtype=object)
>>> _to_object_array([np.array([0]), np.array([1, 2])])
array([array([0]), array([1, 2])], dtype=object)
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{validation_8py_source_l02661}{2661}} of file \mbox{\hyperlink{validation_8py_source}{validation.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1validation_af575c1c3759d1f79358f4b6b9351c1a8}\index{sklearn.utils.validation@{sklearn.utils.validation}!\_use\_interchange\_protocol@{\_use\_interchange\_protocol}}
\index{\_use\_interchange\_protocol@{\_use\_interchange\_protocol}!sklearn.utils.validation@{sklearn.utils.validation}}
\doxysubsubsection{\texorpdfstring{\_use\_interchange\_protocol()}{\_use\_interchange\_protocol()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1validation_af575c1c3759d1f79358f4b6b9351c1a8} 
sklearn.\+utils.\+validation.\+\_\+use\+\_\+interchange\+\_\+protocol (\begin{DoxyParamCaption}\item[{}]{X}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Use interchange protocol for non-pandas dataframes that follow the protocol.

Note: at this point we chose not to use the interchange API on pandas dataframe
to ensure strict behavioral backward compatibility with older versions of
scikit-learn.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{validation_8py_source_l00318}{318}} of file \mbox{\hyperlink{validation_8py_source}{validation.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1validation_a5f02a39543658ecec278249bfd2ff295}\index{sklearn.utils.validation@{sklearn.utils.validation}!as\_float\_array@{as\_float\_array}}
\index{as\_float\_array@{as\_float\_array}!sklearn.utils.validation@{sklearn.utils.validation}}
\doxysubsubsection{\texorpdfstring{as\_float\_array()}{as\_float\_array()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1validation_a5f02a39543658ecec278249bfd2ff295} 
sklearn.\+utils.\+validation.\+as\+\_\+float\+\_\+array (\begin{DoxyParamCaption}\item[{}]{X}{, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{copy}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}, }\item[{}]{force\+\_\+all\+\_\+finite}{ = {\ttfamily "{}deprecated"{}}, }\item[{}]{ensure\+\_\+all\+\_\+finite}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Convert an array-like to an array of floats.

The new dtype will be np.float32 or np.float64, depending on the original
type. The function can create a copy or modify the argument depending
on the argument copy.

Parameters
----------
X : {array-like, sparse matrix}
    The input data.

copy : bool, default=True
    If True, a copy of X will be created. If False, a copy may still be
    returned if X's dtype is not a floating point type.

force_all_finite : bool or 'allow-nan', default=True
    Whether to raise an error on np.inf, np.nan, pd.NA in X. The
    possibilities are:

    - True: Force all values of X to be finite.
    - False: accepts np.inf, np.nan, pd.NA in X.
    - 'allow-nan': accepts only np.nan and pd.NA values in X. Values cannot
      be infinite.

    .. versionadded:: 0.20
       ``force_all_finite`` accepts the string ``'allow-nan'``.

    .. versionchanged:: 0.23
       Accepts `pd.NA` and converts it into `np.nan`

    .. deprecated:: 1.6
       `force_all_finite` was renamed to `ensure_all_finite` and will be removed
       in 1.8.

ensure_all_finite : bool or 'allow-nan', default=True
    Whether to raise an error on np.inf, np.nan, pd.NA in X. The
    possibilities are:

    - True: Force all values of X to be finite.
    - False: accepts np.inf, np.nan, pd.NA in X.
    - 'allow-nan': accepts only np.nan and pd.NA values in X. Values cannot
      be infinite.

    .. versionadded:: 1.6
       `force_all_finite` was renamed to `ensure_all_finite`.

Returns
-------
XT : {ndarray, sparse matrix}
    An array of type float.

Examples
--------
>>> from sklearn.utils import as_float_array
>>> import numpy as np
>>> array = np.array([0, 0, 1, 2, 2], dtype=np.int64)
>>> as_float_array(array)
array([0., 0., 1., 2., 2.])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{validation_8py_source_l00218}{218}} of file \mbox{\hyperlink{validation_8py_source}{validation.\+py}}.



References \mbox{\hyperlink{validation_8py_source_l00752}{check\+\_\+array()}}.

\Hypertarget{namespacesklearn_1_1utils_1_1validation_a2a054b849a7a3d0305a234790e68bbf9}\index{sklearn.utils.validation@{sklearn.utils.validation}!assert\_all\_finite@{assert\_all\_finite}}
\index{assert\_all\_finite@{assert\_all\_finite}!sklearn.utils.validation@{sklearn.utils.validation}}
\doxysubsubsection{\texorpdfstring{assert\_all\_finite()}{assert\_all\_finite()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1validation_a2a054b849a7a3d0305a234790e68bbf9} 
sklearn.\+utils.\+validation.\+assert\+\_\+all\+\_\+finite (\begin{DoxyParamCaption}\item[{}]{X}{, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{allow\+\_\+nan}{ = {\ttfamily False}, }\item[{}]{estimator\+\_\+name}{ = {\ttfamily None}, }\item[{}]{input\+\_\+name}{ = {\ttfamily "{}"{}}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Throw a ValueError if X contains NaN or infinity.

Parameters
----------
X : {ndarray, sparse matrix}
    The input data.

allow_nan : bool, default=False
    If True, do not throw error when `X` contains NaN.

estimator_name : str, default=None
    The estimator name, used to construct the error message.

input_name : str, default=""
    The data name used to construct the error message. In particular
    if `input_name` is "X" and the data has NaN values and
    allow_nan is False, the error message will link to the imputer
    documentation.

Examples
--------
>>> from sklearn.utils import assert_all_finite
>>> import numpy as np
>>> array = np.array([1, np.inf, np.nan, 4])
>>> try:
...     assert_all_finite(array)
...     print("Test passed: Array contains only finite values.")
... except ValueError:
...     print("Test failed: Array contains non-finite values.")
Test failed: Array contains non-finite values.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{validation_8py_source_l00172}{172}} of file \mbox{\hyperlink{validation_8py_source}{validation.\+py}}.



References \mbox{\hyperlink{validation_8py_source_l00092}{\+\_\+assert\+\_\+all\+\_\+finite()}}.

\Hypertarget{namespacesklearn_1_1utils_1_1validation_a828c5472410043c1260586dcc5c2d4af}\index{sklearn.utils.validation@{sklearn.utils.validation}!check\_array@{check\_array}}
\index{check\_array@{check\_array}!sklearn.utils.validation@{sklearn.utils.validation}}
\doxysubsubsection{\texorpdfstring{check\_array()}{check\_array()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1validation_a828c5472410043c1260586dcc5c2d4af} 
sklearn.\+utils.\+validation.\+check\+\_\+array (\begin{DoxyParamCaption}\item[{}]{array}{, }\item[{}]{accept\+\_\+sparse}{ = {\ttfamily False}, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{accept\+\_\+large\+\_\+sparse}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}, }\item[{}]{dtype}{ = {\ttfamily "{}numeric"{}}, }\item[{}]{order}{ = {\ttfamily None}, }\item[{}]{copy}{ = {\ttfamily False}, }\item[{}]{force\+\_\+writeable}{ = {\ttfamily False}, }\item[{}]{force\+\_\+all\+\_\+finite}{ = {\ttfamily "{}deprecated"{}}, }\item[{}]{ensure\+\_\+all\+\_\+finite}{ = {\ttfamily None}, }\item[{}]{ensure\+\_\+non\+\_\+negative}{ = {\ttfamily False}, }\item[{}]{ensure\+\_\+2d}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}, }\item[{}]{allow\+\_\+nd}{ = {\ttfamily False}, }\item[{}]{ensure\+\_\+min\+\_\+samples}{ = {\ttfamily 1}, }\item[{}]{ensure\+\_\+min\+\_\+features}{ = {\ttfamily 1}, }\item[{}]{estimator}{ = {\ttfamily None}, }\item[{}]{input\+\_\+name}{ = {\ttfamily "{}"{}}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Input validation on an array, list, sparse matrix or similar.

By default, the input is checked to be a non-empty 2D array containing
only finite values. If the dtype of the array is object, attempt
converting to float, raising on failure.

Parameters
----------
array : object
    Input object to check / convert.

accept_sparse : str, bool or list/tuple of str, default=False
    String[s] representing allowed sparse matrix formats, such as 'csc',
    'csr', etc. If the input is sparse but not in the allowed format,
    it will be converted to the first listed format. True allows the input
    to be any format. False means that a sparse matrix input will
    raise an error.

accept_large_sparse : bool, default=True
    If a CSR, CSC, COO or BSR sparse matrix is supplied and accepted by
    accept_sparse, accept_large_sparse=False will cause it to be accepted
    only if its indices are stored with a 32-bit dtype.

    .. versionadded:: 0.20

dtype : 'numeric', type, list of type or None, default='numeric'
    Data type of result. If None, the dtype of the input is preserved.
    If "numeric", dtype is preserved unless array.dtype is object.
    If dtype is a list of types, conversion on the first type is only
    performed if the dtype of the input is not in the list.

order : {'F', 'C'} or None, default=None
    Whether an array will be forced to be fortran or c-style.
    When order is None (default), then if copy=False, nothing is ensured
    about the memory layout of the output array; otherwise (copy=True)
    the memory layout of the returned array is kept as close as possible
    to the original array.

copy : bool, default=False
    Whether a forced copy will be triggered. If copy=False, a copy might
    be triggered by a conversion.

force_writeable : bool, default=False
    Whether to force the output array to be writeable. If True, the returned array
    is guaranteed to be writeable, which may require a copy. Otherwise the
    writeability of the input array is preserved.

    .. versionadded:: 1.6

force_all_finite : bool or 'allow-nan', default=True
    Whether to raise an error on np.inf, np.nan, pd.NA in array. The
    possibilities are:

    - True: Force all values of array to be finite.
    - False: accepts np.inf, np.nan, pd.NA in array.
    - 'allow-nan': accepts only np.nan and pd.NA values in array. Values
      cannot be infinite.

    .. versionadded:: 0.20
       ``force_all_finite`` accepts the string ``'allow-nan'``.

    .. versionchanged:: 0.23
       Accepts `pd.NA` and converts it into `np.nan`

    .. deprecated:: 1.6
       `force_all_finite` was renamed to `ensure_all_finite` and will be removed
       in 1.8.

ensure_all_finite : bool or 'allow-nan', default=True
    Whether to raise an error on np.inf, np.nan, pd.NA in array. The
    possibilities are:

    - True: Force all values of array to be finite.
    - False: accepts np.inf, np.nan, pd.NA in array.
    - 'allow-nan': accepts only np.nan and pd.NA values in array. Values
      cannot be infinite.

    .. versionadded:: 1.6
       `force_all_finite` was renamed to `ensure_all_finite`.

ensure_non_negative : bool, default=False
    Make sure the array has only non-negative values. If True, an array that
    contains negative values will raise a ValueError.

    .. versionadded:: 1.6

ensure_2d : bool, default=True
    Whether to raise a value error if array is not 2D.

allow_nd : bool, default=False
    Whether to allow array.ndim > 2.

ensure_min_samples : int, default=1
    Make sure that the array has a minimum number of samples in its first
    axis (rows for a 2D array). Setting to 0 disables this check.

ensure_min_features : int, default=1
    Make sure that the 2D array has some minimum number of features
    (columns). The default value of 1 rejects empty datasets.
    This check is only enforced when the input data has effectively 2
    dimensions or is originally 1D and ``ensure_2d`` is True. Setting to 0
    disables this check.

estimator : str or estimator instance, default=None
    If passed, include the name of the estimator in warning messages.

input_name : str, default=""
    The data name used to construct the error message. In particular
    if `input_name` is "X" and the data has NaN values and
    allow_nan is False, the error message will link to the imputer
    documentation.

    .. versionadded:: 1.1.0

Returns
-------
array_converted : object
    The converted and validated array.

Examples
--------
>>> from sklearn.utils.validation import check_array
>>> X = [[1, 2, 3], [4, 5, 6]]
>>> X_checked = check_array(X)
>>> X_checked
array([[1, 2, 3], [4, 5, 6]])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{validation_8py_source_l00734}{734}} of file \mbox{\hyperlink{validation_8py_source}{validation.\+py}}.



Referenced by \mbox{\hyperlink{validation_8py_source_l00220}{as\+\_\+float\+\_\+array()}}.

\Hypertarget{namespacesklearn_1_1utils_1_1validation_a3d76ca8a780f1b9df7f975d307e28dc8}\index{sklearn.utils.validation@{sklearn.utils.validation}!check\_consistent\_length@{check\_consistent\_length}}
\index{check\_consistent\_length@{check\_consistent\_length}!sklearn.utils.validation@{sklearn.utils.validation}}
\doxysubsubsection{\texorpdfstring{check\_consistent\_length()}{check\_consistent\_length()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1validation_a3d76ca8a780f1b9df7f975d307e28dc8} 
sklearn.\+utils.\+validation.\+check\+\_\+consistent\+\_\+length (\begin{DoxyParamCaption}\item[{\texorpdfstring{$\ast$}{*}}]{arrays}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Check that all arrays have consistent first dimensions.

Checks whether all objects in arrays have the same shape or length.

Parameters
----------
*arrays : list or tuple of input objects.
    Objects that will be checked for consistent length.

Examples
--------
>>> from sklearn.utils.validation import check_consistent_length
>>> a = [1, 2, 3]
>>> b = [2, 3, 4]
>>> check_consistent_length(a, b)
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{validation_8py_source_l00454}{454}} of file \mbox{\hyperlink{validation_8py_source}{validation.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1validation_a7ac4afdc8943b77f8813c63dd98daf32}\index{sklearn.utils.validation@{sklearn.utils.validation}!check\_is\_fitted@{check\_is\_fitted}}
\index{check\_is\_fitted@{check\_is\_fitted}!sklearn.utils.validation@{sklearn.utils.validation}}
\doxysubsubsection{\texorpdfstring{check\_is\_fitted()}{check\_is\_fitted()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1validation_a7ac4afdc8943b77f8813c63dd98daf32} 
sklearn.\+utils.\+validation.\+check\+\_\+is\+\_\+fitted (\begin{DoxyParamCaption}\item[{}]{estimator}{, }\item[{}]{attributes}{ = {\ttfamily None}, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{msg}{ = {\ttfamily None}, }\item[{}]{all\+\_\+or\+\_\+any}{ = {\ttfamily all}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Perform is_fitted validation for estimator.

Checks if the estimator is fitted by verifying the presence of
fitted attributes (ending with a trailing underscore) and otherwise
raises a :class:`~sklearn.exceptions.NotFittedError` with the given message.

If an estimator does not set any attributes with a trailing underscore, it
can define a ``__sklearn_is_fitted__`` method returning a boolean to
specify if the estimator is fitted or not. See
:ref:`sphx_glr_auto_examples_developing_estimators_sklearn_is_fitted.py`
for an example on how to use the API.

If no `attributes` are passed, this function will pass if an estimator is stateless.
An estimator can indicate it's stateless by setting the `requires_fit` tag. See
:ref:`estimator_tags` for more information. Note that the `requires_fit` tag
is ignored if `attributes` are passed.

Parameters
----------
estimator : estimator instance
    Estimator instance for which the check is performed.

attributes : str, list or tuple of str, default=None
    Attribute name(s) given as string or a list/tuple of strings
    Eg.: ``["coef_", "estimator_", ...], "coef_"``

    If `None`, `estimator` is considered fitted if there exist an
    attribute that ends with a underscore and does not start with double
    underscore.

msg : str, default=None
    The default error message is, "This %(name)s instance is not fitted
    yet. Call 'fit' with appropriate arguments before using this
    estimator."

    For custom messages if "%(name)s" is present in the message string,
    it is substituted for the estimator name.

    Eg. : "Estimator, %(name)s, must be fitted before sparsifying".

all_or_any : callable, {all, any}, default=all
    Specify whether all or any of the given attributes must exist.

Raises
------
TypeError
    If the estimator is a class or not an estimator instance

NotFittedError
    If the attributes are not found.

Examples
--------
>>> from sklearn.linear_model import LogisticRegression
>>> from sklearn.utils.validation import check_is_fitted
>>> from sklearn.exceptions import NotFittedError
>>> lr = LogisticRegression()
>>> try:
...     check_is_fitted(lr)
... except NotFittedError as exc:
...     print(f"Model is not fitted yet.")
Model is not fitted yet.
>>> lr.fit([[1, 2], [1, 3]], [1, 0])
LogisticRegression()
>>> check_is_fitted(lr)
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{validation_8py_source_l01670}{1670}} of file \mbox{\hyperlink{validation_8py_source}{validation.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1validation_ab472519c2e841a2531e0a8dc3b9fbd64}\index{sklearn.utils.validation@{sklearn.utils.validation}!check\_memory@{check\_memory}}
\index{check\_memory@{check\_memory}!sklearn.utils.validation@{sklearn.utils.validation}}
\doxysubsubsection{\texorpdfstring{check\_memory()}{check\_memory()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1validation_ab472519c2e841a2531e0a8dc3b9fbd64} 
sklearn.\+utils.\+validation.\+check\+\_\+memory (\begin{DoxyParamCaption}\item[{}]{memory}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Check that ``memory`` is joblib.Memory-like.

joblib.Memory-like means that ``memory`` can be converted into a
joblib.Memory instance (typically a str denoting the ``location``)
or has the same interface (has a ``cache`` method).

Parameters
----------
memory : None, str or object with the joblib.Memory interface
    - If string, the location where to create the `joblib.Memory` interface.
    - If None, no caching is done and the Memory object is completely transparent.

Returns
-------
memory : object with the joblib.Memory interface
    A correct joblib.Memory object.

Raises
------
ValueError
    If ``memory`` is not joblib.Memory-like.

Examples
--------
>>> from sklearn.utils.validation import check_memory
>>> check_memory("caching_dir")
Memory(location=caching_dir/joblib)
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{validation_8py_source_l00414}{414}} of file \mbox{\hyperlink{validation_8py_source}{validation.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1validation_a219a80672df078db2c451d95db8833ee}\index{sklearn.utils.validation@{sklearn.utils.validation}!check\_non\_negative@{check\_non\_negative}}
\index{check\_non\_negative@{check\_non\_negative}!sklearn.utils.validation@{sklearn.utils.validation}}
\doxysubsubsection{\texorpdfstring{check\_non\_negative()}{check\_non\_negative()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1validation_a219a80672df078db2c451d95db8833ee} 
sklearn.\+utils.\+validation.\+check\+\_\+non\+\_\+negative (\begin{DoxyParamCaption}\item[{}]{X}{, }\item[{}]{whom}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Check if there is any negative value in an array.

Parameters
----------
X : {array-like, sparse matrix}
    Input data.

whom : str
    Who passed X to this function.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{validation_8py_source_l01799}{1799}} of file \mbox{\hyperlink{validation_8py_source}{validation.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1validation_a02e9f59100d50fa74df40218a4de1471}\index{sklearn.utils.validation@{sklearn.utils.validation}!check\_random\_state@{check\_random\_state}}
\index{check\_random\_state@{check\_random\_state}!sklearn.utils.validation@{sklearn.utils.validation}}
\doxysubsubsection{\texorpdfstring{check\_random\_state()}{check\_random\_state()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1validation_a02e9f59100d50fa74df40218a4de1471} 
sklearn.\+utils.\+validation.\+check\+\_\+random\+\_\+state (\begin{DoxyParamCaption}\item[{}]{seed}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Turn seed into a np.random.RandomState instance.

Parameters
----------
seed : None, int or instance of RandomState
    If seed is None, return the RandomState singleton used by np.random.
    If seed is an int, return a new RandomState instance seeded with seed.
    If seed is already a RandomState instance, return it.
    Otherwise raise ValueError.

Returns
-------
:class:`numpy:numpy.random.RandomState`
    The random state object based on `seed` parameter.

Examples
--------
>>> from sklearn.utils.validation import check_random_state
>>> check_random_state(42)
RandomState(MT19937) at 0x...
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{validation_8py_source_l01488}{1488}} of file \mbox{\hyperlink{validation_8py_source}{validation.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1validation_ad736b5d420812969b32c65fc0a62ad11}\index{sklearn.utils.validation@{sklearn.utils.validation}!check\_scalar@{check\_scalar}}
\index{check\_scalar@{check\_scalar}!sklearn.utils.validation@{sklearn.utils.validation}}
\doxysubsubsection{\texorpdfstring{check\_scalar()}{check\_scalar()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1validation_ad736b5d420812969b32c65fc0a62ad11} 
sklearn.\+utils.\+validation.\+check\+\_\+scalar (\begin{DoxyParamCaption}\item[{}]{x}{, }\item[{}]{name}{, }\item[{}]{target\+\_\+type}{, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{min\+\_\+val}{ = {\ttfamily None}, }\item[{}]{max\+\_\+val}{ = {\ttfamily None}, }\item[{}]{include\+\_\+boundaries}{ = {\ttfamily "{}both"{}}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Validate scalar parameters type and value.

Parameters
----------
x : object
    The scalar parameter to validate.

name : str
    The name of the parameter to be printed in error messages.

target_type : type or tuple
    Acceptable data types for the parameter.

min_val : float or int, default=None
    The minimum valid value the parameter can take. If None (default) it
    is implied that the parameter does not have a lower bound.

max_val : float or int, default=None
    The maximum valid value the parameter can take. If None (default) it
    is implied that the parameter does not have an upper bound.

include_boundaries : {"left", "right", "both", "neither"}, default="both"
    Whether the interval defined by `min_val` and `max_val` should include
    the boundaries. Possible choices are:

    - `"left"`: only `min_val` is included in the valid interval.
      It is equivalent to the interval `[ min_val, max_val )`.
    - `"right"`: only `max_val` is included in the valid interval.
      It is equivalent to the interval `( min_val, max_val ]`.
    - `"both"`: `min_val` and `max_val` are included in the valid interval.
      It is equivalent to the interval `[ min_val, max_val ]`.
    - `"neither"`: neither `min_val` nor `max_val` are included in the
      valid interval. It is equivalent to the interval `( min_val, max_val )`.

Returns
-------
x : numbers.Number
    The validated number.

Raises
------
TypeError
    If the parameter's type does not match the desired type.

ValueError
    If the parameter's value violates the given bounds.
    If `min_val`, `max_val` and `include_boundaries` are inconsistent.

Examples
--------
>>> from sklearn.utils.validation import check_scalar
>>> check_scalar(10, "x", int, min_val=1, max_val=20)
10
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{validation_8py_source_l01827}{1827}} of file \mbox{\hyperlink{validation_8py_source}{validation.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1validation_a2400c76ab584dbb9176277e186948c96}\index{sklearn.utils.validation@{sklearn.utils.validation}!check\_symmetric@{check\_symmetric}}
\index{check\_symmetric@{check\_symmetric}!sklearn.utils.validation@{sklearn.utils.validation}}
\doxysubsubsection{\texorpdfstring{check\_symmetric()}{check\_symmetric()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1validation_a2400c76ab584dbb9176277e186948c96} 
sklearn.\+utils.\+validation.\+check\+\_\+symmetric (\begin{DoxyParamCaption}\item[{}]{array}{, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{tol}{ = {\ttfamily 1e-\/10}, }\item[{}]{raise\+\_\+warning}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}, }\item[{}]{raise\+\_\+exception}{ = {\ttfamily False}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Make sure that array is 2D, square and symmetric.

If the array is not symmetric, then a symmetrized version is returned.
Optionally, a warning or exception is raised if the matrix is not
symmetric.

Parameters
----------
array : {ndarray, sparse matrix}
    Input object to check / convert. Must be two-dimensional and square,
    otherwise a ValueError will be raised.

tol : float, default=1e-10
    Absolute tolerance for equivalence of arrays. Default = 1E-10.

raise_warning : bool, default=True
    If True then raise a warning if conversion is required.

raise_exception : bool, default=False
    If True then raise an exception if array is not symmetric.

Returns
-------
array_sym : {ndarray, sparse matrix}
    Symmetrized version of the input array, i.e. the average of array
    and array.transpose(). If sparse, then duplicate entries are first
    summed and zeros are eliminated.

Examples
--------
>>> import numpy as np
>>> from sklearn.utils.validation import check_symmetric
>>> symmetric_array = np.array([[0, 1, 2], [1, 0, 1], [2, 1, 0]])
>>> check_symmetric(symmetric_array)
array([[0, 1, 2],
       [1, 0, 1],
       [2, 1, 0]])
>>> from scipy.sparse import csr_matrix
>>> sparse_symmetric_array = csr_matrix(symmetric_array)
>>> check_symmetric(sparse_symmetric_array)
<Compressed Sparse Row sparse matrix of dtype 'int64'
    with 6 stored elements and shape (3, 3)>
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{validation_8py_source_l01554}{1554}} of file \mbox{\hyperlink{validation_8py_source}{validation.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1validation_adea0c511b3202afb470713b61d4d1630}\index{sklearn.utils.validation@{sklearn.utils.validation}!check\_X\_y@{check\_X\_y}}
\index{check\_X\_y@{check\_X\_y}!sklearn.utils.validation@{sklearn.utils.validation}}
\doxysubsubsection{\texorpdfstring{check\_X\_y()}{check\_X\_y()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1validation_adea0c511b3202afb470713b61d4d1630} 
sklearn.\+utils.\+validation.\+check\+\_\+\+X\+\_\+y (\begin{DoxyParamCaption}\item[{}]{X}{, }\item[{}]{y}{, }\item[{}]{accept\+\_\+sparse}{ = {\ttfamily False}, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{accept\+\_\+large\+\_\+sparse}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}, }\item[{}]{dtype}{ = {\ttfamily "{}numeric"{}}, }\item[{}]{order}{ = {\ttfamily None}, }\item[{}]{copy}{ = {\ttfamily False}, }\item[{}]{force\+\_\+writeable}{ = {\ttfamily False}, }\item[{}]{force\+\_\+all\+\_\+finite}{ = {\ttfamily "{}deprecated"{}}, }\item[{}]{ensure\+\_\+all\+\_\+finite}{ = {\ttfamily None}, }\item[{}]{ensure\+\_\+2d}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}, }\item[{}]{allow\+\_\+nd}{ = {\ttfamily False}, }\item[{}]{multi\+\_\+output}{ = {\ttfamily False}, }\item[{}]{ensure\+\_\+min\+\_\+samples}{ = {\ttfamily 1}, }\item[{}]{ensure\+\_\+min\+\_\+features}{ = {\ttfamily 1}, }\item[{}]{y\+\_\+numeric}{ = {\ttfamily False}, }\item[{}]{estimator}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Input validation for standard estimators.

Checks X and y for consistent length, enforces X to be 2D and y 1D. By
default, X is checked to be non-empty and containing only finite values.
Standard input checks are also applied to y, such as checking that y
does not have np.nan or np.inf targets. For multi-label y, set
multi_output=True to allow 2D and sparse y. If the dtype of X is
object, attempt converting to float, raising on failure.

Parameters
----------
X : {ndarray, list, sparse matrix}
    Input data.

y : {ndarray, list, sparse matrix}
    Labels.

accept_sparse : str, bool or list of str, default=False
    String[s] representing allowed sparse matrix formats, such as 'csc',
    'csr', etc. If the input is sparse but not in the allowed format,
    it will be converted to the first listed format. True allows the input
    to be any format. False means that a sparse matrix input will
    raise an error.

accept_large_sparse : bool, default=True
    If a CSR, CSC, COO or BSR sparse matrix is supplied and accepted by
    accept_sparse, accept_large_sparse will cause it to be accepted only
    if its indices are stored with a 32-bit dtype.

    .. versionadded:: 0.20

dtype : 'numeric', type, list of type or None, default='numeric'
    Data type of result. If None, the dtype of the input is preserved.
    If "numeric", dtype is preserved unless array.dtype is object.
    If dtype is a list of types, conversion on the first type is only
    performed if the dtype of the input is not in the list.

order : {'F', 'C'}, default=None
    Whether an array will be forced to be fortran or c-style. If
    `None`, then the input data's order is preserved when possible.

copy : bool, default=False
    Whether a forced copy will be triggered. If copy=False, a copy might
    be triggered by a conversion.

force_writeable : bool, default=False
    Whether to force the output array to be writeable. If True, the returned array
    is guaranteed to be writeable, which may require a copy. Otherwise the
    writeability of the input array is preserved.

    .. versionadded:: 1.6

force_all_finite : bool or 'allow-nan', default=True
    Whether to raise an error on np.inf, np.nan, pd.NA in array. This parameter
    does not influence whether y can have np.inf, np.nan, pd.NA values.
    The possibilities are:

    - True: Force all values of X to be finite.
    - False: accepts np.inf, np.nan, pd.NA in X.
    - 'allow-nan': accepts only np.nan or pd.NA values in X. Values cannot
      be infinite.

    .. versionadded:: 0.20
       ``force_all_finite`` accepts the string ``'allow-nan'``.

    .. versionchanged:: 0.23
       Accepts `pd.NA` and converts it into `np.nan`

    .. deprecated:: 1.6
       `force_all_finite` was renamed to `ensure_all_finite` and will be removed
       in 1.8.

ensure_all_finite : bool or 'allow-nan', default=True
    Whether to raise an error on np.inf, np.nan, pd.NA in array. This parameter
    does not influence whether y can have np.inf, np.nan, pd.NA values.
    The possibilities are:

    - True: Force all values of X to be finite.
    - False: accepts np.inf, np.nan, pd.NA in X.
    - 'allow-nan': accepts only np.nan or pd.NA values in X. Values cannot
      be infinite.

    .. versionadded:: 1.6
       `force_all_finite` was renamed to `ensure_all_finite`.

ensure_2d : bool, default=True
    Whether to raise a value error if X is not 2D.

allow_nd : bool, default=False
    Whether to allow X.ndim > 2.

multi_output : bool, default=False
    Whether to allow 2D y (array or sparse matrix). If false, y will be
    validated as a vector. y cannot have np.nan or np.inf values if
    multi_output=True.

ensure_min_samples : int, default=1
    Make sure that X has a minimum number of samples in its first
    axis (rows for a 2D array).

ensure_min_features : int, default=1
    Make sure that the 2D array has some minimum number of features
    (columns). The default value of 1 rejects empty datasets.
    This check is only enforced when X has effectively 2 dimensions or
    is originally 1D and ``ensure_2d`` is True. Setting to 0 disables
    this check.

y_numeric : bool, default=False
    Whether to ensure that y has a numeric type. If dtype of y is object,
    it is converted to float64. Should only be used for regression
    algorithms.

estimator : str or estimator instance, default=None
    If passed, include the name of the estimator in warning messages.

Returns
-------
X_converted : object
    The converted and validated X.

y_converted : object
    The converted and validated y.

Examples
--------
>>> from sklearn.utils.validation import check_X_y
>>> X = [[1, 2], [3, 4], [5, 6]]
>>> y = [1, 2, 3]
>>> X, y = check_X_y(X, y)
>>> X
array([[1, 2],
      [3, 4],
      [5, 6]])
>>> y
array([1, 2, 3])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{validation_8py_source_l01201}{1201}} of file \mbox{\hyperlink{validation_8py_source}{validation.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1validation_a1bdc07fbd258f21f135d665edc151b2f}\index{sklearn.utils.validation@{sklearn.utils.validation}!column\_or\_1d@{column\_or\_1d}}
\index{column\_or\_1d@{column\_or\_1d}!sklearn.utils.validation@{sklearn.utils.validation}}
\doxysubsubsection{\texorpdfstring{column\_or\_1d()}{column\_or\_1d()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1validation_a1bdc07fbd258f21f135d665edc151b2f} 
sklearn.\+utils.\+validation.\+column\+\_\+or\+\_\+1d (\begin{DoxyParamCaption}\item[{}]{y}{, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{dtype}{ = {\ttfamily None}, }\item[{}]{warn}{ = {\ttfamily False}, }\item[{}]{device}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Ravel column or 1d numpy array, else raises an error.

Parameters
----------
y : array-like
   Input data.

dtype : data-type, default=None
    Data type for `y`.

    .. versionadded:: 1.2

warn : bool, default=False
   To control display of warnings.

device : device, default=None
    `device` object.
    See the :ref:`Array API User Guide <array_api>` for more details.

    .. versionadded:: 1.6

Returns
-------
y : ndarray
   Output data.

Raises
------
ValueError
    If `y` is not a 1D array or a 2D array with a single row or column.

Examples
--------
>>> from sklearn.utils.validation import column_or_1d
>>> column_or_1d([1, 1])
array([1, 1])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{validation_8py_source_l01415}{1415}} of file \mbox{\hyperlink{validation_8py_source}{validation.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1validation_ac4e26a6139a4438d6cb20d7df8e22627}\index{sklearn.utils.validation@{sklearn.utils.validation}!has\_fit\_parameter@{has\_fit\_parameter}}
\index{has\_fit\_parameter@{has\_fit\_parameter}!sklearn.utils.validation@{sklearn.utils.validation}}
\doxysubsubsection{\texorpdfstring{has\_fit\_parameter()}{has\_fit\_parameter()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1validation_ac4e26a6139a4438d6cb20d7df8e22627} 
sklearn.\+utils.\+validation.\+has\+\_\+fit\+\_\+parameter (\begin{DoxyParamCaption}\item[{}]{estimator}{, }\item[{}]{parameter}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Check whether the estimator's fit method supports the given parameter.

Parameters
----------
estimator : object
    An estimator to inspect.

parameter : str
    The searched parameter.

Returns
-------
is_parameter : bool
    Whether the parameter was found to be a named parameter of the
    estimator's fit method.

Examples
--------
>>> from sklearn.svm import SVC
>>> from sklearn.utils.validation import has_fit_parameter
>>> has_fit_parameter(SVC(), "sample_weight")
True
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{validation_8py_source_l01521}{1521}} of file \mbox{\hyperlink{validation_8py_source}{validation.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1validation_a504b868d5db67011bff3ac38f2dbaf4e}\index{sklearn.utils.validation@{sklearn.utils.validation}!indexable@{indexable}}
\index{indexable@{indexable}!sklearn.utils.validation@{sklearn.utils.validation}}
\doxysubsubsection{\texorpdfstring{indexable()}{indexable()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1validation_a504b868d5db67011bff3ac38f2dbaf4e} 
sklearn.\+utils.\+validation.\+indexable (\begin{DoxyParamCaption}\item[{\texorpdfstring{$\ast$}{*}}]{iterables}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Make arrays indexable for cross-validation.

Checks consistent length, passes through None, and ensures that everything
can be indexed by converting sparse matrices to csr and converting
non-iterable objects to arrays.

Parameters
----------
*iterables : {lists, dataframes, ndarrays, sparse matrices}
    List of objects to ensure sliceability.

Returns
-------
result : list of {ndarray, sparse matrix, dataframe} or None
    Returns a list containing indexable arrays (i.e. NumPy array,
    sparse matrix, or dataframe) or `None`.

Examples
--------
>>> from sklearn.utils import indexable
>>> from scipy.sparse import csr_matrix
>>> import numpy as np
>>> iterables = [
...     [1, 2, 3], np.array([2, 3, 4]), None, csr_matrix([[5], [6], [7]])
... ]
>>> indexable(*iterables)
[[1, 2, 3], array([2, 3, 4]), None, <...Sparse...dtype 'int64'...shape (3, 1)>]
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{validation_8py_source_l00499}{499}} of file \mbox{\hyperlink{validation_8py_source}{validation.\+py}}.

\Hypertarget{namespacesklearn_1_1utils_1_1validation_a46a0db1d6e5148292acc9496f018a83f}\index{sklearn.utils.validation@{sklearn.utils.validation}!validate\_data@{validate\_data}}
\index{validate\_data@{validate\_data}!sklearn.utils.validation@{sklearn.utils.validation}}
\doxysubsubsection{\texorpdfstring{validate\_data()}{validate\_data()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1validation_a46a0db1d6e5148292acc9496f018a83f} 
sklearn.\+utils.\+validation.\+validate\+\_\+data (\begin{DoxyParamCaption}\item[{}]{\+\_\+estimator}{, }\item[{}]{X}{ = {\ttfamily "{}no\+\_\+validation"{}}, }\item[{}]{y}{ = {\ttfamily "{}no\+\_\+validation"{}}, }\item[{}]{reset}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}, }\item[{}]{validate\+\_\+separately}{ = {\ttfamily False}, }\item[{}]{skip\+\_\+check\+\_\+array}{ = {\ttfamily False}, }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{check\+\_\+params}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Validate input data and set or check feature names and counts of the input.

This helper function should be used in an estimator that requires input
validation. This mutates the estimator and sets the `n_features_in_` and
`feature_names_in_` attributes if `reset=True`.

.. versionadded:: 1.6

Parameters
----------
_estimator : estimator instance
    The estimator to validate the input for.

X : {array-like, sparse matrix, dataframe} of shape \
        (n_samples, n_features), default='no validation'
    The input samples.
    If `'no_validation'`, no validation is performed on `X`. This is
    useful for meta-estimator which can delegate input validation to
    their underlying estimator(s). In that case `y` must be passed and
    the only accepted `check_params` are `multi_output` and
    `y_numeric`.

y : array-like of shape (n_samples,), default='no_validation'
    The targets.

    - If `None`, :func:`~sklearn.utils.check_array` is called on `X`. If
      the estimator's `requires_y` tag is True, then an error will be raised.
    - If `'no_validation'`, :func:`~sklearn.utils.check_array` is called
      on `X` and the estimator's `requires_y` tag is ignored. This is a default
      placeholder and is never meant to be explicitly set. In that case `X` must be
      passed.
    - Otherwise, only `y` with `_check_y` or both `X` and `y` are checked with
      either :func:`~sklearn.utils.check_array` or
      :func:`~sklearn.utils.check_X_y` depending on `validate_separately`.

reset : bool, default=True
    Whether to reset the `n_features_in_` attribute.
    If False, the input will be checked for consistency with data
    provided when reset was last True.

    .. note::

       It is recommended to call `reset=True` in `fit` and in the first
       call to `partial_fit`. All other methods that validate `X`
       should set `reset=False`.

validate_separately : False or tuple of dicts, default=False
    Only used if `y` is not `None`.
    If `False`, call :func:`~sklearn.utils.check_X_y`. Else, it must be a tuple of
    kwargs to be used for calling :func:`~sklearn.utils.check_array` on `X` and `y`
    respectively.

    `estimator=self` is automatically added to these dicts to generate
    more informative error message in case of invalid input data.

skip_check_array : bool, default=False
    If `True`, `X` and `y` are unchanged and only `feature_names_in_` and
    `n_features_in_` are checked. Otherwise, :func:`~sklearn.utils.check_array`
    is called on `X` and `y`.

**check_params : kwargs
    Parameters passed to :func:`~sklearn.utils.check_array` or
    :func:`~sklearn.utils.check_X_y`. Ignored if validate_separately
    is not False.

    `estimator=self` is automatically added to these params to generate
    more informative error message in case of invalid input data.

Returns
-------
out : {ndarray, sparse matrix} or tuple of these
    The validated input. A tuple is returned if both `X` and `y` are
    validated.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{validation_8py_source_l02845}{2845}} of file \mbox{\hyperlink{validation_8py_source}{validation.\+py}}.



\doxysubsection{Variable Documentation}
\Hypertarget{namespacesklearn_1_1utils_1_1validation_a6f695de28a35eaa5749b3ba2d290d83e}\index{sklearn.utils.validation@{sklearn.utils.validation}!FLOAT\_DTYPES@{FLOAT\_DTYPES}}
\index{FLOAT\_DTYPES@{FLOAT\_DTYPES}!sklearn.utils.validation@{sklearn.utils.validation}}
\doxysubsubsection{\texorpdfstring{FLOAT\_DTYPES}{FLOAT\_DTYPES}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1utils_1_1validation_a6f695de28a35eaa5749b3ba2d290d83e} 
tuple sklearn.\+utils.\+validation.\+FLOAT\+\_\+\+DTYPES = (np.\+float64, np.\+float32, np.\+float16)}



Definition at line \mbox{\hyperlink{validation_8py_source_l00028}{28}} of file \mbox{\hyperlink{validation_8py_source}{validation.\+py}}.

