\doxysection{scipy.\+stats.\+\_\+resampling Namespace Reference}
\hypertarget{namespacescipy_1_1stats_1_1__resampling}{}\label{namespacescipy_1_1stats_1_1__resampling}\index{scipy.stats.\_resampling@{scipy.stats.\_resampling}}
\doxysubsubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classscipy_1_1stats_1_1__resampling_1_1BootstrapMethod}{Bootstrap\+Method}}
\item 
class \mbox{\hyperlink{classscipy_1_1stats_1_1__resampling_1_1BootstrapResult}{Bootstrap\+Result}}
\item 
class \mbox{\hyperlink{classscipy_1_1stats_1_1__resampling_1_1MonteCarloMethod}{Monte\+Carlo\+Method}}
\item 
class \mbox{\hyperlink{classscipy_1_1stats_1_1__resampling_1_1MonteCarloTestResult}{Monte\+Carlo\+Test\+Result}}
\item 
class \mbox{\hyperlink{classscipy_1_1stats_1_1__resampling_1_1PermutationMethod}{Permutation\+Method}}
\item 
class \mbox{\hyperlink{classscipy_1_1stats_1_1__resampling_1_1PermutationTestResult}{Permutation\+Test\+Result}}
\item 
class \mbox{\hyperlink{classscipy_1_1stats_1_1__resampling_1_1ResamplingMethod}{Resampling\+Method}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacescipy_1_1stats_1_1__resampling_a1cbf31c18034ecab33c5c808b268dd86}{\+\_\+vectorize\+\_\+statistic}} (statistic)
\item 
\mbox{\hyperlink{namespacescipy_1_1stats_1_1__resampling_a769ff272403e86cb56c70da1815f7578}{\+\_\+jackknife\+\_\+resample}} (sample, batch=None)
\item 
\mbox{\hyperlink{namespacescipy_1_1stats_1_1__resampling_a92d4dbf131de119c12f6c988ff2f220c}{\+\_\+bootstrap\+\_\+resample}} (sample, n\+\_\+resamples=None, random\+\_\+state=None)
\item 
\mbox{\hyperlink{namespacescipy_1_1stats_1_1__resampling_a4d690dafccfb69022dcf50b4c19becdd}{\+\_\+percentile\+\_\+of\+\_\+score}} (a, score, axis)
\item 
\mbox{\hyperlink{namespacescipy_1_1stats_1_1__resampling_acbe7a1919ac1faf534dd1e5e3f091543}{\+\_\+percentile\+\_\+along\+\_\+axis}} (theta\+\_\+hat\+\_\+b, alpha)
\item 
\mbox{\hyperlink{namespacescipy_1_1stats_1_1__resampling_a2f04e1d5f070ff31f1343441e0d49b13}{\+\_\+bca\+\_\+interval}} (data, statistic, axis, alpha, theta\+\_\+hat\+\_\+b, batch)
\item 
\mbox{\hyperlink{namespacescipy_1_1stats_1_1__resampling_ac8abcdc18ed960610af3403ad6fdf8ac}{\+\_\+bootstrap\+\_\+iv}} (data, statistic, vectorized, paired, axis, confidence\+\_\+level, alternative, n\+\_\+resamples, batch, method, bootstrap\+\_\+result, random\+\_\+state)
\item 
\mbox{\hyperlink{namespacescipy_1_1stats_1_1__resampling_a6c3d395af56f8cabdf385cf951cbc52d}{bootstrap}} (data, statistic, \texorpdfstring{$\ast$}{*}, n\+\_\+resamples=9999, batch=None, vectorized=None, paired=False, axis=0, confidence\+\_\+level=0.\+95, alternative=\textquotesingle{}two-\/sided\textquotesingle{}, method=\textquotesingle{}BCa\textquotesingle{}, bootstrap\+\_\+result=None, random\+\_\+state=None)
\item 
\mbox{\hyperlink{namespacescipy_1_1stats_1_1__resampling_a0d199f6fb5c86b7de1da4cb6443c743e}{\+\_\+monte\+\_\+carlo\+\_\+test\+\_\+iv}} (data, rvs, statistic, vectorized, n\+\_\+resamples, batch, alternative, axis)
\item 
\mbox{\hyperlink{namespacescipy_1_1stats_1_1__resampling_a5486c49c316587dae5db7b43deef6ce9}{monte\+\_\+carlo\+\_\+test}} (data, rvs, statistic, \texorpdfstring{$\ast$}{*}, vectorized=None, n\+\_\+resamples=9999, batch=None, alternative="{}two-\/sided"{}, axis=0)
\item 
\mbox{\hyperlink{namespacescipy_1_1stats_1_1__resampling_a0e31d9de95afc8cc40db53ed7f4cfddd}{\+\_\+all\+\_\+partitions\+\_\+concatenated}} (ns)
\item 
\mbox{\hyperlink{namespacescipy_1_1stats_1_1__resampling_ab2c3fbfa8434bb273175aafd84fd9eb3}{\+\_\+batch\+\_\+generator}} (iterable, batch)
\item 
\mbox{\hyperlink{namespacescipy_1_1stats_1_1__resampling_aff08338ccc8d6e478ee46287731b4869}{\+\_\+pairings\+\_\+permutations\+\_\+gen}} (n\+\_\+permutations, n\+\_\+samples, n\+\_\+obs\+\_\+sample, batch, random\+\_\+state)
\item 
\mbox{\hyperlink{namespacescipy_1_1stats_1_1__resampling_abce466a2e498006d6c0c57bfde7b7ce7}{\+\_\+calculate\+\_\+null\+\_\+both}} (data, statistic, n\+\_\+permutations, batch, random\+\_\+state=None)
\item 
\mbox{\hyperlink{namespacescipy_1_1stats_1_1__resampling_a164b747bb35a0a8fc563729ec8e72e5d}{\+\_\+calculate\+\_\+null\+\_\+pairings}} (data, statistic, n\+\_\+permutations, batch, random\+\_\+state=None)
\item 
\mbox{\hyperlink{namespacescipy_1_1stats_1_1__resampling_a281bd931b030ac46a8df78e1ae2ce06c}{\+\_\+calculate\+\_\+null\+\_\+samples}} (data, statistic, n\+\_\+permutations, batch, random\+\_\+state=None)
\item 
\mbox{\hyperlink{namespacescipy_1_1stats_1_1__resampling_aaa7528e2c981d6bb79547bdb33da599a}{\+\_\+permutation\+\_\+test\+\_\+iv}} (data, statistic, permutation\+\_\+type, vectorized, n\+\_\+resamples, batch, alternative, axis, random\+\_\+state)
\item 
\mbox{\hyperlink{namespacescipy_1_1stats_1_1__resampling_a2121e61e3b44b91dd340f938469b5b38}{permutation\+\_\+test}} (data, statistic, \texorpdfstring{$\ast$}{*}, permutation\+\_\+type=\textquotesingle{}independent\textquotesingle{}, vectorized=None, n\+\_\+resamples=9999, batch=None, alternative="{}two-\/sided"{}, axis=0, random\+\_\+state=None)
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
list \mbox{\hyperlink{namespacescipy_1_1stats_1_1__resampling_a1006fe52525dfb2a6ab2e9f48fbe5263}{\+\_\+\+\_\+all\+\_\+\+\_\+}} = \mbox{[}\textquotesingle{}\mbox{\hyperlink{namespacescipy_1_1stats_1_1__resampling_a6c3d395af56f8cabdf385cf951cbc52d}{bootstrap}}\textquotesingle{}, \textquotesingle{}\mbox{\hyperlink{namespacescipy_1_1stats_1_1__resampling_a5486c49c316587dae5db7b43deef6ce9}{monte\+\_\+carlo\+\_\+test}}\textquotesingle{}, \textquotesingle{}\mbox{\hyperlink{namespacescipy_1_1stats_1_1__resampling_a2121e61e3b44b91dd340f938469b5b38}{permutation\+\_\+test}}\textquotesingle{}\mbox{]}
\end{DoxyCompactItemize}


\doxysubsection{Function Documentation}
\Hypertarget{namespacescipy_1_1stats_1_1__resampling_a0e31d9de95afc8cc40db53ed7f4cfddd}\index{scipy.stats.\_resampling@{scipy.stats.\_resampling}!\_all\_partitions\_concatenated@{\_all\_partitions\_concatenated}}
\index{\_all\_partitions\_concatenated@{\_all\_partitions\_concatenated}!scipy.stats.\_resampling@{scipy.stats.\_resampling}}
\doxysubsubsection{\texorpdfstring{\_all\_partitions\_concatenated()}{\_all\_partitions\_concatenated()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1stats_1_1__resampling_a0e31d9de95afc8cc40db53ed7f4cfddd} 
scipy.\+stats.\+\_\+resampling.\+\_\+all\+\_\+partitions\+\_\+concatenated (\begin{DoxyParamCaption}\item[{}]{ns}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Generate all partitions of indices of groups of given sizes, concatenated

`ns` is an iterable of ints.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__resampling_8py_source_l00959}{959}} of file \mbox{\hyperlink{__resampling_8py_source}{\+\_\+resampling.\+py}}.



Referenced by \mbox{\hyperlink{__resampling_8py_source_l01025}{\+\_\+calculate\+\_\+null\+\_\+both()}}.

\Hypertarget{namespacescipy_1_1stats_1_1__resampling_ab2c3fbfa8434bb273175aafd84fd9eb3}\index{scipy.stats.\_resampling@{scipy.stats.\_resampling}!\_batch\_generator@{\_batch\_generator}}
\index{\_batch\_generator@{\_batch\_generator}!scipy.stats.\_resampling@{scipy.stats.\_resampling}}
\doxysubsubsection{\texorpdfstring{\_batch\_generator()}{\_batch\_generator()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1stats_1_1__resampling_ab2c3fbfa8434bb273175aafd84fd9eb3} 
scipy.\+stats.\+\_\+resampling.\+\_\+batch\+\_\+generator (\begin{DoxyParamCaption}\item[{}]{iterable}{, }\item[{}]{batch}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}A generator that yields batches of elements from an iterable\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__resampling_8py_source_l00986}{986}} of file \mbox{\hyperlink{__resampling_8py_source}{\+\_\+resampling.\+py}}.



Referenced by \mbox{\hyperlink{__resampling_8py_source_l01025}{\+\_\+calculate\+\_\+null\+\_\+both()}}, and \mbox{\hyperlink{__resampling_8py_source_l01085}{\+\_\+calculate\+\_\+null\+\_\+pairings()}}.

\Hypertarget{namespacescipy_1_1stats_1_1__resampling_a2f04e1d5f070ff31f1343441e0d49b13}\index{scipy.stats.\_resampling@{scipy.stats.\_resampling}!\_bca\_interval@{\_bca\_interval}}
\index{\_bca\_interval@{\_bca\_interval}!scipy.stats.\_resampling@{scipy.stats.\_resampling}}
\doxysubsubsection{\texorpdfstring{\_bca\_interval()}{\_bca\_interval()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1stats_1_1__resampling_a2f04e1d5f070ff31f1343441e0d49b13} 
scipy.\+stats.\+\_\+resampling.\+\_\+bca\+\_\+interval (\begin{DoxyParamCaption}\item[{}]{data}{, }\item[{}]{statistic}{, }\item[{}]{axis}{, }\item[{}]{alpha}{, }\item[{}]{theta\+\_\+hat\+\_\+b}{, }\item[{}]{batch}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Bias-corrected and accelerated interval.\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__resampling_8py_source_l00108}{108}} of file \mbox{\hyperlink{__resampling_8py_source}{\+\_\+resampling.\+py}}.



References \mbox{\hyperlink{__resampling_8py_source_l00042}{\+\_\+jackknife\+\_\+resample()}}, and \mbox{\hyperlink{__resampling_8py_source_l00073}{\+\_\+percentile\+\_\+of\+\_\+score()}}.



Referenced by \mbox{\hyperlink{__resampling_8py_source_l00282}{bootstrap()}}.

\Hypertarget{namespacescipy_1_1stats_1_1__resampling_ac8abcdc18ed960610af3403ad6fdf8ac}\index{scipy.stats.\_resampling@{scipy.stats.\_resampling}!\_bootstrap\_iv@{\_bootstrap\_iv}}
\index{\_bootstrap\_iv@{\_bootstrap\_iv}!scipy.stats.\_resampling@{scipy.stats.\_resampling}}
\doxysubsubsection{\texorpdfstring{\_bootstrap\_iv()}{\_bootstrap\_iv()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1stats_1_1__resampling_ac8abcdc18ed960610af3403ad6fdf8ac} 
scipy.\+stats.\+\_\+resampling.\+\_\+bootstrap\+\_\+iv (\begin{DoxyParamCaption}\item[{}]{data}{, }\item[{}]{statistic}{, }\item[{}]{vectorized}{, }\item[{}]{paired}{, }\item[{}]{axis}{, }\item[{}]{confidence\+\_\+level}{, }\item[{}]{alternative}{, }\item[{}]{n\+\_\+resamples}{, }\item[{}]{batch}{, }\item[{}]{method}{, }\item[{}]{bootstrap\+\_\+result}{, }\item[{}]{random\+\_\+state}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Input validation and standardization for `bootstrap`.\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__resampling_8py_source_l00159}{159}} of file \mbox{\hyperlink{__resampling_8py_source}{\+\_\+resampling.\+py}}.



References \mbox{\hyperlink{__resampling_8py_source_l00020}{\+\_\+vectorize\+\_\+statistic()}}.



Referenced by \mbox{\hyperlink{__resampling_8py_source_l00282}{bootstrap()}}.

\Hypertarget{namespacescipy_1_1stats_1_1__resampling_a92d4dbf131de119c12f6c988ff2f220c}\index{scipy.stats.\_resampling@{scipy.stats.\_resampling}!\_bootstrap\_resample@{\_bootstrap\_resample}}
\index{\_bootstrap\_resample@{\_bootstrap\_resample}!scipy.stats.\_resampling@{scipy.stats.\_resampling}}
\doxysubsubsection{\texorpdfstring{\_bootstrap\_resample()}{\_bootstrap\_resample()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1stats_1_1__resampling_a92d4dbf131de119c12f6c988ff2f220c} 
scipy.\+stats.\+\_\+resampling.\+\_\+bootstrap\+\_\+resample (\begin{DoxyParamCaption}\item[{}]{sample}{, }\item[{}]{n\+\_\+resamples}{ = {\ttfamily None}, }\item[{}]{random\+\_\+state}{ = {\ttfamily None}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Bootstrap resample the sample.\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__resampling_8py_source_l00062}{62}} of file \mbox{\hyperlink{__resampling_8py_source}{\+\_\+resampling.\+py}}.



Referenced by \mbox{\hyperlink{__resampling_8py_source_l00282}{bootstrap()}}.

\Hypertarget{namespacescipy_1_1stats_1_1__resampling_abce466a2e498006d6c0c57bfde7b7ce7}\index{scipy.stats.\_resampling@{scipy.stats.\_resampling}!\_calculate\_null\_both@{\_calculate\_null\_both}}
\index{\_calculate\_null\_both@{\_calculate\_null\_both}!scipy.stats.\_resampling@{scipy.stats.\_resampling}}
\doxysubsubsection{\texorpdfstring{\_calculate\_null\_both()}{\_calculate\_null\_both()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1stats_1_1__resampling_abce466a2e498006d6c0c57bfde7b7ce7} 
scipy.\+stats.\+\_\+resampling.\+\_\+calculate\+\_\+null\+\_\+both (\begin{DoxyParamCaption}\item[{}]{data}{, }\item[{}]{statistic}{, }\item[{}]{n\+\_\+permutations}{, }\item[{}]{batch}{, }\item[{}]{random\+\_\+state}{ = {\ttfamily None}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Calculate null distribution for independent sample tests.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__resampling_8py_source_l01024}{1024}} of file \mbox{\hyperlink{__resampling_8py_source}{\+\_\+resampling.\+py}}.



References \mbox{\hyperlink{__resampling_8py_source_l00959}{\+\_\+all\+\_\+partitions\+\_\+concatenated()}}, and \mbox{\hyperlink{__resampling_8py_source_l00986}{\+\_\+batch\+\_\+generator()}}.

\Hypertarget{namespacescipy_1_1stats_1_1__resampling_a164b747bb35a0a8fc563729ec8e72e5d}\index{scipy.stats.\_resampling@{scipy.stats.\_resampling}!\_calculate\_null\_pairings@{\_calculate\_null\_pairings}}
\index{\_calculate\_null\_pairings@{\_calculate\_null\_pairings}!scipy.stats.\_resampling@{scipy.stats.\_resampling}}
\doxysubsubsection{\texorpdfstring{\_calculate\_null\_pairings()}{\_calculate\_null\_pairings()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1stats_1_1__resampling_a164b747bb35a0a8fc563729ec8e72e5d} 
scipy.\+stats.\+\_\+resampling.\+\_\+calculate\+\_\+null\+\_\+pairings (\begin{DoxyParamCaption}\item[{}]{data}{, }\item[{}]{statistic}{, }\item[{}]{n\+\_\+permutations}{, }\item[{}]{batch}{, }\item[{}]{random\+\_\+state}{ = {\ttfamily None}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Calculate null distribution for association tests.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__resampling_8py_source_l01084}{1084}} of file \mbox{\hyperlink{__resampling_8py_source}{\+\_\+resampling.\+py}}.



References \mbox{\hyperlink{__resampling_8py_source_l00986}{\+\_\+batch\+\_\+generator()}}.



Referenced by \mbox{\hyperlink{__resampling_8py_source_l01142}{\+\_\+calculate\+\_\+null\+\_\+samples()}}.

\Hypertarget{namespacescipy_1_1stats_1_1__resampling_a281bd931b030ac46a8df78e1ae2ce06c}\index{scipy.stats.\_resampling@{scipy.stats.\_resampling}!\_calculate\_null\_samples@{\_calculate\_null\_samples}}
\index{\_calculate\_null\_samples@{\_calculate\_null\_samples}!scipy.stats.\_resampling@{scipy.stats.\_resampling}}
\doxysubsubsection{\texorpdfstring{\_calculate\_null\_samples()}{\_calculate\_null\_samples()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1stats_1_1__resampling_a281bd931b030ac46a8df78e1ae2ce06c} 
scipy.\+stats.\+\_\+resampling.\+\_\+calculate\+\_\+null\+\_\+samples (\begin{DoxyParamCaption}\item[{}]{data}{, }\item[{}]{statistic}{, }\item[{}]{n\+\_\+permutations}{, }\item[{}]{batch}{, }\item[{}]{random\+\_\+state}{ = {\ttfamily None}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Calculate null distribution for paired-sample tests.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__resampling_8py_source_l01141}{1141}} of file \mbox{\hyperlink{__resampling_8py_source}{\+\_\+resampling.\+py}}.



References \mbox{\hyperlink{__resampling_8py_source_l01085}{\+\_\+calculate\+\_\+null\+\_\+pairings()}}.

\Hypertarget{namespacescipy_1_1stats_1_1__resampling_a769ff272403e86cb56c70da1815f7578}\index{scipy.stats.\_resampling@{scipy.stats.\_resampling}!\_jackknife\_resample@{\_jackknife\_resample}}
\index{\_jackknife\_resample@{\_jackknife\_resample}!scipy.stats.\_resampling@{scipy.stats.\_resampling}}
\doxysubsubsection{\texorpdfstring{\_jackknife\_resample()}{\_jackknife\_resample()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1stats_1_1__resampling_a769ff272403e86cb56c70da1815f7578} 
scipy.\+stats.\+\_\+resampling.\+\_\+jackknife\+\_\+resample (\begin{DoxyParamCaption}\item[{}]{sample}{, }\item[{}]{batch}{ = {\ttfamily None}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Jackknife resample the sample. Only one-sample stats for now.\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__resampling_8py_source_l00042}{42}} of file \mbox{\hyperlink{__resampling_8py_source}{\+\_\+resampling.\+py}}.



Referenced by \mbox{\hyperlink{__resampling_8py_source_l00108}{\+\_\+bca\+\_\+interval()}}.

\Hypertarget{namespacescipy_1_1stats_1_1__resampling_a0d199f6fb5c86b7de1da4cb6443c743e}\index{scipy.stats.\_resampling@{scipy.stats.\_resampling}!\_monte\_carlo\_test\_iv@{\_monte\_carlo\_test\_iv}}
\index{\_monte\_carlo\_test\_iv@{\_monte\_carlo\_test\_iv}!scipy.stats.\_resampling@{scipy.stats.\_resampling}}
\doxysubsubsection{\texorpdfstring{\_monte\_carlo\_test\_iv()}{\_monte\_carlo\_test\_iv()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1stats_1_1__resampling_a0d199f6fb5c86b7de1da4cb6443c743e} 
scipy.\+stats.\+\_\+resampling.\+\_\+monte\+\_\+carlo\+\_\+test\+\_\+iv (\begin{DoxyParamCaption}\item[{}]{data}{, }\item[{}]{rvs}{, }\item[{}]{statistic}{, }\item[{}]{vectorized}{, }\item[{}]{n\+\_\+resamples}{, }\item[{}]{batch}{, }\item[{}]{alternative}{, }\item[{}]{axis}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Input validation for `monte_carlo_test`.\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__resampling_8py_source_l00663}{663}} of file \mbox{\hyperlink{__resampling_8py_source}{\+\_\+resampling.\+py}}.



References \mbox{\hyperlink{__resampling_8py_source_l00020}{\+\_\+vectorize\+\_\+statistic()}}.



Referenced by \mbox{\hyperlink{__resampling_8py_source_l00745}{monte\+\_\+carlo\+\_\+test()}}.

\Hypertarget{namespacescipy_1_1stats_1_1__resampling_aff08338ccc8d6e478ee46287731b4869}\index{scipy.stats.\_resampling@{scipy.stats.\_resampling}!\_pairings\_permutations\_gen@{\_pairings\_permutations\_gen}}
\index{\_pairings\_permutations\_gen@{\_pairings\_permutations\_gen}!scipy.stats.\_resampling@{scipy.stats.\_resampling}}
\doxysubsubsection{\texorpdfstring{\_pairings\_permutations\_gen()}{\_pairings\_permutations\_gen()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1stats_1_1__resampling_aff08338ccc8d6e478ee46287731b4869} 
scipy.\+stats.\+\_\+resampling.\+\_\+pairings\+\_\+permutations\+\_\+gen (\begin{DoxyParamCaption}\item[{}]{n\+\_\+permutations}{, }\item[{}]{n\+\_\+samples}{, }\item[{}]{n\+\_\+obs\+\_\+sample}{, }\item[{}]{batch}{, }\item[{}]{random\+\_\+state}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{__resampling_8py_source_l00997}{997}} of file \mbox{\hyperlink{__resampling_8py_source}{\+\_\+resampling.\+py}}.

\Hypertarget{namespacescipy_1_1stats_1_1__resampling_acbe7a1919ac1faf534dd1e5e3f091543}\index{scipy.stats.\_resampling@{scipy.stats.\_resampling}!\_percentile\_along\_axis@{\_percentile\_along\_axis}}
\index{\_percentile\_along\_axis@{\_percentile\_along\_axis}!scipy.stats.\_resampling@{scipy.stats.\_resampling}}
\doxysubsubsection{\texorpdfstring{\_percentile\_along\_axis()}{\_percentile\_along\_axis()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1stats_1_1__resampling_acbe7a1919ac1faf534dd1e5e3f091543} 
scipy.\+stats.\+\_\+resampling.\+\_\+percentile\+\_\+along\+\_\+axis (\begin{DoxyParamCaption}\item[{}]{theta\+\_\+hat\+\_\+b}{, }\item[{}]{alpha}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}`np.percentile` with different percentile for each slice.\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__resampling_8py_source_l00084}{84}} of file \mbox{\hyperlink{__resampling_8py_source}{\+\_\+resampling.\+py}}.

\Hypertarget{namespacescipy_1_1stats_1_1__resampling_a4d690dafccfb69022dcf50b4c19becdd}\index{scipy.stats.\_resampling@{scipy.stats.\_resampling}!\_percentile\_of\_score@{\_percentile\_of\_score}}
\index{\_percentile\_of\_score@{\_percentile\_of\_score}!scipy.stats.\_resampling@{scipy.stats.\_resampling}}
\doxysubsubsection{\texorpdfstring{\_percentile\_of\_score()}{\_percentile\_of\_score()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1stats_1_1__resampling_a4d690dafccfb69022dcf50b4c19becdd} 
scipy.\+stats.\+\_\+resampling.\+\_\+percentile\+\_\+of\+\_\+score (\begin{DoxyParamCaption}\item[{}]{a}{, }\item[{}]{score}{, }\item[{}]{axis}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Vectorized, simplified `scipy.stats.percentileofscore`.
Uses logic of the 'mean' value of percentileofscore's kind parameter.

Unlike `stats.percentileofscore`, the percentile returned is a fraction
in [0, 1].
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__resampling_8py_source_l00073}{73}} of file \mbox{\hyperlink{__resampling_8py_source}{\+\_\+resampling.\+py}}.



Referenced by \mbox{\hyperlink{__resampling_8py_source_l00108}{\+\_\+bca\+\_\+interval()}}.

\Hypertarget{namespacescipy_1_1stats_1_1__resampling_aaa7528e2c981d6bb79547bdb33da599a}\index{scipy.stats.\_resampling@{scipy.stats.\_resampling}!\_permutation\_test\_iv@{\_permutation\_test\_iv}}
\index{\_permutation\_test\_iv@{\_permutation\_test\_iv}!scipy.stats.\_resampling@{scipy.stats.\_resampling}}
\doxysubsubsection{\texorpdfstring{\_permutation\_test\_iv()}{\_permutation\_test\_iv()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1stats_1_1__resampling_aaa7528e2c981d6bb79547bdb33da599a} 
scipy.\+stats.\+\_\+resampling.\+\_\+permutation\+\_\+test\+\_\+iv (\begin{DoxyParamCaption}\item[{}]{data}{, }\item[{}]{statistic}{, }\item[{}]{permutation\+\_\+type}{, }\item[{}]{vectorized}{, }\item[{}]{n\+\_\+resamples}{, }\item[{}]{batch}{, }\item[{}]{alternative}{, }\item[{}]{axis}{, }\item[{}]{random\+\_\+state}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Input validation for `permutation_test`.\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__resampling_8py_source_l01172}{1172}} of file \mbox{\hyperlink{__resampling_8py_source}{\+\_\+resampling.\+py}}.



References \mbox{\hyperlink{__resampling_8py_source_l00020}{\+\_\+vectorize\+\_\+statistic()}}.



Referenced by \mbox{\hyperlink{__resampling_8py_source_l01236}{permutation\+\_\+test()}}.

\Hypertarget{namespacescipy_1_1stats_1_1__resampling_a1cbf31c18034ecab33c5c808b268dd86}\index{scipy.stats.\_resampling@{scipy.stats.\_resampling}!\_vectorize\_statistic@{\_vectorize\_statistic}}
\index{\_vectorize\_statistic@{\_vectorize\_statistic}!scipy.stats.\_resampling@{scipy.stats.\_resampling}}
\doxysubsubsection{\texorpdfstring{\_vectorize\_statistic()}{\_vectorize\_statistic()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1stats_1_1__resampling_a1cbf31c18034ecab33c5c808b268dd86} 
scipy.\+stats.\+\_\+resampling.\+\_\+vectorize\+\_\+statistic (\begin{DoxyParamCaption}\item[{}]{statistic}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Vectorize an n-sample statistic\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__resampling_8py_source_l00020}{20}} of file \mbox{\hyperlink{__resampling_8py_source}{\+\_\+resampling.\+py}}.



Referenced by \mbox{\hyperlink{__resampling_8py_source_l00161}{\+\_\+bootstrap\+\_\+iv()}}, \mbox{\hyperlink{__resampling_8py_source_l00664}{\+\_\+monte\+\_\+carlo\+\_\+test\+\_\+iv()}}, and \mbox{\hyperlink{__resampling_8py_source_l01173}{\+\_\+permutation\+\_\+test\+\_\+iv()}}.

\Hypertarget{namespacescipy_1_1stats_1_1__resampling_a6c3d395af56f8cabdf385cf951cbc52d}\index{scipy.stats.\_resampling@{scipy.stats.\_resampling}!bootstrap@{bootstrap}}
\index{bootstrap@{bootstrap}!scipy.stats.\_resampling@{scipy.stats.\_resampling}}
\doxysubsubsection{\texorpdfstring{bootstrap()}{bootstrap()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1stats_1_1__resampling_a6c3d395af56f8cabdf385cf951cbc52d} 
scipy.\+stats.\+\_\+resampling.\+bootstrap (\begin{DoxyParamCaption}\item[{}]{data}{, }\item[{}]{statistic}{, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{n\+\_\+resamples}{ = {\ttfamily 9999}, }\item[{}]{batch}{ = {\ttfamily None}, }\item[{}]{vectorized}{ = {\ttfamily None}, }\item[{}]{paired}{ = {\ttfamily False}, }\item[{}]{axis}{ = {\ttfamily 0}, }\item[{}]{confidence\+\_\+level}{ = {\ttfamily 0.95}, }\item[{}]{alternative}{ = {\ttfamily \textquotesingle{}two-\/sided\textquotesingle{}}, }\item[{}]{method}{ = {\ttfamily \textquotesingle{}BCa\textquotesingle{}}, }\item[{}]{bootstrap\+\_\+result}{ = {\ttfamily None}, }\item[{}]{random\+\_\+state}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute a two-sided bootstrap confidence interval of a statistic.

When `method` is ``'percentile'`` and `alternative` is ``'two-sided'``,
a bootstrap confidence interval is computed according to the following
procedure.

1. Resample the data: for each sample in `data` and for each of
   `n_resamples`, take a random sample of the original sample
   (with replacement) of the same size as the original sample.

2. Compute the bootstrap distribution of the statistic: for each set of
   resamples, compute the test statistic.

3. Determine the confidence interval: find the interval of the bootstrap
   distribution that is

   - symmetric about the median and
   - contains `confidence_level` of the resampled statistic values.

While the ``'percentile'`` method is the most intuitive, it is rarely
used in practice. Two more common methods are available, ``'basic'``
('reverse percentile') and ``'BCa'`` ('bias-corrected and accelerated');
they differ in how step 3 is performed.

If the samples in `data` are  taken at random from their respective
distributions :math:`n` times, the confidence interval returned by
`bootstrap` will contain the true value of the statistic for those
distributions approximately `confidence_level`:math:`\, \times \, n` times.

Parameters
----------
data : sequence of array-like
     Each element of data is a sample from an underlying distribution.
statistic : callable
    Statistic for which the confidence interval is to be calculated.
    `statistic` must be a callable that accepts ``len(data)`` samples
    as separate arguments and returns the resulting statistic.
    If `vectorized` is set ``True``,
    `statistic` must also accept a keyword argument `axis` and be
    vectorized to compute the statistic along the provided `axis`.
n_resamples : int, default: ``9999``
    The number of resamples performed to form the bootstrap distribution
    of the statistic.
batch : int, optional
    The number of resamples to process in each vectorized call to
    `statistic`. Memory usage is O(`batch`*``n``), where ``n`` is the
    sample size. Default is ``None``, in which case ``batch = n_resamples``
    (or ``batch = max(n_resamples, n)`` for ``method='BCa'``).
vectorized : bool, optional
    If `vectorized` is set ``False``, `statistic` will not be passed
    keyword argument `axis` and is expected to calculate the statistic
    only for 1D samples. If ``True``, `statistic` will be passed keyword
    argument `axis` and is expected to calculate the statistic along `axis`
    when passed an ND sample array. If ``None`` (default), `vectorized`
    will be set ``True`` if ``axis`` is a parameter of `statistic`. Use of
    a vectorized statistic typically reduces computation time.
paired : bool, default: ``False``
    Whether the statistic treats corresponding elements of the samples
    in `data` as paired.
axis : int, default: ``0``
    The axis of the samples in `data` along which the `statistic` is
    calculated.
confidence_level : float, default: ``0.95``
    The confidence level of the confidence interval.
alternative : {'two-sided', 'less', 'greater'}, default: ``'two-sided'``
    Choose ``'two-sided'`` (default) for a two-sided confidence interval,
    ``'less'`` for a one-sided confidence interval with the lower bound
    at ``-np.inf``, and ``'greater'`` for a one-sided confidence interval
    with the upper bound at ``np.inf``. The other bound of the one-sided
    confidence intervals is the same as that of a two-sided confidence
    interval with `confidence_level` twice as far from 1.0; e.g. the upper
    bound of a 95% ``'less'``  confidence interval is the same as the upper
    bound of a 90% ``'two-sided'`` confidence interval.
method : {'percentile', 'basic', 'bca'}, default: ``'BCa'``
    Whether to return the 'percentile' bootstrap confidence interval
    (``'percentile'``), the 'basic' (AKA 'reverse') bootstrap confidence
    interval (``'basic'``), or the bias-corrected and accelerated bootstrap
    confidence interval (``'BCa'``).
bootstrap_result : BootstrapResult, optional
    Provide the result object returned by a previous call to `bootstrap`
    to include the previous bootstrap distribution in the new bootstrap
    distribution. This can be used, for example, to change
    `confidence_level`, change `method`, or see the effect of performing
    additional resampling without repeating computations.
random_state : {None, int, `numpy.random.Generator`,
                `numpy.random.RandomState`}, optional

    Pseudorandom number generator state used to generate resamples.

    If `random_state` is ``None`` (or `np.random`), the
    `numpy.random.RandomState` singleton is used.
    If `random_state` is an int, a new ``RandomState`` instance is used,
    seeded with `random_state`.
    If `random_state` is already a ``Generator`` or ``RandomState``
    instance then that instance is used.

Returns
-------
res : BootstrapResult
    An object with attributes:

    confidence_interval : ConfidenceInterval
        The bootstrap confidence interval as an instance of
        `collections.namedtuple` with attributes `low` and `high`.
    bootstrap_distribution : ndarray
        The bootstrap distribution, that is, the value of `statistic` for
        each resample. The last dimension corresponds with the resamples
        (e.g. ``res.bootstrap_distribution.shape[-1] == n_resamples``).
    standard_error : float or ndarray
        The bootstrap standard error, that is, the sample standard
        deviation of the bootstrap distribution.

Warns
-----
`~scipy.stats.DegenerateDataWarning`
    Generated when ``method='BCa'`` and the bootstrap distribution is
    degenerate (e.g. all elements are identical).

Notes
-----
Elements of the confidence interval may be NaN for ``method='BCa'`` if
the bootstrap distribution is degenerate (e.g. all elements are identical).
In this case, consider using another `method` or inspecting `data` for
indications that other analysis may be more appropriate (e.g. all
observations are identical).

References
----------
.. [1] B. Efron and R. J. Tibshirani, An Introduction to the Bootstrap,
   Chapman & Hall/CRC, Boca Raton, FL, USA (1993)
.. [2] Nathaniel E. Helwig, "Bootstrap Confidence Intervals",
   http://users.stat.umn.edu/~helwig/notes/bootci-Notes.pdf
.. [3] Bootstrapping (statistics), Wikipedia,
   https://en.wikipedia.org/wiki/Bootstrapping_%28statistics%29

Examples
--------
Suppose we have sampled data from an unknown distribution.

>>> import numpy as np
>>> rng = np.random.default_rng()
>>> from scipy.stats import norm
>>> dist = norm(loc=2, scale=4)  # our "unknown" distribution
>>> data = dist.rvs(size=100, random_state=rng)

We are interested in the standard deviation of the distribution.

>>> std_true = dist.std()      # the true value of the statistic
>>> print(std_true)
4.0
>>> std_sample = np.std(data)  # the sample statistic
>>> print(std_sample)
3.9460644295563863

The bootstrap is used to approximate the variability we would expect if we
were to repeatedly sample from the unknown distribution and calculate the
statistic of the sample each time. It does this by repeatedly resampling
values *from the original sample* with replacement and calculating the
statistic of each resample. This results in a "bootstrap distribution" of
the statistic.

>>> import matplotlib.pyplot as plt
>>> from scipy.stats import bootstrap
>>> data = (data,)  # samples must be in a sequence
>>> res = bootstrap(data, np.std, confidence_level=0.9,
...                 random_state=rng)
>>> fig, ax = plt.subplots()
>>> ax.hist(res.bootstrap_distribution, bins=25)
>>> ax.set_title('Bootstrap Distribution')
>>> ax.set_xlabel('statistic value')
>>> ax.set_ylabel('frequency')
>>> plt.show()

The standard error quantifies this variability. It is calculated as the
standard deviation of the bootstrap distribution.

>>> res.standard_error
0.24427002125829136
>>> res.standard_error == np.std(res.bootstrap_distribution, ddof=1)
True

The bootstrap distribution of the statistic is often approximately normal
with scale equal to the standard error.

>>> x = np.linspace(3, 5)
>>> pdf = norm.pdf(x, loc=std_sample, scale=res.standard_error)
>>> fig, ax = plt.subplots()
>>> ax.hist(res.bootstrap_distribution, bins=25, density=True)
>>> ax.plot(x, pdf)
>>> ax.set_title('Normal Approximation of the Bootstrap Distribution')
>>> ax.set_xlabel('statistic value')
>>> ax.set_ylabel('pdf')
>>> plt.show()

This suggests that we could construct a 90% confidence interval on the
statistic based on quantiles of this normal distribution.

>>> norm.interval(0.9, loc=std_sample, scale=res.standard_error)
(3.5442759991341726, 4.3478528599786)

Due to central limit theorem, this normal approximation is accurate for a
variety of statistics and distributions underlying the samples; however,
the approximation is not reliable in all cases. Because `bootstrap` is
designed to work with arbitrary underlying distributions and statistics,
it uses more advanced techniques to generate an accurate confidence
interval.

>>> print(res.confidence_interval)
ConfidenceInterval(low=3.57655333533867, high=4.382043696342881)

If we sample from the original distribution 1000 times and form a bootstrap
confidence interval for each sample, the confidence interval
contains the true value of the statistic approximately 90% of the time.

>>> n_trials = 1000
>>> ci_contains_true_std = 0
>>> for i in range(n_trials):
...    data = (dist.rvs(size=100, random_state=rng),)
...    ci = bootstrap(data, np.std, confidence_level=0.9, n_resamples=1000,
...                   random_state=rng).confidence_interval
...    if ci[0] < std_true < ci[1]:
...        ci_contains_true_std += 1
>>> print(ci_contains_true_std)
875

Rather than writing a loop, we can also determine the confidence intervals
for all 1000 samples at once.

>>> data = (dist.rvs(size=(n_trials, 100), random_state=rng),)
>>> res = bootstrap(data, np.std, axis=-1, confidence_level=0.9,
...                 n_resamples=1000, random_state=rng)
>>> ci_l, ci_u = res.confidence_interval

Here, `ci_l` and `ci_u` contain the confidence interval for each of the
``n_trials = 1000`` samples.

>>> print(ci_l[995:])
[3.77729695 3.75090233 3.45829131 3.34078217 3.48072829]
>>> print(ci_u[995:])
[4.88316666 4.86924034 4.32032996 4.2822427  4.59360598]

And again, approximately 90% contain the true value, ``std_true = 4``.

>>> print(np.sum((ci_l < std_true) & (std_true < ci_u)))
900

`bootstrap` can also be used to estimate confidence intervals of
multi-sample statistics, including those calculated by hypothesis
tests. `scipy.stats.mood` perform's Mood's test for equal scale parameters,
and it returns two outputs: a statistic, and a p-value. To get a
confidence interval for the test statistic, we first wrap
`scipy.stats.mood` in a function that accepts two sample arguments,
accepts an `axis` keyword argument, and returns only the statistic.

>>> from scipy.stats import mood
>>> def my_statistic(sample1, sample2, axis):
...     statistic, _ = mood(sample1, sample2, axis=-1)
...     return statistic

Here, we use the 'percentile' method with the default 95% confidence level.

>>> sample1 = norm.rvs(scale=1, size=100, random_state=rng)
>>> sample2 = norm.rvs(scale=2, size=100, random_state=rng)
>>> data = (sample1, sample2)
>>> res = bootstrap(data, my_statistic, method='basic', random_state=rng)
>>> print(mood(sample1, sample2)[0])  # element 0 is the statistic
-5.521109549096542
>>> print(res.confidence_interval)
ConfidenceInterval(low=-7.255994487314675, high=-4.016202624747605)

The bootstrap estimate of the standard error is also available.

>>> print(res.standard_error)
0.8344963846318795

Paired-sample statistics work, too. For example, consider the Pearson
correlation coefficient.

>>> from scipy.stats import pearsonr
>>> n = 100
>>> x = np.linspace(0, 10, n)
>>> y = x + rng.uniform(size=n)
>>> print(pearsonr(x, y)[0])  # element 0 is the statistic
0.9962357936065914

We wrap `pearsonr` so that it returns only the statistic.

>>> def my_statistic(x, y):
...     return pearsonr(x, y)[0]

We call `bootstrap` using ``paired=True``.
Also, since ``my_statistic`` isn't vectorized to calculate the statistic
along a given axis, we pass in ``vectorized=False``.

>>> res = bootstrap((x, y), my_statistic, vectorized=False, paired=True,
...                 random_state=rng)
>>> print(res.confidence_interval)
ConfidenceInterval(low=0.9950085825848624, high=0.9971212407917498)

The result object can be passed back into `bootstrap` to perform additional
resampling:

>>> len(res.bootstrap_distribution)
9999
>>> res = bootstrap((x, y), my_statistic, vectorized=False, paired=True,
...                 n_resamples=1001, random_state=rng,
...                 bootstrap_result=res)
>>> len(res.bootstrap_distribution)
11000

or to change the confidence interval options:

>>> res2 = bootstrap((x, y), my_statistic, vectorized=False, paired=True,
...                  n_resamples=0, random_state=rng, bootstrap_result=res,
...                  method='percentile', confidence_level=0.9)
>>> np.testing.assert_equal(res2.bootstrap_distribution,
...                         res.bootstrap_distribution)
>>> res.confidence_interval
ConfidenceInterval(low=0.9950035351407804, high=0.9971170323404578)

without repeating computation of the original bootstrap distribution.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__resampling_8py_source_l00279}{279}} of file \mbox{\hyperlink{__resampling_8py_source}{\+\_\+resampling.\+py}}.



References \mbox{\hyperlink{__resampling_8py_source_l00108}{\+\_\+bca\+\_\+interval()}}, \mbox{\hyperlink{__resampling_8py_source_l00161}{\+\_\+bootstrap\+\_\+iv()}}, and \mbox{\hyperlink{__resampling_8py_source_l00062}{\+\_\+bootstrap\+\_\+resample()}}.

\Hypertarget{namespacescipy_1_1stats_1_1__resampling_a5486c49c316587dae5db7b43deef6ce9}\index{scipy.stats.\_resampling@{scipy.stats.\_resampling}!monte\_carlo\_test@{monte\_carlo\_test}}
\index{monte\_carlo\_test@{monte\_carlo\_test}!scipy.stats.\_resampling@{scipy.stats.\_resampling}}
\doxysubsubsection{\texorpdfstring{monte\_carlo\_test()}{monte\_carlo\_test()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1stats_1_1__resampling_a5486c49c316587dae5db7b43deef6ce9} 
scipy.\+stats.\+\_\+resampling.\+monte\+\_\+carlo\+\_\+test (\begin{DoxyParamCaption}\item[{}]{data}{, }\item[{}]{rvs}{, }\item[{}]{statistic}{, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{vectorized}{ = {\ttfamily None}, }\item[{}]{n\+\_\+resamples}{ = {\ttfamily 9999}, }\item[{}]{batch}{ = {\ttfamily None}, }\item[{}]{alternative}{ = {\ttfamily "{}two-\/sided"{}}, }\item[{}]{axis}{ = {\ttfamily 0}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Perform a Monte Carlo hypothesis test.

`data` contains a sample or a sequence of one or more samples. `rvs`
specifies the distribution(s) of the sample(s) in `data` under the null
hypothesis. The value of `statistic` for the given `data` is compared
against a Monte Carlo null distribution: the value of the statistic for
each of `n_resamples` sets of samples generated using `rvs`. This gives
the p-value, the probability of observing such an extreme value of the
test statistic under the null hypothesis.

Parameters
----------
data : array-like or sequence of array-like
    An array or sequence of arrays of observations.
rvs : callable or tuple of callables
    A callable or sequence of callables that generates random variates
    under the null hypothesis. Each element of `rvs` must be a callable
    that accepts keyword argument ``size`` (e.g. ``rvs(size=(m, n))``) and
    returns an N-d array sample of that shape. If `rvs` is a sequence, the
    number of callables in `rvs` must match the number of samples in
    `data`, i.e. ``len(rvs) == len(data)``. If `rvs` is a single callable,
    `data` is treated as a single sample.
statistic : callable
    Statistic for which the p-value of the hypothesis test is to be
    calculated. `statistic` must be a callable that accepts a sample
    (e.g. ``statistic(sample)``) or ``len(rvs)`` separate samples (e.g.
    ``statistic(samples1, sample2)`` if `rvs` contains two callables and
    `data` contains two samples) and returns the resulting statistic.
    If `vectorized` is set ``True``, `statistic` must also accept a keyword
    argument `axis` and be vectorized to compute the statistic along the
    provided `axis` of the samples in `data`.
vectorized : bool, optional
    If `vectorized` is set ``False``, `statistic` will not be passed
    keyword argument `axis` and is expected to calculate the statistic
    only for 1D samples. If ``True``, `statistic` will be passed keyword
    argument `axis` and is expected to calculate the statistic along `axis`
    when passed ND sample arrays. If ``None`` (default), `vectorized`
    will be set ``True`` if ``axis`` is a parameter of `statistic`. Use of
    a vectorized statistic typically reduces computation time.
n_resamples : int, default: 9999
    Number of samples drawn from each of the callables of `rvs`.
    Equivalently, the number statistic values under the null hypothesis
    used as the Monte Carlo null distribution.
batch : int, optional
    The number of Monte Carlo samples to process in each call to
    `statistic`. Memory usage is O(`batch`*``sample.size[axis]``). Default
    is ``None``, in which case `batch` equals `n_resamples`.
alternative : {'two-sided', 'less', 'greater'}
    The alternative hypothesis for which the p-value is calculated.
    For each alternative, the p-value is defined as follows.

    - ``'greater'`` : the percentage of the null distribution that is
      greater than or equal to the observed value of the test statistic.
    - ``'less'`` : the percentage of the null distribution that is
      less than or equal to the observed value of the test statistic.
    - ``'two-sided'`` : twice the smaller of the p-values above.

axis : int, default: 0
    The axis of `data` (or each sample within `data`) over which to
    calculate the statistic.

Returns
-------
res : MonteCarloTestResult
    An object with attributes:

    statistic : float or ndarray
        The test statistic of the observed `data`.
    pvalue : float or ndarray
        The p-value for the given alternative.
    null_distribution : ndarray
        The values of the test statistic generated under the null
        hypothesis.

References
----------

.. [1] B. Phipson and G. K. Smyth. "Permutation P-values Should Never Be
   Zero: Calculating Exact P-values When Permutations Are Randomly Drawn."
   Statistical Applications in Genetics and Molecular Biology 9.1 (2010).

Examples
--------

Suppose we wish to test whether a small sample has been drawn from a normal
distribution. We decide that we will use the skew of the sample as a
test statistic, and we will consider a p-value of 0.05 to be statistically
significant.

>>> import numpy as np
>>> from scipy import stats
>>> def statistic(x, axis):
...     return stats.skew(x, axis)

After collecting our data, we calculate the observed value of the test
statistic.

>>> rng = np.random.default_rng()
>>> x = stats.skewnorm.rvs(a=1, size=50, random_state=rng)
>>> statistic(x, axis=0)
0.12457412450240658

To determine the probability of observing such an extreme value of the
skewness by chance if the sample were drawn from the normal distribution,
we can perform a Monte Carlo hypothesis test. The test will draw many
samples at random from their normal distribution, calculate the skewness
of each sample, and compare our original skewness against this
distribution to determine an approximate p-value.

>>> from scipy.stats import monte_carlo_test
>>> # because our statistic is vectorized, we pass `vectorized=True`
>>> rvs = lambda size: stats.norm.rvs(size=size, random_state=rng)
>>> res = monte_carlo_test(x, rvs, statistic, vectorized=True)
>>> print(res.statistic)
0.12457412450240658
>>> print(res.pvalue)
0.7012

The probability of obtaining a test statistic less than or equal to the
observed value under the null hypothesis is ~70%. This is greater than
our chosen threshold of 5%, so we cannot consider this to be significant
evidence against the null hypothesis.

Note that this p-value essentially matches that of
`scipy.stats.skewtest`, which relies on an asymptotic distribution of a
test statistic based on the sample skewness.

>>> stats.skewtest(x).pvalue
0.6892046027110614

This asymptotic approximation is not valid for small sample sizes, but
`monte_carlo_test` can be used with samples of any size.

>>> x = stats.skewnorm.rvs(a=1, size=7, random_state=rng)
>>> # stats.skewtest(x) would produce an error due to small sample
>>> res = monte_carlo_test(x, rvs, statistic, vectorized=True)

The Monte Carlo distribution of the test statistic is provided for
further investigation.

>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots()
>>> ax.hist(res.null_distribution, bins=50)
>>> ax.set_title("Monte Carlo distribution of test statistic")
>>> ax.set_xlabel("Value of Statistic")
>>> ax.set_ylabel("Frequency")
>>> plt.show()
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__resampling_8py_source_l00743}{743}} of file \mbox{\hyperlink{__resampling_8py_source}{\+\_\+resampling.\+py}}.



References \mbox{\hyperlink{__resampling_8py_source_l00664}{\+\_\+monte\+\_\+carlo\+\_\+test\+\_\+iv()}}.

\Hypertarget{namespacescipy_1_1stats_1_1__resampling_a2121e61e3b44b91dd340f938469b5b38}\index{scipy.stats.\_resampling@{scipy.stats.\_resampling}!permutation\_test@{permutation\_test}}
\index{permutation\_test@{permutation\_test}!scipy.stats.\_resampling@{scipy.stats.\_resampling}}
\doxysubsubsection{\texorpdfstring{permutation\_test()}{permutation\_test()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1stats_1_1__resampling_a2121e61e3b44b91dd340f938469b5b38} 
scipy.\+stats.\+\_\+resampling.\+permutation\+\_\+test (\begin{DoxyParamCaption}\item[{}]{data}{, }\item[{}]{statistic}{, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{permutation\+\_\+type}{ = {\ttfamily \textquotesingle{}independent\textquotesingle{}}, }\item[{}]{vectorized}{ = {\ttfamily None}, }\item[{}]{n\+\_\+resamples}{ = {\ttfamily 9999}, }\item[{}]{batch}{ = {\ttfamily None}, }\item[{}]{alternative}{ = {\ttfamily "{}two-\/sided"{}}, }\item[{}]{axis}{ = {\ttfamily 0}, }\item[{}]{random\+\_\+state}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Performs a permutation test of a given statistic on provided data.

For independent sample statistics, the null hypothesis is that the data are
randomly sampled from the same distribution.
For paired sample statistics, two null hypothesis can be tested:
that the data are paired at random or that the data are assigned to samples
at random.

Parameters
----------
data : iterable of array-like
Contains the samples, each of which is an array of observations.
Dimensions of sample arrays must be compatible for broadcasting except
along `axis`.
statistic : callable
Statistic for which the p-value of the hypothesis test is to be
calculated. `statistic` must be a callable that accepts samples
as separate arguments (e.g. ``statistic(*data)``) and returns the
resulting statistic.
If `vectorized` is set ``True``, `statistic` must also accept a keyword
argument `axis` and be vectorized to compute the statistic along the
provided `axis` of the sample arrays.
permutation_type : {'independent', 'samples', 'pairings'}, optional
The type of permutations to be performed, in accordance with the
null hypothesis. The first two permutation types are for paired sample
statistics, in which all samples contain the same number of
observations and observations with corresponding indices along `axis`
are considered to be paired; the third is for independent sample
statistics.

- ``'samples'`` : observations are assigned to different samples
but remain paired with the same observations from other samples.
This permutation type is appropriate for paired sample hypothesis
tests such as the Wilcoxon signed-rank test and the paired t-test.
- ``'pairings'`` : observations are paired with different observations,
but they remain within the same sample. This permutation type is
appropriate for association/correlation tests with statistics such
as Spearman's :math:`\rho`, Kendall's :math:`\tau`, and Pearson's
:math:`r`.
- ``'independent'`` (default) : observations are assigned to different
samples. Samples may contain different numbers of observations. This
permutation type is appropriate for independent sample hypothesis
tests such as the Mann-Whitney :math:`U` test and the independent
sample t-test.

Please see the Notes section below for more detailed descriptions
of the permutation types.

vectorized : bool, optional
If `vectorized` is set ``False``, `statistic` will not be passed
keyword argument `axis` and is expected to calculate the statistic
only for 1D samples. If ``True``, `statistic` will be passed keyword
argument `axis` and is expected to calculate the statistic along `axis`
when passed an ND sample array. If ``None`` (default), `vectorized`
will be set ``True`` if ``axis`` is a parameter of `statistic`. Use
of a vectorized statistic typically reduces computation time.
n_resamples : int or np.inf, default: 9999
Number of random permutations (resamples) used to approximate the null
distribution. If greater than or equal to the number of distinct
permutations, the exact null distribution will be computed.
Note that the number of distinct permutations grows very rapidly with
the sizes of samples, so exact tests are feasible only for very small
data sets.
batch : int, optional
The number of permutations to process in each call to `statistic`.
Memory usage is O(`batch`*``n``), where ``n`` is the total size
of all samples, regardless of the value of `vectorized`. Default is
``None``, in which case ``batch`` is the number of permutations.
alternative : {'two-sided', 'less', 'greater'}, optional
The alternative hypothesis for which the p-value is calculated.
For each alternative, the p-value is defined for exact tests as
follows.

- ``'greater'`` : the percentage of the null distribution that is
greater than or equal to the observed value of the test statistic.
- ``'less'`` : the percentage of the null distribution that is
less than or equal to the observed value of the test statistic.
- ``'two-sided'`` (default) : twice the smaller of the p-values above.

Note that p-values for randomized tests are calculated according to the
conservative (over-estimated) approximation suggested in [2]_ and [3]_
rather than the unbiased estimator suggested in [4]_. That is, when
calculating the proportion of the randomized null distribution that is
as extreme as the observed value of the test statistic, the values in
the numerator and denominator are both increased by one. An
interpretation of this adjustment is that the observed value of the
test statistic is always included as an element of the randomized
null distribution.
The convention used for two-sided p-values is not universal;
the observed test statistic and null distribution are returned in
case a different definition is preferred.

axis : int, default: 0
The axis of the (broadcasted) samples over which to calculate the
statistic. If samples have a different number of dimensions,
singleton dimensions are prepended to samples with fewer dimensions
before `axis` is considered.
random_state : {None, int, `numpy.random.Generator`,
`numpy.random.RandomState`}, optional

Pseudorandom number generator state used to generate permutations.

If `random_state` is ``None`` (default), the
`numpy.random.RandomState` singleton is used.
If `random_state` is an int, a new ``RandomState`` instance is used,
seeded with `random_state`.
If `random_state` is already a ``Generator`` or ``RandomState``
instance then that instance is used.

Returns
-------
res : PermutationTestResult
An object with attributes:

statistic : float or ndarray
The observed test statistic of the data.
pvalue : float or ndarray
The p-value for the given alternative.
null_distribution : ndarray
The values of the test statistic generated under the null
hypothesis.

Notes
-----

The three types of permutation tests supported by this function are
described below.

**Unpaired statistics** (``permutation_type='independent'``):

The null hypothesis associated with this permutation type is that all
observations are sampled from the same underlying distribution and that
they have been assigned to one of the samples at random.

Suppose ``data`` contains two samples; e.g. ``a, b = data``.
When ``1 < n_resamples < binom(n, k)``, where

* ``k`` is the number of observations in ``a``,
* ``n`` is the total number of observations in ``a`` and ``b``, and
* ``binom(n, k)`` is the binomial coefficient (``n`` choose ``k``),

the data are pooled (concatenated), randomly assigned to either the first
or second sample, and the statistic is calculated. This process is
performed repeatedly, `permutation` times, generating a distribution of the
statistic under the null hypothesis. The statistic of the original
data is compared to this distribution to determine the p-value.

When ``n_resamples >= binom(n, k)``, an exact test is performed: the data
are *partitioned* between the samples in each distinct way exactly once,
and the exact null distribution is formed.
Note that for a given partitioning of the data between the samples,
only one ordering/permutation of the data *within* each sample is
considered. For statistics that do not depend on the order of the data
within samples, this dramatically reduces computational cost without
affecting the shape of the null distribution (because the frequency/count
of each value is affected by the same factor).

For ``a = [a1, a2, a3, a4]`` and ``b = [b1, b2, b3]``, an example of this
permutation type is ``x = [b3, a1, a2, b2]`` and ``y = [a4, b1, a3]``.
Because only one ordering/permutation of the data *within* each sample
is considered in an exact test, a resampling like ``x = [b3, a1, b2, a2]``
and ``y = [a4, a3, b1]`` would *not* be considered distinct from the
example above.

``permutation_type='independent'`` does not support one-sample statistics,
but it can be applied to statistics with more than two samples. In this
case, if ``n`` is an array of the number of observations within each
sample, the number of distinct partitions is::

np.prod([binom(sum(n[i:]), sum(n[i+1:])) for i in range(len(n)-1)])

**Paired statistics, permute pairings** (``permutation_type='pairings'``):

The null hypothesis associated with this permutation type is that
observations within each sample are drawn from the same underlying
distribution and that pairings with elements of other samples are
assigned at random.

Suppose ``data`` contains only one sample; e.g. ``a, = data``, and we
wish to consider all possible pairings of elements of ``a`` with elements
of a second sample, ``b``. Let ``n`` be the number of observations in
``a``, which must also equal the number of observations in ``b``.

When ``1 < n_resamples < factorial(n)``, the elements of ``a`` are
randomly permuted. The user-supplied statistic accepts one data argument,
say ``a_perm``, and calculates the statistic considering ``a_perm`` and
``b``. This process is performed repeatedly, `permutation` times,
generating a distribution of the statistic under the null hypothesis.
The statistic of the original data is compared to this distribution to
determine the p-value.

When ``n_resamples >= factorial(n)``, an exact test is performed:
``a`` is permuted in each distinct way exactly once. Therefore, the
`statistic` is computed for each unique pairing of samples between ``a``
and ``b`` exactly once.

For ``a = [a1, a2, a3]`` and ``b = [b1, b2, b3]``, an example of this
permutation type is ``a_perm = [a3, a1, a2]`` while ``b`` is left
in its original order.

``permutation_type='pairings'`` supports ``data`` containing any number
of samples, each of which must contain the same number of observations.
All samples provided in ``data`` are permuted *independently*. Therefore,
if ``m`` is the number of samples and ``n`` is the number of observations
within each sample, then the number of permutations in an exact test is::

factorial(n)**m

Note that if a two-sample statistic, for example, does not inherently
depend on the order in which observations are provided - only on the
*pairings* of observations - then only one of the two samples should be
provided in ``data``. This dramatically reduces computational cost without
affecting the shape of the null distribution (because the frequency/count
of each value is affected by the same factor).

**Paired statistics, permute samples** (``permutation_type='samples'``):

The null hypothesis associated with this permutation type is that
observations within each pair are drawn from the same underlying
distribution and that the sample to which they are assigned is random.

Suppose ``data`` contains two samples; e.g. ``a, b = data``.
Let ``n`` be the number of observations in ``a``, which must also equal
the number of observations in ``b``.

When ``1 < n_resamples < 2**n``, the elements of ``a`` are ``b`` are
randomly swapped between samples (maintaining their pairings) and the
statistic is calculated. This process is performed repeatedly,
`permutation` times,  generating a distribution of the statistic under the
null hypothesis. The statistic of the original data is compared to this
distribution to determine the p-value.

When ``n_resamples >= 2**n``, an exact test is performed: the observations
are assigned to the two samples in each distinct way (while maintaining
pairings) exactly once.

For ``a = [a1, a2, a3]`` and ``b = [b1, b2, b3]``, an example of this
permutation type is ``x = [b1, a2, b3]`` and ``y = [a1, b2, a3]``.

``permutation_type='samples'`` supports ``data`` containing any number
of samples, each of which must contain the same number of observations.
If ``data`` contains more than one sample, paired observations within
``data`` are exchanged between samples *independently*. Therefore, if ``m``
is the number of samples and ``n`` is the number of observations within
each sample, then the number of permutations in an exact test is::

factorial(m)**n

Several paired-sample statistical tests, such as the Wilcoxon signed rank
test and paired-sample t-test, can be performed considering only the
*difference* between two paired elements. Accordingly, if ``data`` contains
only one sample, then the null distribution is formed by independently
changing the *sign* of each observation.

.. warning::
The p-value is calculated by counting the elements of the null
distribution that are as extreme or more extreme than the observed
value of the statistic. Due to the use of finite precision arithmetic,
some statistic functions return numerically distinct values when the
theoretical values would be exactly equal. In some cases, this could
lead to a large error in the calculated p-value. `permutation_test`
guards against this by considering elements in the null distribution
that are "close" (within a factor of ``1+1e-14``) to the observed
value of the test statistic as equal to the observed value of the
test statistic. However, the user is advised to inspect the null
distribution to assess whether this method of comparison is
appropriate, and if not, calculate the p-value manually. See example
below.

References
----------

.. [1] R. A. Fisher. The Design of Experiments, 6th Ed (1951).
.. [2] B. Phipson and G. K. Smyth. "Permutation P-values Should Never Be
Zero: Calculating Exact P-values When Permutations Are Randomly Drawn."
Statistical Applications in Genetics and Molecular Biology 9.1 (2010).
.. [3] M. D. Ernst. "Permutation Methods: A Basis for Exact Inference".
Statistical Science (2004).
.. [4] B. Efron and R. J. Tibshirani. An Introduction to the Bootstrap
(1993).

Examples
--------

Suppose we wish to test whether two samples are drawn from the same
distribution. Assume that the underlying distributions are unknown to us,
and that before observing the data, we hypothesized that the mean of the
first sample would be less than that of the second sample. We decide that
we will use the difference between the sample means as a test statistic,
and we will consider a p-value of 0.05 to be statistically significant.

For efficiency, we write the function defining the test statistic in a
vectorized fashion: the samples ``x`` and ``y`` can be ND arrays, and the
statistic will be calculated for each axis-slice along `axis`.

>>> import numpy as np
>>> def statistic(x, y, axis):
...     return np.mean(x, axis=axis) - np.mean(y, axis=axis)

After collecting our data, we calculate the observed value of the test
statistic.

>>> from scipy.stats import norm
>>> rng = np.random.default_rng()
>>> x = norm.rvs(size=5, random_state=rng)
>>> y = norm.rvs(size=6, loc = 3, random_state=rng)
>>> statistic(x, y, 0)
-3.5411688580987266

Indeed, the test statistic is negative, suggesting that the true mean of
the distribution underlying ``x`` is less than that of the distribution
underlying ``y``. To determine the probability of this occuring by chance
if the two samples were drawn from the same distribution, we perform
a permutation test.

>>> from scipy.stats import permutation_test
>>> # because our statistic is vectorized, we pass `vectorized=True`
>>> # `n_resamples=np.inf` indicates that an exact test is to be performed
>>> res = permutation_test((x, y), statistic, vectorized=True,
...                        n_resamples=np.inf, alternative='less')
>>> print(res.statistic)
-3.5411688580987266
>>> print(res.pvalue)
0.004329004329004329

The probability of obtaining a test statistic less than or equal to the
observed value under the null hypothesis is 0.4329%. This is less than our
chosen threshold of 5%, so we consider this to be significant evidence
against the null hypothesis in favor of the alternative.

Because the size of the samples above was small, `permutation_test` could
perform an exact test. For larger samples, we resort to a randomized
permutation test.

>>> x = norm.rvs(size=100, random_state=rng)
>>> y = norm.rvs(size=120, loc=0.3, random_state=rng)
>>> res = permutation_test((x, y), statistic, n_resamples=100000,
...                        vectorized=True, alternative='less',
...                        random_state=rng)
>>> print(res.statistic)
-0.5230459671240913
>>> print(res.pvalue)
0.00016999830001699983

The approximate probability of obtaining a test statistic less than or
equal to the observed value under the null hypothesis is 0.0225%. This is
again less than our chosen threshold of 5%, so again we have significant
evidence to reject the null hypothesis in favor of the alternative.

For large samples and number of permutations, the result is comparable to
that of the corresponding asymptotic test, the independent sample t-test.

>>> from scipy.stats import ttest_ind
>>> res_asymptotic = ttest_ind(x, y, alternative='less')
>>> print(res_asymptotic.pvalue)
0.00012688101537979522

The permutation distribution of the test statistic is provided for
further investigation.

>>> import matplotlib.pyplot as plt
>>> plt.hist(res.null_distribution, bins=50)
>>> plt.title("Permutation distribution of test statistic")
>>> plt.xlabel("Value of Statistic")
>>> plt.ylabel("Frequency")
>>> plt.show()

Inspection of the null distribution is essential if the statistic suffers
from inaccuracy due to limited machine precision. Consider the following
case:

>>> from scipy.stats import pearsonr
>>> x = [1, 2, 4, 3]
>>> y = [2, 4, 6, 8]
>>> def statistic(x, y):
...     return pearsonr(x, y).statistic
>>> res = permutation_test((x, y), statistic, vectorized=False,
...                        permutation_type='pairings',
...                        alternative='greater')
>>> r, pvalue, null = res.statistic, res.pvalue, res.null_distribution

In this case, some elements of the null distribution differ from the
observed value of the correlation coefficient ``r`` due to numerical noise.
We manually inspect the elements of the null distribution that are nearly
the same as the observed value of the test statistic.

>>> r
0.8
>>> unique = np.unique(null)
>>> unique
array([-1. , -0.8, -0.8, -0.6, -0.4, -0.2, -0.2,  0. ,  0.2,  0.2,  0.4,
0.6,  0.8,  0.8,  1. ]) # may vary
>>> unique[np.isclose(r, unique)].tolist()
[0.7999999999999999, 0.8]

If `permutation_test` were to perform the comparison naively, the
elements of the null distribution with value ``0.7999999999999999`` would
not be considered as extreme or more extreme as the observed value of the
statistic, so the calculated p-value would be too small.

>>> incorrect_pvalue = np.count_nonzero(null >= r) / len(null)
>>> incorrect_pvalue
0.1111111111111111  # may vary

Instead, `permutation_test` treats elements of the null distribution that
are within ``max(1e-14, abs(r)*1e-14)`` of the observed value of the
statistic ``r`` to be equal to ``r``.

>>> correct_pvalue = np.count_nonzero(null >= r - 1e-14) / len(null)
>>> correct_pvalue
0.16666666666666666
>>> res.pvalue == correct_pvalue
True

This method of comparison is expected to be accurate in most practical
situations, but the user is advised to assess this by inspecting the
elements of the null distribution that are close to the observed value
of the statistic. Also, consider the use of statistics that can be
calculated using exact arithmetic (e.g. integer statistics).
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__resampling_8py_source_l01234}{1234}} of file \mbox{\hyperlink{__resampling_8py_source}{\+\_\+resampling.\+py}}.



References \mbox{\hyperlink{__resampling_8py_source_l01173}{\+\_\+permutation\+\_\+test\+\_\+iv()}}.



\doxysubsection{Variable Documentation}
\Hypertarget{namespacescipy_1_1stats_1_1__resampling_a1006fe52525dfb2a6ab2e9f48fbe5263}\index{scipy.stats.\_resampling@{scipy.stats.\_resampling}!\_\_all\_\_@{\_\_all\_\_}}
\index{\_\_all\_\_@{\_\_all\_\_}!scipy.stats.\_resampling@{scipy.stats.\_resampling}}
\doxysubsubsection{\texorpdfstring{\_\_all\_\_}{\_\_all\_\_}}
{\footnotesize\ttfamily \label{namespacescipy_1_1stats_1_1__resampling_a1006fe52525dfb2a6ab2e9f48fbe5263} 
list scipy.\+stats.\+\_\+resampling.\+\_\+\+\_\+all\+\_\+\+\_\+ = \mbox{[}\textquotesingle{}\mbox{\hyperlink{namespacescipy_1_1stats_1_1__resampling_a6c3d395af56f8cabdf385cf951cbc52d}{bootstrap}}\textquotesingle{}, \textquotesingle{}\mbox{\hyperlink{namespacescipy_1_1stats_1_1__resampling_a5486c49c316587dae5db7b43deef6ce9}{monte\+\_\+carlo\+\_\+test}}\textquotesingle{}, \textquotesingle{}\mbox{\hyperlink{namespacescipy_1_1stats_1_1__resampling_a2121e61e3b44b91dd340f938469b5b38}{permutation\+\_\+test}}\textquotesingle{}\mbox{]}\hspace{0.3cm}{\ttfamily [private]}}



Definition at line \mbox{\hyperlink{__resampling_8py_source_l00017}{17}} of file \mbox{\hyperlink{__resampling_8py_source}{\+\_\+resampling.\+py}}.

