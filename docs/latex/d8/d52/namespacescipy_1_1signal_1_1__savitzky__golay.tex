\doxysection{scipy.\+signal.\+\_\+savitzky\+\_\+golay Namespace Reference}
\hypertarget{namespacescipy_1_1signal_1_1__savitzky__golay}{}\label{namespacescipy_1_1signal_1_1__savitzky__golay}\index{scipy.signal.\_savitzky\_golay@{scipy.signal.\_savitzky\_golay}}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__savitzky__golay_a334d89059a23334b13110b895be8e817}{savgol\+\_\+coeffs}} (window\+\_\+length, polyorder, deriv=0, delta=1.\+0, pos=None, use="{}conv"{})
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__savitzky__golay_a3f196608bec7385e539298873bb73285}{\+\_\+polyder}} (p, m)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__savitzky__golay_a63b8ee013eda9f363176bf815bae1cd5}{\+\_\+fit\+\_\+edge}} (x, window\+\_\+start, window\+\_\+stop, interp\+\_\+start, interp\+\_\+stop, axis, polyorder, deriv, delta, y)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__savitzky__golay_ae9ed443b53143c6f6fffca100ce768c4}{\+\_\+fit\+\_\+edges\+\_\+polyfit}} (x, window\+\_\+length, polyorder, deriv, delta, axis, y)
\item 
\mbox{\hyperlink{namespacescipy_1_1signal_1_1__savitzky__golay_a319c808a5a1752894b70a11bea1f6681}{savgol\+\_\+filter}} (x, window\+\_\+length, polyorder, deriv=0, delta=1.\+0, axis=-\/1, mode=\textquotesingle{}interp\textquotesingle{}, cval=0.\+0)
\end{DoxyCompactItemize}


\doxysubsection{Function Documentation}
\Hypertarget{namespacescipy_1_1signal_1_1__savitzky__golay_a63b8ee013eda9f363176bf815bae1cd5}\index{scipy.signal.\_savitzky\_golay@{scipy.signal.\_savitzky\_golay}!\_fit\_edge@{\_fit\_edge}}
\index{\_fit\_edge@{\_fit\_edge}!scipy.signal.\_savitzky\_golay@{scipy.signal.\_savitzky\_golay}}
\doxysubsubsection{\texorpdfstring{\_fit\_edge()}{\_fit\_edge()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__savitzky__golay_a63b8ee013eda9f363176bf815bae1cd5} 
scipy.\+signal.\+\_\+savitzky\+\_\+golay.\+\_\+fit\+\_\+edge (\begin{DoxyParamCaption}\item[{}]{x}{, }\item[{}]{window\+\_\+start}{, }\item[{}]{window\+\_\+stop}{, }\item[{}]{interp\+\_\+start}{, }\item[{}]{interp\+\_\+stop}{, }\item[{}]{axis}{, }\item[{}]{polyorder}{, }\item[{}]{deriv}{, }\item[{}]{delta}{, }\item[{}]{y}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Given an N-d array `x` and the specification of a slice of `x` from
`window_start` to `window_stop` along `axis`, create an interpolating
polynomial of each 1-D slice, and evaluate that polynomial in the slice
from `interp_start` to `interp_stop`. Put the result into the
corresponding slice of `y`.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__savitzky__golay_8py_source_l00171}{171}} of file \mbox{\hyperlink{__savitzky__golay_8py_source}{\+\_\+savitzky\+\_\+golay.\+py}}.



References \mbox{\hyperlink{__savitzky__golay_8py_source_l00147}{\+\_\+polyder()}}.



Referenced by \mbox{\hyperlink{__savitzky__golay_8py_source_l00215}{\+\_\+fit\+\_\+edges\+\_\+polyfit()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__savitzky__golay_ae9ed443b53143c6f6fffca100ce768c4}\index{scipy.signal.\_savitzky\_golay@{scipy.signal.\_savitzky\_golay}!\_fit\_edges\_polyfit@{\_fit\_edges\_polyfit}}
\index{\_fit\_edges\_polyfit@{\_fit\_edges\_polyfit}!scipy.signal.\_savitzky\_golay@{scipy.signal.\_savitzky\_golay}}
\doxysubsubsection{\texorpdfstring{\_fit\_edges\_polyfit()}{\_fit\_edges\_polyfit()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__savitzky__golay_ae9ed443b53143c6f6fffca100ce768c4} 
scipy.\+signal.\+\_\+savitzky\+\_\+golay.\+\_\+fit\+\_\+edges\+\_\+polyfit (\begin{DoxyParamCaption}\item[{}]{x}{, }\item[{}]{window\+\_\+length}{, }\item[{}]{polyorder}{, }\item[{}]{deriv}{, }\item[{}]{delta}{, }\item[{}]{axis}{, }\item[{}]{y}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Use polynomial interpolation of x at the low and high ends of the axis
to fill in the halflen values in y.

This function just calls _fit_edge twice, once for each end of the axis.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__savitzky__golay_8py_source_l00215}{215}} of file \mbox{\hyperlink{__savitzky__golay_8py_source}{\+\_\+savitzky\+\_\+golay.\+py}}.



References \mbox{\hyperlink{__savitzky__golay_8py_source_l00172}{\+\_\+fit\+\_\+edge()}}.



Referenced by \mbox{\hyperlink{__savitzky__golay_8py_source_l00231}{savgol\+\_\+filter()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__savitzky__golay_a3f196608bec7385e539298873bb73285}\index{scipy.signal.\_savitzky\_golay@{scipy.signal.\_savitzky\_golay}!\_polyder@{\_polyder}}
\index{\_polyder@{\_polyder}!scipy.signal.\_savitzky\_golay@{scipy.signal.\_savitzky\_golay}}
\doxysubsubsection{\texorpdfstring{\_polyder()}{\_polyder()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__savitzky__golay_a3f196608bec7385e539298873bb73285} 
scipy.\+signal.\+\_\+savitzky\+\_\+golay.\+\_\+polyder (\begin{DoxyParamCaption}\item[{}]{p}{, }\item[{}]{m}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Differentiate polynomials represented with coefficients.

p must be a 1-D or 2-D array.  In the 2-D case, each column gives
the coefficients of a polynomial; the first row holds the coefficients
associated with the highest power. m must be a nonnegative integer.
(numpy.polyder doesn't handle the 2-D case.)
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__savitzky__golay_8py_source_l00147}{147}} of file \mbox{\hyperlink{__savitzky__golay_8py_source}{\+\_\+savitzky\+\_\+golay.\+py}}.



Referenced by \mbox{\hyperlink{__savitzky__golay_8py_source_l00172}{\+\_\+fit\+\_\+edge()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__savitzky__golay_a334d89059a23334b13110b895be8e817}\index{scipy.signal.\_savitzky\_golay@{scipy.signal.\_savitzky\_golay}!savgol\_coeffs@{savgol\_coeffs}}
\index{savgol\_coeffs@{savgol\_coeffs}!scipy.signal.\_savitzky\_golay@{scipy.signal.\_savitzky\_golay}}
\doxysubsubsection{\texorpdfstring{savgol\_coeffs()}{savgol\_coeffs()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__savitzky__golay_a334d89059a23334b13110b895be8e817} 
scipy.\+signal.\+\_\+savitzky\+\_\+golay.\+savgol\+\_\+coeffs (\begin{DoxyParamCaption}\item[{}]{window\+\_\+length}{, }\item[{}]{polyorder}{, }\item[{}]{deriv}{ = {\ttfamily 0}, }\item[{}]{delta}{ = {\ttfamily 1.0}, }\item[{}]{pos}{ = {\ttfamily None}, }\item[{}]{use}{ = {\ttfamily "{}conv"{}}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute the coefficients for a 1-D Savitzky-Golay FIR filter.

Parameters
----------
window_length : int
    The length of the filter window (i.e., the number of coefficients).
polyorder : int
    The order of the polynomial used to fit the samples.
    `polyorder` must be less than `window_length`.
deriv : int, optional
    The order of the derivative to compute. This must be a
    nonnegative integer. The default is 0, which means to filter
    the data without differentiating.
delta : float, optional
    The spacing of the samples to which the filter will be applied.
    This is only used if deriv > 0.
pos : int or None, optional
    If pos is not None, it specifies evaluation position within the
    window. The default is the middle of the window.
use : str, optional
    Either 'conv' or 'dot'. This argument chooses the order of the
    coefficients. The default is 'conv', which means that the
    coefficients are ordered to be used in a convolution. With
    use='dot', the order is reversed, so the filter is applied by
    dotting the coefficients with the data set.

Returns
-------
coeffs : 1-D ndarray
    The filter coefficients.

See Also
--------
savgol_filter

Notes
-----
.. versionadded:: 0.14.0

References
----------
A. Savitzky, M. J. E. Golay, Smoothing and Differentiation of Data by
Simplified Least Squares Procedures. Analytical Chemistry, 1964, 36 (8),
pp 1627-1639.
Jianwen Luo, Kui Ying, and Jing Bai. 2005. Savitzky-Golay smoothing and
differentiation filter for even number data. Signal Process.
85, 7 (July 2005), 1429-1434.

Examples
--------
>>> import numpy as np
>>> from scipy.signal import savgol_coeffs
>>> savgol_coeffs(5, 2)
array([-0.08571429,  0.34285714,  0.48571429,  0.34285714, -0.08571429])
>>> savgol_coeffs(5, 2, deriv=1)
array([ 2.00000000e-01,  1.00000000e-01,  2.07548111e-16, -1.00000000e-01,
       -2.00000000e-01])

Note that use='dot' simply reverses the coefficients.

>>> savgol_coeffs(5, 2, pos=3)
array([ 0.25714286,  0.37142857,  0.34285714,  0.17142857, -0.14285714])
>>> savgol_coeffs(5, 2, pos=3, use='dot')
array([-0.14285714,  0.17142857,  0.34285714,  0.37142857,  0.25714286])
>>> savgol_coeffs(4, 2, pos=3, deriv=1, use='dot')
array([0.45,  -0.85,  -0.65,  1.05])

`x` contains data from the parabola x = t**2, sampled at
t = -1, 0, 1, 2, 3.  `c` holds the coefficients that will compute the
derivative at the last position.  When dotted with `x` the result should
be 6.

>>> x = np.array([1, 0, 1, 4, 9])
>>> c = savgol_coeffs(5, 2, pos=4, deriv=1, use='dot')
>>> c.dot(x)
6.0
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__savitzky__golay_8py_source_l00008}{8}} of file \mbox{\hyperlink{__savitzky__golay_8py_source}{\+\_\+savitzky\+\_\+golay.\+py}}.



Referenced by \mbox{\hyperlink{__savitzky__golay_8py_source_l00231}{savgol\+\_\+filter()}}.

\Hypertarget{namespacescipy_1_1signal_1_1__savitzky__golay_a319c808a5a1752894b70a11bea1f6681}\index{scipy.signal.\_savitzky\_golay@{scipy.signal.\_savitzky\_golay}!savgol\_filter@{savgol\_filter}}
\index{savgol\_filter@{savgol\_filter}!scipy.signal.\_savitzky\_golay@{scipy.signal.\_savitzky\_golay}}
\doxysubsubsection{\texorpdfstring{savgol\_filter()}{savgol\_filter()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1signal_1_1__savitzky__golay_a319c808a5a1752894b70a11bea1f6681} 
scipy.\+signal.\+\_\+savitzky\+\_\+golay.\+savgol\+\_\+filter (\begin{DoxyParamCaption}\item[{}]{x}{, }\item[{}]{window\+\_\+length}{, }\item[{}]{polyorder}{, }\item[{}]{deriv}{ = {\ttfamily 0}, }\item[{}]{delta}{ = {\ttfamily 1.0}, }\item[{}]{axis}{ = {\ttfamily -\/1}, }\item[{}]{mode}{ = {\ttfamily \textquotesingle{}interp\textquotesingle{}}, }\item[{}]{cval}{ = {\ttfamily 0.0}}\end{DoxyParamCaption})}

\begin{DoxyVerb} Apply a Savitzky-Golay filter to an array.

This is a 1-D filter. If `x`  has dimension greater than 1, `axis`
determines the axis along which the filter is applied.

Parameters
----------
x : array_like
    The data to be filtered. If `x` is not a single or double precision
    floating point array, it will be converted to type ``numpy.float64``
    before filtering.
window_length : int
    The length of the filter window (i.e., the number of coefficients).
    If `mode` is 'interp', `window_length` must be less than or equal
    to the size of `x`.
polyorder : int
    The order of the polynomial used to fit the samples.
    `polyorder` must be less than `window_length`.
deriv : int, optional
    The order of the derivative to compute. This must be a
    nonnegative integer. The default is 0, which means to filter
    the data without differentiating.
delta : float, optional
    The spacing of the samples to which the filter will be applied.
    This is only used if deriv > 0. Default is 1.0.
axis : int, optional
    The axis of the array `x` along which the filter is to be applied.
    Default is -1.
mode : str, optional
    Must be 'mirror', 'constant', 'nearest', 'wrap' or 'interp'. This
    determines the type of extension to use for the padded signal to
    which the filter is applied.  When `mode` is 'constant', the padding
    value is given by `cval`.  See the Notes for more details on 'mirror',
    'constant', 'wrap', and 'nearest'.
    When the 'interp' mode is selected (the default), no extension
    is used.  Instead, a degree `polyorder` polynomial is fit to the
    last `window_length` values of the edges, and this polynomial is
    used to evaluate the last `window_length // 2` output values.
cval : scalar, optional
    Value to fill past the edges of the input if `mode` is 'constant'.
    Default is 0.0.

Returns
-------
y : ndarray, same shape as `x`
    The filtered data.

See Also
--------
savgol_coeffs

Notes
-----
Details on the `mode` options:

    'mirror':
        Repeats the values at the edges in reverse order. The value
        closest to the edge is not included.
    'nearest':
        The extension contains the nearest input value.
    'constant':
        The extension contains the value given by the `cval` argument.
    'wrap':
        The extension contains the values from the other end of the array.

For example, if the input is [1, 2, 3, 4, 5, 6, 7, 8], and
`window_length` is 7, the following shows the extended data for
the various `mode` options (assuming `cval` is 0)::

    mode       |   Ext   |         Input          |   Ext
    -----------+---------+------------------------+---------
    'mirror'   | 4  3  2 | 1  2  3  4  5  6  7  8 | 7  6  5
    'nearest'  | 1  1  1 | 1  2  3  4  5  6  7  8 | 8  8  8
    'constant' | 0  0  0 | 1  2  3  4  5  6  7  8 | 0  0  0
    'wrap'     | 6  7  8 | 1  2  3  4  5  6  7  8 | 1  2  3

.. versionadded:: 0.14.0

Examples
--------
>>> import numpy as np
>>> from scipy.signal import savgol_filter
>>> np.set_printoptions(precision=2)  # For compact display.
>>> x = np.array([2, 2, 5, 2, 1, 0, 1, 4, 9])

Filter with a window length of 5 and a degree 2 polynomial.  Use
the defaults for all other parameters.

>>> savgol_filter(x, 5, 2)
array([1.66, 3.17, 3.54, 2.86, 0.66, 0.17, 1.  , 4.  , 9.  ])

Note that the last five values in x are samples of a parabola, so
when mode='interp' (the default) is used with polyorder=2, the last
three values are unchanged. Compare that to, for example,
`mode='nearest'`:

>>> savgol_filter(x, 5, 2, mode='nearest')
array([1.74, 3.03, 3.54, 2.86, 0.66, 0.17, 1.  , 4.6 , 7.97])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__savitzky__golay_8py_source_l00230}{230}} of file \mbox{\hyperlink{__savitzky__golay_8py_source}{\+\_\+savitzky\+\_\+golay.\+py}}.



References \mbox{\hyperlink{__savitzky__golay_8py_source_l00215}{\+\_\+fit\+\_\+edges\+\_\+polyfit()}}, and \mbox{\hyperlink{__savitzky__golay_8py_source_l00009}{savgol\+\_\+coeffs()}}.

