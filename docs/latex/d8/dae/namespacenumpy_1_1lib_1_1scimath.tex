\doxysection{numpy.\+lib.\+scimath Namespace Reference}
\hypertarget{namespacenumpy_1_1lib_1_1scimath}{}\label{namespacenumpy_1_1lib_1_1scimath}\index{numpy.lib.scimath@{numpy.lib.scimath}}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1scimath_a0fb330746d901f8829ffd741e07bbb5b}{\+\_\+tocomplex}} (arr)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1scimath_a97855e63e46cf94e565b1db3daede63e}{\+\_\+fix\+\_\+real\+\_\+lt\+\_\+zero}} (x)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1scimath_a7b30cfe05ee64c9bb9253250303e4a94}{\+\_\+fix\+\_\+int\+\_\+lt\+\_\+zero}} (x)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1scimath_ac57da869dd9e8e8f8f25ea16910064b4}{\+\_\+fix\+\_\+real\+\_\+abs\+\_\+gt\+\_\+1}} (x)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1scimath_a69ebe8e98ccffe64d9661716a8472f7a}{\+\_\+unary\+\_\+dispatcher}} (x)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1scimath_acedbf1d49f70de16451705e0e567681a}{sqrt}} (x)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1scimath_af0ffe74a68ad56388318c4f703204fee}{log}} (x)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1scimath_a79780c50c7a0cc5e703e4326cbb9f6c9}{log10}} (x)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1scimath_aba532c10eadb947f0ec7bf2d2242159b}{\+\_\+logn\+\_\+dispatcher}} (n, x)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1scimath_a1531b6253aaa1099a6010033ba408e61}{logn}} (n, x)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1scimath_a233428a708eb23ea44ed30cee5fb65fd}{log2}} (x)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1scimath_a5908564c3021c8b9f16ebae44789da56}{\+\_\+power\+\_\+dispatcher}} (x, p)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1scimath_a755c122e6a7f99c806ba7650e50256f9}{power}} (x, p)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1scimath_a4c226d01188121b6ebbd484591c13e61}{arccos}} (x)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1scimath_a2966b87f716fe51ecfcf3385f8d1ae56}{arcsin}} (x)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1scimath_a69ace8c298e22d7ee9cbb41c55ec3f61}{arctanh}} (x)
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
list \mbox{\hyperlink{namespacenumpy_1_1lib_1_1scimath_a07d3abe3f8eeb3627363e9478ce90c41}{\+\_\+\+\_\+all\+\_\+\+\_\+}}
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1scimath_ac68a53f9e8f4deba3f9960e829b3a95e}{\+\_\+ln2}} = nx.\+log(2.\+0)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\begin{DoxyVerb}Wrapper functions to more user-friendly calling of certain math functions
whose output data-type is different than the input data-type in certain
domains of the input.

For example, for functions like `log` with branch cuts, the versions in this
module provide the mathematically valid answers in the complex plane::

  >>> import math
  >>> np.emath.log(-math.exp(1)) == (1+1j*math.pi)
  True

Similarly, `sqrt`, other base logarithms, `power` and trig functions are
correctly handled.  See their respective docstrings for specific examples.

Functions
---------

.. autosummary::
   :toctree: generated/

   sqrt
   log
   log2
   logn
   log10
   power
   arccos
   arcsin
   arctanh
\end{DoxyVerb}
 

\doxysubsection{Function Documentation}
\Hypertarget{namespacenumpy_1_1lib_1_1scimath_a7b30cfe05ee64c9bb9253250303e4a94}\index{numpy.lib.scimath@{numpy.lib.scimath}!\_fix\_int\_lt\_zero@{\_fix\_int\_lt\_zero}}
\index{\_fix\_int\_lt\_zero@{\_fix\_int\_lt\_zero}!numpy.lib.scimath@{numpy.lib.scimath}}
\doxysubsubsection{\texorpdfstring{\_fix\_int\_lt\_zero()}{\_fix\_int\_lt\_zero()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1scimath_a7b30cfe05ee64c9bb9253250303e4a94} 
numpy.\+lib.\+scimath.\+\_\+fix\+\_\+int\+\_\+lt\+\_\+zero (\begin{DoxyParamCaption}\item[{}]{x}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Convert `x` to double if it has real, negative components.

Otherwise, output is just the array version of the input (via asarray).

Parameters
----------
x : array_like

Returns
-------
array

Examples
--------
>>> np.lib.scimath._fix_int_lt_zero([1,2])
array([1, 2])

>>> np.lib.scimath._fix_int_lt_zero([-1,2])
array([-1.,  2.])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{scimath_8py_source_l00140}{140}} of file \mbox{\hyperlink{scimath_8py_source}{scimath.\+py}}.



References \mbox{\hyperlink{core_2fromnumeric_8py_source_l02323}{numpy.\+core.\+fromnumeric.\+any()}}, and \mbox{\hyperlink{type__check_8py_source_l00247}{numpy.\+lib.\+type\+\_\+check.\+isreal()}}.



Referenced by \mbox{\hyperlink{scimath_8py_source_l00442}{power()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1scimath_ac57da869dd9e8e8f8f25ea16910064b4}\index{numpy.lib.scimath@{numpy.lib.scimath}!\_fix\_real\_abs\_gt\_1@{\_fix\_real\_abs\_gt\_1}}
\index{\_fix\_real\_abs\_gt\_1@{\_fix\_real\_abs\_gt\_1}!numpy.lib.scimath@{numpy.lib.scimath}}
\doxysubsubsection{\texorpdfstring{\_fix\_real\_abs\_gt\_1()}{\_fix\_real\_abs\_gt\_1()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1scimath_ac57da869dd9e8e8f8f25ea16910064b4} 
numpy.\+lib.\+scimath.\+\_\+fix\+\_\+real\+\_\+abs\+\_\+gt\+\_\+1 (\begin{DoxyParamCaption}\item[{}]{x}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Convert `x` to complex if it has real components x_i with abs(x_i)>1.

Otherwise, output is just the array version of the input (via asarray).

Parameters
----------
x : array_like

Returns
-------
array

Examples
--------
>>> np.lib.scimath._fix_real_abs_gt_1([0,1])
array([0, 1])

>>> np.lib.scimath._fix_real_abs_gt_1([0,2])
array([0.+0.j, 2.+0.j])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{scimath_8py_source_l00167}{167}} of file \mbox{\hyperlink{scimath_8py_source}{scimath.\+py}}.



References \mbox{\hyperlink{scimath_8py_source_l00049}{\+\_\+tocomplex()}}, \mbox{\hyperlink{core_2fromnumeric_8py_source_l02323}{numpy.\+core.\+fromnumeric.\+any()}}, and \mbox{\hyperlink{type__check_8py_source_l00247}{numpy.\+lib.\+type\+\_\+check.\+isreal()}}.



Referenced by \mbox{\hyperlink{scimath_8py_source_l00487}{arccos()}}, \mbox{\hyperlink{scimath_8py_source_l00532}{arcsin()}}, and \mbox{\hyperlink{scimath_8py_source_l00578}{arctanh()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1scimath_a97855e63e46cf94e565b1db3daede63e}\index{numpy.lib.scimath@{numpy.lib.scimath}!\_fix\_real\_lt\_zero@{\_fix\_real\_lt\_zero}}
\index{\_fix\_real\_lt\_zero@{\_fix\_real\_lt\_zero}!numpy.lib.scimath@{numpy.lib.scimath}}
\doxysubsubsection{\texorpdfstring{\_fix\_real\_lt\_zero()}{\_fix\_real\_lt\_zero()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1scimath_a97855e63e46cf94e565b1db3daede63e} 
numpy.\+lib.\+scimath.\+\_\+fix\+\_\+real\+\_\+lt\+\_\+zero (\begin{DoxyParamCaption}\item[{}]{x}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Convert `x` to complex if it has real, negative components.

Otherwise, output is just the array version of the input (via asarray).

Parameters
----------
x : array_like

Returns
-------
array

Examples
--------
>>> np.lib.scimath._fix_real_lt_zero([1,2])
array([1, 2])

>>> np.lib.scimath._fix_real_lt_zero([-1,2])
array([-1.+0.j,  2.+0.j])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{scimath_8py_source_l00112}{112}} of file \mbox{\hyperlink{scimath_8py_source}{scimath.\+py}}.



References \mbox{\hyperlink{scimath_8py_source_l00049}{\+\_\+tocomplex()}}, \mbox{\hyperlink{core_2fromnumeric_8py_source_l02323}{numpy.\+core.\+fromnumeric.\+any()}}, and \mbox{\hyperlink{type__check_8py_source_l00247}{numpy.\+lib.\+type\+\_\+check.\+isreal()}}.



Referenced by \mbox{\hyperlink{scimath_8py_source_l00252}{log()}}, \mbox{\hyperlink{scimath_8py_source_l00300}{log10()}}, \mbox{\hyperlink{scimath_8py_source_l00390}{log2()}}, \mbox{\hyperlink{scimath_8py_source_l00354}{logn()}}, \mbox{\hyperlink{scimath_8py_source_l00442}{power()}}, and \mbox{\hyperlink{scimath_8py_source_l00199}{sqrt()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1scimath_aba532c10eadb947f0ec7bf2d2242159b}\index{numpy.lib.scimath@{numpy.lib.scimath}!\_logn\_dispatcher@{\_logn\_dispatcher}}
\index{\_logn\_dispatcher@{\_logn\_dispatcher}!numpy.lib.scimath@{numpy.lib.scimath}}
\doxysubsubsection{\texorpdfstring{\_logn\_dispatcher()}{\_logn\_dispatcher()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1scimath_aba532c10eadb947f0ec7bf2d2242159b} 
numpy.\+lib.\+scimath.\+\_\+logn\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{n}{, }\item[{}]{x}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{scimath_8py_source_l00349}{349}} of file \mbox{\hyperlink{scimath_8py_source}{scimath.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1scimath_a5908564c3021c8b9f16ebae44789da56}\index{numpy.lib.scimath@{numpy.lib.scimath}!\_power\_dispatcher@{\_power\_dispatcher}}
\index{\_power\_dispatcher@{\_power\_dispatcher}!numpy.lib.scimath@{numpy.lib.scimath}}
\doxysubsubsection{\texorpdfstring{\_power\_dispatcher()}{\_power\_dispatcher()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1scimath_a5908564c3021c8b9f16ebae44789da56} 
numpy.\+lib.\+scimath.\+\_\+power\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{x}{, }\item[{}]{p}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{scimath_8py_source_l00437}{437}} of file \mbox{\hyperlink{scimath_8py_source}{scimath.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1scimath_a0fb330746d901f8829ffd741e07bbb5b}\index{numpy.lib.scimath@{numpy.lib.scimath}!\_tocomplex@{\_tocomplex}}
\index{\_tocomplex@{\_tocomplex}!numpy.lib.scimath@{numpy.lib.scimath}}
\doxysubsubsection{\texorpdfstring{\_tocomplex()}{\_tocomplex()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1scimath_a0fb330746d901f8829ffd741e07bbb5b} 
numpy.\+lib.\+scimath.\+\_\+tocomplex (\begin{DoxyParamCaption}\item[{}]{arr}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Convert its input `arr` to a complex array.

The input is returned as a complex array of the smallest type that will fit
the original data: types like single, byte, short, etc. become csingle,
while others become cdouble.

A copy of the input is always made.

Parameters
----------
arr : array

Returns
-------
array
    An array with the same input data as the input but in complex form.

Examples
--------

First, consider an input of type short:

>>> a = np.array([1,2,3],np.short)

>>> ac = np.lib.scimath._tocomplex(a); ac
array([1.+0.j, 2.+0.j, 3.+0.j], dtype=complex64)

>>> ac.dtype
dtype('complex64')

If the input is of type double, the output is correspondingly of the
complex double type as well:

>>> b = np.array([1,2,3],np.double)

>>> bc = np.lib.scimath._tocomplex(b); bc
array([1.+0.j, 2.+0.j, 3.+0.j])

>>> bc.dtype
dtype('complex128')

Note that even if the input was complex to begin with, a copy is still
made, since the astype() method always copies:

>>> c = np.array([1,2,3],np.csingle)

>>> cc = np.lib.scimath._tocomplex(c); cc
array([1.+0.j,  2.+0.j,  3.+0.j], dtype=complex64)

>>> c *= 2; c
array([2.+0.j,  4.+0.j,  6.+0.j], dtype=complex64)

>>> cc
array([1.+0.j,  2.+0.j,  3.+0.j], dtype=complex64)
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{scimath_8py_source_l00049}{49}} of file \mbox{\hyperlink{scimath_8py_source}{scimath.\+py}}.



Referenced by \mbox{\hyperlink{scimath_8py_source_l00167}{\+\_\+fix\+\_\+real\+\_\+abs\+\_\+gt\+\_\+1()}}, and \mbox{\hyperlink{scimath_8py_source_l00112}{\+\_\+fix\+\_\+real\+\_\+lt\+\_\+zero()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1scimath_a69ebe8e98ccffe64d9661716a8472f7a}\index{numpy.lib.scimath@{numpy.lib.scimath}!\_unary\_dispatcher@{\_unary\_dispatcher}}
\index{\_unary\_dispatcher@{\_unary\_dispatcher}!numpy.lib.scimath@{numpy.lib.scimath}}
\doxysubsubsection{\texorpdfstring{\_unary\_dispatcher()}{\_unary\_dispatcher()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1scimath_a69ebe8e98ccffe64d9661716a8472f7a} 
numpy.\+lib.\+scimath.\+\_\+unary\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{x}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{scimath_8py_source_l00194}{194}} of file \mbox{\hyperlink{scimath_8py_source}{scimath.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1scimath_a4c226d01188121b6ebbd484591c13e61}\index{numpy.lib.scimath@{numpy.lib.scimath}!arccos@{arccos}}
\index{arccos@{arccos}!numpy.lib.scimath@{numpy.lib.scimath}}
\doxysubsubsection{\texorpdfstring{arccos()}{arccos()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1scimath_a4c226d01188121b6ebbd484591c13e61} 
numpy.\+lib.\+scimath.\+arccos (\begin{DoxyParamCaption}\item[{}]{x}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute the inverse cosine of x.

Return the "principal value" (for a description of this, see
`numpy.arccos`) of the inverse cosine of `x`. For real `x` such that
`abs(x) <= 1`, this is a real number in the closed interval
:math:`[0, \\pi]`.  Otherwise, the complex principle value is returned.

Parameters
----------
x : array_like or scalar
   The value(s) whose arccos is (are) required.

Returns
-------
out : ndarray or scalar
   The inverse cosine(s) of the `x` value(s). If `x` was a scalar, so
   is `out`, otherwise an array object is returned.

See Also
--------
numpy.arccos

Notes
-----
For an arccos() that returns ``NAN`` when real `x` is not in the
interval ``[-1,1]``, use `numpy.arccos`.

Examples
--------
>>> np.set_printoptions(precision=4)

>>> np.emath.arccos(1) # a scalar is returned
0.0

>>> np.emath.arccos([1,2])
array([0.-0.j   , 0.-1.317j])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{scimath_8py_source_l00487}{487}} of file \mbox{\hyperlink{scimath_8py_source}{scimath.\+py}}.



References \mbox{\hyperlink{scimath_8py_source_l00167}{\+\_\+fix\+\_\+real\+\_\+abs\+\_\+gt\+\_\+1()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1scimath_a2966b87f716fe51ecfcf3385f8d1ae56}\index{numpy.lib.scimath@{numpy.lib.scimath}!arcsin@{arcsin}}
\index{arcsin@{arcsin}!numpy.lib.scimath@{numpy.lib.scimath}}
\doxysubsubsection{\texorpdfstring{arcsin()}{arcsin()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1scimath_a2966b87f716fe51ecfcf3385f8d1ae56} 
numpy.\+lib.\+scimath.\+arcsin (\begin{DoxyParamCaption}\item[{}]{x}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute the inverse sine of x.

Return the "principal value" (for a description of this, see
`numpy.arcsin`) of the inverse sine of `x`. For real `x` such that
`abs(x) <= 1`, this is a real number in the closed interval
:math:`[-\\pi/2, \\pi/2]`.  Otherwise, the complex principle value is
returned.

Parameters
----------
x : array_like or scalar
   The value(s) whose arcsin is (are) required.

Returns
-------
out : ndarray or scalar
   The inverse sine(s) of the `x` value(s). If `x` was a scalar, so
   is `out`, otherwise an array object is returned.

See Also
--------
numpy.arcsin

Notes
-----
For an arcsin() that returns ``NAN`` when real `x` is not in the
interval ``[-1,1]``, use `numpy.arcsin`.

Examples
--------
>>> np.set_printoptions(precision=4)

>>> np.emath.arcsin(0)
0.0

>>> np.emath.arcsin([0,1])
array([0.    , 1.5708])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{scimath_8py_source_l00532}{532}} of file \mbox{\hyperlink{scimath_8py_source}{scimath.\+py}}.



References \mbox{\hyperlink{scimath_8py_source_l00167}{\+\_\+fix\+\_\+real\+\_\+abs\+\_\+gt\+\_\+1()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1scimath_a69ace8c298e22d7ee9cbb41c55ec3f61}\index{numpy.lib.scimath@{numpy.lib.scimath}!arctanh@{arctanh}}
\index{arctanh@{arctanh}!numpy.lib.scimath@{numpy.lib.scimath}}
\doxysubsubsection{\texorpdfstring{arctanh()}{arctanh()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1scimath_a69ace8c298e22d7ee9cbb41c55ec3f61} 
numpy.\+lib.\+scimath.\+arctanh (\begin{DoxyParamCaption}\item[{}]{x}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute the inverse hyperbolic tangent of `x`.

Return the "principal value" (for a description of this, see
`numpy.arctanh`) of ``arctanh(x)``. For real `x` such that
``abs(x) < 1``, this is a real number.  If `abs(x) > 1`, or if `x` is
complex, the result is complex. Finally, `x = 1` returns``inf`` and
``x=-1`` returns ``-inf``.

Parameters
----------
x : array_like
   The value(s) whose arctanh is (are) required.

Returns
-------
out : ndarray or scalar
   The inverse hyperbolic tangent(s) of the `x` value(s). If `x` was
   a scalar so is `out`, otherwise an array is returned.


See Also
--------
numpy.arctanh

Notes
-----
For an arctanh() that returns ``NAN`` when real `x` is not in the
interval ``(-1,1)``, use `numpy.arctanh` (this latter, however, does
return +/-inf for ``x = +/-1``).

Examples
--------
>>> np.set_printoptions(precision=4)

>>> from numpy.testing import suppress_warnings
>>> with suppress_warnings() as sup:
...     sup.filter(RuntimeWarning)
...     np.emath.arctanh(np.eye(2))
array([[inf,  0.],
       [ 0., inf]])
>>> np.emath.arctanh([1j])
array([0.+0.7854j])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{scimath_8py_source_l00578}{578}} of file \mbox{\hyperlink{scimath_8py_source}{scimath.\+py}}.



References \mbox{\hyperlink{scimath_8py_source_l00167}{\+\_\+fix\+\_\+real\+\_\+abs\+\_\+gt\+\_\+1()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1scimath_af0ffe74a68ad56388318c4f703204fee}\index{numpy.lib.scimath@{numpy.lib.scimath}!log@{log}}
\index{log@{log}!numpy.lib.scimath@{numpy.lib.scimath}}
\doxysubsubsection{\texorpdfstring{log()}{log()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1scimath_af0ffe74a68ad56388318c4f703204fee} 
numpy.\+lib.\+scimath.\+log (\begin{DoxyParamCaption}\item[{}]{x}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute the natural logarithm of `x`.

Return the "principal value" (for a description of this, see `numpy.log`)
of :math:`log_e(x)`. For real `x > 0`, this is a real number (``log(0)``
returns ``-inf`` and ``log(np.inf)`` returns ``inf``). Otherwise, the
complex principle value is returned.

Parameters
----------
x : array_like
   The value(s) whose log is (are) required.

Returns
-------
out : ndarray or scalar
   The log of the `x` value(s). If `x` was a scalar, so is `out`,
   otherwise an array is returned.

See Also
--------
numpy.log

Notes
-----
For a log() that returns ``NAN`` when real `x < 0`, use `numpy.log`
(note, however, that otherwise `numpy.log` and this `log` are identical,
i.e., both return ``-inf`` for `x = 0`, ``inf`` for `x = inf`, and,
notably, the complex principle value if ``x.imag != 0``).

Examples
--------
>>> np.emath.log(np.exp(1))
1.0

Negative arguments are handled "correctly" (recall that
``exp(log(x)) == x`` does *not* hold for real ``x < 0``):

>>> np.emath.log(-np.exp(1)) == (1 + np.pi * 1j)
True
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{scimath_8py_source_l00252}{252}} of file \mbox{\hyperlink{scimath_8py_source}{scimath.\+py}}.



References \mbox{\hyperlink{scimath_8py_source_l00112}{\+\_\+fix\+\_\+real\+\_\+lt\+\_\+zero()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1scimath_a79780c50c7a0cc5e703e4326cbb9f6c9}\index{numpy.lib.scimath@{numpy.lib.scimath}!log10@{log10}}
\index{log10@{log10}!numpy.lib.scimath@{numpy.lib.scimath}}
\doxysubsubsection{\texorpdfstring{log10()}{log10()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1scimath_a79780c50c7a0cc5e703e4326cbb9f6c9} 
numpy.\+lib.\+scimath.\+log10 (\begin{DoxyParamCaption}\item[{}]{x}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute the logarithm base 10 of `x`.

Return the "principal value" (for a description of this, see
`numpy.log10`) of :math:`log_{10}(x)`. For real `x > 0`, this
is a real number (``log10(0)`` returns ``-inf`` and ``log10(np.inf)``
returns ``inf``). Otherwise, the complex principle value is returned.

Parameters
----------
x : array_like or scalar
   The value(s) whose log base 10 is (are) required.

Returns
-------
out : ndarray or scalar
   The log base 10 of the `x` value(s). If `x` was a scalar, so is `out`,
   otherwise an array object is returned.

See Also
--------
numpy.log10

Notes
-----
For a log10() that returns ``NAN`` when real `x < 0`, use `numpy.log10`
(note, however, that otherwise `numpy.log10` and this `log10` are
identical, i.e., both return ``-inf`` for `x = 0`, ``inf`` for `x = inf`,
and, notably, the complex principle value if ``x.imag != 0``).

Examples
--------

(We set the printing precision so the example can be auto-tested)

>>> np.set_printoptions(precision=4)

>>> np.emath.log10(10**1)
1.0

>>> np.emath.log10([-10**1, -10**2, 10**2])
array([1.+1.3644j, 2.+1.3644j, 2.+0.j    ])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{scimath_8py_source_l00300}{300}} of file \mbox{\hyperlink{scimath_8py_source}{scimath.\+py}}.



References \mbox{\hyperlink{scimath_8py_source_l00112}{\+\_\+fix\+\_\+real\+\_\+lt\+\_\+zero()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1scimath_a233428a708eb23ea44ed30cee5fb65fd}\index{numpy.lib.scimath@{numpy.lib.scimath}!log2@{log2}}
\index{log2@{log2}!numpy.lib.scimath@{numpy.lib.scimath}}
\doxysubsubsection{\texorpdfstring{log2()}{log2()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1scimath_a233428a708eb23ea44ed30cee5fb65fd} 
numpy.\+lib.\+scimath.\+log2 (\begin{DoxyParamCaption}\item[{}]{x}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute the logarithm base 2 of `x`.

Return the "principal value" (for a description of this, see
`numpy.log2`) of :math:`log_2(x)`. For real `x > 0`, this is
a real number (``log2(0)`` returns ``-inf`` and ``log2(np.inf)`` returns
``inf``). Otherwise, the complex principle value is returned.

Parameters
----------
x : array_like
   The value(s) whose log base 2 is (are) required.

Returns
-------
out : ndarray or scalar
   The log base 2 of the `x` value(s). If `x` was a scalar, so is `out`,
   otherwise an array is returned.

See Also
--------
numpy.log2

Notes
-----
For a log2() that returns ``NAN`` when real `x < 0`, use `numpy.log2`
(note, however, that otherwise `numpy.log2` and this `log2` are
identical, i.e., both return ``-inf`` for `x = 0`, ``inf`` for `x = inf`,
and, notably, the complex principle value if ``x.imag != 0``).

Examples
--------
We set the printing precision so the example can be auto-tested:

>>> np.set_printoptions(precision=4)

>>> np.emath.log2(8)
3.0
>>> np.emath.log2([-4, -8, 8])
array([2.+4.5324j, 3.+4.5324j, 3.+0.j    ])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{scimath_8py_source_l00390}{390}} of file \mbox{\hyperlink{scimath_8py_source}{scimath.\+py}}.



References \mbox{\hyperlink{scimath_8py_source_l00112}{\+\_\+fix\+\_\+real\+\_\+lt\+\_\+zero()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1scimath_a1531b6253aaa1099a6010033ba408e61}\index{numpy.lib.scimath@{numpy.lib.scimath}!logn@{logn}}
\index{logn@{logn}!numpy.lib.scimath@{numpy.lib.scimath}}
\doxysubsubsection{\texorpdfstring{logn()}{logn()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1scimath_a1531b6253aaa1099a6010033ba408e61} 
numpy.\+lib.\+scimath.\+logn (\begin{DoxyParamCaption}\item[{}]{n}{, }\item[{}]{x}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Take log base n of x.

If `x` contains negative inputs, the answer is computed and returned in the
complex domain.

Parameters
----------
n : array_like
   The integer base(s) in which the log is taken.
x : array_like
   The value(s) whose log base `n` is (are) required.

Returns
-------
out : ndarray or scalar
   The log base `n` of the `x` value(s). If `x` was a scalar, so is
   `out`, otherwise an array is returned.

Examples
--------
>>> np.set_printoptions(precision=4)

>>> np.emath.logn(2, [4, 8])
array([2., 3.])
>>> np.emath.logn(2, [-4, -8, 8])
array([2.+4.5324j, 3.+4.5324j, 3.+0.j    ])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{scimath_8py_source_l00354}{354}} of file \mbox{\hyperlink{scimath_8py_source}{scimath.\+py}}.



References \mbox{\hyperlink{scimath_8py_source_l00112}{\+\_\+fix\+\_\+real\+\_\+lt\+\_\+zero()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1scimath_a755c122e6a7f99c806ba7650e50256f9}\index{numpy.lib.scimath@{numpy.lib.scimath}!power@{power}}
\index{power@{power}!numpy.lib.scimath@{numpy.lib.scimath}}
\doxysubsubsection{\texorpdfstring{power()}{power()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1scimath_a755c122e6a7f99c806ba7650e50256f9} 
numpy.\+lib.\+scimath.\+power (\begin{DoxyParamCaption}\item[{}]{x}{, }\item[{}]{p}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Return x to the power p, (x**p).

If `x` contains negative values, the output is converted to the
complex domain.

Parameters
----------
x : array_like
    The input value(s).
p : array_like of ints
    The power(s) to which `x` is raised. If `x` contains multiple values,
    `p` has to either be a scalar, or contain the same number of values
    as `x`. In the latter case, the result is
    ``x[0]**p[0], x[1]**p[1], ...``.

Returns
-------
out : ndarray or scalar
    The result of ``x**p``. If `x` and `p` are scalars, so is `out`,
    otherwise an array is returned.

See Also
--------
numpy.power

Examples
--------
>>> np.set_printoptions(precision=4)

>>> np.emath.power([2, 4], 2)
array([ 4, 16])
>>> np.emath.power([2, 4], -2)
array([0.25  ,  0.0625])
>>> np.emath.power([-2, 4], 2)
array([ 4.-0.j, 16.+0.j])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{scimath_8py_source_l00442}{442}} of file \mbox{\hyperlink{scimath_8py_source}{scimath.\+py}}.



References \mbox{\hyperlink{scimath_8py_source_l00140}{\+\_\+fix\+\_\+int\+\_\+lt\+\_\+zero()}}, and \mbox{\hyperlink{scimath_8py_source_l00112}{\+\_\+fix\+\_\+real\+\_\+lt\+\_\+zero()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1scimath_acedbf1d49f70de16451705e0e567681a}\index{numpy.lib.scimath@{numpy.lib.scimath}!sqrt@{sqrt}}
\index{sqrt@{sqrt}!numpy.lib.scimath@{numpy.lib.scimath}}
\doxysubsubsection{\texorpdfstring{sqrt()}{sqrt()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1scimath_acedbf1d49f70de16451705e0e567681a} 
numpy.\+lib.\+scimath.\+sqrt (\begin{DoxyParamCaption}\item[{}]{x}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute the square root of x.

For negative input elements, a complex value is returned
(unlike `numpy.sqrt` which returns NaN).

Parameters
----------
x : array_like
   The input value(s).

Returns
-------
out : ndarray or scalar
   The square root of `x`. If `x` was a scalar, so is `out`,
   otherwise an array is returned.

See Also
--------
numpy.sqrt

Examples
--------
For real, non-negative inputs this works just like `numpy.sqrt`:

>>> np.emath.sqrt(1)
1.0
>>> np.emath.sqrt([1, 4])
array([1.,  2.])

But it automatically handles negative inputs:

>>> np.emath.sqrt(-1)
1j
>>> np.emath.sqrt([-1,4])
array([0.+1.j, 2.+0.j])

Different results are expected because:
floating point 0.0 and -0.0 are distinct.

For more control, explicitly use complex() as follows:

>>> np.emath.sqrt(complex(-4.0, 0.0))
2j
>>> np.emath.sqrt(complex(-4.0, -0.0))
-2j
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{scimath_8py_source_l00199}{199}} of file \mbox{\hyperlink{scimath_8py_source}{scimath.\+py}}.



References \mbox{\hyperlink{scimath_8py_source_l00112}{\+\_\+fix\+\_\+real\+\_\+lt\+\_\+zero()}}.



\doxysubsection{Variable Documentation}
\Hypertarget{namespacenumpy_1_1lib_1_1scimath_a07d3abe3f8eeb3627363e9478ce90c41}\index{numpy.lib.scimath@{numpy.lib.scimath}!\_\_all\_\_@{\_\_all\_\_}}
\index{\_\_all\_\_@{\_\_all\_\_}!numpy.lib.scimath@{numpy.lib.scimath}}
\doxysubsubsection{\texorpdfstring{\_\_all\_\_}{\_\_all\_\_}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1scimath_a07d3abe3f8eeb3627363e9478ce90c41} 
list numpy.\+lib.\+scimath.\+\_\+\+\_\+all\+\_\+\+\_\+\hspace{0.3cm}{\ttfamily [private]}}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ [}
\DoxyCodeLine{00002\ \ \ \ \ \textcolor{stringliteral}{'sqrt'},\ \textcolor{stringliteral}{'log'},\ \textcolor{stringliteral}{'log2'},\ \textcolor{stringliteral}{'logn'},\ \textcolor{stringliteral}{'log10'},\ \textcolor{stringliteral}{'power'},\ \textcolor{stringliteral}{'arccos'},\ \textcolor{stringliteral}{'arcsin'},}
\DoxyCodeLine{00003\ \ \ \ \ \textcolor{stringliteral}{'arctanh'}}
\DoxyCodeLine{00004\ \ \ \ \ ]}

\end{DoxyCode}


Definition at line \mbox{\hyperlink{scimath_8py_source_l00040}{40}} of file \mbox{\hyperlink{scimath_8py_source}{scimath.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1scimath_ac68a53f9e8f4deba3f9960e829b3a95e}\index{numpy.lib.scimath@{numpy.lib.scimath}!\_ln2@{\_ln2}}
\index{\_ln2@{\_ln2}!numpy.lib.scimath@{numpy.lib.scimath}}
\doxysubsubsection{\texorpdfstring{\_ln2}{\_ln2}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1scimath_ac68a53f9e8f4deba3f9960e829b3a95e} 
numpy.\+lib.\+scimath.\+\_\+ln2 = nx.\+log(2.\+0)\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{scimath_8py_source_l00046}{46}} of file \mbox{\hyperlink{scimath_8py_source}{scimath.\+py}}.

