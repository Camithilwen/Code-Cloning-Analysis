\doxysection{scipy.\+optimize.\+\_\+root Namespace Reference}
\hypertarget{namespacescipy_1_1optimize_1_1__root}{}\label{namespacescipy_1_1optimize_1_1__root}\index{scipy.optimize.\_root@{scipy.optimize.\_root}}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__root_a0074362993188d5dd59628411a0c1e05}{root}} (fun, x0, args=(), method=\textquotesingle{}hybr\textquotesingle{}, jac=None, tol=None, callback=None, options=None)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__root_a017c1fd4b109c8b53a7178db946dda5a}{\+\_\+warn\+\_\+jac\+\_\+unused}} (jac, method)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__root_ae151b646d8a180a491a07341c60d5c16}{\+\_\+root\+\_\+leastsq}} (fun, x0, args=(), jac=None, col\+\_\+deriv=0, xtol=1.\+49012e-\/08, ftol=1.\+49012e-\/08, gtol=0.\+0, maxiter=0, eps=0.\+0, factor=100, diag=None, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}unknown\+\_\+options)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__root_a00b7917344143599a55c28618ac3d2a8}{\+\_\+root\+\_\+nonlin\+\_\+solve}} (fun, x0, args=(), jac=None, \+\_\+callback=None, \+\_\+method=None, nit=None, disp=False, maxiter=None, ftol=None, fatol=None, xtol=None, xatol=None, tol\+\_\+norm=None, line\+\_\+search=\textquotesingle{}armijo\textquotesingle{}, jac\+\_\+options=None, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}unknown\+\_\+options)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__root_a5877004b2653c72435ae9e64366eeace}{\+\_\+root\+\_\+broyden1\+\_\+doc}} ()
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__root_aaac1b47dea2ad2b3fc2c76689d8158de}{\+\_\+root\+\_\+broyden2\+\_\+doc}} ()
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__root_ae2769e6d6987f02a23cab187c49ef057}{\+\_\+root\+\_\+anderson\+\_\+doc}} ()
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__root_ad7127360e82b9de8bd04ffa6f4ad5e4b}{\+\_\+root\+\_\+linearmixing\+\_\+doc}} ()
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__root_aebe6f05898ec738607b1775fd3398bad}{\+\_\+root\+\_\+diagbroyden\+\_\+doc}} ()
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__root_acdeadd8dfab569eaa4bb117f4ee9ed9c}{\+\_\+root\+\_\+excitingmixing\+\_\+doc}} ()
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__root_afe54ac2c3a648b43d291798970193b60}{\+\_\+root\+\_\+krylov\+\_\+doc}} ()
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
list \mbox{\hyperlink{namespacescipy_1_1optimize_1_1__root_a172eef1e96392775fe745d3dd3732d55}{\+\_\+\+\_\+all\+\_\+\+\_\+}} = \mbox{[}\textquotesingle{}\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__root_a0074362993188d5dd59628411a0c1e05}{root}}\textquotesingle{}\mbox{]}
\item 
list \mbox{\hyperlink{namespacescipy_1_1optimize_1_1__root_a1b31661557978491ede1460c5d509109}{ROOT\+\_\+\+METHODS}}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\begin{DoxyVerb}Unified interfaces to root finding algorithms.

Functions
---------
- root : find a root of a vector function.
\end{DoxyVerb}
 

\doxysubsection{Function Documentation}
\Hypertarget{namespacescipy_1_1optimize_1_1__root_ae2769e6d6987f02a23cab187c49ef057}\index{scipy.optimize.\_root@{scipy.optimize.\_root}!\_root\_anderson\_doc@{\_root\_anderson\_doc}}
\index{\_root\_anderson\_doc@{\_root\_anderson\_doc}!scipy.optimize.\_root@{scipy.optimize.\_root}}
\doxysubsubsection{\texorpdfstring{\_root\_anderson\_doc()}{\_root\_anderson\_doc()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__root_ae2769e6d6987f02a23cab187c49ef057} 
scipy.\+optimize.\+\_\+root.\+\_\+root\+\_\+anderson\+\_\+doc (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Options
-------
nit : int, optional
    Number of iterations to make. If omitted (default), make as many
    as required to meet tolerances.
disp : bool, optional
    Print status to stdout on every iteration.
maxiter : int, optional
    Maximum number of iterations to make. If more are needed to
    meet convergence, `NoConvergence` is raised.
ftol : float, optional
    Relative tolerance for the residual. If omitted, not used.
fatol : float, optional
    Absolute tolerance (in max-norm) for the residual.
    If omitted, default is 6e-6.
xtol : float, optional
    Relative minimum step size. If omitted, not used.
xatol : float, optional
    Absolute minimum step size, as determined from the Jacobian
    approximation. If the step size is smaller than this, optimization
    is terminated as successful. If omitted, not used.
tol_norm : function(vector) -> scalar, optional
    Norm to use in convergence check. Default is the maximum norm.
line_search : {None, 'armijo' (default), 'wolfe'}, optional
    Which type of a line search to use to determine the step size in
    the direction given by the Jacobian approximation. Defaults to
    'armijo'.
jac_options : dict, optional
    Options for the respective Jacobian approximation.

    alpha : float, optional
        Initial guess for the Jacobian is (-1/alpha).
    M : float, optional
        Number of previous vectors to retain. Defaults to 5.
    w0 : float, optional
        Regularization parameter for numerical stability.
        Compared to unity, good values of the order of 0.01.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__root_8py_source_l00499}{499}} of file \mbox{\hyperlink{__root_8py_source}{\+\_\+root.\+py}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__root_a5877004b2653c72435ae9e64366eeace}\index{scipy.optimize.\_root@{scipy.optimize.\_root}!\_root\_broyden1\_doc@{\_root\_broyden1\_doc}}
\index{\_root\_broyden1\_doc@{\_root\_broyden1\_doc}!scipy.optimize.\_root@{scipy.optimize.\_root}}
\doxysubsubsection{\texorpdfstring{\_root\_broyden1\_doc()}{\_root\_broyden1\_doc()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__root_a5877004b2653c72435ae9e64366eeace} 
scipy.\+optimize.\+\_\+root.\+\_\+root\+\_\+broyden1\+\_\+doc (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Options
-------
nit : int, optional
    Number of iterations to make. If omitted (default), make as many
    as required to meet tolerances.
disp : bool, optional
    Print status to stdout on every iteration.
maxiter : int, optional
    Maximum number of iterations to make. If more are needed to
    meet convergence, `NoConvergence` is raised.
ftol : float, optional
    Relative tolerance for the residual. If omitted, not used.
fatol : float, optional
    Absolute tolerance (in max-norm) for the residual.
    If omitted, default is 6e-6.
xtol : float, optional
    Relative minimum step size. If omitted, not used.
xatol : float, optional
    Absolute minimum step size, as determined from the Jacobian
    approximation. If the step size is smaller than this, optimization
    is terminated as successful. If omitted, not used.
tol_norm : function(vector) -> scalar, optional
    Norm to use in convergence check. Default is the maximum norm.
line_search : {None, 'armijo' (default), 'wolfe'}, optional
    Which type of a line search to use to determine the step size in
    the direction given by the Jacobian approximation. Defaults to
    'armijo'.
jac_options : dict, optional
    Options for the respective Jacobian approximation.
        alpha : float, optional
            Initial guess for the Jacobian is (-1/alpha).
        reduction_method : str or tuple, optional
            Method used in ensuring that the rank of the Broyden
            matrix stays low. Can either be a string giving the
            name of the method, or a tuple of the form ``(method,
            param1, param2, ...)`` that gives the name of the
            method and values for additional parameters.

            Methods available:

                - ``restart``
                    Drop all matrix columns. Has no
                    extra parameters.
                - ``simple``
                    Drop oldest matrix column. Has no
                    extra parameters.
                - ``svd``
                    Keep only the most significant SVD
                    components.

                    Extra parameters:

                        - ``to_retain``
                            Number of SVD components to
                            retain when rank reduction is done.
                            Default is ``max_rank - 2``.
        max_rank : int, optional
            Maximum rank for the Broyden matrix.
            Default is infinity (i.e., no rank reduction).

Examples
--------
>>> def func(x):
...     return np.cos(x) + x[::-1] - [1, 2, 3, 4]
...
>>> from scipy import optimize
>>> res = optimize.root(func, [1, 1, 1, 1], method='broyden1', tol=1e-14)
>>> x = res.x
>>> x
array([4.04674914, 3.91158389, 2.71791677, 1.61756251])
>>> np.cos(x) + x[::-1]
array([1., 2., 3., 4.])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__root_8py_source_l00356}{356}} of file \mbox{\hyperlink{__root_8py_source}{\+\_\+root.\+py}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__root_aaac1b47dea2ad2b3fc2c76689d8158de}\index{scipy.optimize.\_root@{scipy.optimize.\_root}!\_root\_broyden2\_doc@{\_root\_broyden2\_doc}}
\index{\_root\_broyden2\_doc@{\_root\_broyden2\_doc}!scipy.optimize.\_root@{scipy.optimize.\_root}}
\doxysubsubsection{\texorpdfstring{\_root\_broyden2\_doc()}{\_root\_broyden2\_doc()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__root_aaac1b47dea2ad2b3fc2c76689d8158de} 
scipy.\+optimize.\+\_\+root.\+\_\+root\+\_\+broyden2\+\_\+doc (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Options
-------
nit : int, optional
    Number of iterations to make. If omitted (default), make as many
    as required to meet tolerances.
disp : bool, optional
    Print status to stdout on every iteration.
maxiter : int, optional
    Maximum number of iterations to make. If more are needed to
    meet convergence, `NoConvergence` is raised.
ftol : float, optional
    Relative tolerance for the residual. If omitted, not used.
fatol : float, optional
    Absolute tolerance (in max-norm) for the residual.
    If omitted, default is 6e-6.
xtol : float, optional
    Relative minimum step size. If omitted, not used.
xatol : float, optional
    Absolute minimum step size, as determined from the Jacobian
    approximation. If the step size is smaller than this, optimization
    is terminated as successful. If omitted, not used.
tol_norm : function(vector) -> scalar, optional
    Norm to use in convergence check. Default is the maximum norm.
line_search : {None, 'armijo' (default), 'wolfe'}, optional
    Which type of a line search to use to determine the step size in
    the direction given by the Jacobian approximation. Defaults to
    'armijo'.
jac_options : dict, optional
    Options for the respective Jacobian approximation.

    alpha : float, optional
        Initial guess for the Jacobian is (-1/alpha).
    reduction_method : str or tuple, optional
        Method used in ensuring that the rank of the Broyden
        matrix stays low. Can either be a string giving the
        name of the method, or a tuple of the form ``(method,
        param1, param2, ...)`` that gives the name of the
        method and values for additional parameters.

        Methods available:

            - ``restart``
                Drop all matrix columns. Has no
                extra parameters.
            - ``simple``
                Drop oldest matrix column. Has no
                extra parameters.
            - ``svd``
                Keep only the most significant SVD
                components.

                Extra parameters:

                    - ``to_retain``
                        Number of SVD components to
                        retain when rank reduction is done.
                        Default is ``max_rank - 2``.
    max_rank : int, optional
        Maximum rank for the Broyden matrix.
        Default is infinity (i.e., no rank reduction).
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__root_8py_source_l00434}{434}} of file \mbox{\hyperlink{__root_8py_source}{\+\_\+root.\+py}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__root_aebe6f05898ec738607b1775fd3398bad}\index{scipy.optimize.\_root@{scipy.optimize.\_root}!\_root\_diagbroyden\_doc@{\_root\_diagbroyden\_doc}}
\index{\_root\_diagbroyden\_doc@{\_root\_diagbroyden\_doc}!scipy.optimize.\_root@{scipy.optimize.\_root}}
\doxysubsubsection{\texorpdfstring{\_root\_diagbroyden\_doc()}{\_root\_diagbroyden\_doc()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__root_aebe6f05898ec738607b1775fd3398bad} 
scipy.\+optimize.\+\_\+root.\+\_\+root\+\_\+diagbroyden\+\_\+doc (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Options
-------
nit : int, optional
    Number of iterations to make. If omitted (default), make as many
    as required to meet tolerances.
disp : bool, optional
    Print status to stdout on every iteration.
maxiter : int, optional
    Maximum number of iterations to make. If more are needed to
    meet convergence, `NoConvergence` is raised.
ftol : float, optional
    Relative tolerance for the residual. If omitted, not used.
fatol : float, optional
    Absolute tolerance (in max-norm) for the residual.
    If omitted, default is 6e-6.
xtol : float, optional
    Relative minimum step size. If omitted, not used.
xatol : float, optional
    Absolute minimum step size, as determined from the Jacobian
    approximation. If the step size is smaller than this, optimization
    is terminated as successful. If omitted, not used.
tol_norm : function(vector) -> scalar, optional
    Norm to use in convergence check. Default is the maximum norm.
line_search : {None, 'armijo' (default), 'wolfe'}, optional
    Which type of a line search to use to determine the step size in
    the direction given by the Jacobian approximation. Defaults to
    'armijo'.
jac_options : dict, optional
    Options for the respective Jacobian approximation.

    alpha : float, optional
        initial guess for the jacobian is (-1/alpha).
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__root_8py_source_l00578}{578}} of file \mbox{\hyperlink{__root_8py_source}{\+\_\+root.\+py}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__root_acdeadd8dfab569eaa4bb117f4ee9ed9c}\index{scipy.optimize.\_root@{scipy.optimize.\_root}!\_root\_excitingmixing\_doc@{\_root\_excitingmixing\_doc}}
\index{\_root\_excitingmixing\_doc@{\_root\_excitingmixing\_doc}!scipy.optimize.\_root@{scipy.optimize.\_root}}
\doxysubsubsection{\texorpdfstring{\_root\_excitingmixing\_doc()}{\_root\_excitingmixing\_doc()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__root_acdeadd8dfab569eaa4bb117f4ee9ed9c} 
scipy.\+optimize.\+\_\+root.\+\_\+root\+\_\+excitingmixing\+\_\+doc (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Options
-------
nit : int, optional
    Number of iterations to make. If omitted (default), make as many
    as required to meet tolerances.
disp : bool, optional
    Print status to stdout on every iteration.
maxiter : int, optional
    Maximum number of iterations to make. If more are needed to
    meet convergence, `NoConvergence` is raised.
ftol : float, optional
    Relative tolerance for the residual. If omitted, not used.
fatol : float, optional
    Absolute tolerance (in max-norm) for the residual.
    If omitted, default is 6e-6.
xtol : float, optional
    Relative minimum step size. If omitted, not used.
xatol : float, optional
    Absolute minimum step size, as determined from the Jacobian
    approximation. If the step size is smaller than this, optimization
    is terminated as successful. If omitted, not used.
tol_norm : function(vector) -> scalar, optional
    Norm to use in convergence check. Default is the maximum norm.
line_search : {None, 'armijo' (default), 'wolfe'}, optional
    Which type of a line search to use to determine the step size in
    the direction given by the Jacobian approximation. Defaults to
    'armijo'.
jac_options : dict, optional
    Options for the respective Jacobian approximation.

    alpha : float, optional
        Initial Jacobian approximation is (-1/alpha).
    alphamax : float, optional
        The entries of the diagonal Jacobian are kept in the range
        ``[alpha, alphamax]``.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__root_8py_source_l00615}{615}} of file \mbox{\hyperlink{__root_8py_source}{\+\_\+root.\+py}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__root_afe54ac2c3a648b43d291798970193b60}\index{scipy.optimize.\_root@{scipy.optimize.\_root}!\_root\_krylov\_doc@{\_root\_krylov\_doc}}
\index{\_root\_krylov\_doc@{\_root\_krylov\_doc}!scipy.optimize.\_root@{scipy.optimize.\_root}}
\doxysubsubsection{\texorpdfstring{\_root\_krylov\_doc()}{\_root\_krylov\_doc()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__root_afe54ac2c3a648b43d291798970193b60} 
scipy.\+optimize.\+\_\+root.\+\_\+root\+\_\+krylov\+\_\+doc (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Options
-------
nit : int, optional
    Number of iterations to make. If omitted (default), make as many
    as required to meet tolerances.
disp : bool, optional
    Print status to stdout on every iteration.
maxiter : int, optional
    Maximum number of iterations to make. If more are needed to
    meet convergence, `NoConvergence` is raised.
ftol : float, optional
    Relative tolerance for the residual. If omitted, not used.
fatol : float, optional
    Absolute tolerance (in max-norm) for the residual.
    If omitted, default is 6e-6.
xtol : float, optional
    Relative minimum step size. If omitted, not used.
xatol : float, optional
    Absolute minimum step size, as determined from the Jacobian
    approximation. If the step size is smaller than this, optimization
    is terminated as successful. If omitted, not used.
tol_norm : function(vector) -> scalar, optional
    Norm to use in convergence check. Default is the maximum norm.
line_search : {None, 'armijo' (default), 'wolfe'}, optional
    Which type of a line search to use to determine the step size in
    the direction given by the Jacobian approximation. Defaults to
    'armijo'.
jac_options : dict, optional
    Options for the respective Jacobian approximation.

    rdiff : float, optional
        Relative step size to use in numerical differentiation.
    method : str or callable, optional
        Krylov method to use to approximate the Jacobian.  Can be a string,
        or a function implementing the same interface as the iterative
        solvers in `scipy.sparse.linalg`. If a string, needs to be one of:
        ``'lgmres'``, ``'gmres'``, ``'bicgstab'``, ``'cgs'``, ``'minres'``,
        ``'tfqmr'``.

        The default is `scipy.sparse.linalg.lgmres`.
    inner_M : LinearOperator or InverseJacobian
        Preconditioner for the inner Krylov iteration.
        Note that you can use also inverse Jacobians as (adaptive)
        preconditioners. For example,

        >>> jac = BroydenFirst()
        >>> kjac = KrylovJacobian(inner_M=jac.inverse).

        If the preconditioner has a method named 'update', it will
        be called as ``update(x, f)`` after each nonlinear step,
        with ``x`` giving the current point, and ``f`` the current
        function value.
    inner_tol, inner_maxiter, ...
        Parameters to pass on to the "inner" Krylov solver.
        See `scipy.sparse.linalg.gmres` for details.
    outer_k : int, optional
        Size of the subspace kept across LGMRES nonlinear
        iterations.

        See `scipy.sparse.linalg.lgmres` for details.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__root_8py_source_l00655}{655}} of file \mbox{\hyperlink{__root_8py_source}{\+\_\+root.\+py}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__root_ae151b646d8a180a491a07341c60d5c16}\index{scipy.optimize.\_root@{scipy.optimize.\_root}!\_root\_leastsq@{\_root\_leastsq}}
\index{\_root\_leastsq@{\_root\_leastsq}!scipy.optimize.\_root@{scipy.optimize.\_root}}
\doxysubsubsection{\texorpdfstring{\_root\_leastsq()}{\_root\_leastsq()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__root_ae151b646d8a180a491a07341c60d5c16} 
scipy.\+optimize.\+\_\+root.\+\_\+root\+\_\+leastsq (\begin{DoxyParamCaption}\item[{}]{fun}{, }\item[{}]{x0}{, }\item[{}]{args}{ = {\ttfamily ()}, }\item[{}]{jac}{ = {\ttfamily None}, }\item[{}]{col\+\_\+deriv}{ = {\ttfamily 0}, }\item[{}]{xtol}{ = {\ttfamily 1.49012e-\/08}, }\item[{}]{ftol}{ = {\ttfamily 1.49012e-\/08}, }\item[{}]{gtol}{ = {\ttfamily 0.0}, }\item[{}]{maxiter}{ = {\ttfamily 0}, }\item[{}]{eps}{ = {\ttfamily 0.0}, }\item[{}]{factor}{ = {\ttfamily 100}, }\item[{}]{diag}{ = {\ttfamily None}, }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{unknown\+\_\+options}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Solve for least squares with Levenberg-Marquardt

Options
-------
col_deriv : bool
    non-zero to specify that the Jacobian function computes derivatives
    down the columns (faster, because there is no transpose operation).
ftol : float
    Relative error desired in the sum of squares.
xtol : float
    Relative error desired in the approximate solution.
gtol : float
    Orthogonality desired between the function vector and the columns
    of the Jacobian.
maxiter : int
    The maximum number of calls to the function. If zero, then
    100*(N+1) is the maximum where N is the number of elements in x0.
epsfcn : float
    A suitable step length for the forward-difference approximation of
    the Jacobian (for Dfun=None). If epsfcn is less than the machine
    precision, it is assumed that the relative errors in the functions
    are of the order of the machine precision.
factor : float
    A parameter determining the initial step bound
    (``factor * || diag * x||``). Should be in interval ``(0.1, 100)``.
diag : sequence
    N positive entries that serve as a scale factors for the variables.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__root_8py_source_l00261}{261}} of file \mbox{\hyperlink{__root_8py_source}{\+\_\+root.\+py}}.



References \mbox{\hyperlink{__minpack__py_8py_source_l00283}{scipy.\+optimize.\+\_\+minpack\+\_\+py.\+leastsq()}}.



Referenced by \mbox{\hyperlink{__root_8py_source_l00026}{root()}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__root_ad7127360e82b9de8bd04ffa6f4ad5e4b}\index{scipy.optimize.\_root@{scipy.optimize.\_root}!\_root\_linearmixing\_doc@{\_root\_linearmixing\_doc}}
\index{\_root\_linearmixing\_doc@{\_root\_linearmixing\_doc}!scipy.optimize.\_root@{scipy.optimize.\_root}}
\doxysubsubsection{\texorpdfstring{\_root\_linearmixing\_doc()}{\_root\_linearmixing\_doc()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__root_ad7127360e82b9de8bd04ffa6f4ad5e4b} 
scipy.\+optimize.\+\_\+root.\+\_\+root\+\_\+linearmixing\+\_\+doc (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Options
-------
nit : int, optional
    Number of iterations to make. If omitted (default), make as many
    as required to meet tolerances.
disp : bool, optional
    Print status to stdout on every iteration.
maxiter : int, optional
    Maximum number of iterations to make. If more are needed to
    meet convergence, ``NoConvergence`` is raised.
ftol : float, optional
    Relative tolerance for the residual. If omitted, not used.
fatol : float, optional
    Absolute tolerance (in max-norm) for the residual.
    If omitted, default is 6e-6.
xtol : float, optional
    Relative minimum step size. If omitted, not used.
xatol : float, optional
    Absolute minimum step size, as determined from the Jacobian
    approximation. If the step size is smaller than this, optimization
    is terminated as successful. If omitted, not used.
tol_norm : function(vector) -> scalar, optional
    Norm to use in convergence check. Default is the maximum norm.
line_search : {None, 'armijo' (default), 'wolfe'}, optional
    Which type of a line search to use to determine the step size in
    the direction given by the Jacobian approximation. Defaults to
    'armijo'.
jac_options : dict, optional
    Options for the respective Jacobian approximation.

    alpha : float, optional
        initial guess for the jacobian is (-1/alpha).
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__root_8py_source_l00541}{541}} of file \mbox{\hyperlink{__root_8py_source}{\+\_\+root.\+py}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__root_a00b7917344143599a55c28618ac3d2a8}\index{scipy.optimize.\_root@{scipy.optimize.\_root}!\_root\_nonlin\_solve@{\_root\_nonlin\_solve}}
\index{\_root\_nonlin\_solve@{\_root\_nonlin\_solve}!scipy.optimize.\_root@{scipy.optimize.\_root}}
\doxysubsubsection{\texorpdfstring{\_root\_nonlin\_solve()}{\_root\_nonlin\_solve()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__root_a00b7917344143599a55c28618ac3d2a8} 
scipy.\+optimize.\+\_\+root.\+\_\+root\+\_\+nonlin\+\_\+solve (\begin{DoxyParamCaption}\item[{}]{fun}{, }\item[{}]{x0}{, }\item[{}]{args}{ = {\ttfamily ()}, }\item[{}]{jac}{ = {\ttfamily None}, }\item[{}]{\+\_\+callback}{ = {\ttfamily None}, }\item[{}]{\+\_\+method}{ = {\ttfamily None}, }\item[{}]{nit}{ = {\ttfamily None}, }\item[{}]{disp}{ = {\ttfamily False}, }\item[{}]{maxiter}{ = {\ttfamily None}, }\item[{}]{ftol}{ = {\ttfamily None}, }\item[{}]{fatol}{ = {\ttfamily None}, }\item[{}]{xtol}{ = {\ttfamily None}, }\item[{}]{xatol}{ = {\ttfamily None}, }\item[{}]{tol\+\_\+norm}{ = {\ttfamily None}, }\item[{}]{line\+\_\+search}{ = {\ttfamily \textquotesingle{}armijo\textquotesingle{}}, }\item[{}]{jac\+\_\+options}{ = {\ttfamily None}, }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{unknown\+\_\+options}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{__root_8py_source_l00309}{309}} of file \mbox{\hyperlink{__root_8py_source}{\+\_\+root.\+py}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__root_a017c1fd4b109c8b53a7178db946dda5a}\index{scipy.optimize.\_root@{scipy.optimize.\_root}!\_warn\_jac\_unused@{\_warn\_jac\_unused}}
\index{\_warn\_jac\_unused@{\_warn\_jac\_unused}!scipy.optimize.\_root@{scipy.optimize.\_root}}
\doxysubsubsection{\texorpdfstring{\_warn\_jac\_unused()}{\_warn\_jac\_unused()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__root_a017c1fd4b109c8b53a7178db946dda5a} 
scipy.\+optimize.\+\_\+root.\+\_\+warn\+\_\+jac\+\_\+unused (\begin{DoxyParamCaption}\item[{}]{jac}{, }\item[{}]{method}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{__root_8py_source_l00255}{255}} of file \mbox{\hyperlink{__root_8py_source}{\+\_\+root.\+py}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__root_a0074362993188d5dd59628411a0c1e05}\index{scipy.optimize.\_root@{scipy.optimize.\_root}!root@{root}}
\index{root@{root}!scipy.optimize.\_root@{scipy.optimize.\_root}}
\doxysubsubsection{\texorpdfstring{root()}{root()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__root_a0074362993188d5dd59628411a0c1e05} 
scipy.\+optimize.\+\_\+root.\+root (\begin{DoxyParamCaption}\item[{}]{fun}{, }\item[{}]{x0}{, }\item[{}]{args}{ = {\ttfamily ()}, }\item[{}]{method}{ = {\ttfamily \textquotesingle{}hybr\textquotesingle{}}, }\item[{}]{jac}{ = {\ttfamily None}, }\item[{}]{tol}{ = {\ttfamily None}, }\item[{}]{callback}{ = {\ttfamily None}, }\item[{}]{options}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}    Find a root of a vector function.

    Parameters
    ----------
    fun : callable
        A vector function to find a root of.
    x0 : ndarray
        Initial guess.
    args : tuple, optional
        Extra arguments passed to the objective function and its Jacobian.
    method : str, optional
        Type of solver. Should be one of

            - 'hybr'             :ref:`(see here) <optimize.root-hybr>`
            - 'lm'               :ref:`(see here) <optimize.root-lm>`
            - 'broyden1'         :ref:`(see here) <optimize.root-broyden1>`
            - 'broyden2'         :ref:`(see here) <optimize.root-broyden2>`
            - 'anderson'         :ref:`(see here) <optimize.root-anderson>`
            - 'linearmixing'     :ref:`(see here) <optimize.root-linearmixing>`
            - 'diagbroyden'      :ref:`(see here) <optimize.root-diagbroyden>`
            - 'excitingmixing'   :ref:`(see here) <optimize.root-excitingmixing>`
            - 'krylov'           :ref:`(see here) <optimize.root-krylov>`
            - 'df-sane'          :ref:`(see here) <optimize.root-dfsane>`

    jac : bool or callable, optional
        If `jac` is a Boolean and is True, `fun` is assumed to return the
        value of Jacobian along with the objective function. If False, the
        Jacobian will be estimated numerically.
        `jac` can also be a callable returning the Jacobian of `fun`. In
        this case, it must accept the same arguments as `fun`.
    tol : float, optional
        Tolerance for termination. For detailed control, use solver-specific
        options.
    callback : function, optional
        Optional callback function. It is called on every iteration as
        ``callback(x, f)`` where `x` is the current solution and `f`
        the corresponding residual. For all methods but 'hybr' and 'lm'.
    options : dict, optional
        A dictionary of solver options. E.g., `xtol` or `maxiter`, see
        :obj:`show_options()` for details.

    Returns
    -------
    sol : OptimizeResult
        The solution represented as a ``OptimizeResult`` object.
        Important attributes are: ``x`` the solution array, ``success`` a
        Boolean flag indicating if the algorithm exited successfully and
        ``message`` which describes the cause of the termination. See
        `OptimizeResult` for a description of other attributes.

    See also
    --------
    show_options : Additional options accepted by the solvers

    Notes
    -----
    This section describes the available solvers that can be selected by the
    'method' parameter. The default method is *hybr*.

    Method *hybr* uses a modification of the Powell hybrid method as
    implemented in MINPACK [1]_.

    Method *lm* solves the system of nonlinear equations in a least squares
    sense using a modification of the Levenberg-Marquardt algorithm as
    implemented in MINPACK [1]_.

    Method *df-sane* is a derivative-free spectral method. [3]_

    Methods *broyden1*, *broyden2*, *anderson*, *linearmixing*,
    *diagbroyden*, *excitingmixing*, *krylov* are inexact Newton methods,
    with backtracking or full line searches [2]_. Each method corresponds
    to a particular Jacobian approximations.

    - Method *broyden1* uses Broyden's first Jacobian approximation, it is
      known as Broyden's good method.
    - Method *broyden2* uses Broyden's second Jacobian approximation, it
      is known as Broyden's bad method.
    - Method *anderson* uses (extended) Anderson mixing.
    - Method *Krylov* uses Krylov approximation for inverse Jacobian. It
      is suitable for large-scale problem.
    - Method *diagbroyden* uses diagonal Broyden Jacobian approximation.
    - Method *linearmixing* uses a scalar Jacobian approximation.
    - Method *excitingmixing* uses a tuned diagonal Jacobian
      approximation.

    .. warning::

        The algorithms implemented for methods *diagbroyden*,
        *linearmixing* and *excitingmixing* may be useful for specific
        problems, but whether they will work may depend strongly on the
        problem.

    .. versionadded:: 0.11.0

    References
    ----------
    .. [1] More, Jorge J., Burton S. Garbow, and Kenneth E. Hillstrom.
       1980. User Guide for MINPACK-1.
    .. [2] C. T. Kelley. 1995. Iterative Methods for Linear and Nonlinear
       Equations. Society for Industrial and Applied Mathematics.
       <https://archive.siam.org/books/kelley/fr16/>
    .. [3] W. La Cruz, J.M. Martinez, M. Raydan. Math. Comp. 75, 1429 (2006).

    Examples
    --------
    The following functions define a system of nonlinear equations and its
    jacobian.

    >>> import numpy as np
    >>> def fun(x):
    ...     return [x[0]  + 0.5 * (x[0] - x[1])**3 - 1.0,
    ...             0.5 * (x[1] - x[0])**3 + x[1]]

    >>> def jac(x):
    ...     return np.array([[1 + 1.5 * (x[0] - x[1])**2,
    ...                       -1.5 * (x[0] - x[1])**2],
    ...                      [-1.5 * (x[1] - x[0])**2,
    ...                       1 + 1.5 * (x[1] - x[0])**2]])

    A solution can be obtained as follows.

    >>> from scipy import optimize
    >>> sol = optimize.root(fun, [0, 0], jac=jac, method='hybr')
    >>> sol.x
    array([ 0.8411639,  0.1588361])

    **Large problem**

    Suppose that we needed to solve the following integrodifferential
    equation on the square :math:`[0,1]\times[0,1]`:

    .. math::

       \nabla^2 P = 10 \left(\int_0^1\int_0^1\cosh(P)\,dx\,dy\right)^2

    with :math:`P(x,1) = 1` and :math:`P=0` elsewhere on the boundary of
    the square.

    The solution can be found using the ``method='krylov'`` solver:

    >>> from scipy import optimize
    >>> # parameters
    >>> nx, ny = 75, 75
    >>> hx, hy = 1./(nx-1), 1./(ny-1)

    >>> P_left, P_right = 0, 0
    >>> P_top, P_bottom = 1, 0

    >>> def residual(P):
    ...    d2x = np.zeros_like(P)
    ...    d2y = np.zeros_like(P)
    ...
    ...    d2x[1:-1] = (P[2:]   - 2*P[1:-1] + P[:-2]) / hx/hx
    ...    d2x[0]    = (P[1]    - 2*P[0]    + P_left)/hx/hx
    ...    d2x[-1]   = (P_right - 2*P[-1]   + P[-2])/hx/hx
    ...
    ...    d2y[:,1:-1] = (P[:,2:] - 2*P[:,1:-1] + P[:,:-2])/hy/hy
    ...    d2y[:,0]    = (P[:,1]  - 2*P[:,0]    + P_bottom)/hy/hy
    ...    d2y[:,-1]   = (P_top   - 2*P[:,-1]   + P[:,-2])/hy/hy
    ...
    ...    return d2x + d2y - 10*np.cosh(P).mean()**2

    >>> guess = np.zeros((nx, ny), float)
    >>> sol = optimize.root(residual, guess, method='krylov')
    >>> print('Residual: %g' % abs(residual(sol.x)).max())
    Residual: 5.7972e-06  # may vary

    >>> import matplotlib.pyplot as plt
    >>> x, y = np.mgrid[0:1:(nx*1j), 0:1:(ny*1j)]
    >>> plt.pcolormesh(x, y, sol.x, shading='gouraud')
    >>> plt.colorbar()
    >>> plt.show()
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__root_8py_source_l00025}{25}} of file \mbox{\hyperlink{__root_8py_source}{\+\_\+root.\+py}}.



References \mbox{\hyperlink{__minpack__py_8py_source_l00185}{scipy.\+optimize.\+\_\+minpack\+\_\+py.\+\_\+root\+\_\+hybr()}}, and \mbox{\hyperlink{__root_8py_source_l00264}{\+\_\+root\+\_\+leastsq()}}.



\doxysubsection{Variable Documentation}
\Hypertarget{namespacescipy_1_1optimize_1_1__root_a172eef1e96392775fe745d3dd3732d55}\index{scipy.optimize.\_root@{scipy.optimize.\_root}!\_\_all\_\_@{\_\_all\_\_}}
\index{\_\_all\_\_@{\_\_all\_\_}!scipy.optimize.\_root@{scipy.optimize.\_root}}
\doxysubsubsection{\texorpdfstring{\_\_all\_\_}{\_\_all\_\_}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__root_a172eef1e96392775fe745d3dd3732d55} 
list scipy.\+optimize.\+\_\+root.\+\_\+\+\_\+all\+\_\+\+\_\+ = \mbox{[}\textquotesingle{}\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__root_a0074362993188d5dd59628411a0c1e05}{root}}\textquotesingle{}\mbox{]}\hspace{0.3cm}{\ttfamily [private]}}



Definition at line \mbox{\hyperlink{__root_8py_source_l00008}{8}} of file \mbox{\hyperlink{__root_8py_source}{\+\_\+root.\+py}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__root_a1b31661557978491ede1460c5d509109}\index{scipy.optimize.\_root@{scipy.optimize.\_root}!ROOT\_METHODS@{ROOT\_METHODS}}
\index{ROOT\_METHODS@{ROOT\_METHODS}!scipy.optimize.\_root@{scipy.optimize.\_root}}
\doxysubsubsection{\texorpdfstring{ROOT\_METHODS}{ROOT\_METHODS}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__root_a1b31661557978491ede1460c5d509109} 
list scipy.\+optimize.\+\_\+root.\+ROOT\+\_\+\+METHODS}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ [\textcolor{stringliteral}{'hybr'},\ \textcolor{stringliteral}{'lm'},\ \textcolor{stringliteral}{'broyden1'},\ \textcolor{stringliteral}{'broyden2'},\ \textcolor{stringliteral}{'anderson'},}
\DoxyCodeLine{00002\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'linearmixing'},\ \textcolor{stringliteral}{'diagbroyden'},\ \textcolor{stringliteral}{'excitingmixing'},\ \textcolor{stringliteral}{'krylov'},}
\DoxyCodeLine{00003\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'df-\/sane'}]}

\end{DoxyCode}


Definition at line \mbox{\hyperlink{__root_8py_source_l00020}{20}} of file \mbox{\hyperlink{__root_8py_source}{\+\_\+root.\+py}}.

