\doxysection{scipy.\+optimize.\+\_\+zeros\+\_\+py Namespace Reference}
\hypertarget{namespacescipy_1_1optimize_1_1__zeros__py}{}\label{namespacescipy_1_1optimize_1_1__zeros__py}\index{scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}}
\doxysubsubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classscipy_1_1optimize_1_1__zeros__py_1_1RootResults}{Root\+Results}}
\item 
class \mbox{\hyperlink{classscipy_1_1optimize_1_1__zeros__py_1_1TOMS748Solver}{TOMS748\+Solver}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__zeros__py_a3235dfa672e442b19c26409aac1b5346}{results\+\_\+c}} (full\+\_\+output, r)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__zeros__py_aa689dbe6d59afcdcfbd13ead0be02055}{\+\_\+results\+\_\+select}} (full\+\_\+output, r)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__zeros__py_ad630d3429bbccf824c8554900643638a}{\+\_\+wrap\+\_\+nan\+\_\+raise}} (f)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__zeros__py_af424d369dfc1d4ecc41591ee71ec0c8e}{newton}} (func, x0, fprime=None, args=(), tol=1.\+48e-\/8, maxiter=50, fprime2=None, x1=None, rtol=0.\+0, full\+\_\+output=False, disp=\mbox{\hyperlink{classTrue}{True}})
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__zeros__py_a816f02f91e30ce5256d47c82a773c0da}{\+\_\+array\+\_\+newton}} (func, x0, fprime, args, tol, maxiter, fprime2, full\+\_\+output)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__zeros__py_ac2ca5c9782c2ff22c2f5b8ea9081d190}{bisect}} (f, a, b, args=(), xtol=\+\_\+xtol, rtol=\+\_\+rtol, maxiter=\+\_\+iter, full\+\_\+output=False, disp=\mbox{\hyperlink{classTrue}{True}})
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__zeros__py_a00cd37dc830933efa5e8629b8b3f4aa0}{ridder}} (f, a, b, args=(), xtol=\+\_\+xtol, rtol=\+\_\+rtol, maxiter=\+\_\+iter, full\+\_\+output=False, disp=\mbox{\hyperlink{classTrue}{True}})
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__zeros__py_a22d4c7381bf744ebf05e3f6038e44291}{brentq}} (f, a, b, args=(), xtol=\+\_\+xtol, rtol=\+\_\+rtol, maxiter=\+\_\+iter, full\+\_\+output=False, disp=\mbox{\hyperlink{classTrue}{True}})
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__zeros__py_a2b5639636c7d4e83b35a9226e6f0ac26}{brenth}} (f, a, b, args=(), xtol=\+\_\+xtol, rtol=\+\_\+rtol, maxiter=\+\_\+iter, full\+\_\+output=False, disp=\mbox{\hyperlink{classTrue}{True}})
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__zeros__py_a624b3723b6549240919ca0c48ba2605b}{\+\_\+notclose}} (fs, rtol=\+\_\+rtol, atol=\+\_\+xtol)
\begin{DoxyCompactList}\small\item\em TOMS "{}\+Algorithm 748\+: Enclosing Zeros of Continuous Functions"{}, by Alefeld, G. \end{DoxyCompactList}\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__zeros__py_a4ceb913cf0d9139944a688b40f06be50}{\+\_\+secant}} (xvals, fvals)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__zeros__py_af19a3ffa91c232ae3807d37fe5629855}{\+\_\+update\+\_\+bracket}} (ab, fab, c, fc)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__zeros__py_af8aa25d3c0b08e83de24ede212ac55a9}{\+\_\+compute\+\_\+divided\+\_\+differences}} (xvals, fvals, N=None, full=\mbox{\hyperlink{classTrue}{True}}, forward=\mbox{\hyperlink{classTrue}{True}})
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__zeros__py_a2fb4a7be3de6d8012d9eab76f941da21}{\+\_\+interpolated\+\_\+poly}} (xvals, fvals, x)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__zeros__py_a4170f46e79e01e260f5a249adc29ac5a}{\+\_\+inverse\+\_\+poly\+\_\+zero}} (a, b, c, d, fa, fb, fc, fd)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__zeros__py_a38db354308b7ebbb332753e4c89400a5}{\+\_\+newton\+\_\+quadratic}} (ab, fab, d, fd, k)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__zeros__py_ae5004a1b9230e65d0ae385379d1cf1ed}{toms748}} (f, a, b, args=(), k=1, xtol=\+\_\+xtol, rtol=\+\_\+rtol, maxiter=\+\_\+iter, full\+\_\+output=False, disp=\mbox{\hyperlink{classTrue}{True}})
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
int \mbox{\hyperlink{namespacescipy_1_1optimize_1_1__zeros__py_ab4b892c756bdbbd1cbc39f27d92df5c2}{\+\_\+iter}} = 100
\item 
int \mbox{\hyperlink{namespacescipy_1_1optimize_1_1__zeros__py_afd7eb0e42203b1c6c4b40521ec16bea9}{\+\_\+xtol}} = 2e-\/12
\item 
int \mbox{\hyperlink{namespacescipy_1_1optimize_1_1__zeros__py_a9d9dbe7fa007420b1d111c3329e3b89a}{\+\_\+rtol}} = 4 \texorpdfstring{$\ast$}{*} np.\+finfo(float).eps
\item 
list \mbox{\hyperlink{namespacescipy_1_1optimize_1_1__zeros__py_ac3eb6942ed5872bbec489f01d842d02d}{\+\_\+\+\_\+all\+\_\+\+\_\+}}
\item 
int \mbox{\hyperlink{namespacescipy_1_1optimize_1_1__zeros__py_af4bcdd971836677ee38d2d86f050888b}{\+\_\+\+ECONVERGED}} = 0
\item 
int \mbox{\hyperlink{namespacescipy_1_1optimize_1_1__zeros__py_a0238c88b7478ae9555103137c3275405}{\+\_\+\+ESIGNERR}} = -\/1
\item 
int \mbox{\hyperlink{namespacescipy_1_1optimize_1_1__zeros__py_a774fd1666eaace48a1e96b5cb57ad8be}{\+\_\+\+ECONVERR}} = -\/2
\item 
int \mbox{\hyperlink{namespacescipy_1_1optimize_1_1__zeros__py_a9dd7b77302c86b135a86e9ecf6dc96ee}{\+\_\+\+EVALUEERR}} = -\/3
\item 
int \mbox{\hyperlink{namespacescipy_1_1optimize_1_1__zeros__py_a510c7861992d3edabbc67eb63bab3025}{\+\_\+\+EINPROGRESS}} = 1
\item 
str \mbox{\hyperlink{namespacescipy_1_1optimize_1_1__zeros__py_a789cf251f5f3f8dda6d1572a32a2d100}{CONVERGED}} = \textquotesingle{}converged\textquotesingle{}
\item 
str \mbox{\hyperlink{namespacescipy_1_1optimize_1_1__zeros__py_a5b07357c3683e74fc4b96789a269db62}{SIGNERR}} = \textquotesingle{}sign error\textquotesingle{}
\item 
str \mbox{\hyperlink{namespacescipy_1_1optimize_1_1__zeros__py_a13ce602a6739ba11af2e141dc0c2ba91}{CONVERR}} = \textquotesingle{}convergence error\textquotesingle{}
\item 
str \mbox{\hyperlink{namespacescipy_1_1optimize_1_1__zeros__py_abed4a7ba25901d7400ec1b2872815dac}{VALUEERR}} = \textquotesingle{}value error\textquotesingle{}
\item 
str \mbox{\hyperlink{namespacescipy_1_1optimize_1_1__zeros__py_a8381cb99a373fe3c6579e004730edb03}{INPROGRESS}} = \textquotesingle{}No error\textquotesingle{}
\item 
dict \mbox{\hyperlink{namespacescipy_1_1optimize_1_1__zeros__py_af7947d48cdb026201f385bde32e43b21}{flag\+\_\+map}}
\end{DoxyCompactItemize}


\doxysubsection{Function Documentation}
\Hypertarget{namespacescipy_1_1optimize_1_1__zeros__py_a816f02f91e30ce5256d47c82a773c0da}\index{scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}!\_array\_newton@{\_array\_newton}}
\index{\_array\_newton@{\_array\_newton}!scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}}
\doxysubsubsection{\texorpdfstring{\_array\_newton()}{\_array\_newton()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__zeros__py_a816f02f91e30ce5256d47c82a773c0da} 
scipy.\+optimize.\+\_\+zeros\+\_\+py.\+\_\+array\+\_\+newton (\begin{DoxyParamCaption}\item[{}]{func}{, }\item[{}]{x0}{, }\item[{}]{fprime}{, }\item[{}]{args}{, }\item[{}]{tol}{, }\item[{}]{maxiter}{, }\item[{}]{fprime2}{, }\item[{}]{full\+\_\+output}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}A vectorized version of Newton, Halley, and secant methods for arrays.

Do not use this method directly. This method is called from `newton`
when ``np.size(x0) > 1`` is ``True``. For docstring, see `newton`.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__zeros__py_8py_source_l00389}{389}} of file \mbox{\hyperlink{__zeros__py_8py_source}{\+\_\+zeros\+\_\+py.\+py}}.



Referenced by \mbox{\hyperlink{__zeros__py_8py_source_l00107}{newton()}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__zeros__py_af8aa25d3c0b08e83de24ede212ac55a9}\index{scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}!\_compute\_divided\_differences@{\_compute\_divided\_differences}}
\index{\_compute\_divided\_differences@{\_compute\_divided\_differences}!scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}}
\doxysubsubsection{\texorpdfstring{\_compute\_divided\_differences()}{\_compute\_divided\_differences()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__zeros__py_af8aa25d3c0b08e83de24ede212ac55a9} 
scipy.\+optimize.\+\_\+zeros\+\_\+py.\+\_\+compute\+\_\+divided\+\_\+differences (\begin{DoxyParamCaption}\item[{}]{xvals}{, }\item[{}]{fvals}{, }\item[{}]{N}{ = {\ttfamily None}, }\item[{}]{full}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}, }\item[{}]{forward}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Return a matrix of divided differences for the xvals, fvals pairs

DD[i, j] = f[x_{i-j}, ..., x_i] for 0 <= j <= i

If full is False, just return the main diagonal(or last row):
  f[a], f[a, b] and f[a, b, c].
If forward is False, return f[c], f[b, c], f[a, b, c].\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__zeros__py_8py_source_l00961}{961}} of file \mbox{\hyperlink{__zeros__py_8py_source}{\+\_\+zeros\+\_\+py.\+py}}.



Referenced by \mbox{\hyperlink{__zeros__py_8py_source_l01026}{\+\_\+newton\+\_\+quadratic()}}, and \mbox{\hyperlink{__zeros__py_8py_source_l01155}{scipy.\+optimize.\+\_\+zeros\+\_\+py.\+TOMS748\+Solver.\+iterate()}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__zeros__py_a2fb4a7be3de6d8012d9eab76f941da21}\index{scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}!\_interpolated\_poly@{\_interpolated\_poly}}
\index{\_interpolated\_poly@{\_interpolated\_poly}!scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}}
\doxysubsubsection{\texorpdfstring{\_interpolated\_poly()}{\_interpolated\_poly()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__zeros__py_a2fb4a7be3de6d8012d9eab76f941da21} 
scipy.\+optimize.\+\_\+zeros\+\_\+py.\+\_\+interpolated\+\_\+poly (\begin{DoxyParamCaption}\item[{}]{xvals}{, }\item[{}]{fvals}{, }\item[{}]{x}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Compute p(x) for the polynomial passing through the specified locations.

Use Neville's algorithm to compute p(x) where p is the minimal degree
polynomial passing through the points xvals, fvals\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__zeros__py_8py_source_l00996}{996}} of file \mbox{\hyperlink{__zeros__py_8py_source}{\+\_\+zeros\+\_\+py.\+py}}.



Referenced by \mbox{\hyperlink{__zeros__py_8py_source_l01016}{\+\_\+inverse\+\_\+poly\+\_\+zero()}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__zeros__py_a4170f46e79e01e260f5a249adc29ac5a}\index{scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}!\_inverse\_poly\_zero@{\_inverse\_poly\_zero}}
\index{\_inverse\_poly\_zero@{\_inverse\_poly\_zero}!scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}}
\doxysubsubsection{\texorpdfstring{\_inverse\_poly\_zero()}{\_inverse\_poly\_zero()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__zeros__py_a4170f46e79e01e260f5a249adc29ac5a} 
scipy.\+optimize.\+\_\+zeros\+\_\+py.\+\_\+inverse\+\_\+poly\+\_\+zero (\begin{DoxyParamCaption}\item[{}]{a}{, }\item[{}]{b}{, }\item[{}]{c}{, }\item[{}]{d}{, }\item[{}]{fa}{, }\item[{}]{fb}{, }\item[{}]{fc}{, }\item[{}]{fd}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Inverse cubic interpolation f-values -> x-values

Given four points (fa, a), (fb, b), (fc, c), (fd, d) with
fa, fb, fc, fd all distinct, find poly IP(y) through the 4 points
and compute x=IP(0).
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__zeros__py_8py_source_l01016}{1016}} of file \mbox{\hyperlink{__zeros__py_8py_source}{\+\_\+zeros\+\_\+py.\+py}}.



References \mbox{\hyperlink{__zeros__py_8py_source_l00996}{\+\_\+interpolated\+\_\+poly()}}.



Referenced by \mbox{\hyperlink{__zeros__py_8py_source_l01155}{scipy.\+optimize.\+\_\+zeros\+\_\+py.\+TOMS748\+Solver.\+iterate()}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__zeros__py_a38db354308b7ebbb332753e4c89400a5}\index{scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}!\_newton\_quadratic@{\_newton\_quadratic}}
\index{\_newton\_quadratic@{\_newton\_quadratic}!scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}}
\doxysubsubsection{\texorpdfstring{\_newton\_quadratic()}{\_newton\_quadratic()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__zeros__py_a38db354308b7ebbb332753e4c89400a5} 
scipy.\+optimize.\+\_\+zeros\+\_\+py.\+\_\+newton\+\_\+quadratic (\begin{DoxyParamCaption}\item[{}]{ab}{, }\item[{}]{fab}{, }\item[{}]{d}{, }\item[{}]{fd}{, }\item[{}]{k}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Apply Newton-Raphson like steps, using divided differences to approximate f'

ab is a real interval [a, b] containing a root,
fab holds the real values of f(a), f(b)
d is a real number outside [ab, b]
k is the number of steps to apply
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__zeros__py_8py_source_l01026}{1026}} of file \mbox{\hyperlink{__zeros__py_8py_source}{\+\_\+zeros\+\_\+py.\+py}}.



References \mbox{\hyperlink{__zeros__py_8py_source_l00962}{\+\_\+compute\+\_\+divided\+\_\+differences()}}.



Referenced by \mbox{\hyperlink{__zeros__py_8py_source_l01155}{scipy.\+optimize.\+\_\+zeros\+\_\+py.\+TOMS748\+Solver.\+iterate()}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__zeros__py_a624b3723b6549240919ca0c48ba2605b}\index{scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}!\_notclose@{\_notclose}}
\index{\_notclose@{\_notclose}!scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}}
\doxysubsubsection{\texorpdfstring{\_notclose()}{\_notclose()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__zeros__py_a624b3723b6549240919ca0c48ba2605b} 
scipy.\+optimize.\+\_\+zeros\+\_\+py.\+\_\+notclose (\begin{DoxyParamCaption}\item[{}]{fs}{, }\item[{}]{rtol}{ = {\ttfamily \+\_\+rtol}, }\item[{}]{atol}{ = {\ttfamily \+\_\+xtol}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



TOMS "{}\+Algorithm 748\+: Enclosing Zeros of Continuous Functions"{}, by Alefeld, G. 

E. and Potra, F. A. and Shi, Yixun, See \mbox{[}1\mbox{]} 

Definition at line \mbox{\hyperlink{__zeros__py_8py_source_l00923}{923}} of file \mbox{\hyperlink{__zeros__py_8py_source}{\+\_\+zeros\+\_\+py.\+py}}.



Referenced by \mbox{\hyperlink{__zeros__py_8py_source_l01155}{scipy.\+optimize.\+\_\+zeros\+\_\+py.\+TOMS748\+Solver.\+iterate()}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__zeros__py_aa689dbe6d59afcdcfbd13ead0be02055}\index{scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}!\_results\_select@{\_results\_select}}
\index{\_results\_select@{\_results\_select}!scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}}
\doxysubsubsection{\texorpdfstring{\_results\_select()}{\_results\_select()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__zeros__py_aa689dbe6d59afcdcfbd13ead0be02055} 
scipy.\+optimize.\+\_\+zeros\+\_\+py.\+\_\+results\+\_\+select (\begin{DoxyParamCaption}\item[{}]{full\+\_\+output}{, }\item[{}]{r}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Select from a tuple of (root, funccalls, iterations, flag)\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__zeros__py_8py_source_l00075}{75}} of file \mbox{\hyperlink{__zeros__py_8py_source}{\+\_\+zeros\+\_\+py.\+py}}.



Referenced by \mbox{\hyperlink{__zeros__py_8py_source_l00107}{newton()}}, and \mbox{\hyperlink{__zeros__py_8py_source_l01270}{toms748()}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__zeros__py_a4ceb913cf0d9139944a688b40f06be50}\index{scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}!\_secant@{\_secant}}
\index{\_secant@{\_secant}!scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}}
\doxysubsubsection{\texorpdfstring{\_secant()}{\_secant()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__zeros__py_a4ceb913cf0d9139944a688b40f06be50} 
scipy.\+optimize.\+\_\+zeros\+\_\+py.\+\_\+secant (\begin{DoxyParamCaption}\item[{}]{xvals}{, }\item[{}]{fvals}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Perform a secant step, taking a little care\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__zeros__py_8py_source_l00932}{932}} of file \mbox{\hyperlink{__zeros__py_8py_source}{\+\_\+zeros\+\_\+py.\+py}}.



Referenced by \mbox{\hyperlink{__zeros__py_8py_source_l01237}{scipy.\+optimize.\+\_\+zeros\+\_\+py.\+TOMS748\+Solver.\+solve()}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__zeros__py_af19a3ffa91c232ae3807d37fe5629855}\index{scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}!\_update\_bracket@{\_update\_bracket}}
\index{\_update\_bracket@{\_update\_bracket}!scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}}
\doxysubsubsection{\texorpdfstring{\_update\_bracket()}{\_update\_bracket()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__zeros__py_af19a3ffa91c232ae3807d37fe5629855} 
scipy.\+optimize.\+\_\+zeros\+\_\+py.\+\_\+update\+\_\+bracket (\begin{DoxyParamCaption}\item[{}]{ab}{, }\item[{}]{fab}{, }\item[{}]{c}{, }\item[{}]{fc}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Update a bracket given (c, fc), return the discarded endpoints.\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__zeros__py_8py_source_l00951}{951}} of file \mbox{\hyperlink{__zeros__py_8py_source}{\+\_\+zeros\+\_\+py.\+py}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__zeros__py_ad630d3429bbccf824c8554900643638a}\index{scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}!\_wrap\_nan\_raise@{\_wrap\_nan\_raise}}
\index{\_wrap\_nan\_raise@{\_wrap\_nan\_raise}!scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}}
\doxysubsubsection{\texorpdfstring{\_wrap\_nan\_raise()}{\_wrap\_nan\_raise()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__zeros__py_ad630d3429bbccf824c8554900643638a} 
scipy.\+optimize.\+\_\+zeros\+\_\+py.\+\_\+wrap\+\_\+nan\+\_\+raise (\begin{DoxyParamCaption}\item[{}]{f}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{__zeros__py_8py_source_l00087}{87}} of file \mbox{\hyperlink{__zeros__py_8py_source}{\+\_\+zeros\+\_\+py.\+py}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__zeros__py_ac2ca5c9782c2ff22c2f5b8ea9081d190}\index{scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}!bisect@{bisect}}
\index{bisect@{bisect}!scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}}
\doxysubsubsection{\texorpdfstring{bisect()}{bisect()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__zeros__py_ac2ca5c9782c2ff22c2f5b8ea9081d190} 
scipy.\+optimize.\+\_\+zeros\+\_\+py.\+bisect (\begin{DoxyParamCaption}\item[{}]{f}{, }\item[{}]{a}{, }\item[{}]{b}{, }\item[{}]{args}{ = {\ttfamily ()}, }\item[{}]{xtol}{ = {\ttfamily \+\_\+xtol}, }\item[{}]{rtol}{ = {\ttfamily \+\_\+rtol}, }\item[{}]{maxiter}{ = {\ttfamily \+\_\+iter}, }\item[{}]{full\+\_\+output}{ = {\ttfamily False}, }\item[{}]{disp}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Find root of a function within an interval using bisection.

Basic bisection routine to find a root of the function `f` between the
arguments `a` and `b`. `f(a)` and `f(b)` cannot have the same signs.
Slow but sure.

Parameters
----------
f : function
    Python function returning a number.  `f` must be continuous, and
    f(a) and f(b) must have opposite signs.
a : scalar
    One end of the bracketing interval [a,b].
b : scalar
    The other end of the bracketing interval [a,b].
xtol : number, optional
    The computed root ``x0`` will satisfy ``np.allclose(x, x0,
    atol=xtol, rtol=rtol)``, where ``x`` is the exact root. The
    parameter must be positive.
rtol : number, optional
    The computed root ``x0`` will satisfy ``np.allclose(x, x0,
    atol=xtol, rtol=rtol)``, where ``x`` is the exact root. The
    parameter cannot be smaller than its default value of
    ``4*np.finfo(float).eps``.
maxiter : int, optional
    If convergence is not achieved in `maxiter` iterations, an error is
    raised. Must be >= 0.
args : tuple, optional
    Containing extra arguments for the function `f`.
    `f` is called by ``apply(f, (x)+args)``.
full_output : bool, optional
    If `full_output` is False, the root is returned. If `full_output` is
    True, the return value is ``(x, r)``, where x is the root, and r is
    a `RootResults` object.
disp : bool, optional
    If True, raise RuntimeError if the algorithm didn't converge.
    Otherwise, the convergence status is recorded in a `RootResults`
    return object.

Returns
-------
root : float
    Root of `f` between `a` and `b`.
r : `RootResults` (present if ``full_output = True``)
    Object containing information about the convergence. In particular,
    ``r.converged`` is True if the routine converged.

Examples
--------

>>> def f(x):
...     return (x**2 - 1)

>>> from scipy import optimize

>>> root = optimize.bisect(f, 0, 2)
>>> root
1.0

>>> root = optimize.bisect(f, -2, 0)
>>> root
-1.0

See Also
--------
brentq, brenth, bisect, newton
fixed_point : scalar fixed-point finder
fsolve : n-dimensional root-finding
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__zeros__py_8py_source_l00491}{491}} of file \mbox{\hyperlink{__zeros__py_8py_source}{\+\_\+zeros\+\_\+py.\+py}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__zeros__py_a2b5639636c7d4e83b35a9226e6f0ac26}\index{scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}!brenth@{brenth}}
\index{brenth@{brenth}!scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}}
\doxysubsubsection{\texorpdfstring{brenth()}{brenth()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__zeros__py_a2b5639636c7d4e83b35a9226e6f0ac26} 
scipy.\+optimize.\+\_\+zeros\+\_\+py.\+brenth (\begin{DoxyParamCaption}\item[{}]{f}{, }\item[{}]{a}{, }\item[{}]{b}{, }\item[{}]{args}{ = {\ttfamily ()}, }\item[{}]{xtol}{ = {\ttfamily \+\_\+xtol}, }\item[{}]{rtol}{ = {\ttfamily \+\_\+rtol}, }\item[{}]{maxiter}{ = {\ttfamily \+\_\+iter}, }\item[{}]{full\+\_\+output}{ = {\ttfamily False}, }\item[{}]{disp}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Find a root of a function in a bracketing interval using Brent's
method with hyperbolic extrapolation.

A variation on the classic Brent routine to find a root of the function f
between the arguments a and b that uses hyperbolic extrapolation instead of
inverse quadratic extrapolation. Bus & Dekker (1975) guarantee convergence
for this method, claiming that the upper bound of function evaluations here
is 4 or 5 times lesser than that for bisection.
f(a) and f(b) cannot have the same signs. Generally, on a par with the
brent routine, but not as heavily tested. It is a safe version of the
secant method that uses hyperbolic extrapolation.
The version here is by Chuck Harris, and implements Algorithm M of
[BusAndDekker1975]_, where further details (convergence properties,
additional remarks and such) can be found

Parameters
----------
f : function
    Python function returning a number. f must be continuous, and f(a) and
    f(b) must have opposite signs.
a : scalar
    One end of the bracketing interval [a,b].
b : scalar
    The other end of the bracketing interval [a,b].
xtol : number, optional
    The computed root ``x0`` will satisfy ``np.allclose(x, x0,
    atol=xtol, rtol=rtol)``, where ``x`` is the exact root. The
    parameter must be positive. As with `brentq`, for nice
    functions the method will often satisfy the above condition
    with ``xtol/2`` and ``rtol/2``.
rtol : number, optional
    The computed root ``x0`` will satisfy ``np.allclose(x, x0,
    atol=xtol, rtol=rtol)``, where ``x`` is the exact root. The
    parameter cannot be smaller than its default value of
    ``4*np.finfo(float).eps``. As with `brentq`, for nice functions
    the method will often satisfy the above condition with
    ``xtol/2`` and ``rtol/2``.
maxiter : int, optional
    If convergence is not achieved in `maxiter` iterations, an error is
    raised. Must be >= 0.
args : tuple, optional
    Containing extra arguments for the function `f`.
    `f` is called by ``apply(f, (x)+args)``.
full_output : bool, optional
    If `full_output` is False, the root is returned. If `full_output` is
    True, the return value is ``(x, r)``, where `x` is the root, and `r` is
    a `RootResults` object.
disp : bool, optional
    If True, raise RuntimeError if the algorithm didn't converge.
    Otherwise, the convergence status is recorded in any `RootResults`
    return object.

Returns
-------
root : float
    Root of `f` between `a` and `b`.
r : `RootResults` (present if ``full_output = True``)
    Object containing information about the convergence. In particular,
    ``r.converged`` is True if the routine converged.

See Also
--------
fmin, fmin_powell, fmin_cg, fmin_bfgs, fmin_ncg : multivariate local optimizers
leastsq : nonlinear least squares minimizer
fmin_l_bfgs_b, fmin_tnc, fmin_cobyla : constrained multivariate optimizers
basinhopping, differential_evolution, brute : global optimizers
fminbound, brent, golden, bracket : local scalar minimizers
fsolve : N-D root-finding
brentq, brenth, ridder, bisect, newton : 1-D root-finding
fixed_point : scalar fixed-point finder

References
----------
.. [BusAndDekker1975]
   Bus, J. C. P., Dekker, T. J.,
   "Two Efficient Algorithms with Guaranteed Convergence for Finding a Zero
   of a Function", ACM Transactions on Mathematical Software, Vol. 1, Issue
   4, Dec. 1975, pp. 330-345. Section 3: "Algorithm M".
   :doi:`10.1145/355656.355659`

Examples
--------
>>> def f(x):
...     return (x**2 - 1)

>>> from scipy import optimize

>>> root = optimize.brenth(f, -2, 0)
>>> root
-1.0

>>> root = optimize.brenth(f, 0, 2)
>>> root
1.0
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__zeros__py_8py_source_l00806}{806}} of file \mbox{\hyperlink{__zeros__py_8py_source}{\+\_\+zeros\+\_\+py.\+py}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__zeros__py_a22d4c7381bf744ebf05e3f6038e44291}\index{scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}!brentq@{brentq}}
\index{brentq@{brentq}!scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}}
\doxysubsubsection{\texorpdfstring{brentq()}{brentq()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__zeros__py_a22d4c7381bf744ebf05e3f6038e44291} 
scipy.\+optimize.\+\_\+zeros\+\_\+py.\+brentq (\begin{DoxyParamCaption}\item[{}]{f}{, }\item[{}]{a}{, }\item[{}]{b}{, }\item[{}]{args}{ = {\ttfamily ()}, }\item[{}]{xtol}{ = {\ttfamily \+\_\+xtol}, }\item[{}]{rtol}{ = {\ttfamily \+\_\+rtol}, }\item[{}]{maxiter}{ = {\ttfamily \+\_\+iter}, }\item[{}]{full\+\_\+output}{ = {\ttfamily False}, }\item[{}]{disp}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Find a root of a function in a bracketing interval using Brent's method.

Uses the classic Brent's method to find a root of the function `f` on
the sign changing interval [a , b]. Generally considered the best of the
rootfinding routines here. It is a safe version of the secant method that
uses inverse quadratic extrapolation. Brent's method combines root
bracketing, interval bisection, and inverse quadratic interpolation. It is
sometimes known as the van Wijngaarden-Dekker-Brent method. Brent (1973)
claims convergence is guaranteed for functions computable within [a,b].

[Brent1973]_ provides the classic description of the algorithm. Another
description can be found in a recent edition of Numerical Recipes, including
[PressEtal1992]_. A third description is at
http://mathworld.wolfram.com/BrentsMethod.html. It should be easy to
understand the algorithm just by reading our code. Our code diverges a bit
from standard presentations: we choose a different formula for the
extrapolation step.

Parameters
----------
f : function
    Python function returning a number. The function :math:`f`
    must be continuous, and :math:`f(a)` and :math:`f(b)` must
    have opposite signs.
a : scalar
    One end of the bracketing interval :math:`[a, b]`.
b : scalar
    The other end of the bracketing interval :math:`[a, b]`.
xtol : number, optional
    The computed root ``x0`` will satisfy ``np.allclose(x, x0,
    atol=xtol, rtol=rtol)``, where ``x`` is the exact root. The
    parameter must be positive. For nice functions, Brent's
    method will often satisfy the above condition with ``xtol/2``
    and ``rtol/2``. [Brent1973]_
rtol : number, optional
    The computed root ``x0`` will satisfy ``np.allclose(x, x0,
    atol=xtol, rtol=rtol)``, where ``x`` is the exact root. The
    parameter cannot be smaller than its default value of
    ``4*np.finfo(float).eps``. For nice functions, Brent's
    method will often satisfy the above condition with ``xtol/2``
    and ``rtol/2``. [Brent1973]_
maxiter : int, optional
    If convergence is not achieved in `maxiter` iterations, an error is
    raised. Must be >= 0.
args : tuple, optional
    Containing extra arguments for the function `f`.
    `f` is called by ``apply(f, (x)+args)``.
full_output : bool, optional
    If `full_output` is False, the root is returned. If `full_output` is
    True, the return value is ``(x, r)``, where `x` is the root, and `r` is
    a `RootResults` object.
disp : bool, optional
    If True, raise RuntimeError if the algorithm didn't converge.
    Otherwise, the convergence status is recorded in any `RootResults`
    return object.

Returns
-------
root : float
    Root of `f` between `a` and `b`.
r : `RootResults` (present if ``full_output = True``)
    Object containing information about the convergence. In particular,
    ``r.converged`` is True if the routine converged.

Notes
-----
`f` must be continuous.  f(a) and f(b) must have opposite signs.

Related functions fall into several classes:

multivariate local optimizers
  `fmin`, `fmin_powell`, `fmin_cg`, `fmin_bfgs`, `fmin_ncg`
nonlinear least squares minimizer
  `leastsq`
constrained multivariate optimizers
  `fmin_l_bfgs_b`, `fmin_tnc`, `fmin_cobyla`
global optimizers
  `basinhopping`, `brute`, `differential_evolution`
local scalar minimizers
  `fminbound`, `brent`, `golden`, `bracket`
N-D root-finding
  `fsolve`
1-D root-finding
  `brenth`, `ridder`, `bisect`, `newton`
scalar fixed-point finder
  `fixed_point`

References
----------
.. [Brent1973]
   Brent, R. P.,
   *Algorithms for Minimization Without Derivatives*.
   Englewood Cliffs, NJ: Prentice-Hall, 1973. Ch. 3-4.

.. [PressEtal1992]
   Press, W. H.; Flannery, B. P.; Teukolsky, S. A.; and Vetterling, W. T.
   *Numerical Recipes in FORTRAN: The Art of Scientific Computing*, 2nd ed.
   Cambridge, England: Cambridge University Press, pp. 352-355, 1992.
   Section 9.3:  "Van Wijngaarden-Dekker-Brent Method."

Examples
--------
>>> def f(x):
...     return (x**2 - 1)

>>> from scipy import optimize

>>> root = optimize.brentq(f, -2, 0)
>>> root
-1.0

>>> root = optimize.brentq(f, 0, 2)
>>> root
1.0
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__zeros__py_8py_source_l00675}{675}} of file \mbox{\hyperlink{__zeros__py_8py_source}{\+\_\+zeros\+\_\+py.\+py}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__zeros__py_af424d369dfc1d4ecc41591ee71ec0c8e}\index{scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}!newton@{newton}}
\index{newton@{newton}!scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}}
\doxysubsubsection{\texorpdfstring{newton()}{newton()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__zeros__py_af424d369dfc1d4ecc41591ee71ec0c8e} 
scipy.\+optimize.\+\_\+zeros\+\_\+py.\+newton (\begin{DoxyParamCaption}\item[{}]{func}{, }\item[{}]{x0}{, }\item[{}]{fprime}{ = {\ttfamily None}, }\item[{}]{args}{ = {\ttfamily ()}, }\item[{}]{tol}{ = {\ttfamily 1.48e-\/8}, }\item[{}]{maxiter}{ = {\ttfamily 50}, }\item[{}]{fprime2}{ = {\ttfamily None}, }\item[{}]{x1}{ = {\ttfamily None}, }\item[{}]{rtol}{ = {\ttfamily 0.0}, }\item[{}]{full\+\_\+output}{ = {\ttfamily False}, }\item[{}]{disp}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Find a root of a real or complex function using the Newton-Raphson
(or secant or Halley's) method.

Find a root of the scalar-valued function `func` given a nearby scalar
starting point `x0`.
The Newton-Raphson method is used if the derivative `fprime` of `func`
is provided, otherwise the secant method is used. If the second order
derivative `fprime2` of `func` is also provided, then Halley's method is
used.

If `x0` is a sequence with more than one item, `newton` returns an array:
the roots of the function from each (scalar) starting point in `x0`.
In this case, `func` must be vectorized to return a sequence or array of
the same shape as its first argument. If `fprime` (`fprime2`) is given,
then its return must also have the same shape: each element is the first
(second) derivative of `func` with respect to its only variable evaluated
at each element of its first argument.

`newton` is for finding roots of a scalar-valued functions of a single
variable. For problems involving several variables, see `root`.

Parameters
----------
func : callable
    The function whose root is wanted. It must be a function of a
    single variable of the form ``f(x,a,b,c...)``, where ``a,b,c...``
    are extra arguments that can be passed in the `args` parameter.
x0 : float, sequence, or ndarray
    An initial estimate of the root that should be somewhere near the
    actual root. If not scalar, then `func` must be vectorized and return
    a sequence or array of the same shape as its first argument.
fprime : callable, optional
    The derivative of the function when available and convenient. If it
    is None (default), then the secant method is used.
args : tuple, optional
    Extra arguments to be used in the function call.
tol : float, optional
    The allowable error of the root's value. If `func` is complex-valued,
    a larger `tol` is recommended as both the real and imaginary parts
    of `x` contribute to ``|x - x0|``.
maxiter : int, optional
    Maximum number of iterations.
fprime2 : callable, optional
    The second order derivative of the function when available and
    convenient. If it is None (default), then the normal Newton-Raphson
    or the secant method is used. If it is not None, then Halley's method
    is used.
x1 : float, optional
    Another estimate of the root that should be somewhere near the
    actual root. Used if `fprime` is not provided.
rtol : float, optional
    Tolerance (relative) for termination.
full_output : bool, optional
    If `full_output` is False (default), the root is returned.
    If True and `x0` is scalar, the return value is ``(x, r)``, where ``x``
    is the root and ``r`` is a `RootResults` object.
    If True and `x0` is non-scalar, the return value is ``(x, converged,
    zero_der)`` (see Returns section for details).
disp : bool, optional
    If True, raise a RuntimeError if the algorithm didn't converge, with
    the error message containing the number of iterations and current
    function value. Otherwise, the convergence status is recorded in a
    `RootResults` return object.
    Ignored if `x0` is not scalar.
    *Note: this has little to do with displaying, however,
    the `disp` keyword cannot be renamed for backwards compatibility.*

Returns
-------
root : float, sequence, or ndarray
    Estimated location where function is zero.
r : `RootResults`, optional
    Present if ``full_output=True`` and `x0` is scalar.
    Object containing information about the convergence. In particular,
    ``r.converged`` is True if the routine converged.
converged : ndarray of bool, optional
    Present if ``full_output=True`` and `x0` is non-scalar.
    For vector functions, indicates which elements converged successfully.
zero_der : ndarray of bool, optional
    Present if ``full_output=True`` and `x0` is non-scalar.
    For vector functions, indicates which elements had a zero derivative.

See Also
--------
root_scalar : interface to root solvers for scalar functions
root : interface to root solvers for multi-input, multi-output functions

Notes
-----
The convergence rate of the Newton-Raphson method is quadratic,
the Halley method is cubic, and the secant method is
sub-quadratic. This means that if the function is well-behaved
the actual error in the estimated root after the nth iteration
is approximately the square (cube for Halley) of the error
after the (n-1)th step. However, the stopping criterion used
here is the step size and there is no guarantee that a root
has been found. Consequently, the result should be verified.
Safer algorithms are brentq, brenth, ridder, and bisect,
but they all require that the root first be bracketed in an
interval where the function changes sign. The brentq algorithm
is recommended for general use in one dimensional problems
when such an interval has been found.

When `newton` is used with arrays, it is best suited for the following
types of problems:

* The initial guesses, `x0`, are all relatively the same distance from
  the roots.
* Some or all of the extra arguments, `args`, are also arrays so that a
  class of similar problems can be solved together.
* The size of the initial guesses, `x0`, is larger than O(100) elements.
  Otherwise, a naive loop may perform as well or better than a vector.

Examples
--------
>>> import numpy as np
>>> import matplotlib.pyplot as plt
>>> from scipy import optimize

>>> def f(x):
...     return (x**3 - 1)  # only one real root at x = 1

``fprime`` is not provided, use the secant method:

>>> root = optimize.newton(f, 1.5)
>>> root
1.0000000000000016
>>> root = optimize.newton(f, 1.5, fprime2=lambda x: 6 * x)
>>> root
1.0000000000000016

Only ``fprime`` is provided, use the Newton-Raphson method:

>>> root = optimize.newton(f, 1.5, fprime=lambda x: 3 * x**2)
>>> root
1.0

Both ``fprime2`` and ``fprime`` are provided, use Halley's method:

>>> root = optimize.newton(f, 1.5, fprime=lambda x: 3 * x**2,
...                        fprime2=lambda x: 6 * x)
>>> root
1.0

When we want to find roots for a set of related starting values and/or
function parameters, we can provide both of those as an array of inputs:

>>> f = lambda x, a: x**3 - a
>>> fder = lambda x, a: 3 * x**2
>>> rng = np.random.default_rng()
>>> x = rng.standard_normal(100)
>>> a = np.arange(-50, 50)
>>> vec_res = optimize.newton(f, x, fprime=fder, args=(a, ), maxiter=200)

The above is the equivalent of solving for each value in ``(x, a)``
separately in a for-loop, just faster:

>>> loop_res = [optimize.newton(f, x0, fprime=fder, args=(a0,),
...                             maxiter=200)
...             for x0, a0 in zip(x, a)]
>>> np.allclose(vec_res, loop_res)
True

Plot the results found for all values of ``a``:

>>> analytical_result = np.sign(a) * np.abs(a)**(1/3)
>>> fig, ax = plt.subplots()
>>> ax.plot(a, analytical_result, 'o')
>>> ax.plot(a, vec_res, '.')
>>> ax.set_xlabel('$a$')
>>> ax.set_ylabel('$x$ where $f(x, a)=0$')
>>> plt.show()
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__zeros__py_8py_source_l00105}{105}} of file \mbox{\hyperlink{__zeros__py_8py_source}{\+\_\+zeros\+\_\+py.\+py}}.



References \mbox{\hyperlink{__zeros__py_8py_source_l00389}{\+\_\+array\+\_\+newton()}}, and \mbox{\hyperlink{__zeros__py_8py_source_l00075}{\+\_\+results\+\_\+select()}}.



Referenced by \mbox{\hyperlink{test__zeros_8py_source_l00329}{scipy.\+optimize.\+tests.\+test\+\_\+zeros.\+Test\+Newton.\+test\+\_\+array\+\_\+secant\+\_\+active\+\_\+zero\+\_\+der()}}, \mbox{\hyperlink{test__zeros_8py_source_l00682}{scipy.\+optimize.\+tests.\+test\+\_\+zeros.\+test\+\_\+gh\+\_\+8881()}}, and \mbox{\hyperlink{test__zeros_8py_source_l00708}{scipy.\+optimize.\+tests.\+test\+\_\+zeros.\+test\+\_\+gh\+\_\+9608\+\_\+preserve\+\_\+array\+\_\+shape()}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__zeros__py_a3235dfa672e442b19c26409aac1b5346}\index{scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}!results\_c@{results\_c}}
\index{results\_c@{results\_c}!scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}}
\doxysubsubsection{\texorpdfstring{results\_c()}{results\_c()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__zeros__py_a3235dfa672e442b19c26409aac1b5346} 
scipy.\+optimize.\+\_\+zeros\+\_\+py.\+results\+\_\+c (\begin{DoxyParamCaption}\item[{}]{full\+\_\+output}{, }\item[{}]{r}{}\end{DoxyParamCaption})}



Definition at line \mbox{\hyperlink{__zeros__py_8py_source_l00063}{63}} of file \mbox{\hyperlink{__zeros__py_8py_source}{\+\_\+zeros\+\_\+py.\+py}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__zeros__py_a00cd37dc830933efa5e8629b8b3f4aa0}\index{scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}!ridder@{ridder}}
\index{ridder@{ridder}!scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}}
\doxysubsubsection{\texorpdfstring{ridder()}{ridder()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__zeros__py_a00cd37dc830933efa5e8629b8b3f4aa0} 
scipy.\+optimize.\+\_\+zeros\+\_\+py.\+ridder (\begin{DoxyParamCaption}\item[{}]{f}{, }\item[{}]{a}{, }\item[{}]{b}{, }\item[{}]{args}{ = {\ttfamily ()}, }\item[{}]{xtol}{ = {\ttfamily \+\_\+xtol}, }\item[{}]{rtol}{ = {\ttfamily \+\_\+rtol}, }\item[{}]{maxiter}{ = {\ttfamily \+\_\+iter}, }\item[{}]{full\+\_\+output}{ = {\ttfamily False}, }\item[{}]{disp}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Find a root of a function in an interval using Ridder's method.

Parameters
----------
f : function
    Python function returning a number. f must be continuous, and f(a) and
    f(b) must have opposite signs.
a : scalar
    One end of the bracketing interval [a,b].
b : scalar
    The other end of the bracketing interval [a,b].
xtol : number, optional
    The computed root ``x0`` will satisfy ``np.allclose(x, x0,
    atol=xtol, rtol=rtol)``, where ``x`` is the exact root. The
    parameter must be positive.
rtol : number, optional
    The computed root ``x0`` will satisfy ``np.allclose(x, x0,
    atol=xtol, rtol=rtol)``, where ``x`` is the exact root. The
    parameter cannot be smaller than its default value of
    ``4*np.finfo(float).eps``.
maxiter : int, optional
    If convergence is not achieved in `maxiter` iterations, an error is
    raised. Must be >= 0.
args : tuple, optional
    Containing extra arguments for the function `f`.
    `f` is called by ``apply(f, (x)+args)``.
full_output : bool, optional
    If `full_output` is False, the root is returned. If `full_output` is
    True, the return value is ``(x, r)``, where `x` is the root, and `r` is
    a `RootResults` object.
disp : bool, optional
    If True, raise RuntimeError if the algorithm didn't converge.
    Otherwise, the convergence status is recorded in any `RootResults`
    return object.

Returns
-------
root : float
    Root of `f` between `a` and `b`.
r : `RootResults` (present if ``full_output = True``)
    Object containing information about the convergence.
    In particular, ``r.converged`` is True if the routine converged.

See Also
--------
brentq, brenth, bisect, newton : 1-D root-finding
fixed_point : scalar fixed-point finder

Notes
-----
Uses [Ridders1979]_ method to find a root of the function `f` between the
arguments `a` and `b`. Ridders' method is faster than bisection, but not
generally as fast as the Brent routines. [Ridders1979]_ provides the
classic description and source of the algorithm. A description can also be
found in any recent edition of Numerical Recipes.

The routine used here diverges slightly from standard presentations in
order to be a bit more careful of tolerance.

References
----------
.. [Ridders1979]
   Ridders, C. F. J. "A New Algorithm for Computing a
   Single Root of a Real Continuous Function."
   IEEE Trans. Circuits Systems 26, 979-980, 1979.

Examples
--------

>>> def f(x):
...     return (x**2 - 1)

>>> from scipy import optimize

>>> root = optimize.ridder(f, 0, 2)
>>> root
1.0

>>> root = optimize.ridder(f, -2, 0)
>>> root
-1.0
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__zeros__py_8py_source_l00577}{577}} of file \mbox{\hyperlink{__zeros__py_8py_source}{\+\_\+zeros\+\_\+py.\+py}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__zeros__py_ae5004a1b9230e65d0ae385379d1cf1ed}\index{scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}!toms748@{toms748}}
\index{toms748@{toms748}!scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}}
\doxysubsubsection{\texorpdfstring{toms748()}{toms748()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__zeros__py_ae5004a1b9230e65d0ae385379d1cf1ed} 
scipy.\+optimize.\+\_\+zeros\+\_\+py.\+toms748 (\begin{DoxyParamCaption}\item[{}]{f}{, }\item[{}]{a}{, }\item[{}]{b}{, }\item[{}]{args}{ = {\ttfamily ()}, }\item[{}]{k}{ = {\ttfamily 1}, }\item[{}]{xtol}{ = {\ttfamily \+\_\+xtol}, }\item[{}]{rtol}{ = {\ttfamily \+\_\+rtol}, }\item[{}]{maxiter}{ = {\ttfamily \+\_\+iter}, }\item[{}]{full\+\_\+output}{ = {\ttfamily False}, }\item[{}]{disp}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Find a root using TOMS Algorithm 748 method.

Implements the Algorithm 748 method of Alefeld, Potro and Shi to find a
root of the function `f` on the interval `[a , b]`, where `f(a)` and
`f(b)` must have opposite signs.

It uses a mixture of inverse cubic interpolation and
"Newton-quadratic" steps. [APS1995].

Parameters
----------
f : function
    Python function returning a scalar. The function :math:`f`
    must be continuous, and :math:`f(a)` and :math:`f(b)`
    have opposite signs.
a : scalar,
    lower boundary of the search interval
b : scalar,
    upper boundary of the search interval
args : tuple, optional
    containing extra arguments for the function `f`.
    `f` is called by ``f(x, *args)``.
k : int, optional
    The number of Newton quadratic steps to perform each
    iteration. ``k>=1``.
xtol : scalar, optional
    The computed root ``x0`` will satisfy ``np.allclose(x, x0,
    atol=xtol, rtol=rtol)``, where ``x`` is the exact root. The
    parameter must be positive.
rtol : scalar, optional
    The computed root ``x0`` will satisfy ``np.allclose(x, x0,
    atol=xtol, rtol=rtol)``, where ``x`` is the exact root.
maxiter : int, optional
    If convergence is not achieved in `maxiter` iterations, an error is
    raised. Must be >= 0.
full_output : bool, optional
    If `full_output` is False, the root is returned. If `full_output` is
    True, the return value is ``(x, r)``, where `x` is the root, and `r` is
    a `RootResults` object.
disp : bool, optional
    If True, raise RuntimeError if the algorithm didn't converge.
    Otherwise, the convergence status is recorded in the `RootResults`
    return object.

Returns
-------
root : float
    Approximate root of `f`
r : `RootResults` (present if ``full_output = True``)
    Object containing information about the convergence. In particular,
    ``r.converged`` is True if the routine converged.

See Also
--------
brentq, brenth, ridder, bisect, newton
fsolve : find roots in N dimensions.

Notes
-----
`f` must be continuous.
Algorithm 748 with ``k=2`` is asymptotically the most efficient
algorithm known for finding roots of a four times continuously
differentiable function.
In contrast with Brent's algorithm, which may only decrease the length of
the enclosing bracket on the last step, Algorithm 748 decreases it each
iteration with the same asymptotic efficiency as it finds the root.

For easy statement of efficiency indices, assume that `f` has 4
continuouous deriviatives.
For ``k=1``, the convergence order is at least 2.7, and with about
asymptotically 2 function evaluations per iteration, the efficiency
index is approximately 1.65.
For ``k=2``, the order is about 4.6 with asymptotically 3 function
evaluations per iteration, and the efficiency index 1.66.
For higher values of `k`, the efficiency index approaches
the kth root of ``(3k-2)``, hence ``k=1`` or ``k=2`` are
usually appropriate.

References
----------
.. [APS1995]
   Alefeld, G. E. and Potra, F. A. and Shi, Yixun,
   *Algorithm 748: Enclosing Zeros of Continuous Functions*,
   ACM Trans. Math. Softw. Volume 221(1995)
   doi = {10.1145/210089.210111}

Examples
--------
>>> def f(x):
...     return (x**3 - 1)  # only one real root at x = 1

>>> from scipy import optimize
>>> root, results = optimize.toms748(f, 0, 2, full_output=True)
>>> root
1.0
>>> results
      converged: True
           flag: converged
 function_calls: 11
     iterations: 5
           root: 1.0
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__zeros__py_8py_source_l01268}{1268}} of file \mbox{\hyperlink{__zeros__py_8py_source}{\+\_\+zeros\+\_\+py.\+py}}.



References \mbox{\hyperlink{__zeros__py_8py_source_l00075}{\+\_\+results\+\_\+select()}}.



\doxysubsection{Variable Documentation}
\Hypertarget{namespacescipy_1_1optimize_1_1__zeros__py_ac3eb6942ed5872bbec489f01d842d02d}\index{scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}!\_\_all\_\_@{\_\_all\_\_}}
\index{\_\_all\_\_@{\_\_all\_\_}!scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}}
\doxysubsubsection{\texorpdfstring{\_\_all\_\_}{\_\_all\_\_}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__zeros__py_ac3eb6942ed5872bbec489f01d842d02d} 
list scipy.\+optimize.\+\_\+zeros\+\_\+py.\+\_\+\+\_\+all\+\_\+\+\_\+\hspace{0.3cm}{\ttfamily [private]}}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ [\textcolor{stringliteral}{'newton'},\ \textcolor{stringliteral}{'bisect'},\ \textcolor{stringliteral}{'ridder'},\ \textcolor{stringliteral}{'brentq'},\ \textcolor{stringliteral}{'brenth'},\ \textcolor{stringliteral}{'toms748'},}
\DoxyCodeLine{00002\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'RootResults'}]}

\end{DoxyCode}


Definition at line \mbox{\hyperlink{__zeros__py_8py_source_l00013}{13}} of file \mbox{\hyperlink{__zeros__py_8py_source}{\+\_\+zeros\+\_\+py.\+py}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__zeros__py_af4bcdd971836677ee38d2d86f050888b}\index{scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}!\_ECONVERGED@{\_ECONVERGED}}
\index{\_ECONVERGED@{\_ECONVERGED}!scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}}
\doxysubsubsection{\texorpdfstring{\_ECONVERGED}{\_ECONVERGED}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__zeros__py_af4bcdd971836677ee38d2d86f050888b} 
int scipy.\+optimize.\+\_\+zeros\+\_\+py.\+\_\+\+ECONVERGED = 0\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{__zeros__py_8py_source_l00017}{17}} of file \mbox{\hyperlink{__zeros__py_8py_source}{\+\_\+zeros\+\_\+py.\+py}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__zeros__py_a774fd1666eaace48a1e96b5cb57ad8be}\index{scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}!\_ECONVERR@{\_ECONVERR}}
\index{\_ECONVERR@{\_ECONVERR}!scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}}
\doxysubsubsection{\texorpdfstring{\_ECONVERR}{\_ECONVERR}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__zeros__py_a774fd1666eaace48a1e96b5cb57ad8be} 
int scipy.\+optimize.\+\_\+zeros\+\_\+py.\+\_\+\+ECONVERR = -\/2\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{__zeros__py_8py_source_l00019}{19}} of file \mbox{\hyperlink{__zeros__py_8py_source}{\+\_\+zeros\+\_\+py.\+py}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__zeros__py_a510c7861992d3edabbc67eb63bab3025}\index{scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}!\_EINPROGRESS@{\_EINPROGRESS}}
\index{\_EINPROGRESS@{\_EINPROGRESS}!scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}}
\doxysubsubsection{\texorpdfstring{\_EINPROGRESS}{\_EINPROGRESS}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__zeros__py_a510c7861992d3edabbc67eb63bab3025} 
int scipy.\+optimize.\+\_\+zeros\+\_\+py.\+\_\+\+EINPROGRESS = 1\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{__zeros__py_8py_source_l00021}{21}} of file \mbox{\hyperlink{__zeros__py_8py_source}{\+\_\+zeros\+\_\+py.\+py}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__zeros__py_a0238c88b7478ae9555103137c3275405}\index{scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}!\_ESIGNERR@{\_ESIGNERR}}
\index{\_ESIGNERR@{\_ESIGNERR}!scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}}
\doxysubsubsection{\texorpdfstring{\_ESIGNERR}{\_ESIGNERR}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__zeros__py_a0238c88b7478ae9555103137c3275405} 
int scipy.\+optimize.\+\_\+zeros\+\_\+py.\+\_\+\+ESIGNERR = -\/1\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{__zeros__py_8py_source_l00018}{18}} of file \mbox{\hyperlink{__zeros__py_8py_source}{\+\_\+zeros\+\_\+py.\+py}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__zeros__py_a9dd7b77302c86b135a86e9ecf6dc96ee}\index{scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}!\_EVALUEERR@{\_EVALUEERR}}
\index{\_EVALUEERR@{\_EVALUEERR}!scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}}
\doxysubsubsection{\texorpdfstring{\_EVALUEERR}{\_EVALUEERR}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__zeros__py_a9dd7b77302c86b135a86e9ecf6dc96ee} 
int scipy.\+optimize.\+\_\+zeros\+\_\+py.\+\_\+\+EVALUEERR = -\/3\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{__zeros__py_8py_source_l00020}{20}} of file \mbox{\hyperlink{__zeros__py_8py_source}{\+\_\+zeros\+\_\+py.\+py}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__zeros__py_ab4b892c756bdbbd1cbc39f27d92df5c2}\index{scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}!\_iter@{\_iter}}
\index{\_iter@{\_iter}!scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}}
\doxysubsubsection{\texorpdfstring{\_iter}{\_iter}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__zeros__py_ab4b892c756bdbbd1cbc39f27d92df5c2} 
int scipy.\+optimize.\+\_\+zeros\+\_\+py.\+\_\+iter = 100\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{__zeros__py_8py_source_l00009}{9}} of file \mbox{\hyperlink{__zeros__py_8py_source}{\+\_\+zeros\+\_\+py.\+py}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__zeros__py_a9d9dbe7fa007420b1d111c3329e3b89a}\index{scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}!\_rtol@{\_rtol}}
\index{\_rtol@{\_rtol}!scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}}
\doxysubsubsection{\texorpdfstring{\_rtol}{\_rtol}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__zeros__py_a9d9dbe7fa007420b1d111c3329e3b89a} 
int scipy.\+optimize.\+\_\+zeros\+\_\+py.\+\_\+rtol = 4 \texorpdfstring{$\ast$}{*} np.\+finfo(float).eps\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{__zeros__py_8py_source_l00011}{11}} of file \mbox{\hyperlink{__zeros__py_8py_source}{\+\_\+zeros\+\_\+py.\+py}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__zeros__py_afd7eb0e42203b1c6c4b40521ec16bea9}\index{scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}!\_xtol@{\_xtol}}
\index{\_xtol@{\_xtol}!scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}}
\doxysubsubsection{\texorpdfstring{\_xtol}{\_xtol}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__zeros__py_afd7eb0e42203b1c6c4b40521ec16bea9} 
int scipy.\+optimize.\+\_\+zeros\+\_\+py.\+\_\+xtol = 2e-\/12\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{__zeros__py_8py_source_l00010}{10}} of file \mbox{\hyperlink{__zeros__py_8py_source}{\+\_\+zeros\+\_\+py.\+py}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__zeros__py_a789cf251f5f3f8dda6d1572a32a2d100}\index{scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}!CONVERGED@{CONVERGED}}
\index{CONVERGED@{CONVERGED}!scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}}
\doxysubsubsection{\texorpdfstring{CONVERGED}{CONVERGED}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__zeros__py_a789cf251f5f3f8dda6d1572a32a2d100} 
str scipy.\+optimize.\+\_\+zeros\+\_\+py.\+CONVERGED = \textquotesingle{}converged\textquotesingle{}}



Definition at line \mbox{\hyperlink{__zeros__py_8py_source_l00023}{23}} of file \mbox{\hyperlink{__zeros__py_8py_source}{\+\_\+zeros\+\_\+py.\+py}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__zeros__py_a13ce602a6739ba11af2e141dc0c2ba91}\index{scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}!CONVERR@{CONVERR}}
\index{CONVERR@{CONVERR}!scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}}
\doxysubsubsection{\texorpdfstring{CONVERR}{CONVERR}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__zeros__py_a13ce602a6739ba11af2e141dc0c2ba91} 
str scipy.\+optimize.\+\_\+zeros\+\_\+py.\+CONVERR = \textquotesingle{}convergence error\textquotesingle{}}



Definition at line \mbox{\hyperlink{__zeros__py_8py_source_l00025}{25}} of file \mbox{\hyperlink{__zeros__py_8py_source}{\+\_\+zeros\+\_\+py.\+py}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__zeros__py_af7947d48cdb026201f385bde32e43b21}\index{scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}!flag\_map@{flag\_map}}
\index{flag\_map@{flag\_map}!scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}}
\doxysubsubsection{\texorpdfstring{flag\_map}{flag\_map}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__zeros__py_af7947d48cdb026201f385bde32e43b21} 
dict scipy.\+optimize.\+\_\+zeros\+\_\+py.\+flag\+\_\+map}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ \{\_ECONVERGED:\ CONVERGED,\ \_ESIGNERR:\ SIGNERR,\ \_ECONVERR:\ CONVERR,}
\DoxyCodeLine{00002\ \ \ \ \ \ \ \ \ \ \ \ \ \_EVALUEERR:\ VALUEERR,\ \_EINPROGRESS:\ INPROGRESS\}}

\end{DoxyCode}


Definition at line \mbox{\hyperlink{__zeros__py_8py_source_l00030}{30}} of file \mbox{\hyperlink{__zeros__py_8py_source}{\+\_\+zeros\+\_\+py.\+py}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__zeros__py_a8381cb99a373fe3c6579e004730edb03}\index{scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}!INPROGRESS@{INPROGRESS}}
\index{INPROGRESS@{INPROGRESS}!scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}}
\doxysubsubsection{\texorpdfstring{INPROGRESS}{INPROGRESS}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__zeros__py_a8381cb99a373fe3c6579e004730edb03} 
str scipy.\+optimize.\+\_\+zeros\+\_\+py.\+INPROGRESS = \textquotesingle{}No error\textquotesingle{}}



Definition at line \mbox{\hyperlink{__zeros__py_8py_source_l00027}{27}} of file \mbox{\hyperlink{__zeros__py_8py_source}{\+\_\+zeros\+\_\+py.\+py}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__zeros__py_a5b07357c3683e74fc4b96789a269db62}\index{scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}!SIGNERR@{SIGNERR}}
\index{SIGNERR@{SIGNERR}!scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}}
\doxysubsubsection{\texorpdfstring{SIGNERR}{SIGNERR}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__zeros__py_a5b07357c3683e74fc4b96789a269db62} 
str scipy.\+optimize.\+\_\+zeros\+\_\+py.\+SIGNERR = \textquotesingle{}sign error\textquotesingle{}}



Definition at line \mbox{\hyperlink{__zeros__py_8py_source_l00024}{24}} of file \mbox{\hyperlink{__zeros__py_8py_source}{\+\_\+zeros\+\_\+py.\+py}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__zeros__py_abed4a7ba25901d7400ec1b2872815dac}\index{scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}!VALUEERR@{VALUEERR}}
\index{VALUEERR@{VALUEERR}!scipy.optimize.\_zeros\_py@{scipy.optimize.\_zeros\_py}}
\doxysubsubsection{\texorpdfstring{VALUEERR}{VALUEERR}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__zeros__py_abed4a7ba25901d7400ec1b2872815dac} 
str scipy.\+optimize.\+\_\+zeros\+\_\+py.\+VALUEERR = \textquotesingle{}value error\textquotesingle{}}



Definition at line \mbox{\hyperlink{__zeros__py_8py_source_l00026}{26}} of file \mbox{\hyperlink{__zeros__py_8py_source}{\+\_\+zeros\+\_\+py.\+py}}.

