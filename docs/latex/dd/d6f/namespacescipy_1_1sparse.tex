\doxysection{scipy.\+sparse Namespace Reference}
\hypertarget{namespacescipy_1_1sparse}{}\label{namespacescipy_1_1sparse}\index{scipy.sparse@{scipy.sparse}}
\doxysubsubsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
namespace \mbox{\hyperlink{namespacescipy_1_1sparse_1_1__base}{\+\_\+base}}
\item 
namespace \mbox{\hyperlink{namespacescipy_1_1sparse_1_1__bsr}{\+\_\+bsr}}
\item 
namespace \mbox{\hyperlink{namespacescipy_1_1sparse_1_1__compressed}{\+\_\+compressed}}
\item 
namespace \mbox{\hyperlink{namespacescipy_1_1sparse_1_1__construct}{\+\_\+construct}}
\item 
namespace \mbox{\hyperlink{namespacescipy_1_1sparse_1_1__coo}{\+\_\+coo}}
\item 
namespace \mbox{\hyperlink{namespacescipy_1_1sparse_1_1__csc}{\+\_\+csc}}
\item 
namespace \mbox{\hyperlink{namespacescipy_1_1sparse_1_1__csr}{\+\_\+csr}}
\item 
namespace \mbox{\hyperlink{namespacescipy_1_1sparse_1_1__data}{\+\_\+data}}
\item 
namespace \mbox{\hyperlink{namespacescipy_1_1sparse_1_1__dia}{\+\_\+dia}}
\item 
namespace \mbox{\hyperlink{namespacescipy_1_1sparse_1_1__dok}{\+\_\+dok}}
\item 
namespace \mbox{\hyperlink{namespacescipy_1_1sparse_1_1__extract}{\+\_\+extract}}
\item 
namespace \mbox{\hyperlink{namespacescipy_1_1sparse_1_1__index}{\+\_\+index}}
\item 
namespace \mbox{\hyperlink{namespacescipy_1_1sparse_1_1__lil}{\+\_\+lil}}
\item 
namespace \mbox{\hyperlink{namespacescipy_1_1sparse_1_1__spfuncs}{\+\_\+spfuncs}}
\item 
namespace \mbox{\hyperlink{namespacescipy_1_1sparse_1_1__sputils}{\+\_\+sputils}}
\item 
namespace \mbox{\hyperlink{namespacescipy_1_1sparse_1_1csgraph}{csgraph}}
\item 
namespace \mbox{\hyperlink{namespacescipy_1_1sparse_1_1linalg}{linalg}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
list \mbox{\hyperlink{namespacescipy_1_1sparse_a012f619dd03343fa320a2b36b9710de3}{\+\_\+\+\_\+all\+\_\+\+\_\+}} = \mbox{[}s for s in dir() if not s.\+startswith(\textquotesingle{}\+\_\+\textquotesingle{})\mbox{]}
\item 
\mbox{\hyperlink{namespacescipy_1_1sparse_a2997149bf7a14f98da245aa97e965dd4}{message}}
\item 
\mbox{\hyperlink{namespacescipy_1_1sparse_a4b1e5ba742fbc30828185120b5ec541f}{test}} = \mbox{\hyperlink{classscipy_1_1__lib_1_1__testutils_1_1PytestTester}{Pytest\+Tester}}(\mbox{\hyperlink{class____name____}{\+\_\+\+\_\+name\+\_\+\+\_\+}})
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\begin{DoxyVerb}=====================================
Sparse matrices (:mod:`scipy.sparse`)
=====================================

.. currentmodule:: scipy.sparse

.. toctree::
   :hidden:

   sparse.csgraph
   sparse.linalg

SciPy 2-D sparse array package for numeric data.

.. note::

   This package is switching to an array interface, compatible with
   NumPy arrays, from the older matrix interface.  We recommend that
   you use the array objects (`bsr_array`, `coo_array`, etc.) for
   all new work.

   When using the array interface, please note that:

   - ``x * y`` no longer performs matrix multiplication, but
     element-wise multiplication (just like with NumPy arrays).  To
     make code work with both arrays and matrices, use ``x @ y`` for
     matrix multiplication.
   - Operations such as `sum`, that used to produce dense matrices, now
     produce arrays, whose multiplication behavior differs similarly.
   - Sparse arrays currently must be two-dimensional.  This also means
     that all *slicing* operations on these objects must produce
     two-dimensional results, or they will result in an error. This
     will be addressed in a future version.

   The construction utilities (`eye`, `kron`, `random`, `diags`, etc.)
   have not yet been ported, but their results can be wrapped into arrays::

     A = csr_array(eye(3))

Contents
========

Sparse array classes
--------------------

.. autosummary::
   :toctree: generated/

   bsr_array - Block Sparse Row array
   coo_array - A sparse array in COOrdinate format
   csc_array - Compressed Sparse Column array
   csr_array - Compressed Sparse Row array
   dia_array - Sparse array with DIAgonal storage
   dok_array - Dictionary Of Keys based sparse array
   lil_array - Row-based list of lists sparse array
   sparray - Sparse array base class

Sparse matrix classes
---------------------

.. autosummary::
   :toctree: generated/

   bsr_matrix - Block Sparse Row matrix
   coo_matrix - A sparse matrix in COOrdinate format
   csc_matrix - Compressed Sparse Column matrix
   csr_matrix - Compressed Sparse Row matrix
   dia_matrix - Sparse matrix with DIAgonal storage
   dok_matrix - Dictionary Of Keys based sparse matrix
   lil_matrix - Row-based list of lists sparse matrix
   spmatrix - Sparse matrix base class

Functions
---------

Building sparse matrices:

.. autosummary::
   :toctree: generated/

   eye - Sparse MxN matrix whose k-th diagonal is all ones
   identity - Identity matrix in sparse format
   kron - kronecker product of two sparse matrices
   kronsum - kronecker sum of sparse matrices
   diags - Return a sparse matrix from diagonals
   spdiags - Return a sparse matrix from diagonals
   block_diag - Build a block diagonal sparse matrix
   tril - Lower triangular portion of a matrix in sparse format
   triu - Upper triangular portion of a matrix in sparse format
   bmat - Build a sparse matrix from sparse sub-blocks
   hstack - Stack sparse matrices horizontally (column wise)
   vstack - Stack sparse matrices vertically (row wise)
   rand - Random values in a given shape
   random - Random values in a given shape

Save and load sparse matrices:

.. autosummary::
   :toctree: generated/

   save_npz - Save a sparse matrix to a file using ``.npz`` format.
   load_npz - Load a sparse matrix from a file using ``.npz`` format.

Sparse matrix tools:

.. autosummary::
   :toctree: generated/

   find

Identifying sparse matrices:

.. autosummary::
   :toctree: generated/

   issparse
   isspmatrix
   isspmatrix_csc
   isspmatrix_csr
   isspmatrix_bsr
   isspmatrix_lil
   isspmatrix_dok
   isspmatrix_coo
   isspmatrix_dia

Submodules
----------

.. autosummary::

   csgraph - Compressed sparse graph routines
   linalg - sparse linear algebra routines

Exceptions
----------

.. autosummary::
   :toctree: generated/

   SparseEfficiencyWarning
   SparseWarning


Usage information
=================

There are seven available sparse matrix types:

    1. csc_matrix: Compressed Sparse Column format
    2. csr_matrix: Compressed Sparse Row format
    3. bsr_matrix: Block Sparse Row format
    4. lil_matrix: List of Lists format
    5. dok_matrix: Dictionary of Keys format
    6. coo_matrix: COOrdinate format (aka IJV, triplet format)
    7. dia_matrix: DIAgonal format

To construct a matrix efficiently, use either dok_matrix or lil_matrix.
The lil_matrix class supports basic slicing and fancy indexing with a
similar syntax to NumPy arrays. As illustrated below, the COO format
may also be used to efficiently construct matrices. Despite their
similarity to NumPy arrays, it is **strongly discouraged** to use NumPy
functions directly on these matrices because NumPy may not properly convert
them for computations, leading to unexpected (and incorrect) results. If you
do want to apply a NumPy function to these matrices, first check if SciPy has
its own implementation for the given sparse matrix class, or **convert the
sparse matrix to a NumPy array** (e.g., using the `toarray()` method of the
class) first before applying the method.

To perform manipulations such as multiplication or inversion, first
convert the matrix to either CSC or CSR format. The lil_matrix format is
row-based, so conversion to CSR is efficient, whereas conversion to CSC
is less so.

All conversions among the CSR, CSC, and COO formats are efficient,
linear-time operations.

Matrix vector product
---------------------
To do a vector product between a sparse matrix and a vector simply use
the matrix `dot` method, as described in its docstring:

>>> import numpy as np
>>> from scipy.sparse import csr_matrix
>>> A = csr_matrix([[1, 2, 0], [0, 0, 3], [4, 0, 5]])
>>> v = np.array([1, 0, -1])
>>> A.dot(v)
array([ 1, -3, -1], dtype=int64)

.. warning:: As of NumPy 1.7, `np.dot` is not aware of sparse matrices,
  therefore using it will result on unexpected results or errors.
  The corresponding dense array should be obtained first instead:

  >>> np.dot(A.toarray(), v)
  array([ 1, -3, -1], dtype=int64)

  but then all the performance advantages would be lost.

The CSR format is specially suitable for fast matrix vector products.

Example 1
---------
Construct a 1000x1000 lil_matrix and add some values to it:

>>> from scipy.sparse import lil_matrix
>>> from scipy.sparse.linalg import spsolve
>>> from numpy.linalg import solve, norm
>>> from numpy.random import rand

>>> A = lil_matrix((1000, 1000))
>>> A[0, :100] = rand(100)
>>> A[1, 100:200] = A[0, :100]
>>> A.setdiag(rand(1000))

Now convert it to CSR format and solve A x = b for x:

>>> A = A.tocsr()
>>> b = rand(1000)
>>> x = spsolve(A, b)

Convert it to a dense matrix and solve, and check that the result
is the same:

>>> x_ = solve(A.toarray(), b)

Now we can compute norm of the error with:

>>> err = norm(x-x_)
>>> err < 1e-10
True

It should be small :)


Example 2
---------

Construct a matrix in COO format:

>>> from scipy import sparse
>>> from numpy import array
>>> I = array([0,3,1,0])
>>> J = array([0,3,1,2])
>>> V = array([4,5,7,9])
>>> A = sparse.coo_matrix((V,(I,J)),shape=(4,4))

Notice that the indices do not need to be sorted.

Duplicate (i,j) entries are summed when converting to CSR or CSC.

>>> I = array([0,0,1,3,1,0,0])
>>> J = array([0,2,1,3,1,0,0])
>>> V = array([1,1,1,1,1,1,1])
>>> B = sparse.coo_matrix((V,(I,J)),shape=(4,4)).tocsr()

This is useful for constructing finite-element stiffness and mass matrices.

Further details
---------------

CSR column indices are not necessarily sorted. Likewise for CSC row
indices. Use the .sorted_indices() and .sort_indices() methods when
sorted indices are required (e.g., when passing data to other libraries).
\end{DoxyVerb}
 

\doxysubsection{Variable Documentation}
\Hypertarget{namespacescipy_1_1sparse_a012f619dd03343fa320a2b36b9710de3}\index{scipy.sparse@{scipy.sparse}!\_\_all\_\_@{\_\_all\_\_}}
\index{\_\_all\_\_@{\_\_all\_\_}!scipy.sparse@{scipy.sparse}}
\doxysubsubsection{\texorpdfstring{\_\_all\_\_}{\_\_all\_\_}}
{\footnotesize\ttfamily \label{namespacescipy_1_1sparse_a012f619dd03343fa320a2b36b9710de3} 
list scipy.\+sparse.\+\_\+\+\_\+all\+\_\+\+\_\+ = \mbox{[}s for s in dir() if not s.\+startswith(\textquotesingle{}\+\_\+\textquotesingle{})\mbox{]}\hspace{0.3cm}{\ttfamily [private]}}



Definition at line \mbox{\hyperlink{scipy_2sparse_2____init_____8py_source_l00295}{295}} of file \mbox{\hyperlink{scipy_2sparse_2____init_____8py_source}{\+\_\+\+\_\+init\+\_\+\+\_\+.\+py}}.

\Hypertarget{namespacescipy_1_1sparse_a2997149bf7a14f98da245aa97e965dd4}\index{scipy.sparse@{scipy.sparse}!message@{message}}
\index{message@{message}!scipy.sparse@{scipy.sparse}}
\doxysubsubsection{\texorpdfstring{message}{message}}
{\footnotesize\ttfamily \label{namespacescipy_1_1sparse_a2997149bf7a14f98da245aa97e965dd4} 
scipy.\+sparse.\+message}



Definition at line \mbox{\hyperlink{scipy_2sparse_2____init_____8py_source_l00298}{298}} of file \mbox{\hyperlink{scipy_2sparse_2____init_____8py_source}{\+\_\+\+\_\+init\+\_\+\+\_\+.\+py}}.

\Hypertarget{namespacescipy_1_1sparse_a4b1e5ba742fbc30828185120b5ec541f}\index{scipy.sparse@{scipy.sparse}!test@{test}}
\index{test@{test}!scipy.sparse@{scipy.sparse}}
\doxysubsubsection{\texorpdfstring{test}{test}}
{\footnotesize\ttfamily \label{namespacescipy_1_1sparse_a4b1e5ba742fbc30828185120b5ec541f} 
scipy.\+sparse.\+test = \mbox{\hyperlink{classscipy_1_1__lib_1_1__testutils_1_1PytestTester}{Pytest\+Tester}}(\mbox{\hyperlink{class____name____}{\+\_\+\+\_\+name\+\_\+\+\_\+}})}



Definition at line \mbox{\hyperlink{scipy_2sparse_2____init_____8py_source_l00301}{301}} of file \mbox{\hyperlink{scipy_2sparse_2____init_____8py_source}{\+\_\+\+\_\+init\+\_\+\+\_\+.\+py}}.

