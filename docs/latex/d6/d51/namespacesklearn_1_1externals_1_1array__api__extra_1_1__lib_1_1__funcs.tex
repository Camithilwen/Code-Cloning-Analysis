\doxysection{sklearn.\+externals.\+array\+\_\+api\+\_\+extra.\+\_\+lib.\+\_\+funcs Namespace Reference}
\hypertarget{namespacesklearn_1_1externals_1_1array__api__extra_1_1__lib_1_1__funcs}{}\label{namespacesklearn_1_1externals_1_1array__api__extra_1_1__lib_1_1__funcs}\index{sklearn.externals.array\_api\_extra.\_lib.\_funcs@{sklearn.externals.array\_api\_extra.\_lib.\_funcs}}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
Array \mbox{\hyperlink{namespacesklearn_1_1externals_1_1array__api__extra_1_1__lib_1_1__funcs_a97ea18c8a5db22130bf7a7483766249f}{apply\+\_\+where}} (Array cond, Array\texorpdfstring{$\vert$}{|}tuple\mbox{[}Array,...\mbox{]} args, Callable\mbox{[}..., Array\mbox{]} f1, Callable\mbox{[}..., Array\mbox{]} f2, \texorpdfstring{$\ast$}{*}, Module\+Type\texorpdfstring{$\vert$}{|}None xp=None)
\item 
Array \mbox{\hyperlink{namespacesklearn_1_1externals_1_1array__api__extra_1_1__lib_1_1__funcs_a2e8bc8f4e94759b2f06da9e3525a5b2a}{apply\+\_\+where}} (Array cond, Array\texorpdfstring{$\vert$}{|}tuple\mbox{[}Array,...\mbox{]} args, Callable\mbox{[}..., Array\mbox{]} f1, \texorpdfstring{$\ast$}{*}, Array\texorpdfstring{$\vert$}{|}complex fill\+\_\+value, Module\+Type\texorpdfstring{$\vert$}{|}None xp=None)
\item 
Array \mbox{\hyperlink{namespacesklearn_1_1externals_1_1array__api__extra_1_1__lib_1_1__funcs_a3e54f56acde142efc59740289edd76ac}{apply\+\_\+where}} (Array cond, Array\texorpdfstring{$\vert$}{|}tuple\mbox{[}Array,...\mbox{]} args, Callable\mbox{[}..., Array\mbox{]} f1, Callable\mbox{[}..., Array\mbox{]}\texorpdfstring{$\vert$}{|}None f2=None, \texorpdfstring{$\ast$}{*}, Array\texorpdfstring{$\vert$}{|}complex\texorpdfstring{$\vert$}{|}None fill\+\_\+value=None, Module\+Type\texorpdfstring{$\vert$}{|}None xp=None)
\item 
Array \mbox{\hyperlink{namespacesklearn_1_1externals_1_1array__api__extra_1_1__lib_1_1__funcs_aad59c32abe808a5b6d9ef917de61c998}{\+\_\+apply\+\_\+where}} (Array cond, Callable\mbox{[}..., Array\mbox{]} f1, Callable\mbox{[}..., Array\mbox{]}\texorpdfstring{$\vert$}{|}None f2, Array\texorpdfstring{$\vert$}{|}int\texorpdfstring{$\vert$}{|}float\texorpdfstring{$\vert$}{|}complex\texorpdfstring{$\vert$}{|}bool\texorpdfstring{$\vert$}{|}None fill\+\_\+value, \texorpdfstring{$\ast$}{*}Array args, Module\+Type xp)
\item 
Array \mbox{\hyperlink{namespacesklearn_1_1externals_1_1array__api__extra_1_1__lib_1_1__funcs_aab66046cf8038959689ba1a169fbba97}{atleast\+\_\+nd}} (Array x, \texorpdfstring{$\ast$}{*}, int ndim, Module\+Type\texorpdfstring{$\vert$}{|}None xp=None)
\item 
tuple\mbox{[}int\texorpdfstring{$\vert$}{|}None,...\mbox{]} \mbox{\hyperlink{namespacesklearn_1_1externals_1_1array__api__extra_1_1__lib_1_1__funcs_a770af3a01f3679e73704264371083fa3}{broadcast\+\_\+shapes}} (\texorpdfstring{$\ast$}{*}tuple\mbox{[}float\texorpdfstring{$\vert$}{|}None,...\mbox{]} shapes)
\item 
Array \mbox{\hyperlink{namespacesklearn_1_1externals_1_1array__api__extra_1_1__lib_1_1__funcs_ab38b9bf58316a531d10b7ce5cbc7f89a}{cov}} (Array m, \texorpdfstring{$\ast$}{*}, Module\+Type\texorpdfstring{$\vert$}{|}None xp=None)
\item 
Array \mbox{\hyperlink{namespacesklearn_1_1externals_1_1array__api__extra_1_1__lib_1_1__funcs_a41ef63862111270fef008e29785c0456}{create\+\_\+diagonal}} (Array x, \texorpdfstring{$\ast$}{*}, int offset=0, Module\+Type\texorpdfstring{$\vert$}{|}None xp=None)
\item 
Array \mbox{\hyperlink{namespacesklearn_1_1externals_1_1array__api__extra_1_1__lib_1_1__funcs_a909a63d37f598849fa60c894eaf66657}{expand\+\_\+dims}} (Array a, \texorpdfstring{$\ast$}{*}, int\texorpdfstring{$\vert$}{|}tuple\mbox{[}int,...\mbox{]} axis=(0,), Module\+Type\texorpdfstring{$\vert$}{|}None xp=None)
\item 
Array \mbox{\hyperlink{namespacesklearn_1_1externals_1_1array__api__extra_1_1__lib_1_1__funcs_afeeb4dbd2f73b3c9aa74f3f4b0a5e598}{isclose}} (Array\texorpdfstring{$\vert$}{|}complex a, Array\texorpdfstring{$\vert$}{|}complex b, \texorpdfstring{$\ast$}{*}, float rtol=1e-\/05, float atol=1e-\/08, bool equal\+\_\+nan=False, Module\+Type xp)
\item 
Array \mbox{\hyperlink{namespacesklearn_1_1externals_1_1array__api__extra_1_1__lib_1_1__funcs_a576d8bb5e9e8f58499dc0b9cbe74b6f2}{kron}} (Array\texorpdfstring{$\vert$}{|}complex a, Array\texorpdfstring{$\vert$}{|}complex b, \texorpdfstring{$\ast$}{*}, Module\+Type\texorpdfstring{$\vert$}{|}None xp=None)
\item 
Array \mbox{\hyperlink{namespacesklearn_1_1externals_1_1array__api__extra_1_1__lib_1_1__funcs_a19160096f53f6d58a4b9dd1bc8f0f5cc}{nunique}} (Array x, \texorpdfstring{$\ast$}{*}, Module\+Type\texorpdfstring{$\vert$}{|}None xp=None)
\item 
Array \mbox{\hyperlink{namespacesklearn_1_1externals_1_1array__api__extra_1_1__lib_1_1__funcs_aa1fac5a134ba0fa5c17e320fcb90ef3d}{pad}} (Array x, int\texorpdfstring{$\vert$}{|}tuple\mbox{[}int, int\mbox{]}\texorpdfstring{$\vert$}{|}Sequence\mbox{[}tuple\mbox{[}int, int\mbox{]}\mbox{]} pad\+\_\+width, \texorpdfstring{$\ast$}{*}, complex constant\+\_\+values=0, Module\+Type xp)
\item 
Array \mbox{\hyperlink{namespacesklearn_1_1externals_1_1array__api__extra_1_1__lib_1_1__funcs_a875cbd949cc4f9404833c1ad5d901a4b}{setdiff1d}} (Array\texorpdfstring{$\vert$}{|}complex x1, Array\texorpdfstring{$\vert$}{|}complex x2, \texorpdfstring{$\ast$}{*}, bool assume\+\_\+unique=False, Module\+Type\texorpdfstring{$\vert$}{|}None xp=None)
\item 
Array \mbox{\hyperlink{namespacesklearn_1_1externals_1_1array__api__extra_1_1__lib_1_1__funcs_a0664b4c8084d7d5927d115e01a248b0b}{sinc}} (Array x, \texorpdfstring{$\ast$}{*}, Module\+Type\texorpdfstring{$\vert$}{|}None xp=None)
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
list \mbox{\hyperlink{namespacesklearn_1_1externals_1_1array__api__extra_1_1__lib_1_1__funcs_abefb7cb6ab22e3d87e75ca91d66ee75f}{\+\_\+\+\_\+all\+\_\+\+\_\+}}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\begin{DoxyVerb}Array-agnostic implementations for the public API.\end{DoxyVerb}
 

\doxysubsection{Function Documentation}
\Hypertarget{namespacesklearn_1_1externals_1_1array__api__extra_1_1__lib_1_1__funcs_aad59c32abe808a5b6d9ef917de61c998}\index{sklearn.externals.array\_api\_extra.\_lib.\_funcs@{sklearn.externals.array\_api\_extra.\_lib.\_funcs}!\_apply\_where@{\_apply\_where}}
\index{\_apply\_where@{\_apply\_where}!sklearn.externals.array\_api\_extra.\_lib.\_funcs@{sklearn.externals.array\_api\_extra.\_lib.\_funcs}}
\doxysubsubsection{\texorpdfstring{\_apply\_where()}{\_apply\_where()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1externals_1_1array__api__extra_1_1__lib_1_1__funcs_aad59c32abe808a5b6d9ef917de61c998} 
 Array sklearn.\+externals.\+array\+\_\+api\+\_\+extra.\+\_\+lib.\+\_\+funcs.\+\_\+apply\+\_\+where (\begin{DoxyParamCaption}\item[{Array}]{cond}{, }\item[{Callable\mbox{[}..., Array\mbox{]}}]{f1}{, }\item[{Callable\mbox{[}..., Array\mbox{]} \texorpdfstring{$\vert$}{|} None}]{f2}{, }\item[{Array \texorpdfstring{$\vert$}{|} int \texorpdfstring{$\vert$}{|} float \texorpdfstring{$\vert$}{|} complex \texorpdfstring{$\vert$}{|} bool \texorpdfstring{$\vert$}{|} None}]{fill\+\_\+value}{, }\item[{\texorpdfstring{$\ast$}{*}Array}]{args}{, }\item[{Module\+Type}]{xp}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Helper of `apply_where`. On Dask, this runs on a single chunk.\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__funcs_8py_source_l00145}{145}} of file \mbox{\hyperlink{__funcs_8py_source}{\+\_\+funcs.\+py}}.



Referenced by \mbox{\hyperlink{__funcs_8py_source_l00068}{apply\+\_\+where()}}.

\Hypertarget{namespacesklearn_1_1externals_1_1array__api__extra_1_1__lib_1_1__funcs_a2e8bc8f4e94759b2f06da9e3525a5b2a}\index{sklearn.externals.array\_api\_extra.\_lib.\_funcs@{sklearn.externals.array\_api\_extra.\_lib.\_funcs}!apply\_where@{apply\_where}}
\index{apply\_where@{apply\_where}!sklearn.externals.array\_api\_extra.\_lib.\_funcs@{sklearn.externals.array\_api\_extra.\_lib.\_funcs}}
\doxysubsubsection{\texorpdfstring{apply\_where()}{apply\_where()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1externals_1_1array__api__extra_1_1__lib_1_1__funcs_a2e8bc8f4e94759b2f06da9e3525a5b2a} 
 Array sklearn.\+externals.\+array\+\_\+api\+\_\+extra.\+\_\+lib.\+\_\+funcs.\+apply\+\_\+where (\begin{DoxyParamCaption}\item[{Array}]{cond}{, }\item[{Array \texorpdfstring{$\vert$}{|} tuple\mbox{[}Array, ...\mbox{]}}]{args}{, }\item[{Callable\mbox{[}..., Array\mbox{]}}]{f1}{, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{Array \texorpdfstring{$\vert$}{|} complex}]{fill\+\_\+value}{, }\item[{Module\+Type \texorpdfstring{$\vert$}{|} None }]{xp}{ = {\ttfamily None}}\end{DoxyParamCaption})}



Definition at line \mbox{\hyperlink{__funcs_8py_source_l00048}{48}} of file \mbox{\hyperlink{__funcs_8py_source}{\+\_\+funcs.\+py}}.

\Hypertarget{namespacesklearn_1_1externals_1_1array__api__extra_1_1__lib_1_1__funcs_a97ea18c8a5db22130bf7a7483766249f}\index{sklearn.externals.array\_api\_extra.\_lib.\_funcs@{sklearn.externals.array\_api\_extra.\_lib.\_funcs}!apply\_where@{apply\_where}}
\index{apply\_where@{apply\_where}!sklearn.externals.array\_api\_extra.\_lib.\_funcs@{sklearn.externals.array\_api\_extra.\_lib.\_funcs}}
\doxysubsubsection{\texorpdfstring{apply\_where()}{apply\_where()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1externals_1_1array__api__extra_1_1__lib_1_1__funcs_a97ea18c8a5db22130bf7a7483766249f} 
 Array sklearn.\+externals.\+array\+\_\+api\+\_\+extra.\+\_\+lib.\+\_\+funcs.\+apply\+\_\+where (\begin{DoxyParamCaption}\item[{Array}]{cond}{, }\item[{Array \texorpdfstring{$\vert$}{|} tuple\mbox{[}Array, ...\mbox{]}}]{args}{, }\item[{Callable\mbox{[}..., Array\mbox{]}}]{f1}{, }\item[{Callable\mbox{[}..., Array\mbox{]}}]{f2}{, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{Module\+Type \texorpdfstring{$\vert$}{|} None }]{xp}{ = {\ttfamily None}}\end{DoxyParamCaption})}



Definition at line \mbox{\hyperlink{__funcs_8py_source_l00036}{36}} of file \mbox{\hyperlink{__funcs_8py_source}{\+\_\+funcs.\+py}}.

\Hypertarget{namespacesklearn_1_1externals_1_1array__api__extra_1_1__lib_1_1__funcs_a3e54f56acde142efc59740289edd76ac}\index{sklearn.externals.array\_api\_extra.\_lib.\_funcs@{sklearn.externals.array\_api\_extra.\_lib.\_funcs}!apply\_where@{apply\_where}}
\index{apply\_where@{apply\_where}!sklearn.externals.array\_api\_extra.\_lib.\_funcs@{sklearn.externals.array\_api\_extra.\_lib.\_funcs}}
\doxysubsubsection{\texorpdfstring{apply\_where()}{apply\_where()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1externals_1_1array__api__extra_1_1__lib_1_1__funcs_a3e54f56acde142efc59740289edd76ac} 
 Array sklearn.\+externals.\+array\+\_\+api\+\_\+extra.\+\_\+lib.\+\_\+funcs.\+apply\+\_\+where (\begin{DoxyParamCaption}\item[{Array}]{cond}{, }\item[{Array \texorpdfstring{$\vert$}{|} tuple\mbox{[}Array, ...\mbox{]}}]{args}{, }\item[{Callable\mbox{[}..., Array\mbox{]}}]{f1}{, }\item[{Callable\mbox{[}..., Array\mbox{]} \texorpdfstring{$\vert$}{|} None }]{f2}{ = {\ttfamily None}, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{Array \texorpdfstring{$\vert$}{|} complex \texorpdfstring{$\vert$}{|} None }]{fill\+\_\+value}{ = {\ttfamily None}, }\item[{Module\+Type \texorpdfstring{$\vert$}{|} None }]{xp}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Run one of two elementwise functions depending on a condition.

Equivalent to ``f1(*args) if cond else fill_value`` performed elementwise
when `fill_value` is defined, otherwise to ``f1(*args) if cond else f2(*args)``.

Parameters
----------
cond : array
    The condition, expressed as a boolean array.
args : Array or tuple of Arrays
    Argument(s) to `f1` (and `f2`). Must be broadcastable with `cond`.
f1 : callable
    Elementwise function of `args`, returning a single array.
    Where `cond` is True, output will be ``f1(arg0[cond], arg1[cond], ...)``.
f2 : callable, optional
    Elementwise function of `args`, returning a single array.
    Where `cond` is False, output will be ``f2(arg0[cond], arg1[cond], ...)``.
    Mutually exclusive with `fill_value`.
fill_value : Array or scalar, optional
    If provided, value with which to fill output array where `cond` is False.
    It does not need to be scalar; it needs however to be broadcastable with
    `cond` and `args`.
    Mutually exclusive with `f2`. You must provide one or the other.
xp : array_namespace, optional
    The standard-compatible namespace for `cond` and `args`. Default: infer.

Returns
-------
Array
    An array with elements from the output of `f1` where `cond` is True and either
    the output of `f2` or `fill_value` where `cond` is False. The returned array has
    data type determined by type promotion rules between the output of `f1` and
    either `fill_value` or the output of `f2`.

Notes
-----
``xp.where(cond, f1(*args), f2(*args))`` requires explicitly evaluating `f1` even
when `cond` is False, and `f2` when cond is True. This function evaluates each
function only for their matching condition, if the backend allows for it.

On Dask, `f1` and `f2` are applied to the individual chunks and should use functions
from the namespace of the chunks.

Examples
--------
>>> import array_api_strict as xp
>>> import array_api_extra as xpx
>>> a = xp.asarray([5, 4, 3])
>>> b = xp.asarray([0, 2, 2])
>>> def f(a, b):
...     return a // b
>>> xpx.apply_where(b != 0, (a, b), f, fill_value=xp.nan)
array([ nan,  2., 1.])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__funcs_8py_source_l00059}{59}} of file \mbox{\hyperlink{__funcs_8py_source}{\+\_\+funcs.\+py}}.



References \mbox{\hyperlink{__funcs_8py_source_l00152}{\+\_\+apply\+\_\+where()}}.

\Hypertarget{namespacesklearn_1_1externals_1_1array__api__extra_1_1__lib_1_1__funcs_aab66046cf8038959689ba1a169fbba97}\index{sklearn.externals.array\_api\_extra.\_lib.\_funcs@{sklearn.externals.array\_api\_extra.\_lib.\_funcs}!atleast\_nd@{atleast\_nd}}
\index{atleast\_nd@{atleast\_nd}!sklearn.externals.array\_api\_extra.\_lib.\_funcs@{sklearn.externals.array\_api\_extra.\_lib.\_funcs}}
\doxysubsubsection{\texorpdfstring{atleast\_nd()}{atleast\_nd()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1externals_1_1array__api__extra_1_1__lib_1_1__funcs_aab66046cf8038959689ba1a169fbba97} 
 Array sklearn.\+externals.\+array\+\_\+api\+\_\+extra.\+\_\+lib.\+\_\+funcs.\+atleast\+\_\+nd (\begin{DoxyParamCaption}\item[{Array}]{x}{, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{int}]{ndim}{, }\item[{Module\+Type \texorpdfstring{$\vert$}{|} None }]{xp}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Recursively expand the dimension of an array to at least `ndim`.

Parameters
----------
x : array
    Input array.
ndim : int
    The minimum number of dimensions for the result.
xp : array_namespace, optional
    The standard-compatible namespace for `x`. Default: infer.

Returns
-------
array
    An array with ``res.ndim`` >= `ndim`.
    If ``x.ndim`` >= `ndim`, `x` is returned.
    If ``x.ndim`` < `ndim`, `x` is expanded by prepending new axes
    until ``res.ndim`` equals `ndim`.

Examples
--------
>>> import array_api_strict as xp
>>> import array_api_extra as xpx
>>> x = xp.asarray([1])
>>> xpx.atleast_nd(x, ndim=3, xp=xp)
Array([[[1]]], dtype=array_api_strict.int64)

>>> x = xp.asarray([[[1, 2],
...                  [3, 4]]])
>>> xpx.atleast_nd(x, ndim=1, xp=xp) is x
True
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__funcs_8py_source_l00177}{177}} of file \mbox{\hyperlink{__funcs_8py_source}{\+\_\+funcs.\+py}}.



References \mbox{\hyperlink{__funcs_8py_source_l00177}{atleast\+\_\+nd()}}.



Referenced by \mbox{\hyperlink{__funcs_8py_source_l00177}{atleast\+\_\+nd()}}, and \mbox{\hyperlink{__funcs_8py_source_l00283}{cov()}}.

\Hypertarget{namespacesklearn_1_1externals_1_1array__api__extra_1_1__lib_1_1__funcs_a770af3a01f3679e73704264371083fa3}\index{sklearn.externals.array\_api\_extra.\_lib.\_funcs@{sklearn.externals.array\_api\_extra.\_lib.\_funcs}!broadcast\_shapes@{broadcast\_shapes}}
\index{broadcast\_shapes@{broadcast\_shapes}!sklearn.externals.array\_api\_extra.\_lib.\_funcs@{sklearn.externals.array\_api\_extra.\_lib.\_funcs}}
\doxysubsubsection{\texorpdfstring{broadcast\_shapes()}{broadcast\_shapes()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1externals_1_1array__api__extra_1_1__lib_1_1__funcs_a770af3a01f3679e73704264371083fa3} 
 tuple\mbox{[}int \texorpdfstring{$\vert$}{|} None, ...\mbox{]} sklearn.\+externals.\+array\+\_\+api\+\_\+extra.\+\_\+lib.\+\_\+funcs.\+broadcast\+\_\+shapes (\begin{DoxyParamCaption}\item[{\texorpdfstring{$\ast$}{*}tuple\mbox{[}float \texorpdfstring{$\vert$}{|} None, ...\mbox{]}}]{shapes}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute the shape of the broadcasted arrays.

Duplicates :func:`numpy.broadcast_shapes`, with additional support for
None and NaN sizes.

This is equivalent to ``xp.broadcast_arrays(arr1, arr2, ...)[0].shape``
without needing to worry about the backend potentially deep copying
the arrays.

Parameters
----------
*shapes : tuple[int | None, ...]
    Shapes of the arrays to broadcast.

Returns
-------
tuple[int | None, ...]
    The shape of the broadcasted arrays.

See Also
--------
numpy.broadcast_shapes : Equivalent NumPy function.
array_api.broadcast_arrays : Function to broadcast actual arrays.

Notes
-----
This function accepts the Array API's ``None`` for unknown sizes,
as well as Dask's non-standard ``math.nan``.
Regardless of input, the output always contains ``None`` for unknown sizes.

Examples
--------
>>> import array_api_extra as xpx
>>> xpx.broadcast_shapes((2, 3), (2, 1))
(2, 3)
>>> xpx.broadcast_shapes((4, 2, 3), (2, 1), (1, 3))
(4, 2, 3)
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__funcs_8py_source_l00222}{222}} of file \mbox{\hyperlink{__funcs_8py_source}{\+\_\+funcs.\+py}}.

\Hypertarget{namespacesklearn_1_1externals_1_1array__api__extra_1_1__lib_1_1__funcs_ab38b9bf58316a531d10b7ce5cbc7f89a}\index{sklearn.externals.array\_api\_extra.\_lib.\_funcs@{sklearn.externals.array\_api\_extra.\_lib.\_funcs}!cov@{cov}}
\index{cov@{cov}!sklearn.externals.array\_api\_extra.\_lib.\_funcs@{sklearn.externals.array\_api\_extra.\_lib.\_funcs}}
\doxysubsubsection{\texorpdfstring{cov()}{cov()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1externals_1_1array__api__extra_1_1__lib_1_1__funcs_ab38b9bf58316a531d10b7ce5cbc7f89a} 
 Array sklearn.\+externals.\+array\+\_\+api\+\_\+extra.\+\_\+lib.\+\_\+funcs.\+cov (\begin{DoxyParamCaption}\item[{Array}]{m}{, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{Module\+Type \texorpdfstring{$\vert$}{|} None }]{xp}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Estimate a covariance matrix.

Covariance indicates the level to which two variables vary together.
If we examine N-dimensional samples, :math:`X = [x_1, x_2, ... x_N]^T`,
then the covariance matrix element :math:`C_{ij}` is the covariance of
:math:`x_i` and :math:`x_j`. The element :math:`C_{ii}` is the variance
of :math:`x_i`.

This provides a subset of the functionality of ``numpy.cov``.

Parameters
----------
m : array
    A 1-D or 2-D array containing multiple variables and observations.
    Each row of `m` represents a variable, and each column a single
    observation of all those variables.
xp : array_namespace, optional
    The standard-compatible namespace for `m`. Default: infer.

Returns
-------
array
    The covariance matrix of the variables.

Examples
--------
>>> import array_api_strict as xp
>>> import array_api_extra as xpx

Consider two variables, :math:`x_0` and :math:`x_1`, which
correlate perfectly, but in opposite directions:

>>> x = xp.asarray([[0, 2], [1, 1], [2, 0]]).T
>>> x
Array([[0, 1, 2],
       [2, 1, 0]], dtype=array_api_strict.int64)

Note how :math:`x_0` increases while :math:`x_1` decreases. The covariance
matrix shows this clearly:

>>> xpx.cov(x, xp=xp)
Array([[ 1., -1.],
       [-1.,  1.]], dtype=array_api_strict.float64)

Note that element :math:`C_{0,1}`, which shows the correlation between
:math:`x_0` and :math:`x_1`, is negative.

Further, note how `x` and `y` are combined:

>>> x = xp.asarray([-2.1, -1,  4.3])
>>> y = xp.asarray([3,  1.1,  0.12])
>>> X = xp.stack((x, y), axis=0)
>>> xpx.cov(X, xp=xp)
Array([[11.71      , -4.286     ],
       [-4.286     ,  2.14413333]], dtype=array_api_strict.float64)

>>> xpx.cov(x, xp=xp)
Array(11.71, dtype=array_api_strict.float64)

>>> xpx.cov(y, xp=xp)
Array(2.14413333, dtype=array_api_strict.float64)
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__funcs_8py_source_l00283}{283}} of file \mbox{\hyperlink{__funcs_8py_source}{\+\_\+funcs.\+py}}.



References \mbox{\hyperlink{__funcs_8py_source_l00177}{atleast\+\_\+nd()}}.

\Hypertarget{namespacesklearn_1_1externals_1_1array__api__extra_1_1__lib_1_1__funcs_a41ef63862111270fef008e29785c0456}\index{sklearn.externals.array\_api\_extra.\_lib.\_funcs@{sklearn.externals.array\_api\_extra.\_lib.\_funcs}!create\_diagonal@{create\_diagonal}}
\index{create\_diagonal@{create\_diagonal}!sklearn.externals.array\_api\_extra.\_lib.\_funcs@{sklearn.externals.array\_api\_extra.\_lib.\_funcs}}
\doxysubsubsection{\texorpdfstring{create\_diagonal()}{create\_diagonal()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1externals_1_1array__api__extra_1_1__lib_1_1__funcs_a41ef63862111270fef008e29785c0456} 
 Array sklearn.\+externals.\+array\+\_\+api\+\_\+extra.\+\_\+lib.\+\_\+funcs.\+create\+\_\+diagonal (\begin{DoxyParamCaption}\item[{Array}]{x}{, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{int }]{offset}{ = {\ttfamily 0}, }\item[{Module\+Type \texorpdfstring{$\vert$}{|} None }]{xp}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Construct a diagonal array.

Parameters
----------
x : array
    An array having shape ``(*batch_dims, k)``.
offset : int, optional
    Offset from the leading diagonal (default is ``0``).
    Use positive ints for diagonals above the leading diagonal,
    and negative ints for diagonals below the leading diagonal.
xp : array_namespace, optional
    The standard-compatible namespace for `x`. Default: infer.

Returns
-------
array
    An array having shape ``(*batch_dims, k+abs(offset), k+abs(offset))`` with `x`
    on the diagonal (offset by `offset`).

Examples
--------
>>> import array_api_strict as xp
>>> import array_api_extra as xpx
>>> x = xp.asarray([2, 4, 8])

>>> xpx.create_diagonal(x, xp=xp)
Array([[2, 0, 0],
       [0, 4, 0],
       [0, 0, 8]], dtype=array_api_strict.int64)

>>> xpx.create_diagonal(x, offset=-2, xp=xp)
Array([[0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0],
       [2, 0, 0, 0, 0],
       [0, 4, 0, 0, 0],
       [0, 0, 8, 0, 0]], dtype=array_api_strict.int64)
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__funcs_8py_source_l00377}{377}} of file \mbox{\hyperlink{__funcs_8py_source}{\+\_\+funcs.\+py}}.

\Hypertarget{namespacesklearn_1_1externals_1_1array__api__extra_1_1__lib_1_1__funcs_a909a63d37f598849fa60c894eaf66657}\index{sklearn.externals.array\_api\_extra.\_lib.\_funcs@{sklearn.externals.array\_api\_extra.\_lib.\_funcs}!expand\_dims@{expand\_dims}}
\index{expand\_dims@{expand\_dims}!sklearn.externals.array\_api\_extra.\_lib.\_funcs@{sklearn.externals.array\_api\_extra.\_lib.\_funcs}}
\doxysubsubsection{\texorpdfstring{expand\_dims()}{expand\_dims()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1externals_1_1array__api__extra_1_1__lib_1_1__funcs_a909a63d37f598849fa60c894eaf66657} 
 Array sklearn.\+externals.\+array\+\_\+api\+\_\+extra.\+\_\+lib.\+\_\+funcs.\+expand\+\_\+dims (\begin{DoxyParamCaption}\item[{Array}]{a}{, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{int \texorpdfstring{$\vert$}{|} tuple\mbox{[}int, ...\mbox{]} }]{axis}{ = {\ttfamily (0,)}, }\item[{Module\+Type \texorpdfstring{$\vert$}{|} None }]{xp}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Expand the shape of an array.

Insert (a) new axis/axes that will appear at the position(s) specified by
`axis` in the expanded array shape.

This is ``xp.expand_dims`` for `axis` an int *or a tuple of ints*.
Roughly equivalent to ``numpy.expand_dims`` for NumPy arrays.

Parameters
----------
a : array
    Array to have its shape expanded.
axis : int or tuple of ints, optional
    Position(s) in the expanded axes where the new axis (or axes) is/are placed.
    If multiple positions are provided, they should be unique (note that a position
    given by a positive index could also be referred to by a negative index -
    that will also result in an error).
    Default: ``(0,)``.
xp : array_namespace, optional
    The standard-compatible namespace for `a`. Default: infer.

Returns
-------
array
    `a` with an expanded shape.

Examples
--------
>>> import array_api_strict as xp
>>> import array_api_extra as xpx
>>> x = xp.asarray([1, 2])
>>> x.shape
(2,)

The following is equivalent to ``x[xp.newaxis, :]`` or ``x[xp.newaxis]``:

>>> y = xpx.expand_dims(x, axis=0, xp=xp)
>>> y
Array([[1, 2]], dtype=array_api_strict.int64)
>>> y.shape
(1, 2)

The following is equivalent to ``x[:, xp.newaxis]``:

>>> y = xpx.expand_dims(x, axis=1, xp=xp)
>>> y
Array([[1],
       [2]], dtype=array_api_strict.int64)
>>> y.shape
(2, 1)

``axis`` may also be a tuple:

>>> y = xpx.expand_dims(x, axis=(0, 1), xp=xp)
>>> y
Array([[[1, 2]]], dtype=array_api_strict.int64)

>>> y = xpx.expand_dims(x, axis=(2, 0), xp=xp)
>>> y
Array([[[1],
        [2]]], dtype=array_api_strict.int64)
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__funcs_8py_source_l00440}{440}} of file \mbox{\hyperlink{__funcs_8py_source}{\+\_\+funcs.\+py}}.



Referenced by \mbox{\hyperlink{__funcs_8py_source_l00579}{kron()}}.

\Hypertarget{namespacesklearn_1_1externals_1_1array__api__extra_1_1__lib_1_1__funcs_afeeb4dbd2f73b3c9aa74f3f4b0a5e598}\index{sklearn.externals.array\_api\_extra.\_lib.\_funcs@{sklearn.externals.array\_api\_extra.\_lib.\_funcs}!isclose@{isclose}}
\index{isclose@{isclose}!sklearn.externals.array\_api\_extra.\_lib.\_funcs@{sklearn.externals.array\_api\_extra.\_lib.\_funcs}}
\doxysubsubsection{\texorpdfstring{isclose()}{isclose()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1externals_1_1array__api__extra_1_1__lib_1_1__funcs_afeeb4dbd2f73b3c9aa74f3f4b0a5e598} 
 Array sklearn.\+externals.\+array\+\_\+api\+\_\+extra.\+\_\+lib.\+\_\+funcs.\+isclose (\begin{DoxyParamCaption}\item[{Array \texorpdfstring{$\vert$}{|} complex}]{a}{, }\item[{Array \texorpdfstring{$\vert$}{|} complex}]{b}{, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{float }]{rtol}{ = {\ttfamily 1e-\/05}, }\item[{float }]{atol}{ = {\ttfamily 1e-\/08}, }\item[{bool }]{equal\+\_\+nan}{ = {\ttfamily False}, }\item[{Module\+Type}]{xp}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}See docstring in array_api_extra._delegation.\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__funcs_8py_source_l00526}{526}} of file \mbox{\hyperlink{__funcs_8py_source}{\+\_\+funcs.\+py}}.

\Hypertarget{namespacesklearn_1_1externals_1_1array__api__extra_1_1__lib_1_1__funcs_a576d8bb5e9e8f58499dc0b9cbe74b6f2}\index{sklearn.externals.array\_api\_extra.\_lib.\_funcs@{sklearn.externals.array\_api\_extra.\_lib.\_funcs}!kron@{kron}}
\index{kron@{kron}!sklearn.externals.array\_api\_extra.\_lib.\_funcs@{sklearn.externals.array\_api\_extra.\_lib.\_funcs}}
\doxysubsubsection{\texorpdfstring{kron()}{kron()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1externals_1_1array__api__extra_1_1__lib_1_1__funcs_a576d8bb5e9e8f58499dc0b9cbe74b6f2} 
 Array sklearn.\+externals.\+array\+\_\+api\+\_\+extra.\+\_\+lib.\+\_\+funcs.\+kron (\begin{DoxyParamCaption}\item[{Array \texorpdfstring{$\vert$}{|} complex}]{a}{, }\item[{Array \texorpdfstring{$\vert$}{|} complex}]{b}{, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{Module\+Type \texorpdfstring{$\vert$}{|} None }]{xp}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Kronecker product of two arrays.

Computes the Kronecker product, a composite array made of blocks of the
second array scaled by the first.

Equivalent to ``numpy.kron`` for NumPy arrays.

Parameters
----------
a, b : Array | int | float | complex
    Input arrays or scalars. At least one must be an array.
xp : array_namespace, optional
    The standard-compatible namespace for `a` and `b`. Default: infer.

Returns
-------
array
    The Kronecker product of `a` and `b`.

Notes
-----
The function assumes that the number of dimensions of `a` and `b`
are the same, if necessary prepending the smallest with ones.
If ``a.shape = (r0,r1,..,rN)`` and ``b.shape = (s0,s1,...,sN)``,
the Kronecker product has shape ``(r0*s0, r1*s1, ..., rN*SN)``.
The elements are products of elements from `a` and `b`, organized
explicitly by::

    kron(a,b)[k0,k1,...,kN] = a[i0,i1,...,iN] * b[j0,j1,...,jN]

where::

    kt = it * st + jt,  t = 0,...,N

In the common 2-D case (N=1), the block structure can be visualized::

    [[ a[0,0]*b,   a[0,1]*b,  ... , a[0,-1]*b  ],
     [  ...                              ...   ],
     [ a[-1,0]*b,  a[-1,1]*b, ... , a[-1,-1]*b ]]

Examples
--------
>>> import array_api_strict as xp
>>> import array_api_extra as xpx
>>> xpx.kron(xp.asarray([1, 10, 100]), xp.asarray([5, 6, 7]), xp=xp)
Array([  5,   6,   7,  50,  60,  70, 500,
       600, 700], dtype=array_api_strict.int64)

>>> xpx.kron(xp.asarray([5, 6, 7]), xp.asarray([1, 10, 100]), xp=xp)
Array([  5,  50, 500,   6,  60, 600,   7,
        70, 700], dtype=array_api_strict.int64)

>>> xpx.kron(xp.eye(2), xp.ones((2, 2)), xp=xp)
Array([[1., 1., 0., 0.],
       [1., 1., 0., 0.],
       [0., 0., 1., 1.],
       [0., 0., 1., 1.]], dtype=array_api_strict.float64)

>>> a = xp.reshape(xp.arange(100), (2, 5, 2, 5))
>>> b = xp.reshape(xp.arange(24), (2, 3, 4))
>>> c = xpx.kron(a, b, xp=xp)
>>> c.shape
(2, 10, 6, 20)
>>> I = (1, 3, 0, 2)
>>> J = (0, 2, 1)
>>> J1 = (0,) + J             # extend to ndim=4
>>> S1 = (1,) + b.shape
>>> K = tuple(xp.asarray(I) * xp.asarray(S1) + xp.asarray(J1))
>>> c[K] == a[I]*b[J]
Array(True, dtype=array_api_strict.bool)
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__funcs_8py_source_l00573}{573}} of file \mbox{\hyperlink{__funcs_8py_source}{\+\_\+funcs.\+py}}.



References \mbox{\hyperlink{__funcs_8py_source_l00442}{expand\+\_\+dims()}}.

\Hypertarget{namespacesklearn_1_1externals_1_1array__api__extra_1_1__lib_1_1__funcs_a19160096f53f6d58a4b9dd1bc8f0f5cc}\index{sklearn.externals.array\_api\_extra.\_lib.\_funcs@{sklearn.externals.array\_api\_extra.\_lib.\_funcs}!nunique@{nunique}}
\index{nunique@{nunique}!sklearn.externals.array\_api\_extra.\_lib.\_funcs@{sklearn.externals.array\_api\_extra.\_lib.\_funcs}}
\doxysubsubsection{\texorpdfstring{nunique()}{nunique()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1externals_1_1array__api__extra_1_1__lib_1_1__funcs_a19160096f53f6d58a4b9dd1bc8f0f5cc} 
 Array sklearn.\+externals.\+array\+\_\+api\+\_\+extra.\+\_\+lib.\+\_\+funcs.\+nunique (\begin{DoxyParamCaption}\item[{Array}]{x}{, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{Module\+Type \texorpdfstring{$\vert$}{|} None }]{xp}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Count the number of unique elements in an array.

Compatible with JAX and Dask, whose laziness would be otherwise
problematic.

Parameters
----------
x : Array
    Input array.
xp : array_namespace, optional
    The standard-compatible namespace for `x`. Default: infer.

Returns
-------
array: 0-dimensional integer array
    The number of unique elements in `x`. It can be lazy.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__funcs_8py_source_l00685}{685}} of file \mbox{\hyperlink{__funcs_8py_source}{\+\_\+funcs.\+py}}.

\Hypertarget{namespacesklearn_1_1externals_1_1array__api__extra_1_1__lib_1_1__funcs_aa1fac5a134ba0fa5c17e320fcb90ef3d}\index{sklearn.externals.array\_api\_extra.\_lib.\_funcs@{sklearn.externals.array\_api\_extra.\_lib.\_funcs}!pad@{pad}}
\index{pad@{pad}!sklearn.externals.array\_api\_extra.\_lib.\_funcs@{sklearn.externals.array\_api\_extra.\_lib.\_funcs}}
\doxysubsubsection{\texorpdfstring{pad()}{pad()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1externals_1_1array__api__extra_1_1__lib_1_1__funcs_aa1fac5a134ba0fa5c17e320fcb90ef3d} 
 Array sklearn.\+externals.\+array\+\_\+api\+\_\+extra.\+\_\+lib.\+\_\+funcs.\+pad (\begin{DoxyParamCaption}\item[{Array}]{x}{, }\item[{int \texorpdfstring{$\vert$}{|} tuple\mbox{[}int, int\mbox{]} \texorpdfstring{$\vert$}{|} Sequence\mbox{[}tuple\mbox{[}int, int\mbox{]}\mbox{]}}]{pad\+\_\+width}{, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{complex }]{constant\+\_\+values}{ = {\ttfamily 0}, }\item[{Module\+Type}]{xp}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}See docstring in `array_api_extra._delegation.py`.\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__funcs_8py_source_l00721}{721}} of file \mbox{\hyperlink{__funcs_8py_source}{\+\_\+funcs.\+py}}.

\Hypertarget{namespacesklearn_1_1externals_1_1array__api__extra_1_1__lib_1_1__funcs_a875cbd949cc4f9404833c1ad5d901a4b}\index{sklearn.externals.array\_api\_extra.\_lib.\_funcs@{sklearn.externals.array\_api\_extra.\_lib.\_funcs}!setdiff1d@{setdiff1d}}
\index{setdiff1d@{setdiff1d}!sklearn.externals.array\_api\_extra.\_lib.\_funcs@{sklearn.externals.array\_api\_extra.\_lib.\_funcs}}
\doxysubsubsection{\texorpdfstring{setdiff1d()}{setdiff1d()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1externals_1_1array__api__extra_1_1__lib_1_1__funcs_a875cbd949cc4f9404833c1ad5d901a4b} 
 Array sklearn.\+externals.\+array\+\_\+api\+\_\+extra.\+\_\+lib.\+\_\+funcs.\+setdiff1d (\begin{DoxyParamCaption}\item[{Array \texorpdfstring{$\vert$}{|} complex}]{x1}{, }\item[{Array \texorpdfstring{$\vert$}{|} complex}]{x2}{, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{bool }]{assume\+\_\+unique}{ = {\ttfamily False}, }\item[{Module\+Type \texorpdfstring{$\vert$}{|} None }]{xp}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Find the set difference of two arrays.

Return the unique values in `x1` that are not in `x2`.

Parameters
----------
x1 : array | int | float | complex | bool
    Input array.
x2 : array
    Input comparison array.
assume_unique : bool
    If ``True``, the input arrays are both assumed to be unique, which
    can speed up the calculation. Default is ``False``.
xp : array_namespace, optional
    The standard-compatible namespace for `x1` and `x2`. Default: infer.

Returns
-------
array
    1D array of values in `x1` that are not in `x2`. The result
    is sorted when `assume_unique` is ``False``, but otherwise only sorted
    if the input is sorted.

Examples
--------
>>> import array_api_strict as xp
>>> import array_api_extra as xpx

>>> x1 = xp.asarray([1, 2, 3, 2, 4, 1])
>>> x2 = xp.asarray([3, 4, 5, 6])
>>> xpx.setdiff1d(x1, x2, xp=xp)
Array([1, 2], dtype=array_api_strict.int64)
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__funcs_8py_source_l00772}{772}} of file \mbox{\hyperlink{__funcs_8py_source}{\+\_\+funcs.\+py}}.

\Hypertarget{namespacesklearn_1_1externals_1_1array__api__extra_1_1__lib_1_1__funcs_a0664b4c8084d7d5927d115e01a248b0b}\index{sklearn.externals.array\_api\_extra.\_lib.\_funcs@{sklearn.externals.array\_api\_extra.\_lib.\_funcs}!sinc@{sinc}}
\index{sinc@{sinc}!sklearn.externals.array\_api\_extra.\_lib.\_funcs@{sklearn.externals.array\_api\_extra.\_lib.\_funcs}}
\doxysubsubsection{\texorpdfstring{sinc()}{sinc()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1externals_1_1array__api__extra_1_1__lib_1_1__funcs_a0664b4c8084d7d5927d115e01a248b0b} 
 Array sklearn.\+externals.\+array\+\_\+api\+\_\+extra.\+\_\+lib.\+\_\+funcs.\+sinc (\begin{DoxyParamCaption}\item[{Array}]{x}{, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{Module\+Type \texorpdfstring{$\vert$}{|} None }]{xp}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the normalized sinc function.

The sinc function is equal to :math:`\sin(\pi x)/(\pi x)` for any argument
:math:`x\ne 0`. ``sinc(0)`` takes the limit value 1, making ``sinc`` not
only everywhere continuous but also infinitely differentiable.

.. note::

    Note the normalization factor of ``pi`` used in the definition.
    This is the most commonly used definition in signal processing.
    Use ``sinc(x / xp.pi)`` to obtain the unnormalized sinc function
    :math:`\sin(x)/x` that is more common in mathematics.

Parameters
----------
x : array
    Array (possibly multi-dimensional) of values for which to calculate
    ``sinc(x)``. Must have a real floating point dtype.
xp : array_namespace, optional
    The standard-compatible namespace for `x`. Default: infer.

Returns
-------
array
    ``sinc(x)`` calculated elementwise, which has the same shape as the input.

Notes
-----
The name sinc is short for "sine cardinal" or "sinus cardinalis".

The sinc function is used in various signal processing applications,
including in anti-aliasing, in the construction of a Lanczos resampling
filter, and in interpolation.

For bandlimited interpolation of discrete-time signals, the ideal
interpolation kernel is proportional to the sinc function.

References
----------
#. Weisstein, Eric W. "Sinc Function." From MathWorld--A Wolfram Web
   Resource. https://mathworld.wolfram.com/SincFunction.html
#. Wikipedia, "Sinc function",
   https://en.wikipedia.org/wiki/Sinc_function

Examples
--------
>>> import array_api_strict as xp
>>> import array_api_extra as xpx
>>> x = xp.linspace(-4, 4, 41)
>>> xpx.sinc(x, xp=xp)
Array([-3.89817183e-17, -4.92362781e-02,
       -8.40918587e-02, -8.90384387e-02,
       -5.84680802e-02,  3.89817183e-17,
        6.68206631e-02,  1.16434881e-01,
        1.26137788e-01,  8.50444803e-02,
       -3.89817183e-17, -1.03943254e-01,
       -1.89206682e-01, -2.16236208e-01,
       -1.55914881e-01,  3.89817183e-17,
        2.33872321e-01,  5.04551152e-01,
        7.56826729e-01,  9.35489284e-01,
        1.00000000e+00,  9.35489284e-01,
        7.56826729e-01,  5.04551152e-01,
        2.33872321e-01,  3.89817183e-17,
       -1.55914881e-01, -2.16236208e-01,
       -1.89206682e-01, -1.03943254e-01,
       -3.89817183e-17,  8.50444803e-02,
        1.26137788e-01,  1.16434881e-01,
        6.68206631e-02,  3.89817183e-17,
       -5.84680802e-02, -8.90384387e-02,
       -8.40918587e-02, -4.92362781e-02,
       -3.89817183e-17], dtype=array_api_strict.float64)
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__funcs_8py_source_l00829}{829}} of file \mbox{\hyperlink{__funcs_8py_source}{\+\_\+funcs.\+py}}.



\doxysubsection{Variable Documentation}
\Hypertarget{namespacesklearn_1_1externals_1_1array__api__extra_1_1__lib_1_1__funcs_abefb7cb6ab22e3d87e75ca91d66ee75f}\index{sklearn.externals.array\_api\_extra.\_lib.\_funcs@{sklearn.externals.array\_api\_extra.\_lib.\_funcs}!\_\_all\_\_@{\_\_all\_\_}}
\index{\_\_all\_\_@{\_\_all\_\_}!sklearn.externals.array\_api\_extra.\_lib.\_funcs@{sklearn.externals.array\_api\_extra.\_lib.\_funcs}}
\doxysubsubsection{\texorpdfstring{\_\_all\_\_}{\_\_all\_\_}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1externals_1_1array__api__extra_1_1__lib_1_1__funcs_abefb7cb6ab22e3d87e75ca91d66ee75f} 
list sklearn.\+externals.\+array\+\_\+api\+\_\+extra.\+\_\+lib.\+\_\+funcs.\+\_\+\+\_\+all\+\_\+\+\_\+\hspace{0.3cm}{\ttfamily [private]}}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ [}
\DoxyCodeLine{00002\ \ \ \ \ \textcolor{stringliteral}{"{}apply\_where"{}},}
\DoxyCodeLine{00003\ \ \ \ \ \textcolor{stringliteral}{"{}atleast\_nd"{}},}
\DoxyCodeLine{00004\ \ \ \ \ \textcolor{stringliteral}{"{}broadcast\_shapes"{}},}
\DoxyCodeLine{00005\ \ \ \ \ \textcolor{stringliteral}{"{}cov"{}},}
\DoxyCodeLine{00006\ \ \ \ \ \textcolor{stringliteral}{"{}create\_diagonal"{}},}
\DoxyCodeLine{00007\ \ \ \ \ \textcolor{stringliteral}{"{}expand\_dims"{}},}
\DoxyCodeLine{00008\ \ \ \ \ \textcolor{stringliteral}{"{}kron"{}},}
\DoxyCodeLine{00009\ \ \ \ \ \textcolor{stringliteral}{"{}nunique"{}},}
\DoxyCodeLine{00010\ \ \ \ \ \textcolor{stringliteral}{"{}pad"{}},}
\DoxyCodeLine{00011\ \ \ \ \ \textcolor{stringliteral}{"{}setdiff1d"{}},}
\DoxyCodeLine{00012\ \ \ \ \ \textcolor{stringliteral}{"{}sinc"{}},}
\DoxyCodeLine{00013\ ]}

\end{DoxyCode}


Definition at line \mbox{\hyperlink{__funcs_8py_source_l00020}{20}} of file \mbox{\hyperlink{__funcs_8py_source}{\+\_\+funcs.\+py}}.

