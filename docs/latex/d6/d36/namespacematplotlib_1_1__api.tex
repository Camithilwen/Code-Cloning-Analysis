\doxysection{matplotlib.\+\_\+api Namespace Reference}
\hypertarget{namespacematplotlib_1_1__api}{}\label{namespacematplotlib_1_1__api}\index{matplotlib.\_api@{matplotlib.\_api}}
\doxysubsubsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
namespace \mbox{\hyperlink{namespacematplotlib_1_1__api_1_1deprecation}{deprecation}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classmatplotlib_1_1__api_1_1classproperty}{classproperty}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacematplotlib_1_1__api_af27e5b8ad11435f5ee9b257c47b6fe96}{check\+\_\+isinstance}} (types, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}kwargs)
\item 
\mbox{\hyperlink{namespacematplotlib_1_1__api_a2a1dff1a48a83284d5420d2f658cf3e8}{check\+\_\+in\+\_\+list}} (values, \texorpdfstring{$\ast$}{*}, \+\_\+print\+\_\+supported\+\_\+values=\mbox{\hyperlink{classTrue}{True}}, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}kwargs)
\item 
\mbox{\hyperlink{namespacematplotlib_1_1__api_ac35255143c3bfd85a7a8fee81e914f2f}{check\+\_\+shape}} (shape, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}kwargs)
\item 
\mbox{\hyperlink{namespacematplotlib_1_1__api_ac1854af962d2a57995be918df60a9df6}{check\+\_\+getitem}} (mapping, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}kwargs)
\item 
\mbox{\hyperlink{namespacematplotlib_1_1__api_a45e9c651e2fd672e2913ef1f581bd567}{caching\+\_\+module\+\_\+getattr}} (cls)
\item 
\mbox{\hyperlink{namespacematplotlib_1_1__api_a4eb1c0664d00be99a0fc4da78e8f4eb0}{define\+\_\+aliases}} (alias\+\_\+d, cls=None)
\item 
\mbox{\hyperlink{namespacematplotlib_1_1__api_ab41bcee2543b5797feb0e77f2732eabf}{select\+\_\+matching\+\_\+signature}} (funcs, \texorpdfstring{$\ast$}{*}args, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}kwargs)
\item 
\mbox{\hyperlink{namespacematplotlib_1_1__api_a7d20ad97b8b0e549ed4453dc4612254e}{nargs\+\_\+error}} (name, takes, given)
\item 
\mbox{\hyperlink{namespacematplotlib_1_1__api_af32afe3c0e534758fd6722909eddff2a}{kwarg\+\_\+error}} (name, kw)
\item 
\mbox{\hyperlink{namespacematplotlib_1_1__api_af79860f736b3ab1ac943f7be89860622}{recursive\+\_\+subclasses}} (cls)
\item 
\mbox{\hyperlink{namespacematplotlib_1_1__api_aeaafe43664fbb90bbad8786b5f90ce40}{warn\+\_\+external}} (message, category=None)
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
str \mbox{\hyperlink{namespacematplotlib_1_1__api_a51340ba3ebeb41c1476c7cbf64a4567a}{\+\_\+\+\_\+name\+\_\+\+\_\+}} = "{}\+\_\+\+\_\+getattr\+\_\+\+\_\+"{}
\item 
dict \mbox{\hyperlink{namespacematplotlib_1_1__api_a03b33bc5e2a857aad97c76fef3bb1d0f}{\+\_\+alias\+\_\+map}} = \{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}preexisting\+\_\+aliases, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}alias\+\_\+d\}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\begin{DoxyVerb}Helper functions for managing the Matplotlib API.

This documentation is only relevant for Matplotlib developers, not for users.

.. warning::

    This module and its submodules are for internal use only.  Do not use them
    in your own code.  We may change the API at any time with no warning.
\end{DoxyVerb}
 

\doxysubsection{Function Documentation}
\Hypertarget{namespacematplotlib_1_1__api_a45e9c651e2fd672e2913ef1f581bd567}\index{matplotlib.\_api@{matplotlib.\_api}!caching\_module\_getattr@{caching\_module\_getattr}}
\index{caching\_module\_getattr@{caching\_module\_getattr}!matplotlib.\_api@{matplotlib.\_api}}
\doxysubsubsection{\texorpdfstring{caching\_module\_getattr()}{caching\_module\_getattr()}}
{\footnotesize\ttfamily \label{namespacematplotlib_1_1__api_a45e9c651e2fd672e2913ef1f581bd567} 
matplotlib.\+\_\+api.\+caching\+\_\+module\+\_\+getattr (\begin{DoxyParamCaption}\item[{}]{cls}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Helper decorator for implementing module-level ``__getattr__`` as a class.

This decorator must be used at the module toplevel as follows::

    @caching_module_getattr
    class __getattr__:  # The class *must* be named ``__getattr__``.
        @property  # Only properties are taken into account.
        def name(self): ...

The ``__getattr__`` class will be replaced by a ``__getattr__``
function such that trying to access ``name`` on the module will
resolve the corresponding property (which may be decorated e.g. with
``_api.deprecated`` for deprecating module globals).  The properties are
all implicitly cached.  Moreover, a suitable AttributeError is generated
and raised if no property with the given name exists.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{matplotlib_2__api_2____init_____8py_source_l00189}{189}} of file \mbox{\hyperlink{matplotlib_2__api_2____init_____8py_source}{\+\_\+\+\_\+init\+\_\+\+\_\+.\+py}}.

\Hypertarget{namespacematplotlib_1_1__api_ac1854af962d2a57995be918df60a9df6}\index{matplotlib.\_api@{matplotlib.\_api}!check\_getitem@{check\_getitem}}
\index{check\_getitem@{check\_getitem}!matplotlib.\_api@{matplotlib.\_api}}
\doxysubsubsection{\texorpdfstring{check\_getitem()}{check\_getitem()}}
{\footnotesize\ttfamily \label{namespacematplotlib_1_1__api_ac1854af962d2a57995be918df60a9df6} 
matplotlib.\+\_\+api.\+check\+\_\+getitem (\begin{DoxyParamCaption}\item[{}]{mapping}{, }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{kwargs}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}*kwargs* must consist of a single *key, value* pair.  If *key* is in
*mapping*, return ``mapping[value]``; else, raise an appropriate
ValueError.

Examples
--------
>>> _api.check_getitem({"foo": "bar"}, arg=arg)
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{matplotlib_2__api_2____init_____8py_source_l00168}{168}} of file \mbox{\hyperlink{matplotlib_2__api_2____init_____8py_source}{\+\_\+\+\_\+init\+\_\+\+\_\+.\+py}}.

\Hypertarget{namespacematplotlib_1_1__api_a2a1dff1a48a83284d5420d2f658cf3e8}\index{matplotlib.\_api@{matplotlib.\_api}!check\_in\_list@{check\_in\_list}}
\index{check\_in\_list@{check\_in\_list}!matplotlib.\_api@{matplotlib.\_api}}
\doxysubsubsection{\texorpdfstring{check\_in\_list()}{check\_in\_list()}}
{\footnotesize\ttfamily \label{namespacematplotlib_1_1__api_a2a1dff1a48a83284d5420d2f658cf3e8} 
matplotlib.\+\_\+api.\+check\+\_\+in\+\_\+list (\begin{DoxyParamCaption}\item[{}]{values}{, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{\+\_\+print\+\_\+supported\+\_\+values}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}, }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{kwargs}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}For each *key, value* pair in *kwargs*, check that *value* is in *values*;
if not, raise an appropriate ValueError.

Parameters
----------
values : iterable
    Sequence of values to check on.
_print_supported_values : bool, default: True
    Whether to print *values* when raising ValueError.
**kwargs : dict
    *key, value* pairs as keyword arguments to find in *values*.

Raises
------
ValueError
    If any *value* in *kwargs* is not found in *values*.

Examples
--------
>>> _api.check_in_list(["foo", "bar"], arg=arg, other_arg=other_arg)
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{matplotlib_2__api_2____init_____8py_source_l00100}{100}} of file \mbox{\hyperlink{matplotlib_2__api_2____init_____8py_source}{\+\_\+\+\_\+init\+\_\+\+\_\+.\+py}}.

\Hypertarget{namespacematplotlib_1_1__api_af27e5b8ad11435f5ee9b257c47b6fe96}\index{matplotlib.\_api@{matplotlib.\_api}!check\_isinstance@{check\_isinstance}}
\index{check\_isinstance@{check\_isinstance}!matplotlib.\_api@{matplotlib.\_api}}
\doxysubsubsection{\texorpdfstring{check\_isinstance()}{check\_isinstance()}}
{\footnotesize\ttfamily \label{namespacematplotlib_1_1__api_af27e5b8ad11435f5ee9b257c47b6fe96} 
matplotlib.\+\_\+api.\+check\+\_\+isinstance (\begin{DoxyParamCaption}\item[{}]{types}{, }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{kwargs}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}For each *key, value* pair in *kwargs*, check that *value* is an instance
of one of *types*; if not, raise an appropriate TypeError.

As a special case, a ``None`` entry in *types* is treated as NoneType.

Examples
--------
>>> _api.check_isinstance((SomeClass, None), arg=arg)
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{matplotlib_2__api_2____init_____8py_source_l00065}{65}} of file \mbox{\hyperlink{matplotlib_2__api_2____init_____8py_source}{\+\_\+\+\_\+init\+\_\+\+\_\+.\+py}}.

\Hypertarget{namespacematplotlib_1_1__api_ac35255143c3bfd85a7a8fee81e914f2f}\index{matplotlib.\_api@{matplotlib.\_api}!check\_shape@{check\_shape}}
\index{check\_shape@{check\_shape}!matplotlib.\_api@{matplotlib.\_api}}
\doxysubsubsection{\texorpdfstring{check\_shape()}{check\_shape()}}
{\footnotesize\ttfamily \label{namespacematplotlib_1_1__api_ac35255143c3bfd85a7a8fee81e914f2f} 
matplotlib.\+\_\+api.\+check\+\_\+shape (\begin{DoxyParamCaption}\item[{}]{shape}{, }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{kwargs}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}For each *key, value* pair in *kwargs*, check that *value* has the shape *shape*;
if not, raise an appropriate ValueError.

*None* in the shape is treated as a "free" size that can have any length.
e.g. (None, 2) -> (N, 2)

The values checked must be numpy arrays.

Examples
--------
To check for (N, 2) shaped arrays

>>> _api.check_shape((None, 2), arg=arg, other_arg=other_arg)
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{matplotlib_2__api_2____init_____8py_source_l00133}{133}} of file \mbox{\hyperlink{matplotlib_2__api_2____init_____8py_source}{\+\_\+\+\_\+init\+\_\+\+\_\+.\+py}}.

\Hypertarget{namespacematplotlib_1_1__api_a4eb1c0664d00be99a0fc4da78e8f4eb0}\index{matplotlib.\_api@{matplotlib.\_api}!define\_aliases@{define\_aliases}}
\index{define\_aliases@{define\_aliases}!matplotlib.\_api@{matplotlib.\_api}}
\doxysubsubsection{\texorpdfstring{define\_aliases()}{define\_aliases()}}
{\footnotesize\ttfamily \label{namespacematplotlib_1_1__api_a4eb1c0664d00be99a0fc4da78e8f4eb0} 
matplotlib.\+\_\+api.\+define\+\_\+aliases (\begin{DoxyParamCaption}\item[{}]{alias\+\_\+d}{, }\item[{}]{cls}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Class decorator for defining property aliases.

Use as ::

    @_api.define_aliases({"property": ["alias", ...], ...})
    class C: ...

For each property, if the corresponding ``get_property`` is defined in the
class so far, an alias named ``get_alias`` will be defined; the same will
be done for setters.  If neither the getter nor the setter exists, an
exception will be raised.

The alias map is stored as the ``_alias_map`` attribute on the class and
can be used by `.normalize_kwargs` (which assumes that higher priority
aliases come last).
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{matplotlib_2__api_2____init_____8py_source_l00224}{224}} of file \mbox{\hyperlink{matplotlib_2__api_2____init_____8py_source}{\+\_\+\+\_\+init\+\_\+\+\_\+.\+py}}.

\Hypertarget{namespacematplotlib_1_1__api_af32afe3c0e534758fd6722909eddff2a}\index{matplotlib.\_api@{matplotlib.\_api}!kwarg\_error@{kwarg\_error}}
\index{kwarg\_error@{kwarg\_error}!matplotlib.\_api@{matplotlib.\_api}}
\doxysubsubsection{\texorpdfstring{kwarg\_error()}{kwarg\_error()}}
{\footnotesize\ttfamily \label{namespacematplotlib_1_1__api_af32afe3c0e534758fd6722909eddff2a} 
matplotlib.\+\_\+api.\+kwarg\+\_\+error (\begin{DoxyParamCaption}\item[{}]{name}{, }\item[{}]{kw}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Generate a TypeError to be raised by function calls with wrong kwarg.

Parameters
----------
name : str
    The name of the calling function.
kw : str or Iterable[str]
    Either the invalid keyword argument name, or an iterable yielding
    invalid keyword arguments (e.g., a ``kwargs`` dict).
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{matplotlib_2__api_2____init_____8py_source_l00337}{337}} of file \mbox{\hyperlink{matplotlib_2__api_2____init_____8py_source}{\+\_\+\+\_\+init\+\_\+\+\_\+.\+py}}.

\Hypertarget{namespacematplotlib_1_1__api_a7d20ad97b8b0e549ed4453dc4612254e}\index{matplotlib.\_api@{matplotlib.\_api}!nargs\_error@{nargs\_error}}
\index{nargs\_error@{nargs\_error}!matplotlib.\_api@{matplotlib.\_api}}
\doxysubsubsection{\texorpdfstring{nargs\_error()}{nargs\_error()}}
{\footnotesize\ttfamily \label{namespacematplotlib_1_1__api_a7d20ad97b8b0e549ed4453dc4612254e} 
matplotlib.\+\_\+api.\+nargs\+\_\+error (\begin{DoxyParamCaption}\item[{}]{name}{, }\item[{}]{takes}{, }\item[{}]{given}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Generate a TypeError to be raised by function calls with wrong arity.\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{matplotlib_2__api_2____init_____8py_source_l00331}{331}} of file \mbox{\hyperlink{matplotlib_2__api_2____init_____8py_source}{\+\_\+\+\_\+init\+\_\+\+\_\+.\+py}}.

\Hypertarget{namespacematplotlib_1_1__api_af79860f736b3ab1ac943f7be89860622}\index{matplotlib.\_api@{matplotlib.\_api}!recursive\_subclasses@{recursive\_subclasses}}
\index{recursive\_subclasses@{recursive\_subclasses}!matplotlib.\_api@{matplotlib.\_api}}
\doxysubsubsection{\texorpdfstring{recursive\_subclasses()}{recursive\_subclasses()}}
{\footnotesize\ttfamily \label{namespacematplotlib_1_1__api_af79860f736b3ab1ac943f7be89860622} 
matplotlib.\+\_\+api.\+recursive\+\_\+subclasses (\begin{DoxyParamCaption}\item[{}]{cls}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Yield *cls* and direct and indirect subclasses of *cls*.\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{matplotlib_2__api_2____init_____8py_source_l00354}{354}} of file \mbox{\hyperlink{matplotlib_2__api_2____init_____8py_source}{\+\_\+\+\_\+init\+\_\+\+\_\+.\+py}}.



References \mbox{\hyperlink{matplotlib_2__api_2____init_____8py_source_l00354}{recursive\+\_\+subclasses()}}.



Referenced by \mbox{\hyperlink{matplotlib_2__api_2____init_____8py_source_l00354}{recursive\+\_\+subclasses()}}.

\Hypertarget{namespacematplotlib_1_1__api_ab41bcee2543b5797feb0e77f2732eabf}\index{matplotlib.\_api@{matplotlib.\_api}!select\_matching\_signature@{select\_matching\_signature}}
\index{select\_matching\_signature@{select\_matching\_signature}!matplotlib.\_api@{matplotlib.\_api}}
\doxysubsubsection{\texorpdfstring{select\_matching\_signature()}{select\_matching\_signature()}}
{\footnotesize\ttfamily \label{namespacematplotlib_1_1__api_ab41bcee2543b5797feb0e77f2732eabf} 
matplotlib.\+\_\+api.\+select\+\_\+matching\+\_\+signature (\begin{DoxyParamCaption}\item[{}]{funcs}{, }\item[{\texorpdfstring{$\ast$}{*}}]{args}{, }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{kwargs}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Select and call the function that accepts ``*args, **kwargs``.

*funcs* is a list of functions which should not raise any exception (other
than `TypeError` if the arguments passed do not match their signature).

`select_matching_signature` tries to call each of the functions in *funcs*
with ``*args, **kwargs`` (in the order in which they are given).  Calls
that fail with a `TypeError` are silently skipped.  As soon as a call
succeeds, `select_matching_signature` returns its return value.  If no
function accepts ``*args, **kwargs``, then the `TypeError` raised by the
last failing call is re-raised.

Callers should normally make sure that any ``*args, **kwargs`` can only
bind a single *func* (to avoid any ambiguity), although this is not checked
by `select_matching_signature`.

Notes
-----
`select_matching_signature` is intended to help implementing
signature-overloaded functions.  In general, such functions should be
avoided, except for back-compatibility concerns.  A typical use pattern is
::

    def my_func(*args, **kwargs):
        params = select_matching_signature(
            [lambda old1, old2: locals(), lambda new: locals()],
            *args, **kwargs)
        if "old1" in params:
            warn_deprecated(...)
            old1, old2 = params.values()  # note that locals() is ordered.
        else:
            new, = params.values()
        # do things with params

which allows *my_func* to be called either with two parameters (*old1* and
*old2*) or a single one (*new*).  Note that the new signature is given
last, so that callers get a `TypeError` corresponding to the new signature
if the arguments they passed in do not match any signature.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{matplotlib_2__api_2____init_____8py_source_l00279}{279}} of file \mbox{\hyperlink{matplotlib_2__api_2____init_____8py_source}{\+\_\+\+\_\+init\+\_\+\+\_\+.\+py}}.

\Hypertarget{namespacematplotlib_1_1__api_aeaafe43664fbb90bbad8786b5f90ce40}\index{matplotlib.\_api@{matplotlib.\_api}!warn\_external@{warn\_external}}
\index{warn\_external@{warn\_external}!matplotlib.\_api@{matplotlib.\_api}}
\doxysubsubsection{\texorpdfstring{warn\_external()}{warn\_external()}}
{\footnotesize\ttfamily \label{namespacematplotlib_1_1__api_aeaafe43664fbb90bbad8786b5f90ce40} 
matplotlib.\+\_\+api.\+warn\+\_\+external (\begin{DoxyParamCaption}\item[{}]{message}{, }\item[{}]{category}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}`warnings.warn` wrapper that sets *stacklevel* to "outside Matplotlib".

The original emitter of the warning can be obtained by patching this
function back to `warnings.warn`, i.e. ``_api.warn_external =
warnings.warn`` (or ``functools.partial(warnings.warn, stacklevel=2)``,
etc.).
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{matplotlib_2__api_2____init_____8py_source_l00361}{361}} of file \mbox{\hyperlink{matplotlib_2__api_2____init_____8py_source}{\+\_\+\+\_\+init\+\_\+\+\_\+.\+py}}.



Referenced by \mbox{\hyperlink{matplotlib_2__api_2deprecation_8py_source_l00050}{matplotlib.\+\_\+api.\+deprecation.\+warn\+\_\+deprecated()}}.



\doxysubsection{Variable Documentation}
\Hypertarget{namespacematplotlib_1_1__api_a51340ba3ebeb41c1476c7cbf64a4567a}\index{matplotlib.\_api@{matplotlib.\_api}!\_\_name\_\_@{\_\_name\_\_}}
\index{\_\_name\_\_@{\_\_name\_\_}!matplotlib.\_api@{matplotlib.\_api}}
\doxysubsubsection{\texorpdfstring{\_\_name\_\_}{\_\_name\_\_}}
{\footnotesize\ttfamily \label{namespacematplotlib_1_1__api_a51340ba3ebeb41c1476c7cbf64a4567a} 
str matplotlib.\+\_\+api.\+\_\+\+\_\+name\+\_\+\+\_\+ = "{}\+\_\+\+\_\+getattr\+\_\+\+\_\+"{}\hspace{0.3cm}{\ttfamily [private]}}



Definition at line \mbox{\hyperlink{matplotlib_2__api_2____init_____8py_source_l00208}{208}} of file \mbox{\hyperlink{matplotlib_2__api_2____init_____8py_source}{\+\_\+\+\_\+init\+\_\+\+\_\+.\+py}}.

\Hypertarget{namespacematplotlib_1_1__api_a03b33bc5e2a857aad97c76fef3bb1d0f}\index{matplotlib.\_api@{matplotlib.\_api}!\_alias\_map@{\_alias\_map}}
\index{\_alias\_map@{\_alias\_map}!matplotlib.\_api@{matplotlib.\_api}}
\doxysubsubsection{\texorpdfstring{\_alias\_map}{\_alias\_map}}
{\footnotesize\ttfamily \label{namespacematplotlib_1_1__api_a03b33bc5e2a857aad97c76fef3bb1d0f} 
dict matplotlib.\+\_\+api.\+\_\+alias\+\_\+map = \{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}preexisting\+\_\+aliases, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}alias\+\_\+d\}\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{matplotlib_2__api_2____init_____8py_source_l00275}{275}} of file \mbox{\hyperlink{matplotlib_2__api_2____init_____8py_source}{\+\_\+\+\_\+init\+\_\+\+\_\+.\+py}}.

