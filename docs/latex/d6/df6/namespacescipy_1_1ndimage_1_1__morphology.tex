\doxysection{scipy.\+ndimage.\+\_\+morphology Namespace Reference}
\hypertarget{namespacescipy_1_1ndimage_1_1__morphology}{}\label{namespacescipy_1_1ndimage_1_1__morphology}\index{scipy.ndimage.\_morphology@{scipy.ndimage.\_morphology}}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacescipy_1_1ndimage_1_1__morphology_a2851a9e4d44123be02f0ea9d3c67e7ce}{\+\_\+center\+\_\+is\+\_\+true}} (structure, origin)
\item 
\mbox{\hyperlink{namespacescipy_1_1ndimage_1_1__morphology_a9dd391da5464b292a7b7880e7df2ec8c}{iterate\+\_\+structure}} (structure, iterations, origin=None)
\item 
\mbox{\hyperlink{namespacescipy_1_1ndimage_1_1__morphology_ac4cec95e8f208f65adb2a23ae10daccb}{generate\+\_\+binary\+\_\+structure}} (rank, connectivity)
\item 
\mbox{\hyperlink{namespacescipy_1_1ndimage_1_1__morphology_a3f859d5303e7c6616469d6dfa3c3f3c6}{\+\_\+binary\+\_\+erosion}} (input, structure, iterations, mask, output, border\+\_\+value, origin, invert, brute\+\_\+force)
\item 
\mbox{\hyperlink{namespacescipy_1_1ndimage_1_1__morphology_aaf4c69d471160e40476e1ec891e5e17b}{binary\+\_\+erosion}} (input, structure=None, iterations=1, mask=None, output=None, border\+\_\+value=0, origin=0, brute\+\_\+force=False)
\item 
\mbox{\hyperlink{namespacescipy_1_1ndimage_1_1__morphology_ad6f306301c649c5d9e9536bfd2151847}{binary\+\_\+dilation}} (input, structure=None, iterations=1, mask=None, output=None, border\+\_\+value=0, origin=0, brute\+\_\+force=False)
\item 
\mbox{\hyperlink{namespacescipy_1_1ndimage_1_1__morphology_a3cf7eda4cc0b9e687f14c5eb1ccaf023}{binary\+\_\+opening}} (input, structure=None, iterations=1, output=None, origin=0, mask=None, border\+\_\+value=0, brute\+\_\+force=False)
\item 
\mbox{\hyperlink{namespacescipy_1_1ndimage_1_1__morphology_af141f355eae9ec61ee36be125178cbb1}{binary\+\_\+closing}} (input, structure=None, iterations=1, output=None, origin=0, mask=None, border\+\_\+value=0, brute\+\_\+force=False)
\item 
\mbox{\hyperlink{namespacescipy_1_1ndimage_1_1__morphology_aa7bef98325ff647bb1260c97597bf2bd}{binary\+\_\+hit\+\_\+or\+\_\+miss}} (input, structure1=None, structure2=None, output=None, origin1=0, origin2=None)
\item 
\mbox{\hyperlink{namespacescipy_1_1ndimage_1_1__morphology_a064495983f3cea84941fba854c6b4212}{binary\+\_\+propagation}} (input, structure=None, mask=None, output=None, border\+\_\+value=0, origin=0)
\item 
\mbox{\hyperlink{namespacescipy_1_1ndimage_1_1__morphology_abdcb01b54ec069de14c06f87202f4792}{binary\+\_\+fill\+\_\+holes}} (input, structure=None, output=None, origin=0)
\item 
\mbox{\hyperlink{namespacescipy_1_1ndimage_1_1__morphology_adea52fca905158ab16412ce44ef86515}{grey\+\_\+erosion}} (input, size=None, footprint=None, structure=None, output=None, mode="{}reflect"{}, cval=0.\+0, origin=0)
\item 
\mbox{\hyperlink{namespacescipy_1_1ndimage_1_1__morphology_a2f19f05960e0438e963d6cb1bbf53765}{grey\+\_\+dilation}} (input, size=None, footprint=None, structure=None, output=None, mode="{}reflect"{}, cval=0.\+0, origin=0)
\item 
\mbox{\hyperlink{namespacescipy_1_1ndimage_1_1__morphology_a22d6712a86de6eb485961fc8726fcc52}{grey\+\_\+opening}} (input, size=None, footprint=None, structure=None, output=None, mode="{}reflect"{}, cval=0.\+0, origin=0)
\item 
\mbox{\hyperlink{namespacescipy_1_1ndimage_1_1__morphology_ad138cae4d72e92ba608d5ba082f7865a}{grey\+\_\+closing}} (input, size=None, footprint=None, structure=None, output=None, mode="{}reflect"{}, cval=0.\+0, origin=0)
\item 
\mbox{\hyperlink{namespacescipy_1_1ndimage_1_1__morphology_a2adc01fa7bd196f6b4e192bea82c7766}{morphological\+\_\+gradient}} (input, size=None, footprint=None, structure=None, output=None, mode="{}reflect"{}, cval=0.\+0, origin=0)
\item 
\mbox{\hyperlink{namespacescipy_1_1ndimage_1_1__morphology_a0fff8ab8112efaac5e8468232ef05fc5}{morphological\+\_\+laplace}} (input, size=None, footprint=None, structure=None, output=None, mode="{}reflect"{}, cval=0.\+0, origin=0)
\item 
\mbox{\hyperlink{namespacescipy_1_1ndimage_1_1__morphology_afc672dbc002ca4d3046d93c4f97917df}{white\+\_\+tophat}} (input, size=None, footprint=None, structure=None, output=None, mode="{}reflect"{}, cval=0.\+0, origin=0)
\item 
\mbox{\hyperlink{namespacescipy_1_1ndimage_1_1__morphology_a72f0812aaf64f0ecf601fe13285a0773}{black\+\_\+tophat}} (input, size=None, footprint=None, structure=None, output=None, mode="{}reflect"{}, cval=0.\+0, origin=0)
\item 
\mbox{\hyperlink{namespacescipy_1_1ndimage_1_1__morphology_aee604cc266e7e18fdd063bbbb4982b3a}{distance\+\_\+transform\+\_\+bf}} (input, metric="{}euclidean"{}, sampling=None, return\+\_\+distances=\mbox{\hyperlink{classTrue}{True}}, return\+\_\+indices=False, distances=None, indices=None)
\item 
\mbox{\hyperlink{namespacescipy_1_1ndimage_1_1__morphology_a4c50783191be8546186187b4a6fac0c4}{distance\+\_\+transform\+\_\+cdt}} (input, metric=\textquotesingle{}chessboard\textquotesingle{}, return\+\_\+distances=\mbox{\hyperlink{classTrue}{True}}, return\+\_\+indices=False, distances=None, indices=None)
\item 
\mbox{\hyperlink{namespacescipy_1_1ndimage_1_1__morphology_ae4b7e191882073a63602a80343313ea3}{distance\+\_\+transform\+\_\+edt}} (input, sampling=None, return\+\_\+distances=\mbox{\hyperlink{classTrue}{True}}, return\+\_\+indices=False, distances=None, indices=None)
\item 
\mbox{\hyperlink{namespacescipy_1_1ndimage_1_1__morphology_a919de6e43201c152f1b085b5e9380222}{\+\_\+distance\+\_\+tranform\+\_\+arg\+\_\+check}} (distances\+\_\+out, indices\+\_\+out, return\+\_\+distances, return\+\_\+indices)
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
list \mbox{\hyperlink{namespacescipy_1_1ndimage_1_1__morphology_aa5ecc78782b4c7152e2dfdce6e71cc73}{\+\_\+\+\_\+all\+\_\+\+\_\+}}
\end{DoxyCompactItemize}


\doxysubsection{Function Documentation}
\Hypertarget{namespacescipy_1_1ndimage_1_1__morphology_a3f859d5303e7c6616469d6dfa3c3f3c6}\index{scipy.ndimage.\_morphology@{scipy.ndimage.\_morphology}!\_binary\_erosion@{\_binary\_erosion}}
\index{\_binary\_erosion@{\_binary\_erosion}!scipy.ndimage.\_morphology@{scipy.ndimage.\_morphology}}
\doxysubsubsection{\texorpdfstring{\_binary\_erosion()}{\_binary\_erosion()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1ndimage_1_1__morphology_a3f859d5303e7c6616469d6dfa3c3f3c6} 
scipy.\+ndimage.\+\_\+morphology.\+\_\+binary\+\_\+erosion (\begin{DoxyParamCaption}\item[{}]{input}{, }\item[{}]{structure}{, }\item[{}]{iterations}{, }\item[{}]{mask}{, }\item[{}]{output}{, }\item[{}]{border\+\_\+value}{, }\item[{}]{origin}{, }\item[{}]{invert}{, }\item[{}]{brute\+\_\+force}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{__morphology_8py_source_l00216}{216}} of file \mbox{\hyperlink{__morphology_8py_source}{\+\_\+morphology.\+py}}.

\Hypertarget{namespacescipy_1_1ndimage_1_1__morphology_a2851a9e4d44123be02f0ea9d3c67e7ce}\index{scipy.ndimage.\_morphology@{scipy.ndimage.\_morphology}!\_center\_is\_true@{\_center\_is\_true}}
\index{\_center\_is\_true@{\_center\_is\_true}!scipy.ndimage.\_morphology@{scipy.ndimage.\_morphology}}
\doxysubsubsection{\texorpdfstring{\_center\_is\_true()}{\_center\_is\_true()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1ndimage_1_1__morphology_a2851a9e4d44123be02f0ea9d3c67e7ce} 
scipy.\+ndimage.\+\_\+morphology.\+\_\+center\+\_\+is\+\_\+true (\begin{DoxyParamCaption}\item[{}]{structure}{, }\item[{}]{origin}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{__morphology_8py_source_l00048}{48}} of file \mbox{\hyperlink{__morphology_8py_source}{\+\_\+morphology.\+py}}.

\Hypertarget{namespacescipy_1_1ndimage_1_1__morphology_a919de6e43201c152f1b085b5e9380222}\index{scipy.ndimage.\_morphology@{scipy.ndimage.\_morphology}!\_distance\_tranform\_arg\_check@{\_distance\_tranform\_arg\_check}}
\index{\_distance\_tranform\_arg\_check@{\_distance\_tranform\_arg\_check}!scipy.ndimage.\_morphology@{scipy.ndimage.\_morphology}}
\doxysubsubsection{\texorpdfstring{\_distance\_tranform\_arg\_check()}{\_distance\_tranform\_arg\_check()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1ndimage_1_1__morphology_a919de6e43201c152f1b085b5e9380222} 
scipy.\+ndimage.\+\_\+morphology.\+\_\+distance\+\_\+tranform\+\_\+arg\+\_\+check (\begin{DoxyParamCaption}\item[{}]{distances\+\_\+out}{, }\item[{}]{indices\+\_\+out}{, }\item[{}]{return\+\_\+distances}{, }\item[{}]{return\+\_\+indices}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Raise a RuntimeError if the arguments are invalid\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__morphology_8py_source_l02502}{2502}} of file \mbox{\hyperlink{__morphology_8py_source}{\+\_\+morphology.\+py}}.



Referenced by \mbox{\hyperlink{__morphology_8py_source_l01870}{distance\+\_\+transform\+\_\+bf()}}, \mbox{\hyperlink{__morphology_8py_source_l02105}{distance\+\_\+transform\+\_\+cdt()}}, and \mbox{\hyperlink{__morphology_8py_source_l02319}{distance\+\_\+transform\+\_\+edt()}}.

\Hypertarget{namespacescipy_1_1ndimage_1_1__morphology_af141f355eae9ec61ee36be125178cbb1}\index{scipy.ndimage.\_morphology@{scipy.ndimage.\_morphology}!binary\_closing@{binary\_closing}}
\index{binary\_closing@{binary\_closing}!scipy.ndimage.\_morphology@{scipy.ndimage.\_morphology}}
\doxysubsubsection{\texorpdfstring{binary\_closing()}{binary\_closing()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1ndimage_1_1__morphology_af141f355eae9ec61ee36be125178cbb1} 
scipy.\+ndimage.\+\_\+morphology.\+binary\+\_\+closing (\begin{DoxyParamCaption}\item[{}]{input}{, }\item[{}]{structure}{ = {\ttfamily None}, }\item[{}]{iterations}{ = {\ttfamily 1}, }\item[{}]{output}{ = {\ttfamily None}, }\item[{}]{origin}{ = {\ttfamily 0}, }\item[{}]{mask}{ = {\ttfamily None}, }\item[{}]{border\+\_\+value}{ = {\ttfamily 0}, }\item[{}]{brute\+\_\+force}{ = {\ttfamily False}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Multidimensional binary closing with the given structuring element.

The *closing* of an input image by a structuring element is the
*erosion* of the *dilation* of the image by the structuring element.

Parameters
----------
input : array_like
    Binary array_like to be closed. Non-zero (True) elements form
    the subset to be closed.
structure : array_like, optional
    Structuring element used for the closing. Non-zero elements are
    considered True. If no structuring element is provided an element
    is generated with a square connectivity equal to one (i.e., only
    nearest neighbors are connected to the center, diagonally-connected
    elements are not considered neighbors).
iterations : int, optional
    The dilation step of the closing, then the erosion step are each
    repeated `iterations` times (one, by default). If iterations is
    less than 1, each operations is repeated until the result does
    not change anymore. Only an integer of iterations is accepted.
output : ndarray, optional
    Array of the same shape as input, into which the output is placed.
    By default, a new array is created.
origin : int or tuple of ints, optional
    Placement of the filter, by default 0.
mask : array_like, optional
    If a mask is given, only those elements with a True value at
    the corresponding mask element are modified at each iteration.

    .. versionadded:: 1.1.0
border_value : int (cast to 0 or 1), optional
    Value at the border in the output array.

    .. versionadded:: 1.1.0
brute_force : boolean, optional
    Memory condition: if False, only the pixels whose value was changed in
    the last iteration are tracked as candidates to be updated in the
    current iteration; if true al pixels are considered as candidates for
    update, regardless of what happened in the previous iteration.
    False by default.

    .. versionadded:: 1.1.0

Returns
-------
binary_closing : ndarray of bools
    Closing of the input by the structuring element.

See also
--------
grey_closing, binary_opening, binary_dilation, binary_erosion,
generate_binary_structure

Notes
-----
*Closing* [1]_ is a mathematical morphology operation [2]_ that
consists in the succession of a dilation and an erosion of the
input with the same structuring element. Closing therefore fills
holes smaller than the structuring element.

Together with *opening* (`binary_opening`), closing can be used for
noise removal.

References
----------
.. [1] https://en.wikipedia.org/wiki/Closing_%28morphology%29
.. [2] https://en.wikipedia.org/wiki/Mathematical_morphology

Examples
--------
>>> from scipy import ndimage
>>> import numpy as np
>>> a = np.zeros((5,5), dtype=int)
>>> a[1:-1, 1:-1] = 1; a[2,2] = 0
>>> a
array([[0, 0, 0, 0, 0],
       [0, 1, 1, 1, 0],
       [0, 1, 0, 1, 0],
       [0, 1, 1, 1, 0],
       [0, 0, 0, 0, 0]])
>>> # Closing removes small holes
>>> ndimage.binary_closing(a).astype(int)
array([[0, 0, 0, 0, 0],
       [0, 1, 1, 1, 0],
       [0, 1, 1, 1, 0],
       [0, 1, 1, 1, 0],
       [0, 0, 0, 0, 0]])
>>> # Closing is the erosion of the dilation of the input
>>> ndimage.binary_dilation(a).astype(int)
array([[0, 1, 1, 1, 0],
       [1, 1, 1, 1, 1],
       [1, 1, 1, 1, 1],
       [1, 1, 1, 1, 1],
       [0, 1, 1, 1, 0]])
>>> ndimage.binary_erosion(ndimage.binary_dilation(a)).astype(int)
array([[0, 0, 0, 0, 0],
       [0, 1, 1, 1, 0],
       [0, 1, 1, 1, 0],
       [0, 1, 1, 1, 0],
       [0, 0, 0, 0, 0]])


>>> a = np.zeros((7,7), dtype=int)
>>> a[1:6, 2:5] = 1; a[1:3,3] = 0
>>> a
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 0, 1, 0, 1, 0, 0],
       [0, 0, 1, 0, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 0, 0, 0, 0, 0]])
>>> # In addition to removing holes, closing can also
>>> # coarsen boundaries with fine hollows.
>>> ndimage.binary_closing(a).astype(int)
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 0, 1, 0, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 0, 0, 0, 0, 0]])
>>> ndimage.binary_closing(a, structure=np.ones((2,2))).astype(int)
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 0, 0, 0, 0, 0]])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__morphology_8py_source_l00648}{648}} of file \mbox{\hyperlink{__morphology_8py_source}{\+\_\+morphology.\+py}}.



References \mbox{\hyperlink{__morphology_8py_source_l00393}{binary\+\_\+dilation()}}, \mbox{\hyperlink{__morphology_8py_source_l00294}{binary\+\_\+erosion()}}, and \mbox{\hyperlink{__morphology_8py_source_l00124}{generate\+\_\+binary\+\_\+structure()}}.

\Hypertarget{namespacescipy_1_1ndimage_1_1__morphology_ad6f306301c649c5d9e9536bfd2151847}\index{scipy.ndimage.\_morphology@{scipy.ndimage.\_morphology}!binary\_dilation@{binary\_dilation}}
\index{binary\_dilation@{binary\_dilation}!scipy.ndimage.\_morphology@{scipy.ndimage.\_morphology}}
\doxysubsubsection{\texorpdfstring{binary\_dilation()}{binary\_dilation()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1ndimage_1_1__morphology_ad6f306301c649c5d9e9536bfd2151847} 
scipy.\+ndimage.\+\_\+morphology.\+binary\+\_\+dilation (\begin{DoxyParamCaption}\item[{}]{input}{, }\item[{}]{structure}{ = {\ttfamily None}, }\item[{}]{iterations}{ = {\ttfamily 1}, }\item[{}]{mask}{ = {\ttfamily None}, }\item[{}]{output}{ = {\ttfamily None}, }\item[{}]{border\+\_\+value}{ = {\ttfamily 0}, }\item[{}]{origin}{ = {\ttfamily 0}, }\item[{}]{brute\+\_\+force}{ = {\ttfamily False}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Multidimensional binary dilation with the given structuring element.

Parameters
----------
input : array_like
    Binary array_like to be dilated. Non-zero (True) elements form
    the subset to be dilated.
structure : array_like, optional
    Structuring element used for the dilation. Non-zero elements are
    considered True. If no structuring element is provided an element
    is generated with a square connectivity equal to one.
iterations : int, optional
    The dilation is repeated `iterations` times (one, by default).
    If iterations is less than 1, the dilation is repeated until the
    result does not change anymore. Only an integer of iterations is
    accepted.
mask : array_like, optional
    If a mask is given, only those elements with a True value at
    the corresponding mask element are modified at each iteration.
output : ndarray, optional
    Array of the same shape as input, into which the output is placed.
    By default, a new array is created.
border_value : int (cast to 0 or 1), optional
    Value at the border in the output array.
origin : int or tuple of ints, optional
    Placement of the filter, by default 0.
brute_force : boolean, optional
    Memory condition: if False, only the pixels whose value was changed in
    the last iteration are tracked as candidates to be updated (dilated)
    in the current iteration; if True all pixels are considered as
    candidates for dilation, regardless of what happened in the previous
    iteration. False by default.

Returns
-------
binary_dilation : ndarray of bools
    Dilation of the input by the structuring element.

See also
--------
grey_dilation, binary_erosion, binary_closing, binary_opening,
generate_binary_structure

Notes
-----
Dilation [1]_ is a mathematical morphology operation [2]_ that uses a
structuring element for expanding the shapes in an image. The binary
dilation of an image by a structuring element is the locus of the points
covered by the structuring element, when its center lies within the
non-zero points of the image.

References
----------
.. [1] https://en.wikipedia.org/wiki/Dilation_%28morphology%29
.. [2] https://en.wikipedia.org/wiki/Mathematical_morphology

Examples
--------
>>> from scipy import ndimage
>>> import numpy as np
>>> a = np.zeros((5, 5))
>>> a[2, 2] = 1
>>> a
array([[ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  1.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.]])
>>> ndimage.binary_dilation(a)
array([[False, False, False, False, False],
       [False, False,  True, False, False],
       [False,  True,  True,  True, False],
       [False, False,  True, False, False],
       [False, False, False, False, False]], dtype=bool)
>>> ndimage.binary_dilation(a).astype(a.dtype)
array([[ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  1.,  0.,  0.],
       [ 0.,  1.,  1.,  1.,  0.],
       [ 0.,  0.,  1.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.]])
>>> # 3x3 structuring element with connectivity 1, used by default
>>> struct1 = ndimage.generate_binary_structure(2, 1)
>>> struct1
array([[False,  True, False],
       [ True,  True,  True],
       [False,  True, False]], dtype=bool)
>>> # 3x3 structuring element with connectivity 2
>>> struct2 = ndimage.generate_binary_structure(2, 2)
>>> struct2
array([[ True,  True,  True],
       [ True,  True,  True],
       [ True,  True,  True]], dtype=bool)
>>> ndimage.binary_dilation(a, structure=struct1).astype(a.dtype)
array([[ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  1.,  0.,  0.],
       [ 0.,  1.,  1.,  1.,  0.],
       [ 0.,  0.,  1.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.]])
>>> ndimage.binary_dilation(a, structure=struct2).astype(a.dtype)
array([[ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  1.,  1.,  1.,  0.],
       [ 0.,  1.,  1.,  1.,  0.],
       [ 0.,  1.,  1.,  1.,  0.],
       [ 0.,  0.,  0.,  0.,  0.]])
>>> ndimage.binary_dilation(a, structure=struct1,\\
... iterations=2).astype(a.dtype)
array([[ 0.,  0.,  1.,  0.,  0.],
       [ 0.,  1.,  1.,  1.,  0.],
       [ 1.,  1.,  1.,  1.,  1.],
       [ 0.,  1.,  1.,  1.,  0.],
       [ 0.,  0.,  1.,  0.,  0.]])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__morphology_8py_source_l00391}{391}} of file \mbox{\hyperlink{__morphology_8py_source}{\+\_\+morphology.\+py}}.



References \mbox{\hyperlink{__morphology_8py_source_l00124}{generate\+\_\+binary\+\_\+structure()}}.



Referenced by \mbox{\hyperlink{__morphology_8py_source_l00649}{binary\+\_\+closing()}}, \mbox{\hyperlink{__morphology_8py_source_l01037}{binary\+\_\+fill\+\_\+holes()}}, \mbox{\hyperlink{__morphology_8py_source_l00525}{binary\+\_\+opening()}}, \mbox{\hyperlink{__morphology_8py_source_l00906}{binary\+\_\+propagation()}}, \mbox{\hyperlink{__morphology_8py_source_l01870}{distance\+\_\+transform\+\_\+bf()}}, and \mbox{\hyperlink{__morphology_8py_source_l00055}{iterate\+\_\+structure()}}.

\Hypertarget{namespacescipy_1_1ndimage_1_1__morphology_aaf4c69d471160e40476e1ec891e5e17b}\index{scipy.ndimage.\_morphology@{scipy.ndimage.\_morphology}!binary\_erosion@{binary\_erosion}}
\index{binary\_erosion@{binary\_erosion}!scipy.ndimage.\_morphology@{scipy.ndimage.\_morphology}}
\doxysubsubsection{\texorpdfstring{binary\_erosion()}{binary\_erosion()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1ndimage_1_1__morphology_aaf4c69d471160e40476e1ec891e5e17b} 
scipy.\+ndimage.\+\_\+morphology.\+binary\+\_\+erosion (\begin{DoxyParamCaption}\item[{}]{input}{, }\item[{}]{structure}{ = {\ttfamily None}, }\item[{}]{iterations}{ = {\ttfamily 1}, }\item[{}]{mask}{ = {\ttfamily None}, }\item[{}]{output}{ = {\ttfamily None}, }\item[{}]{border\+\_\+value}{ = {\ttfamily 0}, }\item[{}]{origin}{ = {\ttfamily 0}, }\item[{}]{brute\+\_\+force}{ = {\ttfamily False}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Multidimensional binary erosion with a given structuring element.

Binary erosion is a mathematical morphology operation used for image
processing.

Parameters
----------
input : array_like
    Binary image to be eroded. Non-zero (True) elements form
    the subset to be eroded.
structure : array_like, optional
    Structuring element used for the erosion. Non-zero elements are
    considered True. If no structuring element is provided, an element
    is generated with a square connectivity equal to one.
iterations : int, optional
    The erosion is repeated `iterations` times (one, by default).
    If iterations is less than 1, the erosion is repeated until the
    result does not change anymore.
mask : array_like, optional
    If a mask is given, only those elements with a True value at
    the corresponding mask element are modified at each iteration.
output : ndarray, optional
    Array of the same shape as input, into which the output is placed.
    By default, a new array is created.
border_value : int (cast to 0 or 1), optional
    Value at the border in the output array.
origin : int or tuple of ints, optional
    Placement of the filter, by default 0.
brute_force : boolean, optional
    Memory condition: if False, only the pixels whose value was changed in
    the last iteration are tracked as candidates to be updated (eroded) in
    the current iteration; if True all pixels are considered as candidates
    for erosion, regardless of what happened in the previous iteration.
    False by default.

Returns
-------
binary_erosion : ndarray of bools
    Erosion of the input by the structuring element.

See also
--------
grey_erosion, binary_dilation, binary_closing, binary_opening,
generate_binary_structure

Notes
-----
Erosion [1]_ is a mathematical morphology operation [2]_ that uses a
structuring element for shrinking the shapes in an image. The binary
erosion of an image by a structuring element is the locus of the points
where a superimposition of the structuring element centered on the point
is entirely contained in the set of non-zero elements of the image.

References
----------
.. [1] https://en.wikipedia.org/wiki/Erosion_%28morphology%29
.. [2] https://en.wikipedia.org/wiki/Mathematical_morphology

Examples
--------
>>> from scipy import ndimage
>>> import numpy as np
>>> a = np.zeros((7,7), dtype=int)
>>> a[1:6, 2:5] = 1
>>> a
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 0, 0, 0, 0, 0]])
>>> ndimage.binary_erosion(a).astype(a.dtype)
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 1, 0, 0, 0],
       [0, 0, 0, 1, 0, 0, 0],
       [0, 0, 0, 1, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0]])
>>> #Erosion removes objects smaller than the structure
>>> ndimage.binary_erosion(a, structure=np.ones((5,5))).astype(a.dtype)
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0]])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__morphology_8py_source_l00293}{293}} of file \mbox{\hyperlink{__morphology_8py_source}{\+\_\+morphology.\+py}}.



Referenced by \mbox{\hyperlink{__morphology_8py_source_l00649}{binary\+\_\+closing()}}, and \mbox{\hyperlink{__morphology_8py_source_l00525}{binary\+\_\+opening()}}.

\Hypertarget{namespacescipy_1_1ndimage_1_1__morphology_abdcb01b54ec069de14c06f87202f4792}\index{scipy.ndimage.\_morphology@{scipy.ndimage.\_morphology}!binary\_fill\_holes@{binary\_fill\_holes}}
\index{binary\_fill\_holes@{binary\_fill\_holes}!scipy.ndimage.\_morphology@{scipy.ndimage.\_morphology}}
\doxysubsubsection{\texorpdfstring{binary\_fill\_holes()}{binary\_fill\_holes()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1ndimage_1_1__morphology_abdcb01b54ec069de14c06f87202f4792} 
scipy.\+ndimage.\+\_\+morphology.\+binary\+\_\+fill\+\_\+holes (\begin{DoxyParamCaption}\item[{}]{input}{, }\item[{}]{structure}{ = {\ttfamily None}, }\item[{}]{output}{ = {\ttfamily None}, }\item[{}]{origin}{ = {\ttfamily 0}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Fill the holes in binary objects.


Parameters
----------
input : array_like
    N-D binary array with holes to be filled
structure : array_like, optional
    Structuring element used in the computation; large-size elements
    make computations faster but may miss holes separated from the
    background by thin regions. The default element (with a square
    connectivity equal to one) yields the intuitive result where all
    holes in the input have been filled.
output : ndarray, optional
    Array of the same shape as input, into which the output is placed.
    By default, a new array is created.
origin : int, tuple of ints, optional
    Position of the structuring element.

Returns
-------
out : ndarray
    Transformation of the initial image `input` where holes have been
    filled.

See also
--------
binary_dilation, binary_propagation, label

Notes
-----
The algorithm used in this function consists in invading the complementary
of the shapes in `input` from the outer boundary of the image,
using binary dilations. Holes are not connected to the boundary and are
therefore not invaded. The result is the complementary subset of the
invaded region.

References
----------
.. [1] https://en.wikipedia.org/wiki/Mathematical_morphology


Examples
--------
>>> from scipy import ndimage
>>> import numpy as np
>>> a = np.zeros((5, 5), dtype=int)
>>> a[1:4, 1:4] = 1
>>> a[2,2] = 0
>>> a
array([[0, 0, 0, 0, 0],
       [0, 1, 1, 1, 0],
       [0, 1, 0, 1, 0],
       [0, 1, 1, 1, 0],
       [0, 0, 0, 0, 0]])
>>> ndimage.binary_fill_holes(a).astype(int)
array([[0, 0, 0, 0, 0],
       [0, 1, 1, 1, 0],
       [0, 1, 1, 1, 0],
       [0, 1, 1, 1, 0],
       [0, 0, 0, 0, 0]])
>>> # Too big structuring element
>>> ndimage.binary_fill_holes(a, structure=np.ones((5,5))).astype(int)
array([[0, 0, 0, 0, 0],
       [0, 1, 1, 1, 0],
       [0, 1, 0, 1, 0],
       [0, 1, 1, 1, 0],
       [0, 0, 0, 0, 0]])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__morphology_8py_source_l01037}{1037}} of file \mbox{\hyperlink{__morphology_8py_source}{\+\_\+morphology.\+py}}.



References \mbox{\hyperlink{__morphology_8py_source_l00393}{binary\+\_\+dilation()}}.

\Hypertarget{namespacescipy_1_1ndimage_1_1__morphology_aa7bef98325ff647bb1260c97597bf2bd}\index{scipy.ndimage.\_morphology@{scipy.ndimage.\_morphology}!binary\_hit\_or\_miss@{binary\_hit\_or\_miss}}
\index{binary\_hit\_or\_miss@{binary\_hit\_or\_miss}!scipy.ndimage.\_morphology@{scipy.ndimage.\_morphology}}
\doxysubsubsection{\texorpdfstring{binary\_hit\_or\_miss()}{binary\_hit\_or\_miss()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1ndimage_1_1__morphology_aa7bef98325ff647bb1260c97597bf2bd} 
scipy.\+ndimage.\+\_\+morphology.\+binary\+\_\+hit\+\_\+or\+\_\+miss (\begin{DoxyParamCaption}\item[{}]{input}{, }\item[{}]{structure1}{ = {\ttfamily None}, }\item[{}]{structure2}{ = {\ttfamily None}, }\item[{}]{output}{ = {\ttfamily None}, }\item[{}]{origin1}{ = {\ttfamily 0}, }\item[{}]{origin2}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Multidimensional binary hit-or-miss transform.

The hit-or-miss transform finds the locations of a given pattern
inside the input image.

Parameters
----------
input : array_like (cast to booleans)
    Binary image where a pattern is to be detected.
structure1 : array_like (cast to booleans), optional
    Part of the structuring element to be fitted to the foreground
    (non-zero elements) of `input`. If no value is provided, a
    structure of square connectivity 1 is chosen.
structure2 : array_like (cast to booleans), optional
    Second part of the structuring element that has to miss completely
    the foreground. If no value is provided, the complementary of
    `structure1` is taken.
output : ndarray, optional
    Array of the same shape as input, into which the output is placed.
    By default, a new array is created.
origin1 : int or tuple of ints, optional
    Placement of the first part of the structuring element `structure1`,
    by default 0 for a centered structure.
origin2 : int or tuple of ints, optional
    Placement of the second part of the structuring element `structure2`,
    by default 0 for a centered structure. If a value is provided for
    `origin1` and not for `origin2`, then `origin2` is set to `origin1`.

Returns
-------
binary_hit_or_miss : ndarray
    Hit-or-miss transform of `input` with the given structuring
    element (`structure1`, `structure2`).

See also
--------
binary_erosion

References
----------
.. [1] https://en.wikipedia.org/wiki/Hit-or-miss_transform

Examples
--------
>>> from scipy import ndimage
>>> import numpy as np
>>> a = np.zeros((7,7), dtype=int)
>>> a[1, 1] = 1; a[2:4, 2:4] = 1; a[4:6, 4:6] = 1
>>> a
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 1, 0, 0, 0, 0, 0],
       [0, 0, 1, 1, 0, 0, 0],
       [0, 0, 1, 1, 0, 0, 0],
       [0, 0, 0, 0, 1, 1, 0],
       [0, 0, 0, 0, 1, 1, 0],
       [0, 0, 0, 0, 0, 0, 0]])
>>> structure1 = np.array([[1, 0, 0], [0, 1, 1], [0, 1, 1]])
>>> structure1
array([[1, 0, 0],
       [0, 1, 1],
       [0, 1, 1]])
>>> # Find the matches of structure1 in the array a
>>> ndimage.binary_hit_or_miss(a, structure1=structure1).astype(int)
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0]])
>>> # Change the origin of the filter
>>> # origin1=1 is equivalent to origin1=(1,1) here
>>> ndimage.binary_hit_or_miss(a, structure1=structure1,\\
... origin1=1).astype(int)
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 1, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 1, 0],
       [0, 0, 0, 0, 0, 0, 0]])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__morphology_8py_source_l00795}{795}} of file \mbox{\hyperlink{__morphology_8py_source}{\+\_\+morphology.\+py}}.



References \mbox{\hyperlink{__morphology_8py_source_l00124}{generate\+\_\+binary\+\_\+structure()}}.

\Hypertarget{namespacescipy_1_1ndimage_1_1__morphology_a3cf7eda4cc0b9e687f14c5eb1ccaf023}\index{scipy.ndimage.\_morphology@{scipy.ndimage.\_morphology}!binary\_opening@{binary\_opening}}
\index{binary\_opening@{binary\_opening}!scipy.ndimage.\_morphology@{scipy.ndimage.\_morphology}}
\doxysubsubsection{\texorpdfstring{binary\_opening()}{binary\_opening()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1ndimage_1_1__morphology_a3cf7eda4cc0b9e687f14c5eb1ccaf023} 
scipy.\+ndimage.\+\_\+morphology.\+binary\+\_\+opening (\begin{DoxyParamCaption}\item[{}]{input}{, }\item[{}]{structure}{ = {\ttfamily None}, }\item[{}]{iterations}{ = {\ttfamily 1}, }\item[{}]{output}{ = {\ttfamily None}, }\item[{}]{origin}{ = {\ttfamily 0}, }\item[{}]{mask}{ = {\ttfamily None}, }\item[{}]{border\+\_\+value}{ = {\ttfamily 0}, }\item[{}]{brute\+\_\+force}{ = {\ttfamily False}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Multidimensional binary opening with the given structuring element.

The *opening* of an input image by a structuring element is the
*dilation* of the *erosion* of the image by the structuring element.

Parameters
----------
input : array_like
    Binary array_like to be opened. Non-zero (True) elements form
    the subset to be opened.
structure : array_like, optional
    Structuring element used for the opening. Non-zero elements are
    considered True. If no structuring element is provided an element
    is generated with a square connectivity equal to one (i.e., only
    nearest neighbors are connected to the center, diagonally-connected
    elements are not considered neighbors).
iterations : int, optional
    The erosion step of the opening, then the dilation step are each
    repeated `iterations` times (one, by default). If `iterations` is
    less than 1, each operation is repeated until the result does
    not change anymore. Only an integer of iterations is accepted.
output : ndarray, optional
    Array of the same shape as input, into which the output is placed.
    By default, a new array is created.
origin : int or tuple of ints, optional
    Placement of the filter, by default 0.
mask : array_like, optional
    If a mask is given, only those elements with a True value at
    the corresponding mask element are modified at each iteration.

    .. versionadded:: 1.1.0
border_value : int (cast to 0 or 1), optional
    Value at the border in the output array.

    .. versionadded:: 1.1.0
brute_force : boolean, optional
    Memory condition: if False, only the pixels whose value was changed in
    the last iteration are tracked as candidates to be updated in the
    current iteration; if true all pixels are considered as candidates for
    update, regardless of what happened in the previous iteration.
    False by default.

    .. versionadded:: 1.1.0

Returns
-------
binary_opening : ndarray of bools
    Opening of the input by the structuring element.

See also
--------
grey_opening, binary_closing, binary_erosion, binary_dilation,
generate_binary_structure

Notes
-----
*Opening* [1]_ is a mathematical morphology operation [2]_ that
consists in the succession of an erosion and a dilation of the
input with the same structuring element. Opening, therefore, removes
objects smaller than the structuring element.

Together with *closing* (`binary_closing`), opening can be used for
noise removal.

References
----------
.. [1] https://en.wikipedia.org/wiki/Opening_%28morphology%29
.. [2] https://en.wikipedia.org/wiki/Mathematical_morphology

Examples
--------
>>> from scipy import ndimage
>>> import numpy as np
>>> a = np.zeros((5,5), dtype=int)
>>> a[1:4, 1:4] = 1; a[4, 4] = 1
>>> a
array([[0, 0, 0, 0, 0],
       [0, 1, 1, 1, 0],
       [0, 1, 1, 1, 0],
       [0, 1, 1, 1, 0],
       [0, 0, 0, 0, 1]])
>>> # Opening removes small objects
>>> ndimage.binary_opening(a, structure=np.ones((3,3))).astype(int)
array([[0, 0, 0, 0, 0],
       [0, 1, 1, 1, 0],
       [0, 1, 1, 1, 0],
       [0, 1, 1, 1, 0],
       [0, 0, 0, 0, 0]])
>>> # Opening can also smooth corners
>>> ndimage.binary_opening(a).astype(int)
array([[0, 0, 0, 0, 0],
       [0, 0, 1, 0, 0],
       [0, 1, 1, 1, 0],
       [0, 0, 1, 0, 0],
       [0, 0, 0, 0, 0]])
>>> # Opening is the dilation of the erosion of the input
>>> ndimage.binary_erosion(a).astype(int)
array([[0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0],
       [0, 0, 1, 0, 0],
       [0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0]])
>>> ndimage.binary_dilation(ndimage.binary_erosion(a)).astype(int)
array([[0, 0, 0, 0, 0],
       [0, 0, 1, 0, 0],
       [0, 1, 1, 1, 0],
       [0, 0, 1, 0, 0],
       [0, 0, 0, 0, 0]])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__morphology_8py_source_l00524}{524}} of file \mbox{\hyperlink{__morphology_8py_source}{\+\_\+morphology.\+py}}.



References \mbox{\hyperlink{__morphology_8py_source_l00393}{binary\+\_\+dilation()}}, \mbox{\hyperlink{__morphology_8py_source_l00294}{binary\+\_\+erosion()}}, and \mbox{\hyperlink{__morphology_8py_source_l00124}{generate\+\_\+binary\+\_\+structure()}}.

\Hypertarget{namespacescipy_1_1ndimage_1_1__morphology_a064495983f3cea84941fba854c6b4212}\index{scipy.ndimage.\_morphology@{scipy.ndimage.\_morphology}!binary\_propagation@{binary\_propagation}}
\index{binary\_propagation@{binary\_propagation}!scipy.ndimage.\_morphology@{scipy.ndimage.\_morphology}}
\doxysubsubsection{\texorpdfstring{binary\_propagation()}{binary\_propagation()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1ndimage_1_1__morphology_a064495983f3cea84941fba854c6b4212} 
scipy.\+ndimage.\+\_\+morphology.\+binary\+\_\+propagation (\begin{DoxyParamCaption}\item[{}]{input}{, }\item[{}]{structure}{ = {\ttfamily None}, }\item[{}]{mask}{ = {\ttfamily None}, }\item[{}]{output}{ = {\ttfamily None}, }\item[{}]{border\+\_\+value}{ = {\ttfamily 0}, }\item[{}]{origin}{ = {\ttfamily 0}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Multidimensional binary propagation with the given structuring element.

Parameters
----------
input : array_like
    Binary image to be propagated inside `mask`.
structure : array_like, optional
    Structuring element used in the successive dilations. The output
    may depend on the structuring element, especially if `mask` has
    several connex components. If no structuring element is
    provided, an element is generated with a squared connectivity equal
    to one.
mask : array_like, optional
    Binary mask defining the region into which `input` is allowed to
    propagate.
output : ndarray, optional
    Array of the same shape as input, into which the output is placed.
    By default, a new array is created.
border_value : int (cast to 0 or 1), optional
    Value at the border in the output array.
origin : int or tuple of ints, optional
    Placement of the filter, by default 0.

Returns
-------
binary_propagation : ndarray
    Binary propagation of `input` inside `mask`.

Notes
-----
This function is functionally equivalent to calling binary_dilation
with the number of iterations less than one: iterative dilation until
the result does not change anymore.

The succession of an erosion and propagation inside the original image
can be used instead of an *opening* for deleting small objects while
keeping the contours of larger objects untouched.

References
----------
.. [1] http://cmm.ensmp.fr/~serra/cours/pdf/en/ch6en.pdf, slide 15.
.. [2] I.T. Young, J.J. Gerbrands, and L.J. van Vliet, "Fundamentals of
    image processing", 1998
    ftp://qiftp.tudelft.nl/DIPimage/docs/FIP2.3.pdf

Examples
--------
>>> from scipy import ndimage
>>> import numpy as np
>>> input = np.zeros((8, 8), dtype=int)
>>> input[2, 2] = 1
>>> mask = np.zeros((8, 8), dtype=int)
>>> mask[1:4, 1:4] = mask[4, 4]  = mask[6:8, 6:8] = 1
>>> input
array([[0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 1, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0]])
>>> mask
array([[0, 0, 0, 0, 0, 0, 0, 0],
       [0, 1, 1, 1, 0, 0, 0, 0],
       [0, 1, 1, 1, 0, 0, 0, 0],
       [0, 1, 1, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 1, 1],
       [0, 0, 0, 0, 0, 0, 1, 1]])
>>> ndimage.binary_propagation(input, mask=mask).astype(int)
array([[0, 0, 0, 0, 0, 0, 0, 0],
       [0, 1, 1, 1, 0, 0, 0, 0],
       [0, 1, 1, 1, 0, 0, 0, 0],
       [0, 1, 1, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0]])
>>> ndimage.binary_propagation(input, mask=mask,\\
... structure=np.ones((3,3))).astype(int)
array([[0, 0, 0, 0, 0, 0, 0, 0],
       [0, 1, 1, 1, 0, 0, 0, 0],
       [0, 1, 1, 1, 0, 0, 0, 0],
       [0, 1, 1, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0]])

>>> # Comparison between opening and erosion+propagation
>>> a = np.zeros((6,6), dtype=int)
>>> a[2:5, 2:5] = 1; a[0, 0] = 1; a[5, 5] = 1
>>> a
array([[1, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0],
       [0, 0, 1, 1, 1, 0],
       [0, 0, 1, 1, 1, 0],
       [0, 0, 1, 1, 1, 0],
       [0, 0, 0, 0, 0, 1]])
>>> ndimage.binary_opening(a).astype(int)
array([[0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0],
       [0, 0, 0, 1, 0, 0],
       [0, 0, 1, 1, 1, 0],
       [0, 0, 0, 1, 0, 0],
       [0, 0, 0, 0, 0, 0]])
>>> b = ndimage.binary_erosion(a)
>>> b.astype(int)
array([[0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0],
       [0, 0, 0, 1, 0, 0],
       [0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0]])
>>> ndimage.binary_propagation(b, mask=a).astype(int)
array([[0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0],
       [0, 0, 1, 1, 1, 0],
       [0, 0, 1, 1, 1, 0],
       [0, 0, 1, 1, 1, 0],
       [0, 0, 0, 0, 0, 0]])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__morphology_8py_source_l00905}{905}} of file \mbox{\hyperlink{__morphology_8py_source}{\+\_\+morphology.\+py}}.



References \mbox{\hyperlink{__morphology_8py_source_l00393}{binary\+\_\+dilation()}}.

\Hypertarget{namespacescipy_1_1ndimage_1_1__morphology_a72f0812aaf64f0ecf601fe13285a0773}\index{scipy.ndimage.\_morphology@{scipy.ndimage.\_morphology}!black\_tophat@{black\_tophat}}
\index{black\_tophat@{black\_tophat}!scipy.ndimage.\_morphology@{scipy.ndimage.\_morphology}}
\doxysubsubsection{\texorpdfstring{black\_tophat()}{black\_tophat()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1ndimage_1_1__morphology_a72f0812aaf64f0ecf601fe13285a0773} 
scipy.\+ndimage.\+\_\+morphology.\+black\+\_\+tophat (\begin{DoxyParamCaption}\item[{}]{input}{, }\item[{}]{size}{ = {\ttfamily None}, }\item[{}]{footprint}{ = {\ttfamily None}, }\item[{}]{structure}{ = {\ttfamily None}, }\item[{}]{output}{ = {\ttfamily None}, }\item[{}]{mode}{ = {\ttfamily "{}reflect"{}}, }\item[{}]{cval}{ = {\ttfamily 0.0}, }\item[{}]{origin}{ = {\ttfamily 0}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Multidimensional black tophat filter.

Parameters
----------
input : array_like
    Input.
size : tuple of ints, optional
    Shape of a flat and full structuring element used for the filter.
    Optional if `footprint` or `structure` is provided.
footprint : array of ints, optional
    Positions of non-infinite elements of a flat structuring element
    used for the black tophat filter.
structure : array of ints, optional
    Structuring element used for the filter. `structure`
    may be a non-flat structuring element.
output : array, optional
    An array used for storing the output of the filter may be provided.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
    The `mode` parameter determines how the array borders are
    handled, where `cval` is the value when mode is equal to
    'constant'. Default is 'reflect'
cval : scalar, optional
    Value to fill past edges of input if `mode` is 'constant'. Default
    is 0.0.
origin : scalar, optional
    The `origin` parameter controls the placement of the filter.
    Default 0

Returns
-------
black_tophat : ndarray
    Result of the filter of `input` with `structure`.

Examples
--------
Change dark peak to bright peak and subtract background.

>>> from scipy.ndimage import generate_binary_structure, black_tophat
>>> import numpy as np
>>> square = generate_binary_structure(rank=2, connectivity=3)
>>> dark_on_gray = np.array([[7, 6, 6, 6, 7],
...                          [6, 5, 4, 5, 6],
...                          [6, 4, 0, 4, 6],
...                          [6, 5, 4, 5, 6],
...                          [7, 6, 6, 6, 7]])
>>> black_tophat(input=dark_on_gray, structure=square)
array([[0, 0, 0, 0, 0],
       [0, 0, 1, 0, 0],
       [0, 1, 5, 1, 0],
       [0, 0, 1, 0, 0],
       [0, 0, 0, 0, 0]])

See also
--------
white_tophat, grey_opening, grey_closing
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__morphology_8py_source_l01791}{1791}} of file \mbox{\hyperlink{__morphology_8py_source}{\+\_\+morphology.\+py}}.



References \mbox{\hyperlink{__morphology_8py_source_l01234}{grey\+\_\+dilation()}}, and \mbox{\hyperlink{__morphology_8py_source_l01123}{grey\+\_\+erosion()}}.

\Hypertarget{namespacescipy_1_1ndimage_1_1__morphology_aee604cc266e7e18fdd063bbbb4982b3a}\index{scipy.ndimage.\_morphology@{scipy.ndimage.\_morphology}!distance\_transform\_bf@{distance\_transform\_bf}}
\index{distance\_transform\_bf@{distance\_transform\_bf}!scipy.ndimage.\_morphology@{scipy.ndimage.\_morphology}}
\doxysubsubsection{\texorpdfstring{distance\_transform\_bf()}{distance\_transform\_bf()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1ndimage_1_1__morphology_aee604cc266e7e18fdd063bbbb4982b3a} 
scipy.\+ndimage.\+\_\+morphology.\+distance\+\_\+transform\+\_\+bf (\begin{DoxyParamCaption}\item[{}]{input}{, }\item[{}]{metric}{ = {\ttfamily "{}euclidean"{}}, }\item[{}]{sampling}{ = {\ttfamily None}, }\item[{}]{return\+\_\+distances}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}, }\item[{}]{return\+\_\+indices}{ = {\ttfamily False}, }\item[{}]{distances}{ = {\ttfamily None}, }\item[{}]{indices}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Distance transform function by a brute force algorithm.

This function calculates the distance transform of the `input`, by
replacing each foreground (non-zero) element, with its
shortest distance to the background (any zero-valued element).

In addition to the distance transform, the feature transform can
be calculated. In this case the index of the closest background
element to each foreground element is returned in a separate array.

Parameters
----------
input : array_like
    Input
metric : {'euclidean', 'taxicab', 'chessboard'}, optional
    'cityblock' and 'manhattan' are also valid, and map to 'taxicab'.
    The default is 'euclidean'.
sampling : float, or sequence of float, optional
    This parameter is only used when `metric` is 'euclidean'.
    Spacing of elements along each dimension. If a sequence, must be of
    length equal to the input rank; if a single number, this is used for
    all axes. If not specified, a grid spacing of unity is implied.
return_distances : bool, optional
    Whether to calculate the distance transform.
    Default is True.
return_indices : bool, optional
    Whether to calculate the feature transform.
    Default is False.
distances : ndarray, optional
    An output array to store the calculated distance transform, instead of
    returning it.
    `return_distances` must be True.
    It must be the same shape as `input`, and of type float64 if `metric`
    is 'euclidean', uint32 otherwise.
indices : int32 ndarray, optional
    An output array to store the calculated feature transform, instead of
    returning it.
    `return_indicies` must be True.
    Its shape must be `(input.ndim,) + input.shape`.

Returns
-------
distances : ndarray, optional
    The calculated distance transform. Returned only when
    `return_distances` is True and `distances` is not supplied.
    It will have the same shape as the input array.
indices : int32 ndarray, optional
    The calculated feature transform. It has an input-shaped array for each
    dimension of the input. See distance_transform_edt documentation for an
    example.
    Returned only when `return_indices` is True and `indices` is not
    supplied.

See Also
--------
distance_transform_cdt : Faster distance transform for taxicab and
                         chessboard metrics
distance_transform_edt : Faster distance transform for euclidean metric

Notes
-----
This function employs a slow brute force algorithm, see also the
function `distance_transform_cdt` for more efficient taxicab [1]_ and
chessboard algorithms [2]_.

References
----------
.. [1] Taxicab distance. Wikipedia, 2023.
       https://en.wikipedia.org/wiki/Taxicab_geometry
.. [2] Chessboard distance. Wikipedia, 2023.
       https://en.wikipedia.org/wiki/Chebyshev_distance

Examples
--------
Import the necessary modules.

>>> import numpy as np
>>> from scipy.ndimage import distance_transform_bf
>>> import matplotlib.pyplot as plt
>>> from mpl_toolkits.axes_grid1 import ImageGrid

First, we create a toy binary image.

>>> def add_circle(center_x, center_y, radius, image, fillvalue=1):
...     # fill circular area with 1
...     xx, yy = np.mgrid[:image.shape[0], :image.shape[1]]
...     circle = (xx - center_x) ** 2 + (yy - center_y) ** 2
...     circle_shape = np.sqrt(circle) < radius
...     image[circle_shape] = fillvalue
...     return image
>>> image = np.zeros((100, 100), dtype=np.uint8)
>>> image[35:65, 20:80] = 1
>>> image = add_circle(28, 65, 10, image)
>>> image = add_circle(37, 30, 10, image)
>>> image = add_circle(70, 45, 20, image)
>>> image = add_circle(45, 80, 10, image)

Next, we set up the figure.

>>> fig = plt.figure(figsize=(8, 8))  # set up the figure structure
>>> grid = ImageGrid(fig, 111, nrows_ncols=(2, 2), axes_pad=(0.4, 0.3),
...                  label_mode="1", share_all=True,
...                  cbar_location="right", cbar_mode="each",
...                  cbar_size="7%", cbar_pad="2%")
>>> for ax in grid:
...     ax.axis('off')  # remove axes from images

The top left image is the original binary image.

>>> binary_image = grid[0].imshow(image, cmap='gray')
>>> cbar_binary_image = grid.cbar_axes[0].colorbar(binary_image)
>>> cbar_binary_image.set_ticks([0, 1])
>>> grid[0].set_title("Binary image: foreground in white")

The distance transform calculates the distance between foreground pixels
and the image background according to a distance metric. Available metrics
in `distance_transform_bf` are: ``euclidean`` (default), ``taxicab``
and ``chessboard``. The top right image contains the distance transform
based on the ``euclidean`` metric.

>>> distance_transform_euclidean = distance_transform_bf(image)
>>> euclidean_transform = grid[1].imshow(distance_transform_euclidean,
...                                      cmap='gray')
>>> cbar_euclidean = grid.cbar_axes[1].colorbar(euclidean_transform)
>>> colorbar_ticks = [0, 10, 20]
>>> cbar_euclidean.set_ticks(colorbar_ticks)
>>> grid[1].set_title("Euclidean distance")

The lower left image contains the distance transform using the ``taxicab``
metric.

>>> distance_transform_taxicab = distance_transform_bf(image,
...                                                    metric='taxicab')
>>> taxicab_transformation = grid[2].imshow(distance_transform_taxicab,
...                                         cmap='gray')
>>> cbar_taxicab = grid.cbar_axes[2].colorbar(taxicab_transformation)
>>> cbar_taxicab.set_ticks(colorbar_ticks)
>>> grid[2].set_title("Taxicab distance")

Finally, the lower right image contains the distance transform using the
``chessboard`` metric.

>>> distance_transform_cb = distance_transform_bf(image,
...                                               metric='chessboard')
>>> chessboard_transformation = grid[3].imshow(distance_transform_cb,
...                                            cmap='gray')
>>> cbar_taxicab = grid.cbar_axes[3].colorbar(chessboard_transformation)
>>> cbar_taxicab.set_ticks(colorbar_ticks)
>>> grid[3].set_title("Chessboard distance")
>>> plt.show()
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__morphology_8py_source_l01868}{1868}} of file \mbox{\hyperlink{__morphology_8py_source}{\+\_\+morphology.\+py}}.



References \mbox{\hyperlink{__morphology_8py_source_l02503}{\+\_\+distance\+\_\+tranform\+\_\+arg\+\_\+check()}}, \mbox{\hyperlink{__morphology_8py_source_l00393}{binary\+\_\+dilation()}}, and \mbox{\hyperlink{__morphology_8py_source_l00124}{generate\+\_\+binary\+\_\+structure()}}.

\Hypertarget{namespacescipy_1_1ndimage_1_1__morphology_a4c50783191be8546186187b4a6fac0c4}\index{scipy.ndimage.\_morphology@{scipy.ndimage.\_morphology}!distance\_transform\_cdt@{distance\_transform\_cdt}}
\index{distance\_transform\_cdt@{distance\_transform\_cdt}!scipy.ndimage.\_morphology@{scipy.ndimage.\_morphology}}
\doxysubsubsection{\texorpdfstring{distance\_transform\_cdt()}{distance\_transform\_cdt()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1ndimage_1_1__morphology_a4c50783191be8546186187b4a6fac0c4} 
scipy.\+ndimage.\+\_\+morphology.\+distance\+\_\+transform\+\_\+cdt (\begin{DoxyParamCaption}\item[{}]{input}{, }\item[{}]{metric}{ = {\ttfamily \textquotesingle{}chessboard\textquotesingle{}}, }\item[{}]{return\+\_\+distances}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}, }\item[{}]{return\+\_\+indices}{ = {\ttfamily False}, }\item[{}]{distances}{ = {\ttfamily None}, }\item[{}]{indices}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Distance transform for chamfer type of transforms.

This function calculates the distance transform of the `input`, by
replacing each foreground (non-zero) element, with its
shortest distance to the background (any zero-valued element).

In addition to the distance transform, the feature transform can
be calculated. In this case the index of the closest background
element to each foreground element is returned in a separate array.

Parameters
----------
input : array_like
    Input. Values of 0 are treated as background.
metric : {'chessboard', 'taxicab'} or array_like, optional
    The `metric` determines the type of chamfering that is done. If the
    `metric` is equal to 'taxicab' a structure is generated using
    `generate_binary_structure` with a squared distance equal to 1. If
    the `metric` is equal to 'chessboard', a `metric` is generated
    using `generate_binary_structure` with a squared distance equal to
    the dimensionality of the array. These choices correspond to the
    common interpretations of the 'taxicab' and the 'chessboard'
    distance metrics in two dimensions.
    A custom metric may be provided, in the form of a matrix where
    each dimension has a length of three.
    'cityblock' and 'manhattan' are also valid, and map to 'taxicab'.
    The default is 'chessboard'.
return_distances : bool, optional
    Whether to calculate the distance transform.
    Default is True.
return_indices : bool, optional
    Whether to calculate the feature transform.
    Default is False.
distances : int32 ndarray, optional
    An output array to store the calculated distance transform, instead of
    returning it.
    `return_distances` must be True.
    It must be the same shape as `input`.
indices : int32 ndarray, optional
    An output array to store the calculated feature transform, instead of
    returning it.
    `return_indicies` must be True.
    Its shape must be `(input.ndim,) + input.shape`.

Returns
-------
distances : int32 ndarray, optional
    The calculated distance transform. Returned only when
    `return_distances` is True, and `distances` is not supplied.
    It will have the same shape as the input array.
indices : int32 ndarray, optional
    The calculated feature transform. It has an input-shaped array for each
    dimension of the input. See distance_transform_edt documentation for an
    example.
    Returned only when `return_indices` is True, and `indices` is not
    supplied.

See Also
--------
distance_transform_edt : Fast distance transform for euclidean metric
distance_transform_bf : Distance transform for different metrics using
                        a slower brute force algorithm

Examples
--------
Import the necessary modules.

>>> import numpy as np
>>> from scipy.ndimage import distance_transform_cdt
>>> import matplotlib.pyplot as plt
>>> from mpl_toolkits.axes_grid1 import ImageGrid

First, we create a toy binary image.

>>> def add_circle(center_x, center_y, radius, image, fillvalue=1):
...     # fill circular area with 1
...     xx, yy = np.mgrid[:image.shape[0], :image.shape[1]]
...     circle = (xx - center_x) ** 2 + (yy - center_y) ** 2
...     circle_shape = np.sqrt(circle) < radius
...     image[circle_shape] = fillvalue
...     return image
>>> image = np.zeros((100, 100), dtype=np.uint8)
>>> image[35:65, 20:80] = 1
>>> image = add_circle(28, 65, 10, image)
>>> image = add_circle(37, 30, 10, image)
>>> image = add_circle(70, 45, 20, image)
>>> image = add_circle(45, 80, 10, image)

Next, we set up the figure.

>>> fig = plt.figure(figsize=(5, 15))
>>> grid = ImageGrid(fig, 111, nrows_ncols=(3, 1), axes_pad=(0.5, 0.3),
...                  label_mode="1", share_all=True,
...                  cbar_location="right", cbar_mode="each",
...                  cbar_size="7%", cbar_pad="2%")
>>> for ax in grid:
...     ax.axis('off')
>>> top, middle, bottom = grid
>>> colorbar_ticks = [0, 10, 20]

The top image contains the original binary image.

>>> binary_image = top.imshow(image, cmap='gray')
>>> cbar_binary_image = top.cax.colorbar(binary_image)
>>> cbar_binary_image.set_ticks([0, 1])
>>> top.set_title("Binary image: foreground in white")

The middle image contains the distance transform using the ``taxicab``
metric.

>>> distance_taxicab = distance_transform_cdt(image, metric="taxicab")
>>> taxicab_transform = middle.imshow(distance_taxicab, cmap='gray')
>>> cbar_taxicab = middle.cax.colorbar(taxicab_transform)
>>> cbar_taxicab.set_ticks(colorbar_ticks)
>>> middle.set_title("Taxicab metric")

The bottom image contains the distance transform using the ``chessboard``
metric.

>>> distance_chessboard = distance_transform_cdt(image,
...                                              metric="chessboard")
>>> chessboard_transform = bottom.imshow(distance_chessboard, cmap='gray')
>>> cbar_chessboard = bottom.cax.colorbar(chessboard_transform)
>>> cbar_chessboard.set_ticks(colorbar_ticks)
>>> bottom.set_title("Chessboard metric")
>>> plt.tight_layout()
>>> plt.show()
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__morphology_8py_source_l02104}{2104}} of file \mbox{\hyperlink{__morphology_8py_source}{\+\_\+morphology.\+py}}.



References \mbox{\hyperlink{__morphology_8py_source_l02503}{\+\_\+distance\+\_\+tranform\+\_\+arg\+\_\+check()}}, and \mbox{\hyperlink{__morphology_8py_source_l00124}{generate\+\_\+binary\+\_\+structure()}}.

\Hypertarget{namespacescipy_1_1ndimage_1_1__morphology_ae4b7e191882073a63602a80343313ea3}\index{scipy.ndimage.\_morphology@{scipy.ndimage.\_morphology}!distance\_transform\_edt@{distance\_transform\_edt}}
\index{distance\_transform\_edt@{distance\_transform\_edt}!scipy.ndimage.\_morphology@{scipy.ndimage.\_morphology}}
\doxysubsubsection{\texorpdfstring{distance\_transform\_edt()}{distance\_transform\_edt()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1ndimage_1_1__morphology_ae4b7e191882073a63602a80343313ea3} 
scipy.\+ndimage.\+\_\+morphology.\+distance\+\_\+transform\+\_\+edt (\begin{DoxyParamCaption}\item[{}]{input}{, }\item[{}]{sampling}{ = {\ttfamily None}, }\item[{}]{return\+\_\+distances}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}, }\item[{}]{return\+\_\+indices}{ = {\ttfamily False}, }\item[{}]{distances}{ = {\ttfamily None}, }\item[{}]{indices}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Exact Euclidean distance transform.

This function calculates the distance transform of the `input`, by
replacing each foreground (non-zero) element, with its
shortest distance to the background (any zero-valued element).

In addition to the distance transform, the feature transform can
be calculated. In this case the index of the closest background
element to each foreground element is returned in a separate array.

Parameters
----------
input : array_like
    Input data to transform. Can be any type but will be converted
    into binary: 1 wherever input equates to True, 0 elsewhere.
sampling : float, or sequence of float, optional
    Spacing of elements along each dimension. If a sequence, must be of
    length equal to the input rank; if a single number, this is used for
    all axes. If not specified, a grid spacing of unity is implied.
return_distances : bool, optional
    Whether to calculate the distance transform.
    Default is True.
return_indices : bool, optional
    Whether to calculate the feature transform.
    Default is False.
distances : float64 ndarray, optional
    An output array to store the calculated distance transform, instead of
    returning it.
    `return_distances` must be True.
    It must be the same shape as `input`.
indices : int32 ndarray, optional
    An output array to store the calculated feature transform, instead of
    returning it.
    `return_indicies` must be True.
    Its shape must be `(input.ndim,) + input.shape`.

Returns
-------
distances : float64 ndarray, optional
    The calculated distance transform. Returned only when
    `return_distances` is True and `distances` is not supplied.
    It will have the same shape as the input array.
indices : int32 ndarray, optional
    The calculated feature transform. It has an input-shaped array for each
    dimension of the input. See example below.
    Returned only when `return_indices` is True and `indices` is not
    supplied.

Notes
-----
The Euclidean distance transform gives values of the Euclidean
distance::

                n
  y_i = sqrt(sum (x[i]-b[i])**2)
                i

where b[i] is the background point (value 0) with the smallest
Euclidean distance to input points x[i], and n is the
number of dimensions.

Examples
--------
>>> from scipy import ndimage
>>> import numpy as np
>>> a = np.array(([0,1,1,1,1],
...               [0,0,1,1,1],
...               [0,1,1,1,1],
...               [0,1,1,1,0],
...               [0,1,1,0,0]))
>>> ndimage.distance_transform_edt(a)
array([[ 0.    ,  1.    ,  1.4142,  2.2361,  3.    ],
       [ 0.    ,  0.    ,  1.    ,  2.    ,  2.    ],
       [ 0.    ,  1.    ,  1.4142,  1.4142,  1.    ],
       [ 0.    ,  1.    ,  1.4142,  1.    ,  0.    ],
       [ 0.    ,  1.    ,  1.    ,  0.    ,  0.    ]])

With a sampling of 2 units along x, 1 along y:

>>> ndimage.distance_transform_edt(a, sampling=[2,1])
array([[ 0.    ,  1.    ,  2.    ,  2.8284,  3.6056],
       [ 0.    ,  0.    ,  1.    ,  2.    ,  3.    ],
       [ 0.    ,  1.    ,  2.    ,  2.2361,  2.    ],
       [ 0.    ,  1.    ,  2.    ,  1.    ,  0.    ],
       [ 0.    ,  1.    ,  1.    ,  0.    ,  0.    ]])

Asking for indices as well:

>>> edt, inds = ndimage.distance_transform_edt(a, return_indices=True)
>>> inds
array([[[0, 0, 1, 1, 3],
        [1, 1, 1, 1, 3],
        [2, 2, 1, 3, 3],
        [3, 3, 4, 4, 3],
        [4, 4, 4, 4, 4]],
       [[0, 0, 1, 1, 4],
        [0, 1, 1, 1, 4],
        [0, 0, 1, 4, 4],
        [0, 0, 3, 3, 4],
        [0, 0, 3, 3, 4]]])

With arrays provided for inplace outputs:

>>> indices = np.zeros(((np.ndim(a),) + a.shape), dtype=np.int32)
>>> ndimage.distance_transform_edt(a, return_indices=True, indices=indices)
array([[ 0.    ,  1.    ,  1.4142,  2.2361,  3.    ],
       [ 0.    ,  0.    ,  1.    ,  2.    ,  2.    ],
       [ 0.    ,  1.    ,  1.4142,  1.4142,  1.    ],
       [ 0.    ,  1.    ,  1.4142,  1.    ,  0.    ],
       [ 0.    ,  1.    ,  1.    ,  0.    ,  0.    ]])
>>> indices
array([[[0, 0, 1, 1, 3],
        [1, 1, 1, 1, 3],
        [2, 2, 1, 3, 3],
        [3, 3, 4, 4, 3],
        [4, 4, 4, 4, 4]],
       [[0, 0, 1, 1, 4],
        [0, 1, 1, 1, 4],
        [0, 0, 1, 4, 4],
        [0, 0, 3, 3, 4],
        [0, 0, 3, 3, 4]]])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__morphology_8py_source_l02318}{2318}} of file \mbox{\hyperlink{__morphology_8py_source}{\+\_\+morphology.\+py}}.



References \mbox{\hyperlink{__morphology_8py_source_l02503}{\+\_\+distance\+\_\+tranform\+\_\+arg\+\_\+check()}}.

\Hypertarget{namespacescipy_1_1ndimage_1_1__morphology_ac4cec95e8f208f65adb2a23ae10daccb}\index{scipy.ndimage.\_morphology@{scipy.ndimage.\_morphology}!generate\_binary\_structure@{generate\_binary\_structure}}
\index{generate\_binary\_structure@{generate\_binary\_structure}!scipy.ndimage.\_morphology@{scipy.ndimage.\_morphology}}
\doxysubsubsection{\texorpdfstring{generate\_binary\_structure()}{generate\_binary\_structure()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1ndimage_1_1__morphology_ac4cec95e8f208f65adb2a23ae10daccb} 
scipy.\+ndimage.\+\_\+morphology.\+generate\+\_\+binary\+\_\+structure (\begin{DoxyParamCaption}\item[{}]{rank}{, }\item[{}]{connectivity}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Generate a binary structure for binary morphological operations.

Parameters
----------
rank : int
     Number of dimensions of the array to which the structuring element
     will be applied, as returned by `np.ndim`.
connectivity : int
     `connectivity` determines which elements of the output array belong
     to the structure, i.e., are considered as neighbors of the central
     element. Elements up to a squared distance of `connectivity` from
     the center are considered neighbors. `connectivity` may range from 1
     (no diagonal elements are neighbors) to `rank` (all elements are
     neighbors).

Returns
-------
output : ndarray of bools
     Structuring element which may be used for binary morphological
     operations, with `rank` dimensions and all dimensions equal to 3.

See also
--------
iterate_structure, binary_dilation, binary_erosion

Notes
-----
`generate_binary_structure` can only create structuring elements with
dimensions equal to 3, i.e., minimal dimensions. For larger structuring
elements, that are useful e.g., for eroding large objects, one may either
use `iterate_structure`, or create directly custom arrays with
numpy functions such as `numpy.ones`.

Examples
--------
>>> from scipy import ndimage
>>> import numpy as np
>>> struct = ndimage.generate_binary_structure(2, 1)
>>> struct
array([[False,  True, False],
       [ True,  True,  True],
       [False,  True, False]], dtype=bool)
>>> a = np.zeros((5,5))
>>> a[2, 2] = 1
>>> a
array([[ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  1.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.]])
>>> b = ndimage.binary_dilation(a, structure=struct).astype(a.dtype)
>>> b
array([[ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  1.,  0.,  0.],
       [ 0.,  1.,  1.,  1.,  0.],
       [ 0.,  0.,  1.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.]])
>>> ndimage.binary_dilation(b, structure=struct).astype(a.dtype)
array([[ 0.,  0.,  1.,  0.,  0.],
       [ 0.,  1.,  1.,  1.,  0.],
       [ 1.,  1.,  1.,  1.,  1.],
       [ 0.,  1.,  1.,  1.,  0.],
       [ 0.,  0.,  1.,  0.,  0.]])
>>> struct = ndimage.generate_binary_structure(2, 2)
>>> struct
array([[ True,  True,  True],
       [ True,  True,  True],
       [ True,  True,  True]], dtype=bool)
>>> struct = ndimage.generate_binary_structure(3, 1)
>>> struct # no diagonal elements
array([[[False, False, False],
        [False,  True, False],
        [False, False, False]],
       [[False,  True, False],
        [ True,  True,  True],
        [False,  True, False]],
       [[False, False, False],
        [False,  True, False],
        [False, False, False]]], dtype=bool)
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__morphology_8py_source_l00124}{124}} of file \mbox{\hyperlink{__morphology_8py_source}{\+\_\+morphology.\+py}}.



References \mbox{\hyperlink{__morphology_8py_source_l00124}{generate\+\_\+binary\+\_\+structure()}}.



Referenced by \mbox{\hyperlink{__morphology_8py_source_l00649}{binary\+\_\+closing()}}, \mbox{\hyperlink{__morphology_8py_source_l00393}{binary\+\_\+dilation()}}, \mbox{\hyperlink{__morphology_8py_source_l00796}{binary\+\_\+hit\+\_\+or\+\_\+miss()}}, \mbox{\hyperlink{__morphology_8py_source_l00525}{binary\+\_\+opening()}}, \mbox{\hyperlink{__morphology_8py_source_l01870}{distance\+\_\+transform\+\_\+bf()}}, \mbox{\hyperlink{__morphology_8py_source_l02105}{distance\+\_\+transform\+\_\+cdt()}}, and \mbox{\hyperlink{__morphology_8py_source_l00124}{generate\+\_\+binary\+\_\+structure()}}.

\Hypertarget{namespacescipy_1_1ndimage_1_1__morphology_ad138cae4d72e92ba608d5ba082f7865a}\index{scipy.ndimage.\_morphology@{scipy.ndimage.\_morphology}!grey\_closing@{grey\_closing}}
\index{grey\_closing@{grey\_closing}!scipy.ndimage.\_morphology@{scipy.ndimage.\_morphology}}
\doxysubsubsection{\texorpdfstring{grey\_closing()}{grey\_closing()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1ndimage_1_1__morphology_ad138cae4d72e92ba608d5ba082f7865a} 
scipy.\+ndimage.\+\_\+morphology.\+grey\+\_\+closing (\begin{DoxyParamCaption}\item[{}]{input}{, }\item[{}]{size}{ = {\ttfamily None}, }\item[{}]{footprint}{ = {\ttfamily None}, }\item[{}]{structure}{ = {\ttfamily None}, }\item[{}]{output}{ = {\ttfamily None}, }\item[{}]{mode}{ = {\ttfamily "{}reflect"{}}, }\item[{}]{cval}{ = {\ttfamily 0.0}, }\item[{}]{origin}{ = {\ttfamily 0}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Multidimensional grayscale closing.

A grayscale closing consists in the succession of a grayscale dilation,
and a grayscale erosion.

Parameters
----------
input : array_like
    Array over which the grayscale closing is to be computed.
size : tuple of ints
    Shape of a flat and full structuring element used for the grayscale
    closing. Optional if `footprint` or `structure` is provided.
footprint : array of ints, optional
    Positions of non-infinite elements of a flat structuring element
    used for the grayscale closing.
structure : array of ints, optional
    Structuring element used for the grayscale closing. `structure`
    may be a non-flat structuring element.
output : array, optional
    An array used for storing the output of the closing may be provided.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
    The `mode` parameter determines how the array borders are
    handled, where `cval` is the value when mode is equal to
    'constant'. Default is 'reflect'
cval : scalar, optional
    Value to fill past edges of input if `mode` is 'constant'. Default
    is 0.0.
origin : scalar, optional
    The `origin` parameter controls the placement of the filter.
    Default 0

Returns
-------
grey_closing : ndarray
    Result of the grayscale closing of `input` with `structure`.

See also
--------
binary_closing, grey_dilation, grey_erosion, grey_opening,
generate_binary_structure

Notes
-----
The action of a grayscale closing with a flat structuring element amounts
to smoothen deep local minima, whereas binary closing fills small holes.

References
----------
.. [1] https://en.wikipedia.org/wiki/Mathematical_morphology

Examples
--------
>>> from scipy import ndimage
>>> import numpy as np
>>> a = np.arange(36).reshape((6,6))
>>> a[3,3] = 0
>>> a
array([[ 0,  1,  2,  3,  4,  5],
       [ 6,  7,  8,  9, 10, 11],
       [12, 13, 14, 15, 16, 17],
       [18, 19, 20,  0, 22, 23],
       [24, 25, 26, 27, 28, 29],
       [30, 31, 32, 33, 34, 35]])
>>> ndimage.grey_closing(a, size=(3,3))
array([[ 7,  7,  8,  9, 10, 11],
       [ 7,  7,  8,  9, 10, 11],
       [13, 13, 14, 15, 16, 17],
       [19, 19, 20, 20, 22, 23],
       [25, 25, 26, 27, 28, 29],
       [31, 31, 32, 33, 34, 35]])
>>> # Note that the local minimum a[3,3] has disappeared
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__morphology_8py_source_l01466}{1466}} of file \mbox{\hyperlink{__morphology_8py_source}{\+\_\+morphology.\+py}}.



References \mbox{\hyperlink{__morphology_8py_source_l01234}{grey\+\_\+dilation()}}, and \mbox{\hyperlink{__morphology_8py_source_l01123}{grey\+\_\+erosion()}}.

\Hypertarget{namespacescipy_1_1ndimage_1_1__morphology_a2f19f05960e0438e963d6cb1bbf53765}\index{scipy.ndimage.\_morphology@{scipy.ndimage.\_morphology}!grey\_dilation@{grey\_dilation}}
\index{grey\_dilation@{grey\_dilation}!scipy.ndimage.\_morphology@{scipy.ndimage.\_morphology}}
\doxysubsubsection{\texorpdfstring{grey\_dilation()}{grey\_dilation()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1ndimage_1_1__morphology_a2f19f05960e0438e963d6cb1bbf53765} 
scipy.\+ndimage.\+\_\+morphology.\+grey\+\_\+dilation (\begin{DoxyParamCaption}\item[{}]{input}{, }\item[{}]{size}{ = {\ttfamily None}, }\item[{}]{footprint}{ = {\ttfamily None}, }\item[{}]{structure}{ = {\ttfamily None}, }\item[{}]{output}{ = {\ttfamily None}, }\item[{}]{mode}{ = {\ttfamily "{}reflect"{}}, }\item[{}]{cval}{ = {\ttfamily 0.0}, }\item[{}]{origin}{ = {\ttfamily 0}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Calculate a greyscale dilation, using either a structuring element,
or a footprint corresponding to a flat structuring element.

Grayscale dilation is a mathematical morphology operation. For the
simple case of a full and flat structuring element, it can be viewed
as a maximum filter over a sliding window.

Parameters
----------
input : array_like
    Array over which the grayscale dilation is to be computed.
size : tuple of ints
    Shape of a flat and full structuring element used for the grayscale
    dilation. Optional if `footprint` or `structure` is provided.
footprint : array of ints, optional
    Positions of non-infinite elements of a flat structuring element
    used for the grayscale dilation. Non-zero values give the set of
    neighbors of the center over which the maximum is chosen.
structure : array of ints, optional
    Structuring element used for the grayscale dilation. `structure`
    may be a non-flat structuring element.
output : array, optional
    An array used for storing the output of the dilation may be provided.
mode : {'reflect','constant','nearest','mirror', 'wrap'}, optional
    The `mode` parameter determines how the array borders are
    handled, where `cval` is the value when mode is equal to
    'constant'. Default is 'reflect'
cval : scalar, optional
    Value to fill past edges of input if `mode` is 'constant'. Default
    is 0.0.
origin : scalar, optional
    The `origin` parameter controls the placement of the filter.
    Default 0

Returns
-------
grey_dilation : ndarray
    Grayscale dilation of `input`.

See also
--------
binary_dilation, grey_erosion, grey_closing, grey_opening
generate_binary_structure, maximum_filter

Notes
-----
The grayscale dilation of an image input by a structuring element s defined
over a domain E is given by:

(input+s)(x) = max {input(y) + s(x-y), for y in E}

In particular, for structuring elements defined as
s(y) = 0 for y in E, the grayscale dilation computes the maximum of the
input image inside a sliding window defined by E.

Grayscale dilation [1]_ is a *mathematical morphology* operation [2]_.

References
----------
.. [1] https://en.wikipedia.org/wiki/Dilation_%28morphology%29
.. [2] https://en.wikipedia.org/wiki/Mathematical_morphology

Examples
--------
>>> from scipy import ndimage
>>> import numpy as np
>>> a = np.zeros((7,7), dtype=int)
>>> a[2:5, 2:5] = 1
>>> a[4,4] = 2; a[2,3] = 3
>>> a
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 1, 3, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 2, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0]])
>>> ndimage.grey_dilation(a, size=(3,3))
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 1, 3, 3, 3, 1, 0],
       [0, 1, 3, 3, 3, 1, 0],
       [0, 1, 3, 3, 3, 2, 0],
       [0, 1, 1, 2, 2, 2, 0],
       [0, 1, 1, 2, 2, 2, 0],
       [0, 0, 0, 0, 0, 0, 0]])
>>> ndimage.grey_dilation(a, footprint=np.ones((3,3)))
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 1, 3, 3, 3, 1, 0],
       [0, 1, 3, 3, 3, 1, 0],
       [0, 1, 3, 3, 3, 2, 0],
       [0, 1, 1, 2, 2, 2, 0],
       [0, 1, 1, 2, 2, 2, 0],
       [0, 0, 0, 0, 0, 0, 0]])
>>> s = ndimage.generate_binary_structure(2,1)
>>> s
array([[False,  True, False],
       [ True,  True,  True],
       [False,  True, False]], dtype=bool)
>>> ndimage.grey_dilation(a, footprint=s)
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 0, 1, 3, 1, 0, 0],
       [0, 1, 3, 3, 3, 1, 0],
       [0, 1, 1, 3, 2, 1, 0],
       [0, 1, 1, 2, 2, 2, 0],
       [0, 0, 1, 1, 2, 0, 0],
       [0, 0, 0, 0, 0, 0, 0]])
>>> ndimage.grey_dilation(a, size=(3,3), structure=np.ones((3,3)))
array([[1, 1, 1, 1, 1, 1, 1],
       [1, 2, 4, 4, 4, 2, 1],
       [1, 2, 4, 4, 4, 2, 1],
       [1, 2, 4, 4, 4, 3, 1],
       [1, 2, 2, 3, 3, 3, 1],
       [1, 2, 2, 3, 3, 3, 1],
       [1, 1, 1, 1, 1, 1, 1]])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__morphology_8py_source_l01233}{1233}} of file \mbox{\hyperlink{__morphology_8py_source}{\+\_\+morphology.\+py}}.



Referenced by \mbox{\hyperlink{__morphology_8py_source_l01793}{black\+\_\+tophat()}}, \mbox{\hyperlink{__morphology_8py_source_l01467}{grey\+\_\+closing()}}, \mbox{\hyperlink{__morphology_8py_source_l01383}{grey\+\_\+opening()}}, \mbox{\hyperlink{__morphology_8py_source_l01551}{morphological\+\_\+gradient()}}, \mbox{\hyperlink{__morphology_8py_source_l01666}{morphological\+\_\+laplace()}}, and \mbox{\hyperlink{__morphology_8py_source_l01716}{white\+\_\+tophat()}}.

\Hypertarget{namespacescipy_1_1ndimage_1_1__morphology_adea52fca905158ab16412ce44ef86515}\index{scipy.ndimage.\_morphology@{scipy.ndimage.\_morphology}!grey\_erosion@{grey\_erosion}}
\index{grey\_erosion@{grey\_erosion}!scipy.ndimage.\_morphology@{scipy.ndimage.\_morphology}}
\doxysubsubsection{\texorpdfstring{grey\_erosion()}{grey\_erosion()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1ndimage_1_1__morphology_adea52fca905158ab16412ce44ef86515} 
scipy.\+ndimage.\+\_\+morphology.\+grey\+\_\+erosion (\begin{DoxyParamCaption}\item[{}]{input}{, }\item[{}]{size}{ = {\ttfamily None}, }\item[{}]{footprint}{ = {\ttfamily None}, }\item[{}]{structure}{ = {\ttfamily None}, }\item[{}]{output}{ = {\ttfamily None}, }\item[{}]{mode}{ = {\ttfamily "{}reflect"{}}, }\item[{}]{cval}{ = {\ttfamily 0.0}, }\item[{}]{origin}{ = {\ttfamily 0}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Calculate a greyscale erosion, using either a structuring element,
or a footprint corresponding to a flat structuring element.

Grayscale erosion is a mathematical morphology operation. For the
simple case of a full and flat structuring element, it can be viewed
as a minimum filter over a sliding window.

Parameters
----------
input : array_like
    Array over which the grayscale erosion is to be computed.
size : tuple of ints
    Shape of a flat and full structuring element used for the grayscale
    erosion. Optional if `footprint` or `structure` is provided.
footprint : array of ints, optional
    Positions of non-infinite elements of a flat structuring element
    used for the grayscale erosion. Non-zero values give the set of
    neighbors of the center over which the minimum is chosen.
structure : array of ints, optional
    Structuring element used for the grayscale erosion. `structure`
    may be a non-flat structuring element.
output : array, optional
    An array used for storing the output of the erosion may be provided.
mode : {'reflect','constant','nearest','mirror', 'wrap'}, optional
    The `mode` parameter determines how the array borders are
    handled, where `cval` is the value when mode is equal to
    'constant'. Default is 'reflect'
cval : scalar, optional
    Value to fill past edges of input if `mode` is 'constant'. Default
    is 0.0.
origin : scalar, optional
    The `origin` parameter controls the placement of the filter.
    Default 0

Returns
-------
output : ndarray
    Grayscale erosion of `input`.

See also
--------
binary_erosion, grey_dilation, grey_opening, grey_closing
generate_binary_structure, minimum_filter

Notes
-----
The grayscale erosion of an image input by a structuring element s defined
over a domain E is given by:

(input+s)(x) = min {input(y) - s(x-y), for y in E}

In particular, for structuring elements defined as
s(y) = 0 for y in E, the grayscale erosion computes the minimum of the
input image inside a sliding window defined by E.

Grayscale erosion [1]_ is a *mathematical morphology* operation [2]_.

References
----------
.. [1] https://en.wikipedia.org/wiki/Erosion_%28morphology%29
.. [2] https://en.wikipedia.org/wiki/Mathematical_morphology

Examples
--------
>>> from scipy import ndimage
>>> import numpy as np
>>> a = np.zeros((7,7), dtype=int)
>>> a[1:6, 1:6] = 3
>>> a[4,4] = 2; a[2,3] = 1
>>> a
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 3, 3, 3, 3, 3, 0],
       [0, 3, 3, 1, 3, 3, 0],
       [0, 3, 3, 3, 3, 3, 0],
       [0, 3, 3, 3, 2, 3, 0],
       [0, 3, 3, 3, 3, 3, 0],
       [0, 0, 0, 0, 0, 0, 0]])
>>> ndimage.grey_erosion(a, size=(3,3))
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 3, 2, 2, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0]])
>>> footprint = ndimage.generate_binary_structure(2, 1)
>>> footprint
array([[False,  True, False],
       [ True,  True,  True],
       [False,  True, False]], dtype=bool)
>>> # Diagonally-connected elements are not considered neighbors
>>> ndimage.grey_erosion(a, size=(3,3), footprint=footprint)
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 3, 1, 2, 0, 0],
       [0, 0, 3, 2, 2, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0]])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__morphology_8py_source_l01122}{1122}} of file \mbox{\hyperlink{__morphology_8py_source}{\+\_\+morphology.\+py}}.



Referenced by \mbox{\hyperlink{__morphology_8py_source_l01793}{black\+\_\+tophat()}}, \mbox{\hyperlink{__morphology_8py_source_l01467}{grey\+\_\+closing()}}, \mbox{\hyperlink{__morphology_8py_source_l01383}{grey\+\_\+opening()}}, \mbox{\hyperlink{__morphology_8py_source_l01551}{morphological\+\_\+gradient()}}, \mbox{\hyperlink{__morphology_8py_source_l01666}{morphological\+\_\+laplace()}}, and \mbox{\hyperlink{__morphology_8py_source_l01716}{white\+\_\+tophat()}}.

\Hypertarget{namespacescipy_1_1ndimage_1_1__morphology_a22d6712a86de6eb485961fc8726fcc52}\index{scipy.ndimage.\_morphology@{scipy.ndimage.\_morphology}!grey\_opening@{grey\_opening}}
\index{grey\_opening@{grey\_opening}!scipy.ndimage.\_morphology@{scipy.ndimage.\_morphology}}
\doxysubsubsection{\texorpdfstring{grey\_opening()}{grey\_opening()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1ndimage_1_1__morphology_a22d6712a86de6eb485961fc8726fcc52} 
scipy.\+ndimage.\+\_\+morphology.\+grey\+\_\+opening (\begin{DoxyParamCaption}\item[{}]{input}{, }\item[{}]{size}{ = {\ttfamily None}, }\item[{}]{footprint}{ = {\ttfamily None}, }\item[{}]{structure}{ = {\ttfamily None}, }\item[{}]{output}{ = {\ttfamily None}, }\item[{}]{mode}{ = {\ttfamily "{}reflect"{}}, }\item[{}]{cval}{ = {\ttfamily 0.0}, }\item[{}]{origin}{ = {\ttfamily 0}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Multidimensional grayscale opening.

A grayscale opening consists in the succession of a grayscale erosion,
and a grayscale dilation.

Parameters
----------
input : array_like
    Array over which the grayscale opening is to be computed.
size : tuple of ints
    Shape of a flat and full structuring element used for the grayscale
    opening. Optional if `footprint` or `structure` is provided.
footprint : array of ints, optional
    Positions of non-infinite elements of a flat structuring element
    used for the grayscale opening.
structure : array of ints, optional
    Structuring element used for the grayscale opening. `structure`
    may be a non-flat structuring element.
output : array, optional
    An array used for storing the output of the opening may be provided.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
    The `mode` parameter determines how the array borders are
    handled, where `cval` is the value when mode is equal to
    'constant'. Default is 'reflect'
cval : scalar, optional
    Value to fill past edges of input if `mode` is 'constant'. Default
    is 0.0.
origin : scalar, optional
    The `origin` parameter controls the placement of the filter.
    Default 0

Returns
-------
grey_opening : ndarray
    Result of the grayscale opening of `input` with `structure`.

See also
--------
binary_opening, grey_dilation, grey_erosion, grey_closing
generate_binary_structure

Notes
-----
The action of a grayscale opening with a flat structuring element amounts
to smoothen high local maxima, whereas binary opening erases small objects.

References
----------
.. [1] https://en.wikipedia.org/wiki/Mathematical_morphology

Examples
--------
>>> from scipy import ndimage
>>> import numpy as np
>>> a = np.arange(36).reshape((6,6))
>>> a[3, 3] = 50
>>> a
array([[ 0,  1,  2,  3,  4,  5],
       [ 6,  7,  8,  9, 10, 11],
       [12, 13, 14, 15, 16, 17],
       [18, 19, 20, 50, 22, 23],
       [24, 25, 26, 27, 28, 29],
       [30, 31, 32, 33, 34, 35]])
>>> ndimage.grey_opening(a, size=(3,3))
array([[ 0,  1,  2,  3,  4,  4],
       [ 6,  7,  8,  9, 10, 10],
       [12, 13, 14, 15, 16, 16],
       [18, 19, 20, 22, 22, 22],
       [24, 25, 26, 27, 28, 28],
       [24, 25, 26, 27, 28, 28]])
>>> # Note that the local maximum a[3,3] has disappeared
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__morphology_8py_source_l01382}{1382}} of file \mbox{\hyperlink{__morphology_8py_source}{\+\_\+morphology.\+py}}.



References \mbox{\hyperlink{__morphology_8py_source_l01234}{grey\+\_\+dilation()}}, and \mbox{\hyperlink{__morphology_8py_source_l01123}{grey\+\_\+erosion()}}.

\Hypertarget{namespacescipy_1_1ndimage_1_1__morphology_a9dd391da5464b292a7b7880e7df2ec8c}\index{scipy.ndimage.\_morphology@{scipy.ndimage.\_morphology}!iterate\_structure@{iterate\_structure}}
\index{iterate\_structure@{iterate\_structure}!scipy.ndimage.\_morphology@{scipy.ndimage.\_morphology}}
\doxysubsubsection{\texorpdfstring{iterate\_structure()}{iterate\_structure()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1ndimage_1_1__morphology_a9dd391da5464b292a7b7880e7df2ec8c} 
scipy.\+ndimage.\+\_\+morphology.\+iterate\+\_\+structure (\begin{DoxyParamCaption}\item[{}]{structure}{, }\item[{}]{iterations}{, }\item[{}]{origin}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Iterate a structure by dilating it with itself.

Parameters
----------
structure : array_like
   Structuring element (an array of bools, for example), to be dilated with
   itself.
iterations : int
   number of dilations performed on the structure with itself
origin : optional
    If origin is None, only the iterated structure is returned. If
    not, a tuple of the iterated structure and the modified origin is
    returned.

Returns
-------
iterate_structure : ndarray of bools
    A new structuring element obtained by dilating `structure`
    (`iterations` - 1) times with itself.

See also
--------
generate_binary_structure

Examples
--------
>>> from scipy import ndimage
>>> struct = ndimage.generate_binary_structure(2, 1)
>>> struct.astype(int)
array([[0, 1, 0],
       [1, 1, 1],
       [0, 1, 0]])
>>> ndimage.iterate_structure(struct, 2).astype(int)
array([[0, 0, 1, 0, 0],
       [0, 1, 1, 1, 0],
       [1, 1, 1, 1, 1],
       [0, 1, 1, 1, 0],
       [0, 0, 1, 0, 0]])
>>> ndimage.iterate_structure(struct, 3).astype(int)
array([[0, 0, 0, 1, 0, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 1, 1, 1, 1, 1, 0],
       [1, 1, 1, 1, 1, 1, 1],
       [0, 1, 1, 1, 1, 1, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 0, 1, 0, 0, 0]])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__morphology_8py_source_l00055}{55}} of file \mbox{\hyperlink{__morphology_8py_source}{\+\_\+morphology.\+py}}.



References \mbox{\hyperlink{__morphology_8py_source_l00393}{binary\+\_\+dilation()}}.

\Hypertarget{namespacescipy_1_1ndimage_1_1__morphology_a2adc01fa7bd196f6b4e192bea82c7766}\index{scipy.ndimage.\_morphology@{scipy.ndimage.\_morphology}!morphological\_gradient@{morphological\_gradient}}
\index{morphological\_gradient@{morphological\_gradient}!scipy.ndimage.\_morphology@{scipy.ndimage.\_morphology}}
\doxysubsubsection{\texorpdfstring{morphological\_gradient()}{morphological\_gradient()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1ndimage_1_1__morphology_a2adc01fa7bd196f6b4e192bea82c7766} 
scipy.\+ndimage.\+\_\+morphology.\+morphological\+\_\+gradient (\begin{DoxyParamCaption}\item[{}]{input}{, }\item[{}]{size}{ = {\ttfamily None}, }\item[{}]{footprint}{ = {\ttfamily None}, }\item[{}]{structure}{ = {\ttfamily None}, }\item[{}]{output}{ = {\ttfamily None}, }\item[{}]{mode}{ = {\ttfamily "{}reflect"{}}, }\item[{}]{cval}{ = {\ttfamily 0.0}, }\item[{}]{origin}{ = {\ttfamily 0}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Multidimensional morphological gradient.

The morphological gradient is calculated as the difference between a
dilation and an erosion of the input with a given structuring element.

Parameters
----------
input : array_like
    Array over which to compute the morphlogical gradient.
size : tuple of ints
    Shape of a flat and full structuring element used for the mathematical
    morphology operations. Optional if `footprint` or `structure` is
    provided. A larger `size` yields a more blurred gradient.
footprint : array of ints, optional
    Positions of non-infinite elements of a flat structuring element
    used for the morphology operations. Larger footprints
    give a more blurred morphological gradient.
structure : array of ints, optional
    Structuring element used for the morphology operations.
    `structure` may be a non-flat structuring element.
output : array, optional
    An array used for storing the output of the morphological gradient
    may be provided.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
    The `mode` parameter determines how the array borders are
    handled, where `cval` is the value when mode is equal to
    'constant'. Default is 'reflect'
cval : scalar, optional
    Value to fill past edges of input if `mode` is 'constant'. Default
    is 0.0.
origin : scalar, optional
    The `origin` parameter controls the placement of the filter.
    Default 0

Returns
-------
morphological_gradient : ndarray
    Morphological gradient of `input`.

See also
--------
grey_dilation, grey_erosion, gaussian_gradient_magnitude

Notes
-----
For a flat structuring element, the morphological gradient
computed at a given point corresponds to the maximal difference
between elements of the input among the elements covered by the
structuring element centered on the point.

References
----------
.. [1] https://en.wikipedia.org/wiki/Mathematical_morphology

Examples
--------
>>> from scipy import ndimage
>>> import numpy as np
>>> a = np.zeros((7,7), dtype=int)
>>> a[2:5, 2:5] = 1
>>> ndimage.morphological_gradient(a, size=(3,3))
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 1, 1, 1, 1, 1, 0],
       [0, 1, 1, 1, 1, 1, 0],
       [0, 1, 1, 0, 1, 1, 0],
       [0, 1, 1, 1, 1, 1, 0],
       [0, 1, 1, 1, 1, 1, 0],
       [0, 0, 0, 0, 0, 0, 0]])
>>> # The morphological gradient is computed as the difference
>>> # between a dilation and an erosion
>>> ndimage.grey_dilation(a, size=(3,3)) -\\
...  ndimage.grey_erosion(a, size=(3,3))
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 1, 1, 1, 1, 1, 0],
       [0, 1, 1, 1, 1, 1, 0],
       [0, 1, 1, 0, 1, 1, 0],
       [0, 1, 1, 1, 1, 1, 0],
       [0, 1, 1, 1, 1, 1, 0],
       [0, 0, 0, 0, 0, 0, 0]])
>>> a = np.zeros((7,7), dtype=int)
>>> a[2:5, 2:5] = 1
>>> a[4,4] = 2; a[2,3] = 3
>>> a
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 1, 3, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 2, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0]])
>>> ndimage.morphological_gradient(a, size=(3,3))
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 1, 3, 3, 3, 1, 0],
       [0, 1, 3, 3, 3, 1, 0],
       [0, 1, 3, 2, 3, 2, 0],
       [0, 1, 1, 2, 2, 2, 0],
       [0, 1, 1, 2, 2, 2, 0],
       [0, 0, 0, 0, 0, 0, 0]])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__morphology_8py_source_l01550}{1550}} of file \mbox{\hyperlink{__morphology_8py_source}{\+\_\+morphology.\+py}}.



References \mbox{\hyperlink{__morphology_8py_source_l01234}{grey\+\_\+dilation()}}, and \mbox{\hyperlink{__morphology_8py_source_l01123}{grey\+\_\+erosion()}}.

\Hypertarget{namespacescipy_1_1ndimage_1_1__morphology_a0fff8ab8112efaac5e8468232ef05fc5}\index{scipy.ndimage.\_morphology@{scipy.ndimage.\_morphology}!morphological\_laplace@{morphological\_laplace}}
\index{morphological\_laplace@{morphological\_laplace}!scipy.ndimage.\_morphology@{scipy.ndimage.\_morphology}}
\doxysubsubsection{\texorpdfstring{morphological\_laplace()}{morphological\_laplace()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1ndimage_1_1__morphology_a0fff8ab8112efaac5e8468232ef05fc5} 
scipy.\+ndimage.\+\_\+morphology.\+morphological\+\_\+laplace (\begin{DoxyParamCaption}\item[{}]{input}{, }\item[{}]{size}{ = {\ttfamily None}, }\item[{}]{footprint}{ = {\ttfamily None}, }\item[{}]{structure}{ = {\ttfamily None}, }\item[{}]{output}{ = {\ttfamily None}, }\item[{}]{mode}{ = {\ttfamily "{}reflect"{}}, }\item[{}]{cval}{ = {\ttfamily 0.0}, }\item[{}]{origin}{ = {\ttfamily 0}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Multidimensional morphological laplace.

Parameters
----------
input : array_like
    Input.
size : int or sequence of ints, optional
    See `structure`.
footprint : bool or ndarray, optional
    See `structure`.
structure : structure, optional
    Either `size`, `footprint`, or the `structure` must be provided.
output : ndarray, optional
    An output array can optionally be provided.
mode : {'reflect','constant','nearest','mirror', 'wrap'}, optional
    The mode parameter determines how the array borders are handled.
    For 'constant' mode, values beyond borders are set to be `cval`.
    Default is 'reflect'.
cval : scalar, optional
    Value to fill past edges of input if mode is 'constant'.
    Default is 0.0
origin : origin, optional
    The origin parameter controls the placement of the filter.

Returns
-------
morphological_laplace : ndarray
    Output
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__morphology_8py_source_l01664}{1664}} of file \mbox{\hyperlink{__morphology_8py_source}{\+\_\+morphology.\+py}}.



References \mbox{\hyperlink{__morphology_8py_source_l01234}{grey\+\_\+dilation()}}, and \mbox{\hyperlink{__morphology_8py_source_l01123}{grey\+\_\+erosion()}}.

\Hypertarget{namespacescipy_1_1ndimage_1_1__morphology_afc672dbc002ca4d3046d93c4f97917df}\index{scipy.ndimage.\_morphology@{scipy.ndimage.\_morphology}!white\_tophat@{white\_tophat}}
\index{white\_tophat@{white\_tophat}!scipy.ndimage.\_morphology@{scipy.ndimage.\_morphology}}
\doxysubsubsection{\texorpdfstring{white\_tophat()}{white\_tophat()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1ndimage_1_1__morphology_afc672dbc002ca4d3046d93c4f97917df} 
scipy.\+ndimage.\+\_\+morphology.\+white\+\_\+tophat (\begin{DoxyParamCaption}\item[{}]{input}{, }\item[{}]{size}{ = {\ttfamily None}, }\item[{}]{footprint}{ = {\ttfamily None}, }\item[{}]{structure}{ = {\ttfamily None}, }\item[{}]{output}{ = {\ttfamily None}, }\item[{}]{mode}{ = {\ttfamily "{}reflect"{}}, }\item[{}]{cval}{ = {\ttfamily 0.0}, }\item[{}]{origin}{ = {\ttfamily 0}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Multidimensional white tophat filter.

Parameters
----------
input : array_like
    Input.
size : tuple of ints
    Shape of a flat and full structuring element used for the filter.
    Optional if `footprint` or `structure` is provided.
footprint : array of ints, optional
    Positions of elements of a flat structuring element
    used for the white tophat filter.
structure : array of ints, optional
    Structuring element used for the filter. `structure`
    may be a non-flat structuring element.
output : array, optional
    An array used for storing the output of the filter may be provided.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
    The `mode` parameter determines how the array borders are
    handled, where `cval` is the value when mode is equal to
    'constant'. Default is 'reflect'
cval : scalar, optional
    Value to fill past edges of input if `mode` is 'constant'.
    Default is 0.0.
origin : scalar, optional
    The `origin` parameter controls the placement of the filter.
    Default is 0.

Returns
-------
output : ndarray
    Result of the filter of `input` with `structure`.

Examples
--------
Subtract gray background from a bright peak.

>>> from scipy.ndimage import generate_binary_structure, white_tophat
>>> import numpy as np
>>> square = generate_binary_structure(rank=2, connectivity=3)
>>> bright_on_gray = np.array([[2, 3, 3, 3, 2],
...                            [3, 4, 5, 4, 3],
...                            [3, 5, 9, 5, 3],
...                            [3, 4, 5, 4, 3],
...                            [2, 3, 3, 3, 2]])
>>> white_tophat(input=bright_on_gray, structure=square)
array([[0, 0, 0, 0, 0],
       [0, 0, 1, 0, 0],
       [0, 1, 5, 1, 0],
       [0, 0, 1, 0, 0],
       [0, 0, 0, 0, 0]])

See also
--------
black_tophat
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__morphology_8py_source_l01715}{1715}} of file \mbox{\hyperlink{__morphology_8py_source}{\+\_\+morphology.\+py}}.



References \mbox{\hyperlink{__morphology_8py_source_l01234}{grey\+\_\+dilation()}}, and \mbox{\hyperlink{__morphology_8py_source_l01123}{grey\+\_\+erosion()}}.



\doxysubsection{Variable Documentation}
\Hypertarget{namespacescipy_1_1ndimage_1_1__morphology_aa5ecc78782b4c7152e2dfdce6e71cc73}\index{scipy.ndimage.\_morphology@{scipy.ndimage.\_morphology}!\_\_all\_\_@{\_\_all\_\_}}
\index{\_\_all\_\_@{\_\_all\_\_}!scipy.ndimage.\_morphology@{scipy.ndimage.\_morphology}}
\doxysubsubsection{\texorpdfstring{\_\_all\_\_}{\_\_all\_\_}}
{\footnotesize\ttfamily \label{namespacescipy_1_1ndimage_1_1__morphology_aa5ecc78782b4c7152e2dfdce6e71cc73} 
list scipy.\+ndimage.\+\_\+morphology.\+\_\+\+\_\+all\+\_\+\+\_\+\hspace{0.3cm}{\ttfamily [private]}}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ [\textcolor{stringliteral}{'iterate\_structure'},\ \textcolor{stringliteral}{'generate\_binary\_structure'},\ \textcolor{stringliteral}{'binary\_erosion'},}
\DoxyCodeLine{00002\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'binary\_dilation'},\ \textcolor{stringliteral}{'binary\_opening'},\ \textcolor{stringliteral}{'binary\_closing'},}
\DoxyCodeLine{00003\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'binary\_hit\_or\_miss'},\ \textcolor{stringliteral}{'binary\_propagation'},\ \textcolor{stringliteral}{'binary\_fill\_holes'},}
\DoxyCodeLine{00004\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'grey\_erosion'},\ \textcolor{stringliteral}{'grey\_dilation'},\ \textcolor{stringliteral}{'grey\_opening'},\ \textcolor{stringliteral}{'grey\_closing'},}
\DoxyCodeLine{00005\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'morphological\_gradient'},\ \textcolor{stringliteral}{'morphological\_laplace'},\ \textcolor{stringliteral}{'white\_tophat'},}
\DoxyCodeLine{00006\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'black\_tophat'},\ \textcolor{stringliteral}{'distance\_transform\_bf'},\ \textcolor{stringliteral}{'distance\_transform\_cdt'},}
\DoxyCodeLine{00007\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'distance\_transform\_edt'}]}

\end{DoxyCode}


Definition at line \mbox{\hyperlink{__morphology_8py_source_l00039}{39}} of file \mbox{\hyperlink{__morphology_8py_source}{\+\_\+morphology.\+py}}.

