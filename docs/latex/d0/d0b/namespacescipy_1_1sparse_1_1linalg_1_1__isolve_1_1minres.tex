\doxysection{scipy.\+sparse.\+linalg.\+\_\+isolve.\+minres Namespace Reference}
\hypertarget{namespacescipy_1_1sparse_1_1linalg_1_1__isolve_1_1minres}{}\label{namespacescipy_1_1sparse_1_1linalg_1_1__isolve_1_1minres}\index{scipy.sparse.linalg.\_isolve.minres@{scipy.sparse.linalg.\_isolve.minres}}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacescipy_1_1sparse_1_1linalg_1_1__isolve_1_1minres_a8b62c2ba1cf2568c9c34dfda3e83245f}{minres}} (A, b, x0=None, shift=0.\+0, tol=1e-\/5, maxiter=None, M=None, callback=None, show=False, check=False)
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
list \mbox{\hyperlink{namespacescipy_1_1sparse_1_1linalg_1_1__isolve_1_1minres_a3549395498fc91d3d05b28a9dd5c588c}{\+\_\+\+\_\+all\+\_\+\+\_\+}} = \mbox{[}\textquotesingle{}\mbox{\hyperlink{namespacescipy_1_1sparse_1_1linalg_1_1__isolve_1_1minres_a8b62c2ba1cf2568c9c34dfda3e83245f}{minres}}\textquotesingle{}\mbox{]}
\end{DoxyCompactItemize}


\doxysubsection{Function Documentation}
\Hypertarget{namespacescipy_1_1sparse_1_1linalg_1_1__isolve_1_1minres_a8b62c2ba1cf2568c9c34dfda3e83245f}\index{scipy.sparse.linalg.\_isolve.minres@{scipy.sparse.linalg.\_isolve.minres}!minres@{minres}}
\index{minres@{minres}!scipy.sparse.linalg.\_isolve.minres@{scipy.sparse.linalg.\_isolve.minres}}
\doxysubsubsection{\texorpdfstring{minres()}{minres()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1sparse_1_1linalg_1_1__isolve_1_1minres_a8b62c2ba1cf2568c9c34dfda3e83245f} 
scipy.\+sparse.\+linalg.\+\_\+isolve.\+minres.\+minres (\begin{DoxyParamCaption}\item[{}]{A}{, }\item[{}]{b}{, }\item[{}]{x0}{ = {\ttfamily None}, }\item[{}]{shift}{ = {\ttfamily 0.0}, }\item[{}]{tol}{ = {\ttfamily 1e-\/5}, }\item[{}]{maxiter}{ = {\ttfamily None}, }\item[{}]{M}{ = {\ttfamily None}, }\item[{}]{callback}{ = {\ttfamily None}, }\item[{}]{show}{ = {\ttfamily False}, }\item[{}]{check}{ = {\ttfamily False}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Use MINimum RESidual iteration to solve Ax=b

MINRES minimizes norm(Ax - b) for a real symmetric matrix A.  Unlike
the Conjugate Gradient method, A can be indefinite or singular.

If shift != 0 then the method solves (A - shift*I)x = b

Parameters
----------
A : {sparse matrix, ndarray, LinearOperator}
    The real symmetric N-by-N matrix of the linear system
    Alternatively, ``A`` can be a linear operator which can
    produce ``Ax`` using, e.g.,
    ``scipy.sparse.linalg.LinearOperator``.
b : ndarray
    Right hand side of the linear system. Has shape (N,) or (N,1).

Returns
-------
x : ndarray
    The converged solution.
info : integer
    Provides convergence information:
        0  : successful exit
        >0 : convergence to tolerance not achieved, number of iterations
        <0 : illegal input or breakdown

Other Parameters
----------------
x0 : ndarray
    Starting guess for the solution.
shift : float
    Value to apply to the system ``(A - shift * I)x = b``. Default is 0.
tol : float
    Tolerance to achieve. The algorithm terminates when the relative
    residual is below `tol`.
maxiter : integer
    Maximum number of iterations.  Iteration will stop after maxiter
    steps even if the specified tolerance has not been achieved.
M : {sparse matrix, ndarray, LinearOperator}
    Preconditioner for A.  The preconditioner should approximate the
    inverse of A.  Effective preconditioning dramatically improves the
    rate of convergence, which implies that fewer iterations are needed
    to reach a given error tolerance.
callback : function
    User-supplied function to call after each iteration.  It is called
    as callback(xk), where xk is the current solution vector.
show : bool
    If ``True``, print out a summary and metrics related to the solution
    during iterations. Default is ``False``.
check : bool
    If ``True``, run additional input validation to check that `A` and
    `M` (if specified) are symmetric. Default is ``False``.

Examples
--------
>>> import numpy as np
>>> from scipy.sparse import csc_matrix
>>> from scipy.sparse.linalg import minres
>>> A = csc_matrix([[3, 2, 0], [1, -1, 0], [0, 5, 1]], dtype=float)
>>> A = A + A.T
>>> b = np.array([2, 4, -1], dtype=float)
>>> x, exitCode = minres(A, b)
>>> print(exitCode)            # 0 indicates successful convergence
0
>>> np.allclose(A.dot(x), b)
True

References
----------
Solution of sparse indefinite systems of linear equations,
    C. C. Paige and M. A. Saunders (1975),
    SIAM J. Numer. Anal. 12(4), pp. 617-629.
    https://web.stanford.edu/group/SOL/software/minres/

This file is a translation of the following MATLAB implementation:
    https://web.stanford.edu/group/SOL/software/minres/minres-matlab.zip
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{minres_8py_source_l00010}{10}} of file \mbox{\hyperlink{minres_8py_source}{minres.\+py}}.



\doxysubsection{Variable Documentation}
\Hypertarget{namespacescipy_1_1sparse_1_1linalg_1_1__isolve_1_1minres_a3549395498fc91d3d05b28a9dd5c588c}\index{scipy.sparse.linalg.\_isolve.minres@{scipy.sparse.linalg.\_isolve.minres}!\_\_all\_\_@{\_\_all\_\_}}
\index{\_\_all\_\_@{\_\_all\_\_}!scipy.sparse.linalg.\_isolve.minres@{scipy.sparse.linalg.\_isolve.minres}}
\doxysubsubsection{\texorpdfstring{\_\_all\_\_}{\_\_all\_\_}}
{\footnotesize\ttfamily \label{namespacescipy_1_1sparse_1_1linalg_1_1__isolve_1_1minres_a3549395498fc91d3d05b28a9dd5c588c} 
list scipy.\+sparse.\+linalg.\+\_\+isolve.\+minres.\+\_\+\+\_\+all\+\_\+\+\_\+ = \mbox{[}\textquotesingle{}\mbox{\hyperlink{namespacescipy_1_1sparse_1_1linalg_1_1__isolve_1_1minres_a8b62c2ba1cf2568c9c34dfda3e83245f}{minres}}\textquotesingle{}\mbox{]}\hspace{0.3cm}{\ttfamily [private]}}



Definition at line \mbox{\hyperlink{minres_8py_source_l00007}{7}} of file \mbox{\hyperlink{minres_8py_source}{minres.\+py}}.

