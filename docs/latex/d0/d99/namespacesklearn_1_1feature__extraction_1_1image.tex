\doxysection{sklearn.\+feature\+\_\+extraction.\+image Namespace Reference}
\hypertarget{namespacesklearn_1_1feature__extraction_1_1image}{}\label{namespacesklearn_1_1feature__extraction_1_1image}\index{sklearn.feature\_extraction.image@{sklearn.feature\_extraction.image}}
\doxysubsubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classsklearn_1_1feature__extraction_1_1image_1_1PatchExtractor}{Patch\+Extractor}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacesklearn_1_1feature__extraction_1_1image_a479887780bec6b5a3f989f6c86610bab}{\+\_\+make\+\_\+edges\+\_\+3d}} (n\+\_\+x, n\+\_\+y, n\+\_\+z=1)
\begin{DoxyCompactList}\small\item\em From an image to a graph. \end{DoxyCompactList}\item 
\mbox{\hyperlink{namespacesklearn_1_1feature__extraction_1_1image_ae11d2551c8dba88d3f191ed86ac61b17}{\+\_\+compute\+\_\+gradient\+\_\+3d}} (edges, img)
\item 
\mbox{\hyperlink{namespacesklearn_1_1feature__extraction_1_1image_a0d491a5256901a07dccc48f98f2154a8}{\+\_\+mask\+\_\+edges\+\_\+weights}} (mask, edges, weights=None)
\item 
\mbox{\hyperlink{namespacesklearn_1_1feature__extraction_1_1image_a8572e8109d312aeaf844c76535aeea96}{\+\_\+to\+\_\+graph}} (n\+\_\+x, n\+\_\+y, n\+\_\+z, mask=None, img=None, return\+\_\+as=\mbox{\hyperlink{classscipy_1_1sparse_1_1__coo_1_1coo__matrix}{sparse.\+coo\+\_\+matrix}}, dtype=None)
\item 
\mbox{\hyperlink{namespacesklearn_1_1feature__extraction_1_1image_a52ce80cce071204ae080507781b1330f}{img\+\_\+to\+\_\+graph}} (img, \texorpdfstring{$\ast$}{*}, mask=None, return\+\_\+as=\mbox{\hyperlink{classscipy_1_1sparse_1_1__coo_1_1coo__matrix}{sparse.\+coo\+\_\+matrix}}, dtype=None)
\item 
\mbox{\hyperlink{namespacesklearn_1_1feature__extraction_1_1image_aede322fc75dc6655b2fd217da500cf88}{grid\+\_\+to\+\_\+graph}} (n\+\_\+x, n\+\_\+y, n\+\_\+z=1, \texorpdfstring{$\ast$}{*}, mask=None, return\+\_\+as=\mbox{\hyperlink{classscipy_1_1sparse_1_1__coo_1_1coo__matrix}{sparse.\+coo\+\_\+matrix}}, dtype=int)
\item 
\mbox{\hyperlink{namespacesklearn_1_1feature__extraction_1_1image_a9d5d0e38fa15fa1437d44149572dcaea}{\+\_\+compute\+\_\+n\+\_\+patches}} (i\+\_\+h, i\+\_\+w, p\+\_\+h, p\+\_\+w, max\+\_\+patches=None)
\begin{DoxyCompactList}\small\item\em From an image to a set of small image patches. \end{DoxyCompactList}\item 
\mbox{\hyperlink{namespacesklearn_1_1feature__extraction_1_1image_ad43a02e87afb752c6c26e763a24ce3a6}{\+\_\+extract\+\_\+patches}} (arr, patch\+\_\+shape=8, extraction\+\_\+step=1)
\item 
\mbox{\hyperlink{namespacesklearn_1_1feature__extraction_1_1image_a5e8eea279402c407c65ff7e13b1d64ff}{extract\+\_\+patches\+\_\+2d}} (image, patch\+\_\+size, \texorpdfstring{$\ast$}{*}, max\+\_\+patches=None, random\+\_\+state=None)
\item 
\mbox{\hyperlink{namespacesklearn_1_1feature__extraction_1_1image_a36d31839d5fed72f5e44e56e162fd66a}{reconstruct\+\_\+from\+\_\+patches\+\_\+2d}} (patches, image\+\_\+size)
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
list \mbox{\hyperlink{namespacesklearn_1_1feature__extraction_1_1image_a8d3a766ca333391d922c324f0471288d}{\+\_\+\+\_\+all\+\_\+\+\_\+}}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\begin{DoxyVerb}Utilities to extract features from images.\end{DoxyVerb}
 

\doxysubsection{Function Documentation}
\Hypertarget{namespacesklearn_1_1feature__extraction_1_1image_ae11d2551c8dba88d3f191ed86ac61b17}\index{sklearn.feature\_extraction.image@{sklearn.feature\_extraction.image}!\_compute\_gradient\_3d@{\_compute\_gradient\_3d}}
\index{\_compute\_gradient\_3d@{\_compute\_gradient\_3d}!sklearn.feature\_extraction.image@{sklearn.feature\_extraction.image}}
\doxysubsubsection{\texorpdfstring{\_compute\_gradient\_3d()}{\_compute\_gradient\_3d()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1feature__extraction_1_1image_ae11d2551c8dba88d3f191ed86ac61b17} 
sklearn.\+feature\+\_\+extraction.\+image.\+\_\+compute\+\_\+gradient\+\_\+3d (\begin{DoxyParamCaption}\item[{}]{edges}{, }\item[{}]{img}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{sklearn_2feature__extraction_2image_8py_source_l00051}{51}} of file \mbox{\hyperlink{sklearn_2feature__extraction_2image_8py_source}{image.\+py}}.

\Hypertarget{namespacesklearn_1_1feature__extraction_1_1image_a9d5d0e38fa15fa1437d44149572dcaea}\index{sklearn.feature\_extraction.image@{sklearn.feature\_extraction.image}!\_compute\_n\_patches@{\_compute\_n\_patches}}
\index{\_compute\_n\_patches@{\_compute\_n\_patches}!sklearn.feature\_extraction.image@{sklearn.feature\_extraction.image}}
\doxysubsubsection{\texorpdfstring{\_compute\_n\_patches()}{\_compute\_n\_patches()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1feature__extraction_1_1image_a9d5d0e38fa15fa1437d44149572dcaea} 
sklearn.\+feature\+\_\+extraction.\+image.\+\_\+compute\+\_\+n\+\_\+patches (\begin{DoxyParamCaption}\item[{}]{i\+\_\+h}{, }\item[{}]{i\+\_\+w}{, }\item[{}]{p\+\_\+h}{, }\item[{}]{p\+\_\+w}{, }\item[{}]{max\+\_\+patches}{ = {\ttfamily None}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



From an image to a set of small image patches. 

\begin{DoxyVerb}Compute the number of patches that will be extracted in an image.

Read more in the :ref:`User Guide <image_feature_extraction>`.

Parameters
----------
i_h : int
    The image height
i_w : int
    The image with
p_h : int
    The height of a patch
p_w : int
    The width of a patch
max_patches : int or float, default=None
    The maximum number of patches to extract. If `max_patches` is a float
    between 0 and 1, it is taken to be a proportion of the total number
    of patches. If `max_patches` is None, all possible patches are extracted.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{sklearn_2feature__extraction_2image_8py_source_l00254}{254}} of file \mbox{\hyperlink{sklearn_2feature__extraction_2image_8py_source}{image.\+py}}.



Referenced by \mbox{\hyperlink{sklearn_2feature__extraction_2image_8py_source_l00363}{extract\+\_\+patches\+\_\+2d()}}, and \mbox{\hyperlink{sklearn_2feature__extraction_2image_8py_source_l00618}{sklearn.\+feature\+\_\+extraction.\+image.\+Patch\+Extractor.\+transform()}}.

\Hypertarget{namespacesklearn_1_1feature__extraction_1_1image_ad43a02e87afb752c6c26e763a24ce3a6}\index{sklearn.feature\_extraction.image@{sklearn.feature\_extraction.image}!\_extract\_patches@{\_extract\_patches}}
\index{\_extract\_patches@{\_extract\_patches}!sklearn.feature\_extraction.image@{sklearn.feature\_extraction.image}}
\doxysubsubsection{\texorpdfstring{\_extract\_patches()}{\_extract\_patches()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1feature__extraction_1_1image_ad43a02e87afb752c6c26e763a24ce3a6} 
sklearn.\+feature\+\_\+extraction.\+image.\+\_\+extract\+\_\+patches (\begin{DoxyParamCaption}\item[{}]{arr}{, }\item[{}]{patch\+\_\+shape}{ = {\ttfamily 8}, }\item[{}]{extraction\+\_\+step}{ = {\ttfamily 1}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Extracts patches of any n-dimensional array in place using strides.

Given an n-dimensional array it will return a 2n-dimensional array with
the first n dimensions indexing patch position and the last n indexing
the patch content. This operation is immediate (O(1)). A reshape
performed on the first n dimensions will cause numpy to copy data, leading
to a list of extracted patches.

Read more in the :ref:`User Guide <image_feature_extraction>`.

Parameters
----------
arr : ndarray
    n-dimensional array of which patches are to be extracted

patch_shape : int or tuple of length arr.ndim.default=8
    Indicates the shape of the patches to be extracted. If an
    integer is given, the shape will be a hypercube of
    sidelength given by its value.

extraction_step : int or tuple of length arr.ndim, default=1
    Indicates step size at which extraction shall be performed.
    If integer is given, then the step is uniform in all dimensions.


Returns
-------
patches : strided ndarray
    2n-dimensional array indexing patches on first n dimensions and
    containing patches on the last n dimensions. These dimensions
    are fake, but this way no data is copied. A simple reshape invokes
    a copying operation to obtain a list of patches:
    result.reshape([-1] + list(patch_shape))
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{sklearn_2feature__extraction_2image_8py_source_l00291}{291}} of file \mbox{\hyperlink{sklearn_2feature__extraction_2image_8py_source}{image.\+py}}.



Referenced by \mbox{\hyperlink{sklearn_2feature__extraction_2image_8py_source_l00363}{extract\+\_\+patches\+\_\+2d()}}.

\Hypertarget{namespacesklearn_1_1feature__extraction_1_1image_a479887780bec6b5a3f989f6c86610bab}\index{sklearn.feature\_extraction.image@{sklearn.feature\_extraction.image}!\_make\_edges\_3d@{\_make\_edges\_3d}}
\index{\_make\_edges\_3d@{\_make\_edges\_3d}!sklearn.feature\_extraction.image@{sklearn.feature\_extraction.image}}
\doxysubsubsection{\texorpdfstring{\_make\_edges\_3d()}{\_make\_edges\_3d()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1feature__extraction_1_1image_a479887780bec6b5a3f989f6c86610bab} 
sklearn.\+feature\+\_\+extraction.\+image.\+\_\+make\+\_\+edges\+\_\+3d (\begin{DoxyParamCaption}\item[{}]{n\+\_\+x}{, }\item[{}]{n\+\_\+y}{, }\item[{}]{n\+\_\+z}{ = {\ttfamily 1}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



From an image to a graph. 

\begin{DoxyVerb}Returns a list of edges for a 3D image.

Parameters
----------
n_x : int
    The size of the grid in the x direction.
n_y : int
    The size of the grid in the y direction.
n_z : integer, default=1
    The size of the grid in the z direction, defaults to 1
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{sklearn_2feature__extraction_2image_8py_source_l00031}{31}} of file \mbox{\hyperlink{sklearn_2feature__extraction_2image_8py_source}{image.\+py}}.



Referenced by \mbox{\hyperlink{sklearn_2feature__extraction_2image_8py_source_l00093}{\+\_\+to\+\_\+graph()}}.

\Hypertarget{namespacesklearn_1_1feature__extraction_1_1image_a0d491a5256901a07dccc48f98f2154a8}\index{sklearn.feature\_extraction.image@{sklearn.feature\_extraction.image}!\_mask\_edges\_weights@{\_mask\_edges\_weights}}
\index{\_mask\_edges\_weights@{\_mask\_edges\_weights}!sklearn.feature\_extraction.image@{sklearn.feature\_extraction.image}}
\doxysubsubsection{\texorpdfstring{\_mask\_edges\_weights()}{\_mask\_edges\_weights()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1feature__extraction_1_1image_a0d491a5256901a07dccc48f98f2154a8} 
sklearn.\+feature\+\_\+extraction.\+image.\+\_\+mask\+\_\+edges\+\_\+weights (\begin{DoxyParamCaption}\item[{}]{mask}{, }\item[{}]{edges}{, }\item[{}]{weights}{ = {\ttfamily None}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Apply a mask to edges (weighted or not)\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{sklearn_2feature__extraction_2image_8py_source_l00071}{71}} of file \mbox{\hyperlink{sklearn_2feature__extraction_2image_8py_source}{image.\+py}}.



Referenced by \mbox{\hyperlink{sklearn_2feature__extraction_2image_8py_source_l00093}{\+\_\+to\+\_\+graph()}}.

\Hypertarget{namespacesklearn_1_1feature__extraction_1_1image_a8572e8109d312aeaf844c76535aeea96}\index{sklearn.feature\_extraction.image@{sklearn.feature\_extraction.image}!\_to\_graph@{\_to\_graph}}
\index{\_to\_graph@{\_to\_graph}!sklearn.feature\_extraction.image@{sklearn.feature\_extraction.image}}
\doxysubsubsection{\texorpdfstring{\_to\_graph()}{\_to\_graph()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1feature__extraction_1_1image_a8572e8109d312aeaf844c76535aeea96} 
sklearn.\+feature\+\_\+extraction.\+image.\+\_\+to\+\_\+graph (\begin{DoxyParamCaption}\item[{}]{n\+\_\+x}{, }\item[{}]{n\+\_\+y}{, }\item[{}]{n\+\_\+z}{, }\item[{}]{mask}{ = {\ttfamily None}, }\item[{}]{img}{ = {\ttfamily None}, }\item[{}]{return\+\_\+as}{ = {\ttfamily \mbox{\hyperlink{classscipy_1_1sparse_1_1__coo_1_1coo__matrix}{sparse.\+coo\+\_\+matrix}}}, }\item[{}]{dtype}{ = {\ttfamily None}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Auxiliary function for img_to_graph and grid_to_graph\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{sklearn_2feature__extraction_2image_8py_source_l00091}{91}} of file \mbox{\hyperlink{sklearn_2feature__extraction_2image_8py_source}{image.\+py}}.



References \mbox{\hyperlink{sklearn_2feature__extraction_2image_8py_source_l00031}{\+\_\+make\+\_\+edges\+\_\+3d()}}, and \mbox{\hyperlink{sklearn_2feature__extraction_2image_8py_source_l00071}{\+\_\+mask\+\_\+edges\+\_\+weights()}}.



Referenced by \mbox{\hyperlink{sklearn_2feature__extraction_2image_8py_source_l00203}{grid\+\_\+to\+\_\+graph()}}, and \mbox{\hyperlink{sklearn_2feature__extraction_2image_8py_source_l00147}{img\+\_\+to\+\_\+graph()}}.

\Hypertarget{namespacesklearn_1_1feature__extraction_1_1image_a5e8eea279402c407c65ff7e13b1d64ff}\index{sklearn.feature\_extraction.image@{sklearn.feature\_extraction.image}!extract\_patches\_2d@{extract\_patches\_2d}}
\index{extract\_patches\_2d@{extract\_patches\_2d}!sklearn.feature\_extraction.image@{sklearn.feature\_extraction.image}}
\doxysubsubsection{\texorpdfstring{extract\_patches\_2d()}{extract\_patches\_2d()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1feature__extraction_1_1image_a5e8eea279402c407c65ff7e13b1d64ff} 
sklearn.\+feature\+\_\+extraction.\+image.\+extract\+\_\+patches\+\_\+2d (\begin{DoxyParamCaption}\item[{}]{image}{, }\item[{}]{patch\+\_\+size}{, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{max\+\_\+patches}{ = {\ttfamily None}, }\item[{}]{random\+\_\+state}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Reshape a 2D image into a collection of patches.

The resulting patches are allocated in a dedicated array.

Read more in the :ref:`User Guide <image_feature_extraction>`.

Parameters
----------
image : ndarray of shape (image_height, image_width) or \
    (image_height, image_width, n_channels)
    The original image data. For color images, the last dimension specifies
    the channel: a RGB image would have `n_channels=3`.

patch_size : tuple of int (patch_height, patch_width)
    The dimensions of one patch.

max_patches : int or float, default=None
    The maximum number of patches to extract. If `max_patches` is a float
    between 0 and 1, it is taken to be a proportion of the total number
    of patches. If `max_patches` is None it corresponds to the total number
    of patches that can be extracted.

random_state : int, RandomState instance, default=None
    Determines the random number generator used for random sampling when
    `max_patches` is not None. Use an int to make the randomness
    deterministic.
    See :term:`Glossary <random_state>`.

Returns
-------
patches : array of shape (n_patches, patch_height, patch_width) or \
    (n_patches, patch_height, patch_width, n_channels)
    The collection of patches extracted from the image, where `n_patches`
    is either `max_patches` or the total number of patches that can be
    extracted.

Examples
--------
>>> from sklearn.datasets import load_sample_image
>>> from sklearn.feature_extraction import image
>>> # Use the array data from the first image in this dataset:
>>> one_image = load_sample_image("china.jpg")
>>> print('Image shape: {}'.format(one_image.shape))
Image shape: (427, 640, 3)
>>> patches = image.extract_patches_2d(one_image, (2, 2))
>>> print('Patches shape: {}'.format(patches.shape))
Patches shape: (272214, 2, 2, 3)
>>> # Here are just two of these patches:
>>> print(patches[1])
[[[174 201 231]
  [174 201 231]]
 [[173 200 230]
  [173 200 230]]]
>>> print(patches[800])
[[[187 214 243]
  [188 215 244]]
 [[187 214 243]
  [188 215 244]]]
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{sklearn_2feature__extraction_2image_8py_source_l00363}{363}} of file \mbox{\hyperlink{sklearn_2feature__extraction_2image_8py_source}{image.\+py}}.



References \mbox{\hyperlink{sklearn_2feature__extraction_2image_8py_source_l00254}{\+\_\+compute\+\_\+n\+\_\+patches()}}, and \mbox{\hyperlink{sklearn_2feature__extraction_2image_8py_source_l00291}{\+\_\+extract\+\_\+patches()}}.



Referenced by \mbox{\hyperlink{sklearn_2feature__extraction_2image_8py_source_l00618}{sklearn.\+feature\+\_\+extraction.\+image.\+Patch\+Extractor.\+transform()}}.

\Hypertarget{namespacesklearn_1_1feature__extraction_1_1image_aede322fc75dc6655b2fd217da500cf88}\index{sklearn.feature\_extraction.image@{sklearn.feature\_extraction.image}!grid\_to\_graph@{grid\_to\_graph}}
\index{grid\_to\_graph@{grid\_to\_graph}!sklearn.feature\_extraction.image@{sklearn.feature\_extraction.image}}
\doxysubsubsection{\texorpdfstring{grid\_to\_graph()}{grid\_to\_graph()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1feature__extraction_1_1image_aede322fc75dc6655b2fd217da500cf88} 
sklearn.\+feature\+\_\+extraction.\+image.\+grid\+\_\+to\+\_\+graph (\begin{DoxyParamCaption}\item[{}]{n\+\_\+x}{, }\item[{}]{n\+\_\+y}{, }\item[{}]{n\+\_\+z}{ = {\ttfamily 1}, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{mask}{ = {\ttfamily None}, }\item[{}]{return\+\_\+as}{ = {\ttfamily \mbox{\hyperlink{classscipy_1_1sparse_1_1__coo_1_1coo__matrix}{sparse.\+coo\+\_\+matrix}}}, }\item[{}]{dtype}{ = {\ttfamily int}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Graph of the pixel-to-pixel connections.

Edges exist if 2 voxels are connected.

Read more in the :ref:`User Guide <connectivity_graph_image>`.

Parameters
----------
n_x : int
    Dimension in x axis.
n_y : int
    Dimension in y axis.
n_z : int, default=1
    Dimension in z axis.
mask : ndarray of shape (n_x, n_y, n_z), dtype=bool, default=None
    An optional mask of the image, to consider only part of the
    pixels.
return_as : np.ndarray or a sparse matrix class, \
        default=sparse.coo_matrix
    The class to use to build the returned adjacency matrix.
dtype : dtype, default=int
    The data of the returned sparse matrix. By default it is int.

Returns
-------
graph : np.ndarray or a sparse matrix class
    The computed adjacency matrix.

Examples
--------
>>> import numpy as np
>>> from sklearn.feature_extraction.image import grid_to_graph
>>> shape_img = (4, 4, 1)
>>> mask = np.zeros(shape=shape_img, dtype=bool)
>>> mask[[1, 2], [1, 2], :] = True
>>> graph = grid_to_graph(*shape_img, mask=mask)
>>> print(graph)
<COOrdinate sparse matrix of dtype 'int64'
  with 2 stored elements and shape (2, 2)>
  Coords    Values
  (0, 0)    1
  (1, 1)    1
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{sklearn_2feature__extraction_2image_8py_source_l00201}{201}} of file \mbox{\hyperlink{sklearn_2feature__extraction_2image_8py_source}{image.\+py}}.



References \mbox{\hyperlink{sklearn_2feature__extraction_2image_8py_source_l00093}{\+\_\+to\+\_\+graph()}}.

\Hypertarget{namespacesklearn_1_1feature__extraction_1_1image_a52ce80cce071204ae080507781b1330f}\index{sklearn.feature\_extraction.image@{sklearn.feature\_extraction.image}!img\_to\_graph@{img\_to\_graph}}
\index{img\_to\_graph@{img\_to\_graph}!sklearn.feature\_extraction.image@{sklearn.feature\_extraction.image}}
\doxysubsubsection{\texorpdfstring{img\_to\_graph()}{img\_to\_graph()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1feature__extraction_1_1image_a52ce80cce071204ae080507781b1330f} 
sklearn.\+feature\+\_\+extraction.\+image.\+img\+\_\+to\+\_\+graph (\begin{DoxyParamCaption}\item[{}]{img}{, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{}]{mask}{ = {\ttfamily None}, }\item[{}]{return\+\_\+as}{ = {\ttfamily \mbox{\hyperlink{classscipy_1_1sparse_1_1__coo_1_1coo__matrix}{sparse.\+coo\+\_\+matrix}}}, }\item[{}]{dtype}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Graph of the pixel-to-pixel gradient connections.

Edges are weighted with the gradient values.

Read more in the :ref:`User Guide <image_feature_extraction>`.

Parameters
----------
img : array-like of shape (height, width) or (height, width, channel)
    2D or 3D image.
mask : ndarray of shape (height, width) or \
        (height, width, channel), dtype=bool, default=None
    An optional mask of the image, to consider only part of the
    pixels.
return_as : np.ndarray or a sparse matrix class, \
        default=sparse.coo_matrix
    The class to use to build the returned adjacency matrix.
dtype : dtype, default=None
    The data of the returned sparse matrix. By default it is the
    dtype of img.

Returns
-------
graph : ndarray or a sparse matrix class
    The computed adjacency matrix.

Examples
--------
>>> import numpy as np
>>> from sklearn.feature_extraction.image import img_to_graph
>>> img = np.array([[0, 0], [0, 1]])
>>> img_to_graph(img, return_as=np.ndarray)
array([[0, 0, 0, 0],
       [0, 0, 0, 1],
       [0, 0, 0, 1],
       [0, 1, 1, 1]])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{sklearn_2feature__extraction_2image_8py_source_l00147}{147}} of file \mbox{\hyperlink{sklearn_2feature__extraction_2image_8py_source}{image.\+py}}.



References \mbox{\hyperlink{sklearn_2feature__extraction_2image_8py_source_l00093}{\+\_\+to\+\_\+graph()}}.

\Hypertarget{namespacesklearn_1_1feature__extraction_1_1image_a36d31839d5fed72f5e44e56e162fd66a}\index{sklearn.feature\_extraction.image@{sklearn.feature\_extraction.image}!reconstruct\_from\_patches\_2d@{reconstruct\_from\_patches\_2d}}
\index{reconstruct\_from\_patches\_2d@{reconstruct\_from\_patches\_2d}!sklearn.feature\_extraction.image@{sklearn.feature\_extraction.image}}
\doxysubsubsection{\texorpdfstring{reconstruct\_from\_patches\_2d()}{reconstruct\_from\_patches\_2d()}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1feature__extraction_1_1image_a36d31839d5fed72f5e44e56e162fd66a} 
sklearn.\+feature\+\_\+extraction.\+image.\+reconstruct\+\_\+from\+\_\+patches\+\_\+2d (\begin{DoxyParamCaption}\item[{}]{patches}{, }\item[{}]{image\+\_\+size}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Reconstruct the image from all of its patches.

Patches are assumed to overlap and the image is constructed by filling in
the patches from left to right, top to bottom, averaging the overlapping
regions.

Read more in the :ref:`User Guide <image_feature_extraction>`.

Parameters
----------
patches : ndarray of shape (n_patches, patch_height, patch_width) or \
    (n_patches, patch_height, patch_width, n_channels)
    The complete set of patches. If the patches contain colour information,
    channels are indexed along the last dimension: RGB patches would
    have `n_channels=3`.

image_size : tuple of int (image_height, image_width) or \
    (image_height, image_width, n_channels)
    The size of the image that will be reconstructed.

Returns
-------
image : ndarray of shape image_size
    The reconstructed image.

Examples
--------
>>> from sklearn.datasets import load_sample_image
>>> from sklearn.feature_extraction import image
>>> one_image = load_sample_image("china.jpg")
>>> print('Image shape: {}'.format(one_image.shape))
Image shape: (427, 640, 3)
>>> image_patches = image.extract_patches_2d(image=one_image, patch_size=(10, 10))
>>> print('Patches shape: {}'.format(image_patches.shape))
Patches shape: (263758, 10, 10, 3)
>>> image_reconstructed = image.reconstruct_from_patches_2d(
...     patches=image_patches,
...     image_size=one_image.shape
... )
>>> print(f"Reconstructed shape: {image_reconstructed.shape}")
Reconstructed shape: (427, 640, 3)
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{sklearn_2feature__extraction_2image_8py_source_l00465}{465}} of file \mbox{\hyperlink{sklearn_2feature__extraction_2image_8py_source}{image.\+py}}.



\doxysubsection{Variable Documentation}
\Hypertarget{namespacesklearn_1_1feature__extraction_1_1image_a8d3a766ca333391d922c324f0471288d}\index{sklearn.feature\_extraction.image@{sklearn.feature\_extraction.image}!\_\_all\_\_@{\_\_all\_\_}}
\index{\_\_all\_\_@{\_\_all\_\_}!sklearn.feature\_extraction.image@{sklearn.feature\_extraction.image}}
\doxysubsubsection{\texorpdfstring{\_\_all\_\_}{\_\_all\_\_}}
{\footnotesize\ttfamily \label{namespacesklearn_1_1feature__extraction_1_1image_a8d3a766ca333391d922c324f0471288d} 
list sklearn.\+feature\+\_\+extraction.\+image.\+\_\+\+\_\+all\+\_\+\+\_\+\hspace{0.3cm}{\ttfamily [private]}}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ [}
\DoxyCodeLine{00002\ \ \ \ \ \textcolor{stringliteral}{"{}PatchExtractor"{}},}
\DoxyCodeLine{00003\ \ \ \ \ \textcolor{stringliteral}{"{}extract\_patches\_2d"{}},}
\DoxyCodeLine{00004\ \ \ \ \ \textcolor{stringliteral}{"{}grid\_to\_graph"{}},}
\DoxyCodeLine{00005\ \ \ \ \ \textcolor{stringliteral}{"{}img\_to\_graph"{}},}
\DoxyCodeLine{00006\ \ \ \ \ \textcolor{stringliteral}{"{}reconstruct\_from\_patches\_2d"{}},}
\DoxyCodeLine{00007\ ]}

\end{DoxyCode}


Definition at line \mbox{\hyperlink{sklearn_2feature__extraction_2image_8py_source_l00017}{17}} of file \mbox{\hyperlink{sklearn_2feature__extraction_2image_8py_source}{image.\+py}}.

