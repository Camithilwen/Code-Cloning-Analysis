\doxysection{scipy.\+interpolate.\+\_\+polyint Namespace Reference}
\hypertarget{namespacescipy_1_1interpolate_1_1__polyint}{}\label{namespacescipy_1_1interpolate_1_1__polyint}\index{scipy.interpolate.\_polyint@{scipy.interpolate.\_polyint}}
\doxysubsubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classscipy_1_1interpolate_1_1__polyint_1_1__Interpolator1D}{\+\_\+\+Interpolator1D}}
\item 
class \mbox{\hyperlink{classscipy_1_1interpolate_1_1__polyint_1_1__Interpolator1DWithDerivatives}{\+\_\+\+Interpolator1\+DWith\+Derivatives}}
\item 
class \mbox{\hyperlink{classscipy_1_1interpolate_1_1__polyint_1_1BarycentricInterpolator}{Barycentric\+Interpolator}}
\item 
class \mbox{\hyperlink{classscipy_1_1interpolate_1_1__polyint_1_1KroghInterpolator}{Krogh\+Interpolator}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacescipy_1_1interpolate_1_1__polyint_ac949282a006e08fa2a5c17f22c86fdbf}{\+\_\+isscalar}} (x)
\item 
\mbox{\hyperlink{namespacescipy_1_1interpolate_1_1__polyint_ac6945dafe5abbbb939bcbe6df2b3706f}{krogh\+\_\+interpolate}} (xi, yi, x, der=0, axis=0)
\item 
\mbox{\hyperlink{namespacescipy_1_1interpolate_1_1__polyint_ae7ee93f4589c080c5fcdd852791b80ea}{approximate\+\_\+taylor\+\_\+polynomial}} (f, x, degree, scale, order=None)
\item 
\mbox{\hyperlink{namespacescipy_1_1interpolate_1_1__polyint_a113e326189bf3339365a401cc41b6542}{barycentric\+\_\+interpolate}} (xi, yi, x, axis=0)
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
list \mbox{\hyperlink{namespacescipy_1_1interpolate_1_1__polyint_af2fbf429c8b4551b6f78987185d513ff}{\+\_\+\+\_\+all\+\_\+\+\_\+}}
\end{DoxyCompactItemize}


\doxysubsection{Function Documentation}
\Hypertarget{namespacescipy_1_1interpolate_1_1__polyint_ac949282a006e08fa2a5c17f22c86fdbf}\index{scipy.interpolate.\_polyint@{scipy.interpolate.\_polyint}!\_isscalar@{\_isscalar}}
\index{\_isscalar@{\_isscalar}!scipy.interpolate.\_polyint@{scipy.interpolate.\_polyint}}
\doxysubsubsection{\texorpdfstring{\_isscalar()}{\_isscalar()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1interpolate_1_1__polyint_ac949282a006e08fa2a5c17f22c86fdbf} 
scipy.\+interpolate.\+\_\+polyint.\+\_\+isscalar (\begin{DoxyParamCaption}\item[{}]{x}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Check whether x is if a scalar type, or 0-dim\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__polyint_8py_source_l00012}{12}} of file \mbox{\hyperlink{__polyint_8py_source}{\+\_\+polyint.\+py}}.



Referenced by \mbox{\hyperlink{__polyint_8py_source_l00369}{krogh\+\_\+interpolate()}}, and \mbox{\hyperlink{__cubic_8py_source_l00305}{scipy.\+interpolate.\+\_\+cubic.\+pchip\+\_\+interpolate()}}.

\Hypertarget{namespacescipy_1_1interpolate_1_1__polyint_ae7ee93f4589c080c5fcdd852791b80ea}\index{scipy.interpolate.\_polyint@{scipy.interpolate.\_polyint}!approximate\_taylor\_polynomial@{approximate\_taylor\_polynomial}}
\index{approximate\_taylor\_polynomial@{approximate\_taylor\_polynomial}!scipy.interpolate.\_polyint@{scipy.interpolate.\_polyint}}
\doxysubsubsection{\texorpdfstring{approximate\_taylor\_polynomial()}{approximate\_taylor\_polynomial()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1interpolate_1_1__polyint_ae7ee93f4589c080c5fcdd852791b80ea} 
scipy.\+interpolate.\+\_\+polyint.\+approximate\+\_\+taylor\+\_\+polynomial (\begin{DoxyParamCaption}\item[{}]{f}{, }\item[{}]{x}{, }\item[{}]{degree}{, }\item[{}]{scale}{, }\item[{}]{order}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Estimate the Taylor polynomial of f at x by polynomial fitting.

Parameters
----------
f : callable
    The function whose Taylor polynomial is sought. Should accept
    a vector of `x` values.
x : scalar
    The point at which the polynomial is to be evaluated.
degree : int
    The degree of the Taylor polynomial
scale : scalar
    The width of the interval to use to evaluate the Taylor polynomial.
    Function values spread over a range this wide are used to fit the
    polynomial. Must be chosen carefully.
order : int or None, optional
    The order of the polynomial to be used in the fitting; `f` will be
    evaluated ``order+1`` times. If None, use `degree`.

Returns
-------
p : poly1d instance
    The Taylor polynomial (translated to the origin, so that
    for example p(0)=f(x)).

Notes
-----
The appropriate choice of "scale" is a trade-off; too large and the
function differs from its Taylor polynomial too much to get a good
answer, too small and round-off errors overwhelm the higher-order terms.
The algorithm used becomes numerically unstable around order 30 even
under ideal circumstances.

Choosing order somewhat larger than degree may improve the higher-order
terms.

Examples
--------
We can calculate Taylor approximation polynomials of sin function with
various degrees:

>>> import numpy as np
>>> import matplotlib.pyplot as plt
>>> from scipy.interpolate import approximate_taylor_polynomial
>>> x = np.linspace(-10.0, 10.0, num=100)
>>> plt.plot(x, np.sin(x), label="sin curve")
>>> for degree in np.arange(1, 15, step=2):
...     sin_taylor = approximate_taylor_polynomial(np.sin, 0, degree, 1,
...                                                order=degree + 2)
...     plt.plot(x, sin_taylor(x), label=f"degree={degree}")
>>> plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left',
...            borderaxespad=0.0, shadow=True)
>>> plt.tight_layout()
>>> plt.axis([-10, 10, -10, 10])
>>> plt.show()
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__polyint_8py_source_l00436}{436}} of file \mbox{\hyperlink{__polyint_8py_source}{\+\_\+polyint.\+py}}.

\Hypertarget{namespacescipy_1_1interpolate_1_1__polyint_a113e326189bf3339365a401cc41b6542}\index{scipy.interpolate.\_polyint@{scipy.interpolate.\_polyint}!barycentric\_interpolate@{barycentric\_interpolate}}
\index{barycentric\_interpolate@{barycentric\_interpolate}!scipy.interpolate.\_polyint@{scipy.interpolate.\_polyint}}
\doxysubsubsection{\texorpdfstring{barycentric\_interpolate()}{barycentric\_interpolate()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1interpolate_1_1__polyint_a113e326189bf3339365a401cc41b6542} 
scipy.\+interpolate.\+\_\+polyint.\+barycentric\+\_\+interpolate (\begin{DoxyParamCaption}\item[{}]{xi}{, }\item[{}]{yi}{, }\item[{}]{x}{, }\item[{}]{axis}{ = {\ttfamily 0}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Convenience function for polynomial interpolation.

Constructs a polynomial that passes through a given set of points,
then evaluates the polynomial. For reasons of numerical stability,
this function does not compute the coefficients of the polynomial.

This function uses a "barycentric interpolation" method that treats
the problem as a special case of rational function interpolation.
This algorithm is quite stable, numerically, but even in a world of
exact computation, unless the `x` coordinates are chosen very
carefully - Chebyshev zeros (e.g., cos(i*pi/n)) are a good choice -
polynomial interpolation itself is a very ill-conditioned process
due to the Runge phenomenon.

Parameters
----------
xi : array_like
    1-D array of x coordinates of the points the polynomial should
    pass through
yi : array_like
    The y coordinates of the points the polynomial should pass through.
x : scalar or array_like
    Points to evaluate the interpolator at.
axis : int, optional
    Axis in the yi array corresponding to the x-coordinate values.

Returns
-------
y : scalar or array_like
    Interpolated values. Shape is determined by replacing
    the interpolation axis in the original array with the shape of x.

See Also
--------
BarycentricInterpolator : Bary centric interpolator

Notes
-----
Construction of the interpolation weights is a relatively slow process.
If you want to call this many times with the same xi (but possibly
varying yi or x) you should use the class `BarycentricInterpolator`.
This is what this function uses internally.

Examples
--------
We can interpolate 2D observed data using barycentric interpolation:

>>> import numpy as np
>>> import matplotlib.pyplot as plt
>>> from scipy.interpolate import barycentric_interpolate
>>> x_observed = np.linspace(0.0, 10.0, 11)
>>> y_observed = np.sin(x_observed)
>>> x = np.linspace(min(x_observed), max(x_observed), num=100)
>>> y = barycentric_interpolate(x_observed, y_observed, x)
>>> plt.plot(x_observed, y_observed, "o", label="observation")
>>> plt.plot(x, y, label="barycentric interpolation")
>>> plt.legend()
>>> plt.show()
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__polyint_8py_source_l00687}{687}} of file \mbox{\hyperlink{__polyint_8py_source}{\+\_\+polyint.\+py}}.

\Hypertarget{namespacescipy_1_1interpolate_1_1__polyint_ac6945dafe5abbbb939bcbe6df2b3706f}\index{scipy.interpolate.\_polyint@{scipy.interpolate.\_polyint}!krogh\_interpolate@{krogh\_interpolate}}
\index{krogh\_interpolate@{krogh\_interpolate}!scipy.interpolate.\_polyint@{scipy.interpolate.\_polyint}}
\doxysubsubsection{\texorpdfstring{krogh\_interpolate()}{krogh\_interpolate()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1interpolate_1_1__polyint_ac6945dafe5abbbb939bcbe6df2b3706f} 
scipy.\+interpolate.\+\_\+polyint.\+krogh\+\_\+interpolate (\begin{DoxyParamCaption}\item[{}]{xi}{, }\item[{}]{yi}{, }\item[{}]{x}{, }\item[{}]{der}{ = {\ttfamily 0}, }\item[{}]{axis}{ = {\ttfamily 0}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Convenience function for polynomial interpolation.

See `KroghInterpolator` for more details.

Parameters
----------
xi : array_like
    Known x-coordinates.
yi : array_like
    Known y-coordinates, of shape ``(xi.size, R)``. Interpreted as
    vectors of length R, or scalars if R=1.
x : array_like
    Point or points at which to evaluate the derivatives.
der : int or list, optional
    How many derivatives to extract; None for all potentially
    nonzero derivatives (that is a number equal to the number
    of points), or a list of derivatives to extract. This number
    includes the function value as 0th derivative.
axis : int, optional
    Axis in the yi array corresponding to the x-coordinate values.

Returns
-------
d : ndarray
    If the interpolator's values are R-D then the
    returned array will be the number of derivatives by N by R.
    If `x` is a scalar, the middle dimension will be dropped; if
    the `yi` are scalars then the last dimension will be dropped.

See Also
--------
KroghInterpolator : Krogh interpolator

Notes
-----
Construction of the interpolating polynomial is a relatively expensive
process. If you want to evaluate it repeatedly consider using the class
KroghInterpolator (which is what this function uses).

Examples
--------
We can interpolate 2D observed data using krogh interpolation:

>>> import numpy as np
>>> import matplotlib.pyplot as plt
>>> from scipy.interpolate import krogh_interpolate
>>> x_observed = np.linspace(0.0, 10.0, 11)
>>> y_observed = np.sin(x_observed)
>>> x = np.linspace(min(x_observed), max(x_observed), num=100)
>>> y = krogh_interpolate(x_observed, y_observed, x)
>>> plt.plot(x_observed, y_observed, "o", label="observation")
>>> plt.plot(x, y, label="krogh interpolation")
>>> plt.legend()
>>> plt.show()
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__polyint_8py_source_l00369}{369}} of file \mbox{\hyperlink{__polyint_8py_source}{\+\_\+polyint.\+py}}.



References \mbox{\hyperlink{__polyint_8py_source_l00012}{\+\_\+isscalar()}}.



\doxysubsection{Variable Documentation}
\Hypertarget{namespacescipy_1_1interpolate_1_1__polyint_af2fbf429c8b4551b6f78987185d513ff}\index{scipy.interpolate.\_polyint@{scipy.interpolate.\_polyint}!\_\_all\_\_@{\_\_all\_\_}}
\index{\_\_all\_\_@{\_\_all\_\_}!scipy.interpolate.\_polyint@{scipy.interpolate.\_polyint}}
\doxysubsubsection{\texorpdfstring{\_\_all\_\_}{\_\_all\_\_}}
{\footnotesize\ttfamily \label{namespacescipy_1_1interpolate_1_1__polyint_af2fbf429c8b4551b6f78987185d513ff} 
list scipy.\+interpolate.\+\_\+polyint.\+\_\+\+\_\+all\+\_\+\+\_\+\hspace{0.3cm}{\ttfamily [private]}}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ [\textcolor{stringliteral}{"{}KroghInterpolator"{}},\ \textcolor{stringliteral}{"{}krogh\_interpolate"{}},\ \textcolor{stringliteral}{"{}BarycentricInterpolator"{}},}
\DoxyCodeLine{00002\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}barycentric\_interpolate"{}},\ \textcolor{stringliteral}{"{}approximate\_taylor\_polynomial"{}}]}

\end{DoxyCode}


Definition at line \mbox{\hyperlink{__polyint_8py_source_l00008}{8}} of file \mbox{\hyperlink{__polyint_8py_source}{\+\_\+polyint.\+py}}.

