\doxysection{pandas.\+core.\+sorting Namespace Reference}
\hypertarget{namespacepandas_1_1core_1_1sorting}{}\label{namespacepandas_1_1core_1_1sorting}\index{pandas.core.sorting@{pandas.core.sorting}}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
npt.\+NDArray\mbox{[}np.\+intp\mbox{]}\texorpdfstring{$\vert$}{|}None \mbox{\hyperlink{namespacepandas_1_1core_1_1sorting_a5d59af530c66d30bee514adae3065f97}{get\+\_\+indexer\+\_\+indexer}} (\mbox{\hyperlink{classpandas_1_1core_1_1indexes_1_1base_1_1Index}{Index}} target, Level\texorpdfstring{$\vert$}{|}list\mbox{[}Level\mbox{]}\texorpdfstring{$\vert$}{|}None level, list\mbox{[}bool\mbox{]}\texorpdfstring{$\vert$}{|}bool ascending, Sort\+Kind kind, Na\+Position na\+\_\+position, bool sort\+\_\+remaining, Index\+Key\+Func key)
\item 
npt.\+NDArray\mbox{[}np.\+int64\mbox{]} \mbox{\hyperlink{namespacepandas_1_1core_1_1sorting_adbcaea4c69033b757e68fb6f8ed6105c}{get\+\_\+group\+\_\+index}} (labels, Shape shape, bool sort, bool xnull)
\item 
tuple\mbox{[}npt.\+NDArray\mbox{[}np.\+intp\mbox{]}, npt.\+NDArray\mbox{[}np.\+int64\mbox{]}\mbox{]} \mbox{\hyperlink{namespacepandas_1_1core_1_1sorting_a958d45b3afb39502d01b014cccbb7401}{get\+\_\+compressed\+\_\+ids}} (labels, Shape sizes)
\item 
bool \mbox{\hyperlink{namespacepandas_1_1core_1_1sorting_a6ae8cf75c93f330b36b0d473c588b747}{is\+\_\+int64\+\_\+overflow\+\_\+possible}} (Shape shape)
\item 
list\mbox{[}npt.\+NDArray\mbox{[}np.\+intp\mbox{]}\mbox{]} \mbox{\hyperlink{namespacepandas_1_1core_1_1sorting_aea88f88f2c88a1a2966dd2406e7f06ab}{\+\_\+decons\+\_\+group\+\_\+index}} (npt.\+NDArray\mbox{[}np.\+intp\mbox{]} comp\+\_\+labels, Shape shape)
\item 
list\mbox{[}npt.\+NDArray\mbox{[}np.\+intp\mbox{]}\mbox{]} \mbox{\hyperlink{namespacepandas_1_1core_1_1sorting_ae47f9cd7d5058c4fcd4f6f5830bb1b84}{decons\+\_\+obs\+\_\+group\+\_\+ids}} (npt.\+NDArray\mbox{[}np.\+intp\mbox{]} comp\+\_\+ids, npt.\+NDArray\mbox{[}np.\+intp\mbox{]} obs\+\_\+ids, Shape shape, Sequence\mbox{[}npt.\+NDArray\mbox{[}np.\+signedinteger\mbox{]}\mbox{]} labels, bool xnull)
\item 
npt.\+NDArray\mbox{[}np.\+intp\mbox{]} \mbox{\hyperlink{namespacepandas_1_1core_1_1sorting_a984c5ea1947ec578cdaff655702df5a3}{lexsort\+\_\+indexer}} (Sequence\mbox{[}Array\+Like\texorpdfstring{$\vert$}{|}\mbox{\hyperlink{classpandas_1_1core_1_1indexes_1_1base_1_1Index}{Index}}\texorpdfstring{$\vert$}{|}Series\mbox{]} keys, orders=None, str na\+\_\+position="{}last"{}, Callable\texorpdfstring{$\vert$}{|}None key=None, bool codes\+\_\+given=False)
\item 
npt.\+NDArray\mbox{[}np.\+intp\mbox{]} \mbox{\hyperlink{namespacepandas_1_1core_1_1sorting_add1268682e9720be5e4682def9a832ed}{nargsort}} (Array\+Like\texorpdfstring{$\vert$}{|}\mbox{\hyperlink{classpandas_1_1core_1_1indexes_1_1base_1_1Index}{Index}}\texorpdfstring{$\vert$}{|}Series items, Sort\+Kind kind="{}quicksort"{}, bool ascending=\mbox{\hyperlink{classTrue}{True}}, str na\+\_\+position="{}last"{}, Callable\texorpdfstring{$\vert$}{|}None key=None, npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]}\texorpdfstring{$\vert$}{|}None mask=None)
\item 
\mbox{\hyperlink{namespacepandas_1_1core_1_1sorting_acc3cdcbfcd60d2253e7e843f254a8d6b}{nargminmax}} (\mbox{\hyperlink{classpandas_1_1core_1_1arrays_1_1base_1_1ExtensionArray}{Extension\+Array}} values, str method, Axis\+Int axis=0)
\item 
int \mbox{\hyperlink{namespacepandas_1_1core_1_1sorting_a98e3a92a42103c4b3e5ff927d4c908b6}{\+\_\+nanargminmax}} (np.\+ndarray values, npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]} mask, func)
\item 
Multi\+Index \mbox{\hyperlink{namespacepandas_1_1core_1_1sorting_a40672fba282049a52ada719678ec5baf}{\+\_\+ensure\+\_\+key\+\_\+mapped\+\_\+multiindex}} (Multi\+Index index, Callable key, level=None)
\item 
Array\+Like\texorpdfstring{$\vert$}{|}\mbox{\hyperlink{classpandas_1_1core_1_1indexes_1_1base_1_1Index}{Index}}\texorpdfstring{$\vert$}{|}Series \mbox{\hyperlink{namespacepandas_1_1core_1_1sorting_a987539d31d22237fc43c6ee443d2120f}{ensure\+\_\+key\+\_\+mapped}} (Array\+Like\texorpdfstring{$\vert$}{|}\mbox{\hyperlink{classpandas_1_1core_1_1indexes_1_1base_1_1Index}{Index}}\texorpdfstring{$\vert$}{|}Series values, Callable\texorpdfstring{$\vert$}{|}None key, levels=None)
\item 
list\mbox{[}tuple\mbox{]} \mbox{\hyperlink{namespacepandas_1_1core_1_1sorting_aeb4b09b6dcedc57a6e7d13733b54e395}{get\+\_\+flattened\+\_\+list}} (npt.\+NDArray\mbox{[}np.\+intp\mbox{]} comp\+\_\+ids, int ngroups, Iterable\mbox{[}\mbox{\hyperlink{classpandas_1_1core_1_1indexes_1_1base_1_1Index}{Index}}\mbox{]} levels, Iterable\mbox{[}np.\+ndarray\mbox{]} labels)
\item 
dict\mbox{[}Hashable, npt.\+NDArray\mbox{[}np.\+intp\mbox{]}\mbox{]} \mbox{\hyperlink{namespacepandas_1_1core_1_1sorting_ac2f9b61304768d12c21ff05d08e6f739}{get\+\_\+indexer\+\_\+dict}} (list\mbox{[}np.\+ndarray\mbox{]} label\+\_\+list, list\mbox{[}\mbox{\hyperlink{classpandas_1_1core_1_1indexes_1_1base_1_1Index}{Index}}\mbox{]} keys)
\item 
npt.\+NDArray\mbox{[}np.\+intp\mbox{]} \mbox{\hyperlink{namespacepandas_1_1core_1_1sorting_a508c4e5b564f2354194bf7a44b6df8e7}{get\+\_\+group\+\_\+index\+\_\+sorter}} (npt.\+NDArray\mbox{[}np.\+intp\mbox{]} group\+\_\+index, int\texorpdfstring{$\vert$}{|}None ngroups=None)
\item 
tuple\mbox{[}npt.\+NDArray\mbox{[}np.\+int64\mbox{]}, npt.\+NDArray\mbox{[}np.\+int64\mbox{]}\mbox{]} \mbox{\hyperlink{namespacepandas_1_1core_1_1sorting_a4671f23853e5550b2dce6fcaaa13e00b}{compress\+\_\+group\+\_\+index}} (npt.\+NDArray\mbox{[}np.\+int64\mbox{]} group\+\_\+index, bool sort=\mbox{\hyperlink{classTrue}{True}})
\item 
tuple\mbox{[}npt.\+NDArray\mbox{[}np.\+int64\mbox{]}, npt.\+NDArray\mbox{[}np.\+intp\mbox{]}\mbox{]} \mbox{\hyperlink{namespacepandas_1_1core_1_1sorting_a6fed5723f0a2dffd444d6b22afe32692}{\+\_\+reorder\+\_\+by\+\_\+uniques}} (npt.\+NDArray\mbox{[}np.\+int64\mbox{]} uniques, npt.\+NDArray\mbox{[}np.\+intp\mbox{]} labels)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\begin{DoxyVerb} miscellaneous sorting / groupby utilities \end{DoxyVerb}
 

\doxysubsection{Function Documentation}
\Hypertarget{namespacepandas_1_1core_1_1sorting_aea88f88f2c88a1a2966dd2406e7f06ab}\index{pandas.core.sorting@{pandas.core.sorting}!\_decons\_group\_index@{\_decons\_group\_index}}
\index{\_decons\_group\_index@{\_decons\_group\_index}!pandas.core.sorting@{pandas.core.sorting}}
\doxysubsubsection{\texorpdfstring{\_decons\_group\_index()}{\_decons\_group\_index()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1core_1_1sorting_aea88f88f2c88a1a2966dd2406e7f06ab} 
 list\mbox{[}npt.\+NDArray\mbox{[}np.\+intp\mbox{]}\mbox{]} pandas.\+core.\+sorting.\+\_\+decons\+\_\+group\+\_\+index (\begin{DoxyParamCaption}\item[{npt.\+NDArray\mbox{[}np.\+intp\mbox{]}}]{comp\+\_\+labels}{, }\item[{Shape }]{shape}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{sorting_8py_source_l00246}{246}} of file \mbox{\hyperlink{sorting_8py_source}{sorting.\+py}}.

\Hypertarget{namespacepandas_1_1core_1_1sorting_a40672fba282049a52ada719678ec5baf}\index{pandas.core.sorting@{pandas.core.sorting}!\_ensure\_key\_mapped\_multiindex@{\_ensure\_key\_mapped\_multiindex}}
\index{\_ensure\_key\_mapped\_multiindex@{\_ensure\_key\_mapped\_multiindex}!pandas.core.sorting@{pandas.core.sorting}}
\doxysubsubsection{\texorpdfstring{\_ensure\_key\_mapped\_multiindex()}{\_ensure\_key\_mapped\_multiindex()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1core_1_1sorting_a40672fba282049a52ada719678ec5baf} 
 Multi\+Index pandas.\+core.\+sorting.\+\_\+ensure\+\_\+key\+\_\+mapped\+\_\+multiindex (\begin{DoxyParamCaption}\item[{Multi\+Index}]{index}{, }\item[{Callable}]{key}{, }\item[{}]{level}{ = {\ttfamily None}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Returns a new MultiIndex in which key has been applied
to all levels specified in level (or all levels if level
is None). Used for key sorting for MultiIndex.

Parameters
----------
index : MultiIndex
    Index to which to apply the key function on the
    specified levels.
key : Callable
    Function that takes an Index and returns an Index of
    the same shape. This key is applied to each level
    separately. The name of the level can be used to
    distinguish different levels for application.
level : list-like, int or str, default None
    Level or list of levels to apply the key function to.
    If None, key function is applied to all levels. Other
    levels are left unchanged.

Returns
-------
labels : MultiIndex
    Resulting MultiIndex with modified levels.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{sorting_8py_source_l00497}{497}} of file \mbox{\hyperlink{sorting_8py_source}{sorting.\+py}}.



References \mbox{\hyperlink{sorting_8py_source_l00548}{ensure\+\_\+key\+\_\+mapped()}}.



Referenced by \mbox{\hyperlink{sorting_8py_source_l00548}{ensure\+\_\+key\+\_\+mapped()}}.

\Hypertarget{namespacepandas_1_1core_1_1sorting_a98e3a92a42103c4b3e5ff927d4c908b6}\index{pandas.core.sorting@{pandas.core.sorting}!\_nanargminmax@{\_nanargminmax}}
\index{\_nanargminmax@{\_nanargminmax}!pandas.core.sorting@{pandas.core.sorting}}
\doxysubsubsection{\texorpdfstring{\_nanargminmax()}{\_nanargminmax()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1core_1_1sorting_a98e3a92a42103c4b3e5ff927d4c908b6} 
 int pandas.\+core.\+sorting.\+\_\+nanargminmax (\begin{DoxyParamCaption}\item[{np.\+ndarray}]{values}{, }\item[{npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]}}]{mask}{, }\item[{}]{func}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}See nanargminmax.__doc__.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{sorting_8py_source_l00486}{486}} of file \mbox{\hyperlink{sorting_8py_source}{sorting.\+py}}.



Referenced by \mbox{\hyperlink{sorting_8py_source_l00453}{nargminmax()}}.

\Hypertarget{namespacepandas_1_1core_1_1sorting_a6fed5723f0a2dffd444d6b22afe32692}\index{pandas.core.sorting@{pandas.core.sorting}!\_reorder\_by\_uniques@{\_reorder\_by\_uniques}}
\index{\_reorder\_by\_uniques@{\_reorder\_by\_uniques}!pandas.core.sorting@{pandas.core.sorting}}
\doxysubsubsection{\texorpdfstring{\_reorder\_by\_uniques()}{\_reorder\_by\_uniques()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1core_1_1sorting_a6fed5723f0a2dffd444d6b22afe32692} 
 tuple\mbox{[}npt.\+NDArray\mbox{[}np.\+int64\mbox{]}, npt.\+NDArray\mbox{[}np.\+intp\mbox{]}\mbox{]} pandas.\+core.\+sorting.\+\_\+reorder\+\_\+by\+\_\+uniques (\begin{DoxyParamCaption}\item[{npt.\+NDArray\mbox{[}np.\+int64\mbox{]}}]{uniques}{, }\item[{npt.\+NDArray\mbox{[}np.\+intp\mbox{]} }]{labels}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Parameters
----------
uniques : np.ndarray[np.int64]
labels : np.ndarray[np.intp]

Returns
-------
np.ndarray[np.int64]
np.ndarray[np.intp]
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{sorting_8py_source_l00718}{718}} of file \mbox{\hyperlink{sorting_8py_source}{sorting.\+py}}.



Referenced by \mbox{\hyperlink{sorting_8py_source_l00689}{compress\+\_\+group\+\_\+index()}}.

\Hypertarget{namespacepandas_1_1core_1_1sorting_a4671f23853e5550b2dce6fcaaa13e00b}\index{pandas.core.sorting@{pandas.core.sorting}!compress\_group\_index@{compress\_group\_index}}
\index{compress\_group\_index@{compress\_group\_index}!pandas.core.sorting@{pandas.core.sorting}}
\doxysubsubsection{\texorpdfstring{compress\_group\_index()}{compress\_group\_index()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1core_1_1sorting_a4671f23853e5550b2dce6fcaaa13e00b} 
 tuple\mbox{[}npt.\+NDArray\mbox{[}np.\+int64\mbox{]}, npt.\+NDArray\mbox{[}np.\+int64\mbox{]}\mbox{]} pandas.\+core.\+sorting.\+compress\+\_\+group\+\_\+index (\begin{DoxyParamCaption}\item[{npt.\+NDArray\mbox{[}np.\+int64\mbox{]}}]{group\+\_\+index}{, }\item[{bool }]{sort}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Group_index is offsets into cartesian product of all possible labels. This
space can be huge, so this function compresses it, by computing offsets
(comp_ids) into the list of unique labels (obs_group_ids).
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{sorting_8py_source_l00687}{687}} of file \mbox{\hyperlink{sorting_8py_source}{sorting.\+py}}.



References \mbox{\hyperlink{sorting_8py_source_l00720}{\+\_\+reorder\+\_\+by\+\_\+uniques()}}.



Referenced by \mbox{\hyperlink{sorting_8py_source_l00216}{get\+\_\+compressed\+\_\+ids()}}, and \mbox{\hyperlink{sorting_8py_source_l00124}{get\+\_\+group\+\_\+index()}}.

\Hypertarget{namespacepandas_1_1core_1_1sorting_ae47f9cd7d5058c4fcd4f6f5830bb1b84}\index{pandas.core.sorting@{pandas.core.sorting}!decons\_obs\_group\_ids@{decons\_obs\_group\_ids}}
\index{decons\_obs\_group\_ids@{decons\_obs\_group\_ids}!pandas.core.sorting@{pandas.core.sorting}}
\doxysubsubsection{\texorpdfstring{decons\_obs\_group\_ids()}{decons\_obs\_group\_ids()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1core_1_1sorting_ae47f9cd7d5058c4fcd4f6f5830bb1b84} 
 list\mbox{[}npt.\+NDArray\mbox{[}np.\+intp\mbox{]}\mbox{]} pandas.\+core.\+sorting.\+decons\+\_\+obs\+\_\+group\+\_\+ids (\begin{DoxyParamCaption}\item[{npt.\+NDArray\mbox{[}np.\+intp\mbox{]}}]{comp\+\_\+ids}{, }\item[{npt.\+NDArray\mbox{[}np.\+intp\mbox{]}}]{obs\+\_\+ids}{, }\item[{Shape}]{shape}{, }\item[{Sequence\mbox{[}npt.\+NDArray\mbox{[}np.\+signedinteger\mbox{]}\mbox{]}}]{labels}{, }\item[{bool}]{xnull}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Reconstruct labels from observed group ids.

Parameters
----------
comp_ids : np.ndarray[np.intp]
obs_ids: np.ndarray[np.intp]
shape : tuple[int]
labels : Sequence[np.ndarray[np.signedinteger]]
xnull : bool
    If nulls are excluded; i.e. -1 labels are passed through.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{sorting_8py_source_l00268}{268}} of file \mbox{\hyperlink{sorting_8py_source}{sorting.\+py}}.

\Hypertarget{namespacepandas_1_1core_1_1sorting_a987539d31d22237fc43c6ee443d2120f}\index{pandas.core.sorting@{pandas.core.sorting}!ensure\_key\_mapped@{ensure\_key\_mapped}}
\index{ensure\_key\_mapped@{ensure\_key\_mapped}!pandas.core.sorting@{pandas.core.sorting}}
\doxysubsubsection{\texorpdfstring{ensure\_key\_mapped()}{ensure\_key\_mapped()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1core_1_1sorting_a987539d31d22237fc43c6ee443d2120f} 
 Array\+Like \texorpdfstring{$\vert$}{|} \mbox{\hyperlink{classpandas_1_1core_1_1indexes_1_1base_1_1Index}{Index}} \texorpdfstring{$\vert$}{|} Series pandas.\+core.\+sorting.\+ensure\+\_\+key\+\_\+mapped (\begin{DoxyParamCaption}\item[{Array\+Like \texorpdfstring{$\vert$}{|} \mbox{\hyperlink{classpandas_1_1core_1_1indexes_1_1base_1_1Index}{Index}} \texorpdfstring{$\vert$}{|} Series}]{values}{, }\item[{Callable \texorpdfstring{$\vert$}{|} None}]{key}{, }\item[{}]{levels}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Applies a callable key function to the values function and checks
that the resulting value has the same shape. Can be called on Index
subclasses, Series, DataFrames, or ndarrays.

Parameters
----------
values : Series, DataFrame, Index subclass, or ndarray
key : Optional[Callable], key to be called on the values array
levels : Optional[List], if values is a MultiIndex, list of levels to
apply the key to.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{sorting_8py_source_l00546}{546}} of file \mbox{\hyperlink{sorting_8py_source}{sorting.\+py}}.



References \mbox{\hyperlink{sorting_8py_source_l00499}{\+\_\+ensure\+\_\+key\+\_\+mapped\+\_\+multiindex()}}.



Referenced by \mbox{\hyperlink{sorting_8py_source_l00499}{\+\_\+ensure\+\_\+key\+\_\+mapped\+\_\+multiindex()}}, \mbox{\hyperlink{sorting_8py_source_l00067}{get\+\_\+indexer\+\_\+indexer()}}, \mbox{\hyperlink{sorting_8py_source_l00307}{lexsort\+\_\+indexer()}}, and \mbox{\hyperlink{sorting_8py_source_l00376}{nargsort()}}.

\Hypertarget{namespacepandas_1_1core_1_1sorting_a958d45b3afb39502d01b014cccbb7401}\index{pandas.core.sorting@{pandas.core.sorting}!get\_compressed\_ids@{get\_compressed\_ids}}
\index{get\_compressed\_ids@{get\_compressed\_ids}!pandas.core.sorting@{pandas.core.sorting}}
\doxysubsubsection{\texorpdfstring{get\_compressed\_ids()}{get\_compressed\_ids()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1core_1_1sorting_a958d45b3afb39502d01b014cccbb7401} 
 tuple\mbox{[}npt.\+NDArray\mbox{[}np.\+intp\mbox{]}, npt.\+NDArray\mbox{[}np.\+int64\mbox{]}\mbox{]} pandas.\+core.\+sorting.\+get\+\_\+compressed\+\_\+ids (\begin{DoxyParamCaption}\item[{}]{labels}{, }\item[{Shape }]{sizes}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Group_index is offsets into cartesian product of all possible labels. This
space can be huge, so this function compresses it, by computing offsets
(comp_ids) into the list of unique labels (obs_group_ids).

Parameters
----------
labels : list of label arrays
sizes : tuple[int] of size of the levels

Returns
-------
np.ndarray[np.intp]
    comp_ids
np.ndarray[np.int64]
    obs_group_ids
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{sorting_8py_source_l00214}{214}} of file \mbox{\hyperlink{sorting_8py_source}{sorting.\+py}}.



References \mbox{\hyperlink{sorting_8py_source_l00689}{compress\+\_\+group\+\_\+index()}}, and \mbox{\hyperlink{sorting_8py_source_l00124}{get\+\_\+group\+\_\+index()}}.

\Hypertarget{namespacepandas_1_1core_1_1sorting_aeb4b09b6dcedc57a6e7d13733b54e395}\index{pandas.core.sorting@{pandas.core.sorting}!get\_flattened\_list@{get\_flattened\_list}}
\index{get\_flattened\_list@{get\_flattened\_list}!pandas.core.sorting@{pandas.core.sorting}}
\doxysubsubsection{\texorpdfstring{get\_flattened\_list()}{get\_flattened\_list()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1core_1_1sorting_aeb4b09b6dcedc57a6e7d13733b54e395} 
 list\mbox{[}tuple\mbox{]} pandas.\+core.\+sorting.\+get\+\_\+flattened\+\_\+list (\begin{DoxyParamCaption}\item[{npt.\+NDArray\mbox{[}np.\+intp\mbox{]}}]{comp\+\_\+ids}{, }\item[{int}]{ngroups}{, }\item[{Iterable\mbox{[}\mbox{\hyperlink{classpandas_1_1core_1_1indexes_1_1base_1_1Index}{Index}}\mbox{]}}]{levels}{, }\item[{Iterable\mbox{[}np.\+ndarray\mbox{]}}]{labels}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Map compressed group id -> key tuple.\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{sorting_8py_source_l00594}{594}} of file \mbox{\hyperlink{sorting_8py_source}{sorting.\+py}}.

\Hypertarget{namespacepandas_1_1core_1_1sorting_adbcaea4c69033b757e68fb6f8ed6105c}\index{pandas.core.sorting@{pandas.core.sorting}!get\_group\_index@{get\_group\_index}}
\index{get\_group\_index@{get\_group\_index}!pandas.core.sorting@{pandas.core.sorting}}
\doxysubsubsection{\texorpdfstring{get\_group\_index()}{get\_group\_index()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1core_1_1sorting_adbcaea4c69033b757e68fb6f8ed6105c} 
 npt.\+NDArray\mbox{[}np.\+int64\mbox{]} pandas.\+core.\+sorting.\+get\+\_\+group\+\_\+index (\begin{DoxyParamCaption}\item[{}]{labels}{, }\item[{Shape}]{shape}{, }\item[{bool}]{sort}{, }\item[{bool }]{xnull}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}For the particular label_list, gets the offsets into the hypothetical list
representing the totally ordered cartesian product of all possible label
combinations, *as long as* this space fits within int64 bounds;
otherwise, though group indices identify unique combinations of
labels, they cannot be deconstructed.
- If `sort`, rank of returned ids preserve lexical ranks of labels.
  i.e. returned id's can be used to do lexical sort on labels;
- If `xnull` nulls (-1 labels) are passed through.

Parameters
----------
labels : sequence of arrays
    Integers identifying levels at each location
shape : tuple[int, ...]
    Number of unique levels at each location
sort : bool
    If the ranks of returned ids should match lexical ranks of labels
xnull : bool
    If true nulls are excluded. i.e. -1 values in the labels are
    passed through.

Returns
-------
An array of type int64 where two elements are equal if their corresponding
labels are equal at all location.

Notes
-----
The length of `labels` and `shape` must be identical.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{sorting_8py_source_l00122}{122}} of file \mbox{\hyperlink{sorting_8py_source}{sorting.\+py}}.



References \mbox{\hyperlink{sorting_8py_source_l00689}{compress\+\_\+group\+\_\+index()}}.



Referenced by \mbox{\hyperlink{sorting_8py_source_l00216}{get\+\_\+compressed\+\_\+ids()}}, and \mbox{\hyperlink{sorting_8py_source_l00613}{get\+\_\+indexer\+\_\+dict()}}.

\Hypertarget{namespacepandas_1_1core_1_1sorting_a508c4e5b564f2354194bf7a44b6df8e7}\index{pandas.core.sorting@{pandas.core.sorting}!get\_group\_index\_sorter@{get\_group\_index\_sorter}}
\index{get\_group\_index\_sorter@{get\_group\_index\_sorter}!pandas.core.sorting@{pandas.core.sorting}}
\doxysubsubsection{\texorpdfstring{get\_group\_index\_sorter()}{get\_group\_index\_sorter()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1core_1_1sorting_a508c4e5b564f2354194bf7a44b6df8e7} 
 npt.\+NDArray\mbox{[}np.\+intp\mbox{]} pandas.\+core.\+sorting.\+get\+\_\+group\+\_\+index\+\_\+sorter (\begin{DoxyParamCaption}\item[{npt.\+NDArray\mbox{[}np.\+intp\mbox{]}}]{group\+\_\+index}{, }\item[{int \texorpdfstring{$\vert$}{|} None }]{ngroups}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}algos.groupsort_indexer implements `counting sort` and it is at least
O(ngroups), where
    ngroups = prod(shape)
    shape = map(len, keys)
that is, linear in the number of combinations (cartesian product) of unique
values of groupby keys. This can be huge when doing multi-key groupby.
np.argsort(kind='mergesort') is O(count x log(count)) where count is the
length of the data-frame;
Both algorithms are `stable` sort and that is necessary for correctness of
groupby operations. e.g. consider:
    df.groupby(key)[col].transform('first')

Parameters
----------
group_index : np.ndarray[np.intp]
    signed integer dtype
ngroups : int or None, default None

Returns
-------
np.ndarray[np.intp]
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{sorting_8py_source_l00644}{644}} of file \mbox{\hyperlink{sorting_8py_source}{sorting.\+py}}.



Referenced by \mbox{\hyperlink{sorting_8py_source_l00613}{get\+\_\+indexer\+\_\+dict()}}.

\Hypertarget{namespacepandas_1_1core_1_1sorting_ac2f9b61304768d12c21ff05d08e6f739}\index{pandas.core.sorting@{pandas.core.sorting}!get\_indexer\_dict@{get\_indexer\_dict}}
\index{get\_indexer\_dict@{get\_indexer\_dict}!pandas.core.sorting@{pandas.core.sorting}}
\doxysubsubsection{\texorpdfstring{get\_indexer\_dict()}{get\_indexer\_dict()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1core_1_1sorting_ac2f9b61304768d12c21ff05d08e6f739} 
 dict\mbox{[}Hashable, npt.\+NDArray\mbox{[}np.\+intp\mbox{]}\mbox{]} pandas.\+core.\+sorting.\+get\+\_\+indexer\+\_\+dict (\begin{DoxyParamCaption}\item[{list\mbox{[}np.\+ndarray\mbox{]}}]{label\+\_\+list}{, }\item[{list\mbox{[}\mbox{\hyperlink{classpandas_1_1core_1_1indexes_1_1base_1_1Index}{Index}}\mbox{]} }]{keys}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns
-------
dict:
    Labels mapped to indexers.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{sorting_8py_source_l00611}{611}} of file \mbox{\hyperlink{sorting_8py_source}{sorting.\+py}}.



References \mbox{\hyperlink{sorting_8py_source_l00124}{get\+\_\+group\+\_\+index()}}, and \mbox{\hyperlink{sorting_8py_source_l00646}{get\+\_\+group\+\_\+index\+\_\+sorter()}}.

\Hypertarget{namespacepandas_1_1core_1_1sorting_a5d59af530c66d30bee514adae3065f97}\index{pandas.core.sorting@{pandas.core.sorting}!get\_indexer\_indexer@{get\_indexer\_indexer}}
\index{get\_indexer\_indexer@{get\_indexer\_indexer}!pandas.core.sorting@{pandas.core.sorting}}
\doxysubsubsection{\texorpdfstring{get\_indexer\_indexer()}{get\_indexer\_indexer()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1core_1_1sorting_a5d59af530c66d30bee514adae3065f97} 
 npt.\+NDArray\mbox{[}np.\+intp\mbox{]} \texorpdfstring{$\vert$}{|} None pandas.\+core.\+sorting.\+get\+\_\+indexer\+\_\+indexer (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classpandas_1_1core_1_1indexes_1_1base_1_1Index}{Index}}}]{target}{, }\item[{Level \texorpdfstring{$\vert$}{|} list\mbox{[}Level\mbox{]} \texorpdfstring{$\vert$}{|} None}]{level}{, }\item[{list\mbox{[}bool\mbox{]} \texorpdfstring{$\vert$}{|} bool}]{ascending}{, }\item[{Sort\+Kind}]{kind}{, }\item[{Na\+Position}]{na\+\_\+position}{, }\item[{bool}]{sort\+\_\+remaining}{, }\item[{Index\+Key\+Func}]{key}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Helper method that return the indexer according to input parameters for
the sort_index method of DataFrame and Series.

Parameters
----------
target : Index
level : int or level name or list of ints or list of level names
ascending : bool or list of bools, default True
kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}
na_position : {'first', 'last'}
sort_remaining : bool
key : callable, optional

Returns
-------
Optional[ndarray[intp]]
    The indexer for the new index.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{sorting_8py_source_l00059}{59}} of file \mbox{\hyperlink{sorting_8py_source}{sorting.\+py}}.



References \mbox{\hyperlink{sorting_8py_source_l00548}{ensure\+\_\+key\+\_\+mapped()}}, \mbox{\hyperlink{sorting_8py_source_l00307}{lexsort\+\_\+indexer()}}, and \mbox{\hyperlink{sorting_8py_source_l00376}{nargsort()}}.

\Hypertarget{namespacepandas_1_1core_1_1sorting_a6ae8cf75c93f330b36b0d473c588b747}\index{pandas.core.sorting@{pandas.core.sorting}!is\_int64\_overflow\_possible@{is\_int64\_overflow\_possible}}
\index{is\_int64\_overflow\_possible@{is\_int64\_overflow\_possible}!pandas.core.sorting@{pandas.core.sorting}}
\doxysubsubsection{\texorpdfstring{is\_int64\_overflow\_possible()}{is\_int64\_overflow\_possible()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1core_1_1sorting_a6ae8cf75c93f330b36b0d473c588b747} 
 bool pandas.\+core.\+sorting.\+is\+\_\+int64\+\_\+overflow\+\_\+possible (\begin{DoxyParamCaption}\item[{Shape}]{shape}{}\end{DoxyParamCaption})}



Definition at line \mbox{\hyperlink{sorting_8py_source_l00238}{238}} of file \mbox{\hyperlink{sorting_8py_source}{sorting.\+py}}.

\Hypertarget{namespacepandas_1_1core_1_1sorting_a984c5ea1947ec578cdaff655702df5a3}\index{pandas.core.sorting@{pandas.core.sorting}!lexsort\_indexer@{lexsort\_indexer}}
\index{lexsort\_indexer@{lexsort\_indexer}!pandas.core.sorting@{pandas.core.sorting}}
\doxysubsubsection{\texorpdfstring{lexsort\_indexer()}{lexsort\_indexer()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1core_1_1sorting_a984c5ea1947ec578cdaff655702df5a3} 
 npt.\+NDArray\mbox{[}np.\+intp\mbox{]} pandas.\+core.\+sorting.\+lexsort\+\_\+indexer (\begin{DoxyParamCaption}\item[{Sequence\mbox{[}Array\+Like \texorpdfstring{$\vert$}{|} \mbox{\hyperlink{classpandas_1_1core_1_1indexes_1_1base_1_1Index}{Index}} \texorpdfstring{$\vert$}{|} Series\mbox{]}}]{keys}{, }\item[{}]{orders}{ = {\ttfamily None}, }\item[{str }]{na\+\_\+position}{ = {\ttfamily "{}last"{}}, }\item[{Callable \texorpdfstring{$\vert$}{|} None }]{key}{ = {\ttfamily None}, }\item[{bool }]{codes\+\_\+given}{ = {\ttfamily False}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Performs lexical sorting on a set of keys

Parameters
----------
keys : Sequence[ArrayLike | Index | Series]
    Sequence of arrays to be sorted by the indexer
    Sequence[Series] is only if key is not None.
orders : bool or list of booleans, optional
    Determines the sorting order for each element in keys. If a list,
    it must be the same length as keys. This determines whether the
    corresponding element in keys should be sorted in ascending
    (True) or descending (False) order. if bool, applied to all
    elements as above. if None, defaults to True.
na_position : {'first', 'last'}, default 'last'
    Determines placement of NA elements in the sorted list ("last" or "first")
key : Callable, optional
    Callable key function applied to every element in keys before sorting
codes_given: bool, False
    Avoid categorical materialization if codes are already provided.

Returns
-------
np.ndarray[np.intp]
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{sorting_8py_source_l00301}{301}} of file \mbox{\hyperlink{sorting_8py_source}{sorting.\+py}}.



References \mbox{\hyperlink{sorting_8py_source_l00548}{ensure\+\_\+key\+\_\+mapped()}}.



Referenced by \mbox{\hyperlink{sorting_8py_source_l00067}{get\+\_\+indexer\+\_\+indexer()}}.

\Hypertarget{namespacepandas_1_1core_1_1sorting_acc3cdcbfcd60d2253e7e843f254a8d6b}\index{pandas.core.sorting@{pandas.core.sorting}!nargminmax@{nargminmax}}
\index{nargminmax@{nargminmax}!pandas.core.sorting@{pandas.core.sorting}}
\doxysubsubsection{\texorpdfstring{nargminmax()}{nargminmax()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1core_1_1sorting_acc3cdcbfcd60d2253e7e843f254a8d6b} 
pandas.\+core.\+sorting.\+nargminmax (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classpandas_1_1core_1_1arrays_1_1base_1_1ExtensionArray}{Extension\+Array}}}]{values}{, }\item[{str}]{method}{, }\item[{Axis\+Int }]{axis}{ = {\ttfamily 0}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Implementation of np.argmin/argmax but for ExtensionArray and which
handles missing values.

Parameters
----------
values : ExtensionArray
method : {"argmax", "argmin"}
axis : int, default 0

Returns
-------
int
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{sorting_8py_source_l00453}{453}} of file \mbox{\hyperlink{sorting_8py_source}{sorting.\+py}}.



References \mbox{\hyperlink{sorting_8py_source_l00486}{\+\_\+nanargminmax()}}.

\Hypertarget{namespacepandas_1_1core_1_1sorting_add1268682e9720be5e4682def9a832ed}\index{pandas.core.sorting@{pandas.core.sorting}!nargsort@{nargsort}}
\index{nargsort@{nargsort}!pandas.core.sorting@{pandas.core.sorting}}
\doxysubsubsection{\texorpdfstring{nargsort()}{nargsort()}}
{\footnotesize\ttfamily \label{namespacepandas_1_1core_1_1sorting_add1268682e9720be5e4682def9a832ed} 
 npt.\+NDArray\mbox{[}np.\+intp\mbox{]} pandas.\+core.\+sorting.\+nargsort (\begin{DoxyParamCaption}\item[{Array\+Like \texorpdfstring{$\vert$}{|} \mbox{\hyperlink{classpandas_1_1core_1_1indexes_1_1base_1_1Index}{Index}} \texorpdfstring{$\vert$}{|} Series}]{items}{, }\item[{Sort\+Kind }]{kind}{ = {\ttfamily "{}quicksort"{}}, }\item[{bool }]{ascending}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}, }\item[{str }]{na\+\_\+position}{ = {\ttfamily "{}last"{}}, }\item[{Callable \texorpdfstring{$\vert$}{|} None }]{key}{ = {\ttfamily None}, }\item[{npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]} \texorpdfstring{$\vert$}{|} None }]{mask}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Intended to be a drop-in replacement for np.argsort which handles NaNs.

Adds ascending, na_position, and key parameters.

(GH #6399, #5231, #27237)

Parameters
----------
items : np.ndarray, ExtensionArray, Index, or Series
kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, default 'quicksort'
ascending : bool, default True
na_position : {'first', 'last'}, default 'last'
key : Optional[Callable], default None
mask : Optional[np.ndarray[bool]], default None
    Passed when called by ExtensionArray.argsort.

Returns
-------
np.ndarray[np.intp]
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{sorting_8py_source_l00369}{369}} of file \mbox{\hyperlink{sorting_8py_source}{sorting.\+py}}.



References \mbox{\hyperlink{sorting_8py_source_l00548}{ensure\+\_\+key\+\_\+mapped()}}, and \mbox{\hyperlink{sorting_8py_source_l00376}{nargsort()}}.



Referenced by \mbox{\hyperlink{sorting_8py_source_l00067}{get\+\_\+indexer\+\_\+indexer()}}, and \mbox{\hyperlink{sorting_8py_source_l00376}{nargsort()}}.

