\doxysection{scipy.\+interpolate.\+\_\+cubic.\+Cubic\+Spline Class Reference}
\hypertarget{classscipy_1_1interpolate_1_1__cubic_1_1CubicSpline}{}\label{classscipy_1_1interpolate_1_1__cubic_1_1CubicSpline}\index{scipy.interpolate.\_cubic.CubicSpline@{scipy.interpolate.\_cubic.CubicSpline}}


Inheritance diagram for scipy.\+interpolate.\+\_\+cubic.\+Cubic\+Spline\+:
% FIG 0


Collaboration diagram for scipy.\+interpolate.\+\_\+cubic.\+Cubic\+Spline\+:
% FIG 1
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classscipy_1_1interpolate_1_1__cubic_1_1CubicSpline_ae9eb15c7221b39cf36d0dfa46bb67049}{\+\_\+\+\_\+init\+\_\+\+\_\+}} (self, x, y, axis=0, bc\+\_\+type=\textquotesingle{}not-\/a-\/knot\textquotesingle{}, extrapolate=None)
\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions inherited from \mbox{\hyperlink{classscipy_1_1interpolate_1_1__cubic_1_1CubicHermiteSpline}{scipy.\+interpolate.\+\_\+cubic.\+Cubic\+Hermite\+Spline}}}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classscipy_1_1interpolate_1_1__cubic_1_1CubicHermiteSpline_aeab23c65479ad365f8c330c1dbea2c07}{\+\_\+\+\_\+init\+\_\+\+\_\+}} (self, x, y, dydx, axis=0, extrapolate=None)
\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions inherited from \mbox{\hyperlink{classscipy_1_1interpolate_1_1__interpolate_1_1PPoly}{scipy.\+interpolate.\+\_\+interpolate.\+PPoly}}}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classscipy_1_1interpolate_1_1__interpolate_1_1PPoly_aa4f9a9dd9fffd9b089bbaa43e004668d}{derivative}} (self, nu=1)
\item 
\mbox{\hyperlink{classscipy_1_1interpolate_1_1__interpolate_1_1PPoly_a2c1c887eac36de341307e424419b37ad}{antiderivative}} (self, nu=1)
\item 
\mbox{\hyperlink{classscipy_1_1interpolate_1_1__interpolate_1_1PPoly_a5f4da82c42e8806aa63f176ebb6552b6}{integrate}} (self, a, b, extrapolate=None)
\item 
\mbox{\hyperlink{classscipy_1_1interpolate_1_1__interpolate_1_1PPoly_ae451619e65b098febdfc488ed0779b95}{solve}} (self, y=0., discontinuity=\mbox{\hyperlink{classTrue}{True}}, extrapolate=None)
\item 
\mbox{\hyperlink{classscipy_1_1interpolate_1_1__interpolate_1_1PPoly_a01b94f6410111c4133c9d6eecdedbf50}{roots}} (self, discontinuity=\mbox{\hyperlink{classTrue}{True}}, extrapolate=None)
\item 
\mbox{\hyperlink{classscipy_1_1interpolate_1_1__interpolate_1_1PPoly_a8d8b2937fb94854b3e8d4362b7436c33}{from\+\_\+spline}} (cls, tck, extrapolate=None)
\item 
\mbox{\hyperlink{classscipy_1_1interpolate_1_1__interpolate_1_1PPoly_ac1417679842f7deb630ac0ce475bbaa4}{from\+\_\+bernstein\+\_\+basis}} (cls, bp, extrapolate=None)
\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions inherited from \mbox{\hyperlink{classscipy_1_1interpolate_1_1__interpolate_1_1__PPolyBase}{scipy.\+interpolate.\+\_\+interpolate.\+\_\+\+PPoly\+Base}}}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classscipy_1_1interpolate_1_1__interpolate_1_1__PPolyBase_ab80ebd4c99bd98dee588215a01b0e8b3}{\+\_\+\+\_\+init\+\_\+\+\_\+}} (self, c, x, extrapolate=None, axis=0)
\item 
\mbox{\hyperlink{classscipy_1_1interpolate_1_1__interpolate_1_1__PPolyBase_a47abbddbea8e891424a18c1d01e979f2}{construct\+\_\+fast}} (cls, c, x, extrapolate=None, axis=0)
\item 
\mbox{\hyperlink{classscipy_1_1interpolate_1_1__interpolate_1_1__PPolyBase_ac93a5c8f2a289b5a85d6017ed4a1423f}{extend}} (self, c, x)
\item 
\mbox{\hyperlink{classscipy_1_1interpolate_1_1__interpolate_1_1__PPolyBase_ab7b1749a9bb0635c809cec4d1f8718b9}{\+\_\+\+\_\+call\+\_\+\+\_\+}} (self, x, nu=0, extrapolate=None)
\end{DoxyCompactItemize}
\doxysubsubsection*{Static Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classscipy_1_1interpolate_1_1__cubic_1_1CubicSpline_aee4b9ed4805aa805a7b2af267311801c}{\+\_\+validate\+\_\+bc}} (bc\+\_\+type, y, expected\+\_\+deriv\+\_\+shape, axis)
\end{DoxyCompactItemize}
\doxysubsubsection*{Additional Inherited Members}
\doxysubsection*{Public Attributes inherited from \mbox{\hyperlink{classscipy_1_1interpolate_1_1__interpolate_1_1__PPolyBase}{scipy.\+interpolate.\+\_\+interpolate.\+\_\+\+PPoly\+Base}}}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classscipy_1_1interpolate_1_1__interpolate_1_1__PPolyBase_a32aecbb2004c9f3289a0b4bbed3f6b60}{c}} = np.\+asarray(c)
\item 
\mbox{\hyperlink{classscipy_1_1interpolate_1_1__interpolate_1_1__PPolyBase_a45a7b8abb6950064c227c3faa81a4e22}{x}} = np.\+ascontiguousarray(x, dtype=np.\+float64)
\item 
\mbox{\hyperlink{classscipy_1_1interpolate_1_1__interpolate_1_1__PPolyBase_a8ced0b6deba8fce9e49bbc7626f8f978}{extrapolate}} = extrapolate
\item 
\mbox{\hyperlink{classscipy_1_1interpolate_1_1__interpolate_1_1__PPolyBase_a2a1171aedb8f833241e95d3b5ef13e45}{axis}} = axis
\end{DoxyCompactItemize}
\doxysubsection*{Protected Member Functions inherited from \mbox{\hyperlink{classscipy_1_1interpolate_1_1__interpolate_1_1PPoly}{scipy.\+interpolate.\+\_\+interpolate.\+PPoly}}}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classscipy_1_1interpolate_1_1__interpolate_1_1PPoly_ab75d51e8506e8bca6921c11bbf351441}{\+\_\+evaluate}} (self, x, nu, extrapolate, out)
\end{DoxyCompactItemize}
\doxysubsection*{Protected Member Functions inherited from \mbox{\hyperlink{classscipy_1_1interpolate_1_1__interpolate_1_1__PPolyBase}{scipy.\+interpolate.\+\_\+interpolate.\+\_\+\+PPoly\+Base}}}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classscipy_1_1interpolate_1_1__interpolate_1_1__PPolyBase_a804d5a43c1a1109e1f9d146d1378ffbb}{\+\_\+get\+\_\+dtype}} (self, dtype)
\item 
\mbox{\hyperlink{classscipy_1_1interpolate_1_1__interpolate_1_1__PPolyBase_a1c482dd4c4890596d4c60a754802581e}{\+\_\+ensure\+\_\+c\+\_\+contiguous}} (self)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\begin{DoxyVerb}Cubic spline data interpolator.

Interpolate data with a piecewise cubic polynomial which is twice
continuously differentiable [1]_. The result is represented as a `PPoly`
instance with breakpoints matching the given data.

Parameters
----------
x : array_like, shape (n,)
    1-D array containing values of the independent variable.
    Values must be real, finite and in strictly increasing order.
y : array_like
    Array containing values of the dependent variable. It can have
    arbitrary number of dimensions, but the length along ``axis``
    (see below) must match the length of ``x``. Values must be finite.
axis : int, optional
    Axis along which `y` is assumed to be varying. Meaning that for
    ``x[i]`` the corresponding values are ``np.take(y, i, axis=axis)``.
    Default is 0.
bc_type : string or 2-tuple, optional
    Boundary condition type. Two additional equations, given by the
    boundary conditions, are required to determine all coefficients of
    polynomials on each segment [2]_.

    If `bc_type` is a string, then the specified condition will be applied
    at both ends of a spline. Available conditions are:

    * 'not-a-knot' (default): The first and second segment at a curve end
      are the same polynomial. It is a good default when there is no
      information on boundary conditions.
    * 'periodic': The interpolated functions is assumed to be periodic
      of period ``x[-1] - x[0]``. The first and last value of `y` must be
      identical: ``y[0] == y[-1]``. This boundary condition will result in
      ``y'[0] == y'[-1]`` and ``y''[0] == y''[-1]``.
    * 'clamped': The first derivative at curves ends are zero. Assuming
      a 1D `y`, ``bc_type=((1, 0.0), (1, 0.0))`` is the same condition.
    * 'natural': The second derivative at curve ends are zero. Assuming
      a 1D `y`, ``bc_type=((2, 0.0), (2, 0.0))`` is the same condition.

    If `bc_type` is a 2-tuple, the first and the second value will be
    applied at the curve start and end respectively. The tuple values can
    be one of the previously mentioned strings (except 'periodic') or a
    tuple `(order, deriv_values)` allowing to specify arbitrary
    derivatives at curve ends:

    * `order`: the derivative order, 1 or 2.
    * `deriv_value`: array_like containing derivative values, shape must
      be the same as `y`, excluding ``axis`` dimension. For example, if
      `y` is 1-D, then `deriv_value` must be a scalar. If `y` is 3-D with
      the shape (n0, n1, n2) and axis=2, then `deriv_value` must be 2-D
      and have the shape (n0, n1).
extrapolate : {bool, 'periodic', None}, optional
    If bool, determines whether to extrapolate to out-of-bounds points
    based on first and last intervals, or to return NaNs. If 'periodic',
    periodic extrapolation is used. If None (default), ``extrapolate`` is
    set to 'periodic' for ``bc_type='periodic'`` and to True otherwise.

Attributes
----------
x : ndarray, shape (n,)
    Breakpoints. The same ``x`` which was passed to the constructor.
c : ndarray, shape (4, n-1, ...)
    Coefficients of the polynomials on each segment. The trailing
    dimensions match the dimensions of `y`, excluding ``axis``.
    For example, if `y` is 1-d, then ``c[k, i]`` is a coefficient for
    ``(x-x[i])**(3-k)`` on the segment between ``x[i]`` and ``x[i+1]``.
axis : int
    Interpolation axis. The same axis which was passed to the
    constructor.

Methods
-------
__call__
derivative
antiderivative
integrate
roots

See Also
--------
Akima1DInterpolator : Akima 1D interpolator.
PchipInterpolator : PCHIP 1-D monotonic cubic interpolator.
PPoly : Piecewise polynomial in terms of coefficients and breakpoints.

Notes
-----
Parameters `bc_type` and ``extrapolate`` work independently, i.e. the
former controls only construction of a spline, and the latter only
evaluation.

When a boundary condition is 'not-a-knot' and n = 2, it is replaced by
a condition that the first derivative is equal to the linear interpolant
slope. When both boundary conditions are 'not-a-knot' and n = 3, the
solution is sought as a parabola passing through given points.

When 'not-a-knot' boundary conditions is applied to both ends, the
resulting spline will be the same as returned by `splrep` (with ``s=0``)
and `InterpolatedUnivariateSpline`, but these two methods use a
representation in B-spline basis.

.. versionadded:: 0.18.0

Examples
--------
In this example the cubic spline is used to interpolate a sampled sinusoid.
You can see that the spline continuity property holds for the first and
second derivatives and violates only for the third derivative.

>>> import numpy as np
>>> from scipy.interpolate import CubicSpline
>>> import matplotlib.pyplot as plt
>>> x = np.arange(10)
>>> y = np.sin(x)
>>> cs = CubicSpline(x, y)
>>> xs = np.arange(-0.5, 9.6, 0.1)
>>> fig, ax = plt.subplots(figsize=(6.5, 4))
>>> ax.plot(x, y, 'o', label='data')
>>> ax.plot(xs, np.sin(xs), label='true')
>>> ax.plot(xs, cs(xs), label="S")
>>> ax.plot(xs, cs(xs, 1), label="S'")
>>> ax.plot(xs, cs(xs, 2), label="S''")
>>> ax.plot(xs, cs(xs, 3), label="S'''")
>>> ax.set_xlim(-0.5, 9.5)
>>> ax.legend(loc='lower left', ncol=2)
>>> plt.show()

In the second example, the unit circle is interpolated with a spline. A
periodic boundary condition is used. You can see that the first derivative
values, ds/dx=0, ds/dy=1 at the periodic point (1, 0) are correctly
computed. Note that a circle cannot be exactly represented by a cubic
spline. To increase precision, more breakpoints would be required.

>>> theta = 2 * np.pi * np.linspace(0, 1, 5)
>>> y = np.c_[np.cos(theta), np.sin(theta)]
>>> cs = CubicSpline(theta, y, bc_type='periodic')
>>> print("ds/dx={:.1f} ds/dy={:.1f}".format(cs(0, 1)[0], cs(0, 1)[1]))
ds/dx=0.0 ds/dy=1.0
>>> xs = 2 * np.pi * np.linspace(0, 1, 100)
>>> fig, ax = plt.subplots(figsize=(6.5, 4))
>>> ax.plot(y[:, 0], y[:, 1], 'o', label='data')
>>> ax.plot(np.cos(xs), np.sin(xs), label='true')
>>> ax.plot(cs(xs)[:, 0], cs(xs)[:, 1], label='spline')
>>> ax.axes.set_aspect('equal')
>>> ax.legend(loc='center')
>>> plt.show()

The third example is the interpolation of a polynomial y = x**3 on the
interval 0 <= x<= 1. A cubic spline can represent this function exactly.
To achieve that we need to specify values and first derivatives at
endpoints of the interval. Note that y' = 3 * x**2 and thus y'(0) = 0 and
y'(1) = 3.

>>> cs = CubicSpline([0, 1], [0, 1], bc_type=((1, 0), (1, 3)))
>>> x = np.linspace(0, 1)
>>> np.allclose(x**3, cs(x))
True

References
----------
.. [1] `Cubic Spline Interpolation
        <https://en.wikiversity.org/wiki/Cubic_Spline_Interpolation>`_
        on Wikiversity.
.. [2] Carl de Boor, "A Practical Guide to Splines", Springer-Verlag, 1978.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__cubic_8py_source_l00469}{469}} of file \mbox{\hyperlink{__cubic_8py_source}{\+\_\+cubic.\+py}}.



\doxysubsection{Constructor \& Destructor Documentation}
\Hypertarget{classscipy_1_1interpolate_1_1__cubic_1_1CubicSpline_ae9eb15c7221b39cf36d0dfa46bb67049}\index{scipy.interpolate.\_cubic.CubicSpline@{scipy.interpolate.\_cubic.CubicSpline}!\_\_init\_\_@{\_\_init\_\_}}
\index{\_\_init\_\_@{\_\_init\_\_}!scipy.interpolate.\_cubic.CubicSpline@{scipy.interpolate.\_cubic.CubicSpline}}
\doxysubsubsection{\texorpdfstring{\_\_init\_\_()}{\_\_init\_\_()}}
{\footnotesize\ttfamily \label{classscipy_1_1interpolate_1_1__cubic_1_1CubicSpline_ae9eb15c7221b39cf36d0dfa46bb67049} 
scipy.\+interpolate.\+\_\+cubic.\+Cubic\+Spline.\+\_\+\+\_\+init\+\_\+\+\_\+ (\begin{DoxyParamCaption}\item[{}]{self}{, }\item[{}]{x}{, }\item[{}]{y}{, }\item[{}]{axis}{ = {\ttfamily 0}, }\item[{}]{bc\+\_\+type}{ = {\ttfamily \textquotesingle{}not-\/a-\/knot\textquotesingle{}}, }\item[{}]{extrapolate}{ = {\ttfamily None}}\end{DoxyParamCaption})}



Definition at line \mbox{\hyperlink{__cubic_8py_source_l00635}{635}} of file \mbox{\hyperlink{__cubic_8py_source}{\+\_\+cubic.\+py}}.



Referenced by \mbox{\hyperlink{kernels_8py_source_l00178}{sklearn.\+gaussian\+\_\+process.\+kernels.\+Kernel.\+get\+\_\+params()}}, and \mbox{\hyperlink{__distn__infrastructure_8py_source_l00643}{scipy.\+stats.\+\_\+distn\+\_\+infrastructure.\+rv\+\_\+generic.\+random\+\_\+state()}}.



\doxysubsection{Member Function Documentation}
\Hypertarget{classscipy_1_1interpolate_1_1__cubic_1_1CubicSpline_aee4b9ed4805aa805a7b2af267311801c}\index{scipy.interpolate.\_cubic.CubicSpline@{scipy.interpolate.\_cubic.CubicSpline}!\_validate\_bc@{\_validate\_bc}}
\index{\_validate\_bc@{\_validate\_bc}!scipy.interpolate.\_cubic.CubicSpline@{scipy.interpolate.\_cubic.CubicSpline}}
\doxysubsubsection{\texorpdfstring{\_validate\_bc()}{\_validate\_bc()}}
{\footnotesize\ttfamily \label{classscipy_1_1interpolate_1_1__cubic_1_1CubicSpline_aee4b9ed4805aa805a7b2af267311801c} 
scipy.\+interpolate.\+\_\+cubic.\+Cubic\+Spline.\+\_\+validate\+\_\+bc (\begin{DoxyParamCaption}\item[{}]{bc\+\_\+type}{, }\item[{}]{y}{, }\item[{}]{expected\+\_\+deriv\+\_\+shape}{, }\item[{}]{axis}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [protected]}}

\begin{DoxyVerb}Validate and prepare boundary conditions.

Returns
-------
validated_bc : 2-tuple
    Boundary conditions for a curve start and end.
y : ndarray
    y casted to complex dtype if one of the boundary conditions has
    complex dtype.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__cubic_8py_source_l00799}{799}} of file \mbox{\hyperlink{__cubic_8py_source}{\+\_\+cubic.\+py}}.



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/home/jam/\+Research/\+IRES-\/2025/dev/src/llm-\/scripts/testing/hypothesis-\/testing/hyp-\/env/lib/python3.\+12/site-\/packages/scipy/interpolate/\+\_\+cubic.\+py\end{DoxyCompactItemize}
