\doxysection{numpy.\+lib.\+arraypad Namespace Reference}
\hypertarget{namespacenumpy_1_1lib_1_1arraypad}{}\label{namespacenumpy_1_1lib_1_1arraypad}\index{numpy.lib.arraypad@{numpy.lib.arraypad}}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1arraypad_aa7460d8995330adb81edac72607c5f79}{\+\_\+round\+\_\+if\+\_\+needed}} (arr, dtype)
\begin{DoxyCompactList}\small\item\em Private utility functions. \end{DoxyCompactList}\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1arraypad_a02c6a68eb64f5bb61960e803dd07c884}{\+\_\+slice\+\_\+at\+\_\+axis}} (sl, axis)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1arraypad_a14ce2ba54b8417fc3a481a4c5ba69cd6}{\+\_\+view\+\_\+roi}} (array, original\+\_\+area\+\_\+slice, axis)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1arraypad_a39919b9582e52a6ffafa42c81c1e1d60}{\+\_\+pad\+\_\+simple}} (array, pad\+\_\+width, fill\+\_\+value=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1arraypad_a9b1898525b60749417fc05922db9c872}{\+\_\+set\+\_\+pad\+\_\+area}} (padded, axis, width\+\_\+pair, value\+\_\+pair)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1arraypad_a841b9954aae119493d6e5e1536195778}{\+\_\+get\+\_\+edges}} (padded, axis, width\+\_\+pair)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1arraypad_a1b6398a036646fe6b7c4ab4e5ff6c1bd}{\+\_\+get\+\_\+linear\+\_\+ramps}} (padded, axis, width\+\_\+pair, end\+\_\+value\+\_\+pair)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1arraypad_a3ddb7169260593afb561b47396788518}{\+\_\+get\+\_\+stats}} (padded, axis, width\+\_\+pair, length\+\_\+pair, stat\+\_\+func)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1arraypad_a199e591eaea076f82376e77b7908be7f}{\+\_\+set\+\_\+reflect\+\_\+both}} (padded, axis, width\+\_\+pair, method, include\+\_\+edge=False)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1arraypad_a72cbe94181cd26959c72012d89266b7a}{\+\_\+set\+\_\+wrap\+\_\+both}} (padded, axis, width\+\_\+pair, original\+\_\+period)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1arraypad_ae6b964186a3e797729b4c3c289e11a4a}{\+\_\+as\+\_\+pairs}} (x, \mbox{\hyperlink{namespacenumpy_1_1core_1_1fromnumeric_a9dfc7f1d399bd7dbdd89ecb52594e20d}{ndim}}, as\+\_\+index=False)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1arraypad_ac8dad4ff5561deb84a6922067d71ce93}{\+\_\+pad\+\_\+dispatcher}} (array, pad\+\_\+width, mode=None, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}kwargs)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1arraypad_a03f6ba7ccefaab37a09357632bdcd7b7}{pad}} (array, pad\+\_\+width, mode=\textquotesingle{}constant\textquotesingle{}, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}kwargs)
\begin{DoxyCompactList}\small\item\em Public functions. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
list \mbox{\hyperlink{namespacenumpy_1_1lib_1_1arraypad_a39de842c5f73c6e9b02643a33ed2ad26}{\+\_\+\+\_\+all\+\_\+\+\_\+}} = \mbox{[}\textquotesingle{}\mbox{\hyperlink{namespacenumpy_1_1lib_1_1arraypad_a03f6ba7ccefaab37a09357632bdcd7b7}{pad}}\textquotesingle{}\mbox{]}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\begin{DoxyVerb}The arraypad module contains a group of functions to pad values onto the edges
of an n-dimensional array.
\end{DoxyVerb}
 

\doxysubsection{Function Documentation}
\Hypertarget{namespacenumpy_1_1lib_1_1arraypad_ae6b964186a3e797729b4c3c289e11a4a}\index{numpy.lib.arraypad@{numpy.lib.arraypad}!\_as\_pairs@{\_as\_pairs}}
\index{\_as\_pairs@{\_as\_pairs}!numpy.lib.arraypad@{numpy.lib.arraypad}}
\doxysubsubsection{\texorpdfstring{\_as\_pairs()}{\_as\_pairs()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1arraypad_ae6b964186a3e797729b4c3c289e11a4a} 
numpy.\+lib.\+arraypad.\+\_\+as\+\_\+pairs (\begin{DoxyParamCaption}\item[{}]{x}{, }\item[{}]{ndim}{, }\item[{}]{as\+\_\+index}{ = {\ttfamily False}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Broadcast `x` to an array with the shape (`ndim`, 2).

A helper function for `pad` that prepares and validates arguments like
`pad_width` for iteration in pairs.

Parameters
----------
x : {None, scalar, array-like}
    The object to broadcast to the shape (`ndim`, 2).
ndim : int
    Number of pairs the broadcasted `x` will have.
as_index : bool, optional
    If `x` is not None, try to round each element of `x` to an integer
    (dtype `np.intp`) and ensure every element is positive.

Returns
-------
pairs : nested iterables, shape (`ndim`, 2)
    The broadcasted version of `x`.

Raises
------
ValueError
    If `as_index` is True and `x` contains negative elements.
    Or if `x` is not broadcastable to the shape (`ndim`, 2).
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{arraypad_8py_source_l00458}{458}} of file \mbox{\hyperlink{arraypad_8py_source}{arraypad.\+py}}.



Referenced by \mbox{\hyperlink{arraypad_8py_source_l00534}{pad()}}, \mbox{\hyperlink{test__arraypad_8py_source_l00090}{numpy.\+lib.\+tests.\+test\+\_\+arraypad.\+Test\+As\+Pairs.\+test\+\_\+as\+\_\+index()}}, \mbox{\hyperlink{test__arraypad_8py_source_l00105}{numpy.\+lib.\+tests.\+test\+\_\+arraypad.\+Test\+As\+Pairs.\+test\+\_\+exceptions()}}, \mbox{\hyperlink{test__arraypad_8py_source_l00082}{numpy.\+lib.\+tests.\+test\+\_\+arraypad.\+Test\+As\+Pairs.\+test\+\_\+pass\+\_\+through()}}, \mbox{\hyperlink{test__arraypad_8py_source_l00033}{numpy.\+lib.\+tests.\+test\+\_\+arraypad.\+Test\+As\+Pairs.\+test\+\_\+single\+\_\+value()}}, and \mbox{\hyperlink{test__arraypad_8py_source_l00046}{numpy.\+lib.\+tests.\+test\+\_\+arraypad.\+Test\+As\+Pairs.\+test\+\_\+two\+\_\+values()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1arraypad_a841b9954aae119493d6e5e1536195778}\index{numpy.lib.arraypad@{numpy.lib.arraypad}!\_get\_edges@{\_get\_edges}}
\index{\_get\_edges@{\_get\_edges}!numpy.lib.arraypad@{numpy.lib.arraypad}}
\doxysubsubsection{\texorpdfstring{\_get\_edges()}{\_get\_edges()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1arraypad_a841b9954aae119493d6e5e1536195778} 
numpy.\+lib.\+arraypad.\+\_\+get\+\_\+edges (\begin{DoxyParamCaption}\item[{}]{padded}{, }\item[{}]{axis}{, }\item[{}]{width\+\_\+pair}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Retrieve edge values from empty-padded array in given dimension.

Parameters
----------
padded : ndarray
    Empty-padded array.
axis : int
    Dimension in which the edges are considered.
width_pair : (int, int)
    Pair of widths that mark the pad area on both sides in the given
    dimension.

Returns
-------
left_edge, right_edge : ndarray
    Edge values of the valid area in `padded` in the given dimension. Its
    shape will always match `padded` except for the dimension given by
    `axis` which will have a length of 1.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{arraypad_8py_source_l00154}{154}} of file \mbox{\hyperlink{arraypad_8py_source}{arraypad.\+py}}.



References \mbox{\hyperlink{arraypad_8py_source_l00033}{\+\_\+slice\+\_\+at\+\_\+axis()}}.



Referenced by \mbox{\hyperlink{arraypad_8py_source_l00186}{\+\_\+get\+\_\+linear\+\_\+ramps()}}, and \mbox{\hyperlink{arraypad_8py_source_l00534}{pad()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1arraypad_a1b6398a036646fe6b7c4ab4e5ff6c1bd}\index{numpy.lib.arraypad@{numpy.lib.arraypad}!\_get\_linear\_ramps@{\_get\_linear\_ramps}}
\index{\_get\_linear\_ramps@{\_get\_linear\_ramps}!numpy.lib.arraypad@{numpy.lib.arraypad}}
\doxysubsubsection{\texorpdfstring{\_get\_linear\_ramps()}{\_get\_linear\_ramps()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1arraypad_a1b6398a036646fe6b7c4ab4e5ff6c1bd} 
numpy.\+lib.\+arraypad.\+\_\+get\+\_\+linear\+\_\+ramps (\begin{DoxyParamCaption}\item[{}]{padded}{, }\item[{}]{axis}{, }\item[{}]{width\+\_\+pair}{, }\item[{}]{end\+\_\+value\+\_\+pair}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Construct linear ramps for empty-padded array in given dimension.

Parameters
----------
padded : ndarray
    Empty-padded array.
axis : int
    Dimension in which the ramps are constructed.
width_pair : (int, int)
    Pair of widths that mark the pad area on both sides in the given
    dimension.
end_value_pair : (scalar, scalar)
    End values for the linear ramps which form the edge of the fully padded
    array. These values are included in the linear ramps.

Returns
-------
left_ramp, right_ramp : ndarray
    Linear ramps to set on both sides of `padded`.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{arraypad_8py_source_l00186}{186}} of file \mbox{\hyperlink{arraypad_8py_source}{arraypad.\+py}}.



References \mbox{\hyperlink{arraypad_8py_source_l00154}{\+\_\+get\+\_\+edges()}}, and \mbox{\hyperlink{arraypad_8py_source_l00033}{\+\_\+slice\+\_\+at\+\_\+axis()}}.



Referenced by \mbox{\hyperlink{arraypad_8py_source_l00534}{pad()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1arraypad_a3ddb7169260593afb561b47396788518}\index{numpy.lib.arraypad@{numpy.lib.arraypad}!\_get\_stats@{\_get\_stats}}
\index{\_get\_stats@{\_get\_stats}!numpy.lib.arraypad@{numpy.lib.arraypad}}
\doxysubsubsection{\texorpdfstring{\_get\_stats()}{\_get\_stats()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1arraypad_a3ddb7169260593afb561b47396788518} 
numpy.\+lib.\+arraypad.\+\_\+get\+\_\+stats (\begin{DoxyParamCaption}\item[{}]{padded}{, }\item[{}]{axis}{, }\item[{}]{width\+\_\+pair}{, }\item[{}]{length\+\_\+pair}{, }\item[{}]{stat\+\_\+func}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Calculate statistic for the empty-padded array in given dimension.

Parameters
----------
padded : ndarray
    Empty-padded array.
axis : int
    Dimension in which the statistic is calculated.
width_pair : (int, int)
    Pair of widths that mark the pad area on both sides in the given
    dimension.
length_pair : 2-element sequence of None or int
    Gives the number of values in valid area from each side that is
    taken into account when calculating the statistic. If None the entire
    valid area in `padded` is considered.
stat_func : function
    Function to compute statistic. The expected signature is
    ``stat_func(x: ndarray, axis: int, keepdims: bool) -> ndarray``.

Returns
-------
left_stat, right_stat : ndarray
    Calculated statistic for both sides of `padded`.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{arraypad_8py_source_l00230}{230}} of file \mbox{\hyperlink{arraypad_8py_source}{arraypad.\+py}}.



References \mbox{\hyperlink{arraypad_8py_source_l00018}{\+\_\+round\+\_\+if\+\_\+needed()}}, and \mbox{\hyperlink{arraypad_8py_source_l00033}{\+\_\+slice\+\_\+at\+\_\+axis()}}.



Referenced by \mbox{\hyperlink{arraypad_8py_source_l00534}{pad()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1arraypad_ac8dad4ff5561deb84a6922067d71ce93}\index{numpy.lib.arraypad@{numpy.lib.arraypad}!\_pad\_dispatcher@{\_pad\_dispatcher}}
\index{\_pad\_dispatcher@{\_pad\_dispatcher}!numpy.lib.arraypad@{numpy.lib.arraypad}}
\doxysubsubsection{\texorpdfstring{\_pad\_dispatcher()}{\_pad\_dispatcher()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1arraypad_ac8dad4ff5561deb84a6922067d71ce93} 
numpy.\+lib.\+arraypad.\+\_\+pad\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{array}{, }\item[{}]{pad\+\_\+width}{, }\item[{}]{mode}{ = {\ttfamily None}, }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{kwargs}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{arraypad_8py_source_l00525}{525}} of file \mbox{\hyperlink{arraypad_8py_source}{arraypad.\+py}}.

\Hypertarget{namespacenumpy_1_1lib_1_1arraypad_a39919b9582e52a6ffafa42c81c1e1d60}\index{numpy.lib.arraypad@{numpy.lib.arraypad}!\_pad\_simple@{\_pad\_simple}}
\index{\_pad\_simple@{\_pad\_simple}!numpy.lib.arraypad@{numpy.lib.arraypad}}
\doxysubsubsection{\texorpdfstring{\_pad\_simple()}{\_pad\_simple()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1arraypad_a39919b9582e52a6ffafa42c81c1e1d60} 
numpy.\+lib.\+arraypad.\+\_\+pad\+\_\+simple (\begin{DoxyParamCaption}\item[{}]{array}{, }\item[{}]{pad\+\_\+width}{, }\item[{}]{fill\+\_\+value}{ = {\ttfamily None}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Pad array on all sides with either a single value or undefined values.

Parameters
----------
array : ndarray
    Array to grow.
pad_width : sequence of tuple[int, int]
    Pad width on both sides for each dimension in `arr`.
fill_value : scalar, optional
    If provided the padded area is filled with this value, otherwise
    the pad area left undefined.

Returns
-------
padded : ndarray
    The padded array with the same dtype as`array`. Its order will default
    to C-style if `array` is not F-contiguous.
original_area_slice : tuple
    A tuple of slices pointing to the area of the original array.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{arraypad_8py_source_l00086}{86}} of file \mbox{\hyperlink{arraypad_8py_source}{arraypad.\+py}}.



Referenced by \mbox{\hyperlink{arraypad_8py_source_l00534}{pad()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1arraypad_aa7460d8995330adb81edac72607c5f79}\index{numpy.lib.arraypad@{numpy.lib.arraypad}!\_round\_if\_needed@{\_round\_if\_needed}}
\index{\_round\_if\_needed@{\_round\_if\_needed}!numpy.lib.arraypad@{numpy.lib.arraypad}}
\doxysubsubsection{\texorpdfstring{\_round\_if\_needed()}{\_round\_if\_needed()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1arraypad_aa7460d8995330adb81edac72607c5f79} 
numpy.\+lib.\+arraypad.\+\_\+round\+\_\+if\+\_\+needed (\begin{DoxyParamCaption}\item[{}]{arr}{, }\item[{}]{dtype}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Private utility functions. 

\begin{DoxyVerb}Rounds arr inplace if destination dtype is integer.

Parameters
----------
arr : ndarray
    Input array.
dtype : dtype
    The dtype of the destination array.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{arraypad_8py_source_l00018}{18}} of file \mbox{\hyperlink{arraypad_8py_source}{arraypad.\+py}}.



Referenced by \mbox{\hyperlink{arraypad_8py_source_l00230}{\+\_\+get\+\_\+stats()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1arraypad_a9b1898525b60749417fc05922db9c872}\index{numpy.lib.arraypad@{numpy.lib.arraypad}!\_set\_pad\_area@{\_set\_pad\_area}}
\index{\_set\_pad\_area@{\_set\_pad\_area}!numpy.lib.arraypad@{numpy.lib.arraypad}}
\doxysubsubsection{\texorpdfstring{\_set\_pad\_area()}{\_set\_pad\_area()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1arraypad_a9b1898525b60749417fc05922db9c872} 
numpy.\+lib.\+arraypad.\+\_\+set\+\_\+pad\+\_\+area (\begin{DoxyParamCaption}\item[{}]{padded}{, }\item[{}]{axis}{, }\item[{}]{width\+\_\+pair}{, }\item[{}]{value\+\_\+pair}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Set empty-padded area in given dimension.

Parameters
----------
padded : ndarray
    Array with the pad area which is modified inplace.
axis : int
    Dimension with the pad area to set.
width_pair : (int, int)
    Pair of widths that mark the pad area on both sides in the given
    dimension.
value_pair : tuple of scalars or ndarrays
    Values inserted into the pad area on each side. It must match or be
    broadcastable to the shape of `arr`.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{arraypad_8py_source_l00129}{129}} of file \mbox{\hyperlink{arraypad_8py_source}{arraypad.\+py}}.



References \mbox{\hyperlink{arraypad_8py_source_l00033}{\+\_\+slice\+\_\+at\+\_\+axis()}}.



Referenced by \mbox{\hyperlink{arraypad_8py_source_l00534}{pad()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1arraypad_a199e591eaea076f82376e77b7908be7f}\index{numpy.lib.arraypad@{numpy.lib.arraypad}!\_set\_reflect\_both@{\_set\_reflect\_both}}
\index{\_set\_reflect\_both@{\_set\_reflect\_both}!numpy.lib.arraypad@{numpy.lib.arraypad}}
\doxysubsubsection{\texorpdfstring{\_set\_reflect\_both()}{\_set\_reflect\_both()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1arraypad_a199e591eaea076f82376e77b7908be7f} 
numpy.\+lib.\+arraypad.\+\_\+set\+\_\+reflect\+\_\+both (\begin{DoxyParamCaption}\item[{}]{padded}{, }\item[{}]{axis}{, }\item[{}]{width\+\_\+pair}{, }\item[{}]{method}{, }\item[{}]{include\+\_\+edge}{ = {\ttfamily False}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Pad `axis` of `arr` with reflection.

Parameters
----------
padded : ndarray
    Input array of arbitrary shape.
axis : int
    Axis along which to pad `arr`.
width_pair : (int, int)
    Pair of widths that mark the pad area on both sides in the given
    dimension.
method : str
    Controls method of reflection; options are 'even' or 'odd'.
include_edge : bool
    If true, edge value is included in reflection, otherwise the edge
    value forms the symmetric axis to the reflection.

Returns
-------
pad_amt : tuple of ints, length 2
    New index positions of padding to do along the `axis`. If these are
    both 0, padding is done in this dimension.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{arraypad_8py_source_l00296}{296}} of file \mbox{\hyperlink{arraypad_8py_source}{arraypad.\+py}}.



References \mbox{\hyperlink{arraypad_8py_source_l00033}{\+\_\+slice\+\_\+at\+\_\+axis()}}, and \mbox{\hyperlink{core_2fromnumeric_8py_source_l02838}{numpy.\+core.\+fromnumeric.\+min()}}.



Referenced by \mbox{\hyperlink{arraypad_8py_source_l00534}{pad()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1arraypad_a72cbe94181cd26959c72012d89266b7a}\index{numpy.lib.arraypad@{numpy.lib.arraypad}!\_set\_wrap\_both@{\_set\_wrap\_both}}
\index{\_set\_wrap\_both@{\_set\_wrap\_both}!numpy.lib.arraypad@{numpy.lib.arraypad}}
\doxysubsubsection{\texorpdfstring{\_set\_wrap\_both()}{\_set\_wrap\_both()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1arraypad_a72cbe94181cd26959c72012d89266b7a} 
numpy.\+lib.\+arraypad.\+\_\+set\+\_\+wrap\+\_\+both (\begin{DoxyParamCaption}\item[{}]{padded}{, }\item[{}]{axis}{, }\item[{}]{width\+\_\+pair}{, }\item[{}]{original\+\_\+period}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Pad `axis` of `arr` with wrapped values.

Parameters
----------
padded : ndarray
    Input array of arbitrary shape.
axis : int
    Axis along which to pad `arr`.
width_pair : (int, int)
    Pair of widths that mark the pad area on both sides in the given
    dimension.
original_period : int
    Original length of data on `axis` of `arr`.

Returns
-------
pad_amt : tuple of ints, length 2
    New index positions of padding to do along the `axis`. If these are
    both 0, padding is done in this dimension.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{arraypad_8py_source_l00381}{381}} of file \mbox{\hyperlink{arraypad_8py_source}{arraypad.\+py}}.



References \mbox{\hyperlink{arraypad_8py_source_l00033}{\+\_\+slice\+\_\+at\+\_\+axis()}}, and \mbox{\hyperlink{core_2fromnumeric_8py_source_l02838}{numpy.\+core.\+fromnumeric.\+min()}}.



Referenced by \mbox{\hyperlink{arraypad_8py_source_l00534}{pad()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1arraypad_a02c6a68eb64f5bb61960e803dd07c884}\index{numpy.lib.arraypad@{numpy.lib.arraypad}!\_slice\_at\_axis@{\_slice\_at\_axis}}
\index{\_slice\_at\_axis@{\_slice\_at\_axis}!numpy.lib.arraypad@{numpy.lib.arraypad}}
\doxysubsubsection{\texorpdfstring{\_slice\_at\_axis()}{\_slice\_at\_axis()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1arraypad_a02c6a68eb64f5bb61960e803dd07c884} 
numpy.\+lib.\+arraypad.\+\_\+slice\+\_\+at\+\_\+axis (\begin{DoxyParamCaption}\item[{}]{sl}{, }\item[{}]{axis}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Construct tuple of slices to slice an array in the given dimension.

Parameters
----------
sl : slice
    The slice for the given dimension.
axis : int
    The axis to which `sl` is applied. All other dimensions are left
    "unsliced".

Returns
-------
sl : tuple of slices
    A tuple with slices matching `shape` in length.

Examples
--------
>>> _slice_at_axis(slice(None, 3, -1), 1)
(slice(None, None, None), slice(None, 3, -1), (...,))
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{arraypad_8py_source_l00033}{33}} of file \mbox{\hyperlink{arraypad_8py_source}{arraypad.\+py}}.



Referenced by \mbox{\hyperlink{arraypad_8py_source_l00154}{\+\_\+get\+\_\+edges()}}, \mbox{\hyperlink{arraypad_8py_source_l00186}{\+\_\+get\+\_\+linear\+\_\+ramps()}}, \mbox{\hyperlink{arraypad_8py_source_l00230}{\+\_\+get\+\_\+stats()}}, \mbox{\hyperlink{arraypad_8py_source_l00129}{\+\_\+set\+\_\+pad\+\_\+area()}}, \mbox{\hyperlink{arraypad_8py_source_l00296}{\+\_\+set\+\_\+reflect\+\_\+both()}}, and \mbox{\hyperlink{arraypad_8py_source_l00381}{\+\_\+set\+\_\+wrap\+\_\+both()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1arraypad_a14ce2ba54b8417fc3a481a4c5ba69cd6}\index{numpy.lib.arraypad@{numpy.lib.arraypad}!\_view\_roi@{\_view\_roi}}
\index{\_view\_roi@{\_view\_roi}!numpy.lib.arraypad@{numpy.lib.arraypad}}
\doxysubsubsection{\texorpdfstring{\_view\_roi()}{\_view\_roi()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1arraypad_a14ce2ba54b8417fc3a481a4c5ba69cd6} 
numpy.\+lib.\+arraypad.\+\_\+view\+\_\+roi (\begin{DoxyParamCaption}\item[{}]{array}{, }\item[{}]{original\+\_\+area\+\_\+slice}{, }\item[{}]{axis}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Get a view of the current region of interest during iterative padding.

When padding multiple dimensions iteratively corner values are
unnecessarily overwritten multiple times. This function reduces the
working area for the first dimensions so that corners are excluded.

Parameters
----------
array : ndarray
    The array with the region of interest.
original_area_slice : tuple of slices
    Denotes the area with original values of the unpadded array.
axis : int
    The currently padded dimension assuming that `axis` is padded before
    `axis` + 1.

Returns
-------
roi : ndarray
    The region of interest of the original `array`.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{arraypad_8py_source_l00058}{58}} of file \mbox{\hyperlink{arraypad_8py_source}{arraypad.\+py}}.



Referenced by \mbox{\hyperlink{arraypad_8py_source_l00534}{pad()}}.

\Hypertarget{namespacenumpy_1_1lib_1_1arraypad_a03f6ba7ccefaab37a09357632bdcd7b7}\index{numpy.lib.arraypad@{numpy.lib.arraypad}!pad@{pad}}
\index{pad@{pad}!numpy.lib.arraypad@{numpy.lib.arraypad}}
\doxysubsubsection{\texorpdfstring{pad()}{pad()}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1arraypad_a03f6ba7ccefaab37a09357632bdcd7b7} 
numpy.\+lib.\+arraypad.\+pad (\begin{DoxyParamCaption}\item[{}]{array}{, }\item[{}]{pad\+\_\+width}{, }\item[{}]{mode}{ = {\ttfamily \textquotesingle{}constant\textquotesingle{}}, }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{kwargs}{}\end{DoxyParamCaption})}



Public functions. 

\begin{DoxyVerb}Pad an array.

Parameters
----------
array : array_like of rank N
    The array to pad.
pad_width : {sequence, array_like, int}
    Number of values padded to the edges of each axis.
    ``((before_1, after_1), ... (before_N, after_N))`` unique pad widths
    for each axis.
    ``(before, after)`` or ``((before, after),)`` yields same before
    and after pad for each axis.
    ``(pad,)`` or ``int`` is a shortcut for before = after = pad width
    for all axes.
mode : str or function, optional
    One of the following string values or a user supplied function.

    'constant' (default)
        Pads with a constant value.
    'edge'
        Pads with the edge values of array.
    'linear_ramp'
        Pads with the linear ramp between end_value and the
        array edge value.
    'maximum'
        Pads with the maximum value of all or part of the
        vector along each axis.
    'mean'
        Pads with the mean value of all or part of the
        vector along each axis.
    'median'
        Pads with the median value of all or part of the
        vector along each axis.
    'minimum'
        Pads with the minimum value of all or part of the
        vector along each axis.
    'reflect'
        Pads with the reflection of the vector mirrored on
        the first and last values of the vector along each
        axis.
    'symmetric'
        Pads with the reflection of the vector mirrored
        along the edge of the array.
    'wrap'
        Pads with the wrap of the vector along the axis.
        The first values are used to pad the end and the
        end values are used to pad the beginning.
    'empty'
        Pads with undefined values.

        .. versionadded:: 1.17

    <function>
        Padding function, see Notes.
stat_length : sequence or int, optional
    Used in 'maximum', 'mean', 'median', and 'minimum'.  Number of
    values at edge of each axis used to calculate the statistic value.

    ``((before_1, after_1), ... (before_N, after_N))`` unique statistic
    lengths for each axis.

    ``(before, after)`` or ``((before, after),)`` yields same before
    and after statistic lengths for each axis.

    ``(stat_length,)`` or ``int`` is a shortcut for
    ``before = after = statistic`` length for all axes.

    Default is ``None``, to use the entire axis.
constant_values : sequence or scalar, optional
    Used in 'constant'.  The values to set the padded values for each
    axis.

    ``((before_1, after_1), ... (before_N, after_N))`` unique pad constants
    for each axis.

    ``(before, after)`` or ``((before, after),)`` yields same before
    and after constants for each axis.

    ``(constant,)`` or ``constant`` is a shortcut for
    ``before = after = constant`` for all axes.

    Default is 0.
end_values : sequence or scalar, optional
    Used in 'linear_ramp'.  The values used for the ending value of the
    linear_ramp and that will form the edge of the padded array.

    ``((before_1, after_1), ... (before_N, after_N))`` unique end values
    for each axis.

    ``(before, after)`` or ``((before, after),)`` yields same before
    and after end values for each axis.

    ``(constant,)`` or ``constant`` is a shortcut for
    ``before = after = constant`` for all axes.

    Default is 0.
reflect_type : {'even', 'odd'}, optional
    Used in 'reflect', and 'symmetric'.  The 'even' style is the
    default with an unaltered reflection around the edge value.  For
    the 'odd' style, the extended part of the array is created by
    subtracting the reflected values from two times the edge value.

Returns
-------
pad : ndarray
    Padded array of rank equal to `array` with shape increased
    according to `pad_width`.

Notes
-----
.. versionadded:: 1.7.0

For an array with rank greater than 1, some of the padding of later
axes is calculated from padding of previous axes.  This is easiest to
think about with a rank 2 array where the corners of the padded array
are calculated by using padded values from the first axis.

The padding function, if used, should modify a rank 1 array in-place. It
has the following signature::

    padding_func(vector, iaxis_pad_width, iaxis, kwargs)

where

    vector : ndarray
        A rank 1 array already padded with zeros.  Padded values are
        vector[:iaxis_pad_width[0]] and vector[-iaxis_pad_width[1]:].
    iaxis_pad_width : tuple
        A 2-tuple of ints, iaxis_pad_width[0] represents the number of
        values padded at the beginning of vector where
        iaxis_pad_width[1] represents the number of values padded at
        the end of vector.
    iaxis : int
        The axis currently being calculated.
    kwargs : dict
        Any keyword arguments the function requires.

Examples
--------
>>> a = [1, 2, 3, 4, 5]
>>> np.pad(a, (2, 3), 'constant', constant_values=(4, 6))
array([4, 4, 1, ..., 6, 6, 6])

>>> np.pad(a, (2, 3), 'edge')
array([1, 1, 1, ..., 5, 5, 5])

>>> np.pad(a, (2, 3), 'linear_ramp', end_values=(5, -4))
array([ 5,  3,  1,  2,  3,  4,  5,  2, -1, -4])

>>> np.pad(a, (2,), 'maximum')
array([5, 5, 1, 2, 3, 4, 5, 5, 5])

>>> np.pad(a, (2,), 'mean')
array([3, 3, 1, 2, 3, 4, 5, 3, 3])

>>> np.pad(a, (2,), 'median')
array([3, 3, 1, 2, 3, 4, 5, 3, 3])

>>> a = [[1, 2], [3, 4]]
>>> np.pad(a, ((3, 2), (2, 3)), 'minimum')
array([[1, 1, 1, 2, 1, 1, 1],
       [1, 1, 1, 2, 1, 1, 1],
       [1, 1, 1, 2, 1, 1, 1],
       [1, 1, 1, 2, 1, 1, 1],
       [3, 3, 3, 4, 3, 3, 3],
       [1, 1, 1, 2, 1, 1, 1],
       [1, 1, 1, 2, 1, 1, 1]])

>>> a = [1, 2, 3, 4, 5]
>>> np.pad(a, (2, 3), 'reflect')
array([3, 2, 1, 2, 3, 4, 5, 4, 3, 2])

>>> np.pad(a, (2, 3), 'reflect', reflect_type='odd')
array([-1,  0,  1,  2,  3,  4,  5,  6,  7,  8])

>>> np.pad(a, (2, 3), 'symmetric')
array([2, 1, 1, 2, 3, 4, 5, 5, 4, 3])

>>> np.pad(a, (2, 3), 'symmetric', reflect_type='odd')
array([0, 1, 1, 2, 3, 4, 5, 5, 6, 7])

>>> np.pad(a, (2, 3), 'wrap')
array([4, 5, 1, 2, 3, 4, 5, 1, 2, 3])

>>> def pad_with(vector, pad_width, iaxis, kwargs):
...     pad_value = kwargs.get('padder', 10)
...     vector[:pad_width[0]] = pad_value
...     vector[-pad_width[1]:] = pad_value
>>> a = np.arange(6)
>>> a = a.reshape((2, 3))
>>> np.pad(a, 2, pad_with)
array([[10, 10, 10, 10, 10, 10, 10],
       [10, 10, 10, 10, 10, 10, 10],
       [10, 10,  0,  1,  2, 10, 10],
       [10, 10,  3,  4,  5, 10, 10],
       [10, 10, 10, 10, 10, 10, 10],
       [10, 10, 10, 10, 10, 10, 10]])
>>> np.pad(a, 2, pad_with, padder=100)
array([[100, 100, 100, 100, 100, 100, 100],
       [100, 100, 100, 100, 100, 100, 100],
       [100, 100,   0,   1,   2, 100, 100],
       [100, 100,   3,   4,   5, 100, 100],
       [100, 100, 100, 100, 100, 100, 100],
       [100, 100, 100, 100, 100, 100, 100]])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{arraypad_8py_source_l00534}{534}} of file \mbox{\hyperlink{arraypad_8py_source}{arraypad.\+py}}.



References \mbox{\hyperlink{arraypad_8py_source_l00458}{\+\_\+as\+\_\+pairs()}}, \mbox{\hyperlink{arraypad_8py_source_l00154}{\+\_\+get\+\_\+edges()}}, \mbox{\hyperlink{arraypad_8py_source_l00186}{\+\_\+get\+\_\+linear\+\_\+ramps()}}, \mbox{\hyperlink{arraypad_8py_source_l00230}{\+\_\+get\+\_\+stats()}}, \mbox{\hyperlink{arraypad_8py_source_l00086}{\+\_\+pad\+\_\+simple()}}, \mbox{\hyperlink{arraypad_8py_source_l00129}{\+\_\+set\+\_\+pad\+\_\+area()}}, \mbox{\hyperlink{arraypad_8py_source_l00296}{\+\_\+set\+\_\+reflect\+\_\+both()}}, \mbox{\hyperlink{arraypad_8py_source_l00381}{\+\_\+set\+\_\+wrap\+\_\+both()}}, \mbox{\hyperlink{arraypad_8py_source_l00058}{\+\_\+view\+\_\+roi()}}, and \mbox{\hyperlink{core_2fromnumeric_8py_source_l02323}{numpy.\+core.\+fromnumeric.\+any()}}.



\doxysubsection{Variable Documentation}
\Hypertarget{namespacenumpy_1_1lib_1_1arraypad_a39de842c5f73c6e9b02643a33ed2ad26}\index{numpy.lib.arraypad@{numpy.lib.arraypad}!\_\_all\_\_@{\_\_all\_\_}}
\index{\_\_all\_\_@{\_\_all\_\_}!numpy.lib.arraypad@{numpy.lib.arraypad}}
\doxysubsubsection{\texorpdfstring{\_\_all\_\_}{\_\_all\_\_}}
{\footnotesize\ttfamily \label{namespacenumpy_1_1lib_1_1arraypad_a39de842c5f73c6e9b02643a33ed2ad26} 
list numpy.\+lib.\+arraypad.\+\_\+\+\_\+all\+\_\+\+\_\+ = \mbox{[}\textquotesingle{}\mbox{\hyperlink{namespacenumpy_1_1lib_1_1arraypad_a03f6ba7ccefaab37a09357632bdcd7b7}{pad}}\textquotesingle{}\mbox{]}\hspace{0.3cm}{\ttfamily [private]}}



Definition at line \mbox{\hyperlink{arraypad_8py_source_l00011}{11}} of file \mbox{\hyperlink{arraypad_8py_source}{arraypad.\+py}}.

