\doxysection{matplotlib.\+tri.\+\_\+triinterpolate Namespace Reference}
\hypertarget{namespacematplotlib_1_1tri_1_1__triinterpolate}{}\label{namespacematplotlib_1_1tri_1_1__triinterpolate}\index{matplotlib.tri.\_triinterpolate@{matplotlib.tri.\_triinterpolate}}
\doxysubsubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classmatplotlib_1_1tri_1_1__triinterpolate_1_1__DOF__estimator}{\+\_\+\+DOF\+\_\+estimator}}
\item 
class \mbox{\hyperlink{classmatplotlib_1_1tri_1_1__triinterpolate_1_1__DOF__estimator__geom}{\+\_\+\+DOF\+\_\+estimator\+\_\+geom}}
\item 
class \mbox{\hyperlink{classmatplotlib_1_1tri_1_1__triinterpolate_1_1__DOF__estimator__min__E}{\+\_\+\+DOF\+\_\+estimator\+\_\+min\+\_\+E}}
\item 
class \mbox{\hyperlink{classmatplotlib_1_1tri_1_1__triinterpolate_1_1__DOF__estimator__user}{\+\_\+\+DOF\+\_\+estimator\+\_\+user}}
\item 
class \mbox{\hyperlink{classmatplotlib_1_1tri_1_1__triinterpolate_1_1__ReducedHCT__Element}{\+\_\+\+Reduced\+HCT\+\_\+\+Element}}
\item 
class \mbox{\hyperlink{classmatplotlib_1_1tri_1_1__triinterpolate_1_1__Sparse__Matrix__coo}{\+\_\+\+Sparse\+\_\+\+Matrix\+\_\+coo}}
\item 
class \mbox{\hyperlink{classmatplotlib_1_1tri_1_1__triinterpolate_1_1CubicTriInterpolator}{Cubic\+Tri\+Interpolator}}
\item 
class \mbox{\hyperlink{classmatplotlib_1_1tri_1_1__triinterpolate_1_1LinearTriInterpolator}{Linear\+Tri\+Interpolator}}
\item 
class \mbox{\hyperlink{classmatplotlib_1_1tri_1_1__triinterpolate_1_1TriInterpolator}{Tri\+Interpolator}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacematplotlib_1_1tri_1_1__triinterpolate_aa5eff9355c0a78bf39e0d9cc6b1ea8bd}{\+\_\+cg}} (A, b, x0=None, tol=1.e-\/10, maxiter=1000)
\item 
\mbox{\hyperlink{namespacematplotlib_1_1tri_1_1__triinterpolate_acc11bb85cb90fac2a1ea3295cb79a6c9}{\+\_\+safe\+\_\+inv22\+\_\+vectorized}} (M)
\item 
\mbox{\hyperlink{namespacematplotlib_1_1tri_1_1__triinterpolate_a35e96be952e386567060ae058d73b547}{\+\_\+pseudo\+\_\+inv22sym\+\_\+vectorized}} (M)
\item 
\mbox{\hyperlink{namespacematplotlib_1_1tri_1_1__triinterpolate_af0d6eb72366c92922afcc6f4283a05d9}{\+\_\+scalar\+\_\+vectorized}} (scalar, M)
\item 
\mbox{\hyperlink{namespacematplotlib_1_1tri_1_1__triinterpolate_a8f9f1eff0df36aad9a6fb0f872481706}{\+\_\+transpose\+\_\+vectorized}} (M)
\item 
\mbox{\hyperlink{namespacematplotlib_1_1tri_1_1__triinterpolate_a0908d8fae881ab710d09ff98c6ed5258}{\+\_\+roll\+\_\+vectorized}} (M, roll\+\_\+indices, axis)
\item 
\mbox{\hyperlink{namespacematplotlib_1_1tri_1_1__triinterpolate_a0077efc1ff24fe9a813c5c39fd98f1c8}{\+\_\+to\+\_\+matrix\+\_\+vectorized}} (M)
\item 
\mbox{\hyperlink{namespacematplotlib_1_1tri_1_1__triinterpolate_a20fbcf30d888929f741f348a88e21a29}{\+\_\+extract\+\_\+submatrices}} (M, block\+\_\+indices, block\+\_\+size, axis)
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
tuple \mbox{\hyperlink{namespacematplotlib_1_1tri_1_1__triinterpolate_a0fa75be706fa6ec27f709b9c6a1a3ee6}{\+\_\+\+\_\+all\+\_\+\+\_\+}} = (\textquotesingle{}\mbox{\hyperlink{classmatplotlib_1_1tri_1_1__triinterpolate_1_1TriInterpolator}{Tri\+Interpolator}}\textquotesingle{}, \textquotesingle{}\mbox{\hyperlink{classmatplotlib_1_1tri_1_1__triinterpolate_1_1LinearTriInterpolator}{Linear\+Tri\+Interpolator}}\textquotesingle{}, \textquotesingle{}\mbox{\hyperlink{classmatplotlib_1_1tri_1_1__triinterpolate_1_1CubicTriInterpolator}{Cubic\+Tri\+Interpolator}}\textquotesingle{})
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\begin{DoxyVerb}Interpolation inside triangular grids.
\end{DoxyVerb}
 

\doxysubsection{Function Documentation}
\Hypertarget{namespacematplotlib_1_1tri_1_1__triinterpolate_aa5eff9355c0a78bf39e0d9cc6b1ea8bd}\index{matplotlib.tri.\_triinterpolate@{matplotlib.tri.\_triinterpolate}!\_cg@{\_cg}}
\index{\_cg@{\_cg}!matplotlib.tri.\_triinterpolate@{matplotlib.tri.\_triinterpolate}}
\doxysubsubsection{\texorpdfstring{\_cg()}{\_cg()}}
{\footnotesize\ttfamily \label{namespacematplotlib_1_1tri_1_1__triinterpolate_aa5eff9355c0a78bf39e0d9cc6b1ea8bd} 
matplotlib.\+tri.\+\_\+triinterpolate.\+\_\+cg (\begin{DoxyParamCaption}\item[{}]{A}{, }\item[{}]{b}{, }\item[{}]{x0}{ = {\ttfamily None}, }\item[{}]{tol}{ = {\ttfamily 1.e-\/10}, }\item[{}]{maxiter}{ = {\ttfamily 1000}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Use Preconditioned Conjugate Gradient iteration to solve A x = b
A simple Jacobi (diagonal) preconditioner is used.

Parameters
----------
A : _Sparse_Matrix_coo
    *A* must have been compressed before by compress_csc or
    compress_csr method.
b : array
    Right hand side of the linear system.
x0 : array, optional
    Starting guess for the solution. Defaults to the zero vector.
tol : float, optional
    Tolerance to achieve. The algorithm terminates when the relative
    residual is below tol. Default is 1e-10.
maxiter : int, optional
    Maximum number of iterations.  Iteration will stop after *maxiter*
    steps even if the specified tolerance has not been achieved. Defaults
    to 1000.

Returns
-------
x : array
    The converged solution.
err : float
    The absolute error np.linalg.norm(A.dot(x) - b)
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__triinterpolate_8py_source_l01283}{1283}} of file \mbox{\hyperlink{__triinterpolate_8py_source}{\+\_\+triinterpolate.\+py}}.



Referenced by \mbox{\hyperlink{__triinterpolate_8py_source_l01166}{matplotlib.\+tri.\+\_\+triinterpolate.\+\_\+\+DOF\+\_\+estimator\+\_\+min\+\_\+\+E.\+compute\+\_\+dz()}}.

\Hypertarget{namespacematplotlib_1_1tri_1_1__triinterpolate_a20fbcf30d888929f741f348a88e21a29}\index{matplotlib.tri.\_triinterpolate@{matplotlib.tri.\_triinterpolate}!\_extract\_submatrices@{\_extract\_submatrices}}
\index{\_extract\_submatrices@{\_extract\_submatrices}!matplotlib.tri.\_triinterpolate@{matplotlib.tri.\_triinterpolate}}
\doxysubsubsection{\texorpdfstring{\_extract\_submatrices()}{\_extract\_submatrices()}}
{\footnotesize\ttfamily \label{namespacematplotlib_1_1tri_1_1__triinterpolate_a20fbcf30d888929f741f348a88e21a29} 
matplotlib.\+tri.\+\_\+triinterpolate.\+\_\+extract\+\_\+submatrices (\begin{DoxyParamCaption}\item[{}]{M}{, }\item[{}]{block\+\_\+indices}{, }\item[{}]{block\+\_\+size}{, }\item[{}]{axis}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Extract selected blocks of a matrices *M* depending on parameters
*block_indices* and *block_size*.

Returns the array of extracted matrices *Mres* so that ::

    M_res[..., ir, :] = M[(block_indices*block_size+ir), :]
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__triinterpolate_8py_source_l01547}{1547}} of file \mbox{\hyperlink{__triinterpolate_8py_source}{\+\_\+triinterpolate.\+py}}.



Referenced by \mbox{\hyperlink{__triinterpolate_8py_source_l00789}{matplotlib.\+tri.\+\_\+triinterpolate.\+\_\+\+Reduced\+HCT\+\_\+\+Element.\+get\+\_\+d2\+Sidksij2()}}, and \mbox{\hyperlink{__triinterpolate_8py_source_l00708}{matplotlib.\+tri.\+\_\+triinterpolate.\+\_\+\+Reduced\+HCT\+\_\+\+Element.\+get\+\_\+function\+\_\+derivatives()}}.

\Hypertarget{namespacematplotlib_1_1tri_1_1__triinterpolate_a35e96be952e386567060ae058d73b547}\index{matplotlib.tri.\_triinterpolate@{matplotlib.tri.\_triinterpolate}!\_pseudo\_inv22sym\_vectorized@{\_pseudo\_inv22sym\_vectorized}}
\index{\_pseudo\_inv22sym\_vectorized@{\_pseudo\_inv22sym\_vectorized}!matplotlib.tri.\_triinterpolate@{matplotlib.tri.\_triinterpolate}}
\doxysubsubsection{\texorpdfstring{\_pseudo\_inv22sym\_vectorized()}{\_pseudo\_inv22sym\_vectorized()}}
{\footnotesize\ttfamily \label{namespacematplotlib_1_1tri_1_1__triinterpolate_a35e96be952e386567060ae058d73b547} 
matplotlib.\+tri.\+\_\+triinterpolate.\+\_\+pseudo\+\_\+inv22sym\+\_\+vectorized (\begin{DoxyParamCaption}\item[{}]{M}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Inversion of arrays of (2, 2) SYMMETRIC matrices; returns the
(Moore-Penrose) pseudo-inverse for rank-deficient matrices.

In case M is of rank 1, we have M = trace(M) x P where P is the orthogonal
projection on Im(M), and we return trace(M)^-1 x P == M / trace(M)**2
In case M is of rank 0, we return the null matrix.

*M* : array of (2, 2) matrices to inverse, shape (n, 2, 2)
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__triinterpolate_8py_source_l01429}{1429}} of file \mbox{\hyperlink{__triinterpolate_8py_source}{\+\_\+triinterpolate.\+py}}.



Referenced by \mbox{\hyperlink{__triinterpolate_8py_source_l00479}{matplotlib.\+tri.\+\_\+triinterpolate.\+Cubic\+Tri\+Interpolator.\+\_\+get\+\_\+alpha\+\_\+vec()}}.

\Hypertarget{namespacematplotlib_1_1tri_1_1__triinterpolate_a0908d8fae881ab710d09ff98c6ed5258}\index{matplotlib.tri.\_triinterpolate@{matplotlib.tri.\_triinterpolate}!\_roll\_vectorized@{\_roll\_vectorized}}
\index{\_roll\_vectorized@{\_roll\_vectorized}!matplotlib.tri.\_triinterpolate@{matplotlib.tri.\_triinterpolate}}
\doxysubsubsection{\texorpdfstring{\_roll\_vectorized()}{\_roll\_vectorized()}}
{\footnotesize\ttfamily \label{namespacematplotlib_1_1tri_1_1__triinterpolate_a0908d8fae881ab710d09ff98c6ed5258} 
matplotlib.\+tri.\+\_\+triinterpolate.\+\_\+roll\+\_\+vectorized (\begin{DoxyParamCaption}\item[{}]{M}{, }\item[{}]{roll\+\_\+indices}{, }\item[{}]{axis}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Roll an array of matrices along *axis* (0: rows, 1: columns) according to
an array of indices *roll_indices*.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__triinterpolate_8py_source_l01489}{1489}} of file \mbox{\hyperlink{__triinterpolate_8py_source}{\+\_\+triinterpolate.\+py}}.



Referenced by \mbox{\hyperlink{__triinterpolate_8py_source_l00789}{matplotlib.\+tri.\+\_\+triinterpolate.\+\_\+\+Reduced\+HCT\+\_\+\+Element.\+get\+\_\+d2\+Sidksij2()}}, \mbox{\hyperlink{__triinterpolate_8py_source_l00708}{matplotlib.\+tri.\+\_\+triinterpolate.\+\_\+\+Reduced\+HCT\+\_\+\+Element.\+get\+\_\+function\+\_\+derivatives()}}, and \mbox{\hyperlink{__triinterpolate_8py_source_l00674}{matplotlib.\+tri.\+\_\+triinterpolate.\+\_\+\+Reduced\+HCT\+\_\+\+Element.\+get\+\_\+function\+\_\+values()}}.

\Hypertarget{namespacematplotlib_1_1tri_1_1__triinterpolate_acc11bb85cb90fac2a1ea3295cb79a6c9}\index{matplotlib.tri.\_triinterpolate@{matplotlib.tri.\_triinterpolate}!\_safe\_inv22\_vectorized@{\_safe\_inv22\_vectorized}}
\index{\_safe\_inv22\_vectorized@{\_safe\_inv22\_vectorized}!matplotlib.tri.\_triinterpolate@{matplotlib.tri.\_triinterpolate}}
\doxysubsubsection{\texorpdfstring{\_safe\_inv22\_vectorized()}{\_safe\_inv22\_vectorized()}}
{\footnotesize\ttfamily \label{namespacematplotlib_1_1tri_1_1__triinterpolate_acc11bb85cb90fac2a1ea3295cb79a6c9} 
matplotlib.\+tri.\+\_\+triinterpolate.\+\_\+safe\+\_\+inv22\+\_\+vectorized (\begin{DoxyParamCaption}\item[{}]{M}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Inversion of arrays of (2, 2) matrices, returns 0 for rank-deficient
matrices.

*M* : array of (2, 2) matrices to inverse, shape (n, 2, 2)
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__triinterpolate_8py_source_l01399}{1399}} of file \mbox{\hyperlink{__triinterpolate_8py_source}{\+\_\+triinterpolate.\+py}}.



Referenced by \mbox{\hyperlink{__triinterpolate_8py_source_l01129}{matplotlib.\+tri.\+\_\+triinterpolate.\+\_\+\+DOF\+\_\+estimator\+\_\+geom.\+compute\+\_\+geom\+\_\+grads()}}, \mbox{\hyperlink{__triinterpolate_8py_source_l00708}{matplotlib.\+tri.\+\_\+triinterpolate.\+\_\+\+Reduced\+HCT\+\_\+\+Element.\+get\+\_\+function\+\_\+derivatives()}}, and \mbox{\hyperlink{__triinterpolate_8py_source_l00881}{matplotlib.\+tri.\+\_\+triinterpolate.\+\_\+\+Reduced\+HCT\+\_\+\+Element.\+get\+\_\+\+Hrot\+\_\+from\+\_\+\+J()}}.

\Hypertarget{namespacematplotlib_1_1tri_1_1__triinterpolate_af0d6eb72366c92922afcc6f4283a05d9}\index{matplotlib.tri.\_triinterpolate@{matplotlib.tri.\_triinterpolate}!\_scalar\_vectorized@{\_scalar\_vectorized}}
\index{\_scalar\_vectorized@{\_scalar\_vectorized}!matplotlib.tri.\_triinterpolate@{matplotlib.tri.\_triinterpolate}}
\doxysubsubsection{\texorpdfstring{\_scalar\_vectorized()}{\_scalar\_vectorized()}}
{\footnotesize\ttfamily \label{namespacematplotlib_1_1tri_1_1__triinterpolate_af0d6eb72366c92922afcc6f4283a05d9} 
matplotlib.\+tri.\+\_\+triinterpolate.\+\_\+scalar\+\_\+vectorized (\begin{DoxyParamCaption}\item[{}]{scalar}{, }\item[{}]{M}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Scalar product between scalars and matrices.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__triinterpolate_8py_source_l01475}{1475}} of file \mbox{\hyperlink{__triinterpolate_8py_source}{\+\_\+triinterpolate.\+py}}.



Referenced by \mbox{\hyperlink{__triinterpolate_8py_source_l00830}{matplotlib.\+tri.\+\_\+triinterpolate.\+\_\+\+Reduced\+HCT\+\_\+\+Element.\+get\+\_\+bending\+\_\+matrices()}}, \mbox{\hyperlink{__triinterpolate_8py_source_l00789}{matplotlib.\+tri.\+\_\+triinterpolate.\+\_\+\+Reduced\+HCT\+\_\+\+Element.\+get\+\_\+d2\+Sidksij2()}}, \mbox{\hyperlink{__triinterpolate_8py_source_l00708}{matplotlib.\+tri.\+\_\+triinterpolate.\+\_\+\+Reduced\+HCT\+\_\+\+Element.\+get\+\_\+function\+\_\+derivatives()}}, and \mbox{\hyperlink{__triinterpolate_8py_source_l00674}{matplotlib.\+tri.\+\_\+triinterpolate.\+\_\+\+Reduced\+HCT\+\_\+\+Element.\+get\+\_\+function\+\_\+values()}}.

\Hypertarget{namespacematplotlib_1_1tri_1_1__triinterpolate_a0077efc1ff24fe9a813c5c39fd98f1c8}\index{matplotlib.tri.\_triinterpolate@{matplotlib.tri.\_triinterpolate}!\_to\_matrix\_vectorized@{\_to\_matrix\_vectorized}}
\index{\_to\_matrix\_vectorized@{\_to\_matrix\_vectorized}!matplotlib.tri.\_triinterpolate@{matplotlib.tri.\_triinterpolate}}
\doxysubsubsection{\texorpdfstring{\_to\_matrix\_vectorized()}{\_to\_matrix\_vectorized()}}
{\footnotesize\ttfamily \label{namespacematplotlib_1_1tri_1_1__triinterpolate_a0077efc1ff24fe9a813c5c39fd98f1c8} 
matplotlib.\+tri.\+\_\+triinterpolate.\+\_\+to\+\_\+matrix\+\_\+vectorized (\begin{DoxyParamCaption}\item[{}]{M}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Build an array of matrices from individuals np.arrays of identical shapes.

Parameters
----------
M
    ncols-list of nrows-lists of shape sh.

Returns
-------
M_res : np.array of shape (sh, nrow, ncols)
    *M_res* satisfies ``M_res[..., i, j] = M[i][j]``.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__triinterpolate_8py_source_l01517}{1517}} of file \mbox{\hyperlink{__triinterpolate_8py_source}{\+\_\+triinterpolate.\+py}}.



Referenced by \mbox{\hyperlink{__triinterpolate_8py_source_l00546}{matplotlib.\+tri.\+\_\+triinterpolate.\+Cubic\+Tri\+Interpolator.\+\_\+compute\+\_\+tri\+\_\+eccentricities()}}, \mbox{\hyperlink{__triinterpolate_8py_source_l00479}{matplotlib.\+tri.\+\_\+triinterpolate.\+Cubic\+Tri\+Interpolator.\+\_\+get\+\_\+alpha\+\_\+vec()}}, \mbox{\hyperlink{__triinterpolate_8py_source_l00518}{matplotlib.\+tri.\+\_\+triinterpolate.\+Cubic\+Tri\+Interpolator.\+\_\+get\+\_\+jacobian()}}, \mbox{\hyperlink{__triinterpolate_8py_source_l00789}{matplotlib.\+tri.\+\_\+triinterpolate.\+\_\+\+Reduced\+HCT\+\_\+\+Element.\+get\+\_\+d2\+Sidksij2()}}, \mbox{\hyperlink{__triinterpolate_8py_source_l01020}{matplotlib.\+tri.\+\_\+triinterpolate.\+\_\+\+DOF\+\_\+estimator.\+get\+\_\+dof\+\_\+vec()}}, \mbox{\hyperlink{__triinterpolate_8py_source_l00708}{matplotlib.\+tri.\+\_\+triinterpolate.\+\_\+\+Reduced\+HCT\+\_\+\+Element.\+get\+\_\+function\+\_\+derivatives()}}, \mbox{\hyperlink{__triinterpolate_8py_source_l00674}{matplotlib.\+tri.\+\_\+triinterpolate.\+\_\+\+Reduced\+HCT\+\_\+\+Element.\+get\+\_\+function\+\_\+values()}}, \mbox{\hyperlink{__triinterpolate_8py_source_l00881}{matplotlib.\+tri.\+\_\+triinterpolate.\+\_\+\+Reduced\+HCT\+\_\+\+Element.\+get\+\_\+\+Hrot\+\_\+from\+\_\+\+J()}}, and \mbox{\hyperlink{__triinterpolate_8py_source_l00911}{matplotlib.\+tri.\+\_\+triinterpolate.\+\_\+\+Reduced\+HCT\+\_\+\+Element.\+get\+\_\+\+Kff\+\_\+and\+\_\+\+Ff()}}.

\Hypertarget{namespacematplotlib_1_1tri_1_1__triinterpolate_a8f9f1eff0df36aad9a6fb0f872481706}\index{matplotlib.tri.\_triinterpolate@{matplotlib.tri.\_triinterpolate}!\_transpose\_vectorized@{\_transpose\_vectorized}}
\index{\_transpose\_vectorized@{\_transpose\_vectorized}!matplotlib.tri.\_triinterpolate@{matplotlib.tri.\_triinterpolate}}
\doxysubsubsection{\texorpdfstring{\_transpose\_vectorized()}{\_transpose\_vectorized()}}
{\footnotesize\ttfamily \label{namespacematplotlib_1_1tri_1_1__triinterpolate_a8f9f1eff0df36aad9a6fb0f872481706} 
matplotlib.\+tri.\+\_\+triinterpolate.\+\_\+transpose\+\_\+vectorized (\begin{DoxyParamCaption}\item[{}]{M}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Transposition of an array of matrices *M*.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__triinterpolate_8py_source_l01482}{1482}} of file \mbox{\hyperlink{__triinterpolate_8py_source}{\+\_\+triinterpolate.\+py}}.



Referenced by \mbox{\hyperlink{__triinterpolate_8py_source_l00546}{matplotlib.\+tri.\+\_\+triinterpolate.\+Cubic\+Tri\+Interpolator.\+\_\+compute\+\_\+tri\+\_\+eccentricities()}}, \mbox{\hyperlink{__triinterpolate_8py_source_l00479}{matplotlib.\+tri.\+\_\+triinterpolate.\+Cubic\+Tri\+Interpolator.\+\_\+get\+\_\+alpha\+\_\+vec()}}, \mbox{\hyperlink{__triinterpolate_8py_source_l00830}{matplotlib.\+tri.\+\_\+triinterpolate.\+\_\+\+Reduced\+HCT\+\_\+\+Element.\+get\+\_\+bending\+\_\+matrices()}}, \mbox{\hyperlink{__triinterpolate_8py_source_l00708}{matplotlib.\+tri.\+\_\+triinterpolate.\+\_\+\+Reduced\+HCT\+\_\+\+Element.\+get\+\_\+function\+\_\+derivatives()}}, \mbox{\hyperlink{__triinterpolate_8py_source_l00764}{matplotlib.\+tri.\+\_\+triinterpolate.\+\_\+\+Reduced\+HCT\+\_\+\+Element.\+get\+\_\+function\+\_\+hessians()}}, and \mbox{\hyperlink{__triinterpolate_8py_source_l00911}{matplotlib.\+tri.\+\_\+triinterpolate.\+\_\+\+Reduced\+HCT\+\_\+\+Element.\+get\+\_\+\+Kff\+\_\+and\+\_\+\+Ff()}}.



\doxysubsection{Variable Documentation}
\Hypertarget{namespacematplotlib_1_1tri_1_1__triinterpolate_a0fa75be706fa6ec27f709b9c6a1a3ee6}\index{matplotlib.tri.\_triinterpolate@{matplotlib.tri.\_triinterpolate}!\_\_all\_\_@{\_\_all\_\_}}
\index{\_\_all\_\_@{\_\_all\_\_}!matplotlib.tri.\_triinterpolate@{matplotlib.tri.\_triinterpolate}}
\doxysubsubsection{\texorpdfstring{\_\_all\_\_}{\_\_all\_\_}}
{\footnotesize\ttfamily \label{namespacematplotlib_1_1tri_1_1__triinterpolate_a0fa75be706fa6ec27f709b9c6a1a3ee6} 
tuple matplotlib.\+tri.\+\_\+triinterpolate.\+\_\+\+\_\+all\+\_\+\+\_\+ = (\textquotesingle{}\mbox{\hyperlink{classmatplotlib_1_1tri_1_1__triinterpolate_1_1TriInterpolator}{Tri\+Interpolator}}\textquotesingle{}, \textquotesingle{}\mbox{\hyperlink{classmatplotlib_1_1tri_1_1__triinterpolate_1_1LinearTriInterpolator}{Linear\+Tri\+Interpolator}}\textquotesingle{}, \textquotesingle{}\mbox{\hyperlink{classmatplotlib_1_1tri_1_1__triinterpolate_1_1CubicTriInterpolator}{Cubic\+Tri\+Interpolator}}\textquotesingle{})\hspace{0.3cm}{\ttfamily [private]}}



Definition at line \mbox{\hyperlink{__triinterpolate_8py_source_l00012}{12}} of file \mbox{\hyperlink{__triinterpolate_8py_source}{\+\_\+triinterpolate.\+py}}.

