\doxysection{scipy.\+linalg.\+\_\+matfuncs Namespace Reference}
\hypertarget{namespacescipy_1_1linalg_1_1__matfuncs}{}\label{namespacescipy_1_1linalg_1_1__matfuncs}\index{scipy.linalg.\_matfuncs@{scipy.linalg.\_matfuncs}}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacescipy_1_1linalg_1_1__matfuncs_a05a2b5e07664ebfce8a689d3fbf3e6cf}{\+\_\+asarray\+\_\+square}} (A)
\begin{DoxyCompactList}\small\item\em Utility functions. \end{DoxyCompactList}\item 
\mbox{\hyperlink{namespacescipy_1_1linalg_1_1__matfuncs_abaa09eb301194b21a0927ed064f32801}{\+\_\+maybe\+\_\+real}} (A, B, tol=None)
\item 
\mbox{\hyperlink{namespacescipy_1_1linalg_1_1__matfuncs_ab96d70c734b036dd8dbf7fb87e5978f1}{fractional\+\_\+matrix\+\_\+power}} (A, t)
\begin{DoxyCompactList}\small\item\em Matrix functions. \end{DoxyCompactList}\item 
\mbox{\hyperlink{namespacescipy_1_1linalg_1_1__matfuncs_a4dc544afa3b784dda9f742dc92abc723}{logm}} (A, disp=\mbox{\hyperlink{classTrue}{True}})
\item 
\mbox{\hyperlink{namespacescipy_1_1linalg_1_1__matfuncs_a9edbf3475cc0c5e6e7701aeae53e3e45}{expm}} (A)
\item 
\mbox{\hyperlink{namespacescipy_1_1linalg_1_1__matfuncs_a3c9a70da144ebd7e293232984aa4a250}{\+\_\+exp\+\_\+sinch}} (x)
\item 
\mbox{\hyperlink{namespacescipy_1_1linalg_1_1__matfuncs_a03ad72297d785e035af8ef4758d69ba8}{cosm}} (A)
\item 
\mbox{\hyperlink{namespacescipy_1_1linalg_1_1__matfuncs_a8e99a09f6c589271840bfd95e5b486a2}{sinm}} (A)
\item 
\mbox{\hyperlink{namespacescipy_1_1linalg_1_1__matfuncs_ad78ae302b448227e7da621691243e3e4}{tanm}} (A)
\item 
\mbox{\hyperlink{namespacescipy_1_1linalg_1_1__matfuncs_a8b7f46803ff176233973b65648f0f705}{coshm}} (A)
\item 
\mbox{\hyperlink{namespacescipy_1_1linalg_1_1__matfuncs_ae5b85f6f126ab691a7864badfd995171}{sinhm}} (A)
\item 
\mbox{\hyperlink{namespacescipy_1_1linalg_1_1__matfuncs_a4aa2595514d8229c828e71e95adbc282}{tanhm}} (A)
\item 
\mbox{\hyperlink{namespacescipy_1_1linalg_1_1__matfuncs_a1a713ca22800d9fe9c00a5608be2c99c}{funm}} (A, func, disp=\mbox{\hyperlink{classTrue}{True}})
\item 
\mbox{\hyperlink{namespacescipy_1_1linalg_1_1__matfuncs_a241dd03afab2072a15bdccb481bf5812}{signm}} (A, disp=\mbox{\hyperlink{classTrue}{True}})
\item 
\mbox{\hyperlink{namespacescipy_1_1linalg_1_1__matfuncs_aeaab816e6d56905a12a502b211a5e7ff}{khatri\+\_\+rao}} (a, b)
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
list \mbox{\hyperlink{namespacescipy_1_1linalg_1_1__matfuncs_a8ff5879e17b489010d13b6e1c1b732a3}{\+\_\+\+\_\+all\+\_\+\+\_\+}}
\item 
\mbox{\hyperlink{namespacescipy_1_1linalg_1_1__matfuncs_a836b45113aeaa4577c5a7d2fed5a5969}{eps}} = np.\+finfo(\textquotesingle{}d\textquotesingle{}).eps
\item 
\mbox{\hyperlink{namespacescipy_1_1linalg_1_1__matfuncs_a1dcda5082d96e3a0d6ce409f93b72e71}{feps}} = np.\+finfo(\textquotesingle{}f\textquotesingle{}).eps
\item 
dict \mbox{\hyperlink{namespacescipy_1_1linalg_1_1__matfuncs_acb829b26a93c85b6faab8111d76b6b2c}{\+\_\+array\+\_\+precision}} = \{\textquotesingle{}i\textquotesingle{}\+: 1, \textquotesingle{}l\textquotesingle{}\+: 1, \textquotesingle{}f\textquotesingle{}\+: 0, \textquotesingle{}d\textquotesingle{}\+: 1, \textquotesingle{}F\textquotesingle{}\+: 0, \textquotesingle{}D\textquotesingle{}\+: 1\}
\end{DoxyCompactItemize}


\doxysubsection{Function Documentation}
\Hypertarget{namespacescipy_1_1linalg_1_1__matfuncs_a05a2b5e07664ebfce8a689d3fbf3e6cf}\index{scipy.linalg.\_matfuncs@{scipy.linalg.\_matfuncs}!\_asarray\_square@{\_asarray\_square}}
\index{\_asarray\_square@{\_asarray\_square}!scipy.linalg.\_matfuncs@{scipy.linalg.\_matfuncs}}
\doxysubsubsection{\texorpdfstring{\_asarray\_square()}{\_asarray\_square()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1linalg_1_1__matfuncs_a05a2b5e07664ebfce8a689d3fbf3e6cf} 
scipy.\+linalg.\+\_\+matfuncs.\+\_\+asarray\+\_\+square (\begin{DoxyParamCaption}\item[{}]{A}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Utility functions. 

\begin{DoxyVerb}Wraps asarray with the extra requirement that the input be a square matrix.

The motivation is that the matfuncs module has real functions that have
been lifted to square matrix functions.

Parameters
----------
A : array_like
    A square matrix.

Returns
-------
out : ndarray
    An ndarray copy or view or other representation of A.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00035}{35}} of file \mbox{\hyperlink{linalg_2__matfuncs_8py_source}{\+\_\+matfuncs.\+py}}.



Referenced by \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00517}{coshm()}}, \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00398}{cosm()}}, \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00097}{fractional\+\_\+matrix\+\_\+power()}}, \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00634}{funm()}}, \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00143}{logm()}}, \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00739}{signm()}}, \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00556}{sinhm()}}, \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00438}{sinm()}}, \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00595}{tanhm()}}, and \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00478}{tanm()}}.

\Hypertarget{namespacescipy_1_1linalg_1_1__matfuncs_a3c9a70da144ebd7e293232984aa4a250}\index{scipy.linalg.\_matfuncs@{scipy.linalg.\_matfuncs}!\_exp\_sinch@{\_exp\_sinch}}
\index{\_exp\_sinch@{\_exp\_sinch}!scipy.linalg.\_matfuncs@{scipy.linalg.\_matfuncs}}
\doxysubsubsection{\texorpdfstring{\_exp\_sinch()}{\_exp\_sinch()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1linalg_1_1__matfuncs_a3c9a70da144ebd7e293232984aa4a250} 
scipy.\+linalg.\+\_\+matfuncs.\+\_\+exp\+\_\+sinch (\begin{DoxyParamCaption}\item[{}]{x}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00388}{388}} of file \mbox{\hyperlink{linalg_2__matfuncs_8py_source}{\+\_\+matfuncs.\+py}}.

\Hypertarget{namespacescipy_1_1linalg_1_1__matfuncs_abaa09eb301194b21a0927ed064f32801}\index{scipy.linalg.\_matfuncs@{scipy.linalg.\_matfuncs}!\_maybe\_real@{\_maybe\_real}}
\index{\_maybe\_real@{\_maybe\_real}!scipy.linalg.\_matfuncs@{scipy.linalg.\_matfuncs}}
\doxysubsubsection{\texorpdfstring{\_maybe\_real()}{\_maybe\_real()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1linalg_1_1__matfuncs_abaa09eb301194b21a0927ed064f32801} 
scipy.\+linalg.\+\_\+matfuncs.\+\_\+maybe\+\_\+real (\begin{DoxyParamCaption}\item[{}]{A}{, }\item[{}]{B}{, }\item[{}]{tol}{ = {\ttfamily None}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Return either B or the real part of B, depending on properties of A and B.

The motivation is that B has been computed as a complicated function of A,
and B may be perturbed by negligible imaginary components.
If A is real and B is complex with small imaginary components,
then return a real copy of B.  The assumption in that case would be that
the imaginary components of B are numerical artifacts.

Parameters
----------
A : ndarray
    Input array whose type is to be checked as real vs. complex.
B : ndarray
    Array to be returned, possibly without its imaginary part.
tol : float
    Absolute tolerance.

Returns
-------
out : real or complex array
    Either the input array B or only the real part of the input array B.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00059}{59}} of file \mbox{\hyperlink{linalg_2__matfuncs_8py_source}{\+\_\+matfuncs.\+py}}.



Referenced by \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00517}{coshm()}}, \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00634}{funm()}}, \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00143}{logm()}}, \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00556}{sinhm()}}, \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00595}{tanhm()}}, and \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00478}{tanm()}}.

\Hypertarget{namespacescipy_1_1linalg_1_1__matfuncs_a8b7f46803ff176233973b65648f0f705}\index{scipy.linalg.\_matfuncs@{scipy.linalg.\_matfuncs}!coshm@{coshm}}
\index{coshm@{coshm}!scipy.linalg.\_matfuncs@{scipy.linalg.\_matfuncs}}
\doxysubsubsection{\texorpdfstring{coshm()}{coshm()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1linalg_1_1__matfuncs_a8b7f46803ff176233973b65648f0f705} 
scipy.\+linalg.\+\_\+matfuncs.\+coshm (\begin{DoxyParamCaption}\item[{}]{A}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute the hyperbolic matrix cosine.

This routine uses expm to compute the matrix exponentials.

Parameters
----------
A : (N, N) array_like
    Input array.

Returns
-------
coshm : (N, N) ndarray
    Hyperbolic matrix cosine of `A`

Examples
--------
>>> import numpy as np
>>> from scipy.linalg import tanhm, sinhm, coshm
>>> a = np.array([[1.0, 3.0], [1.0, 4.0]])
>>> c = coshm(a)
>>> c
array([[ 11.24592233,  38.76236492],
       [ 12.92078831,  50.00828725]])

Verify tanhm(a) = sinhm(a).dot(inv(coshm(a)))

>>> t = tanhm(a)
>>> s = sinhm(a)
>>> t - s.dot(np.linalg.inv(c))
array([[  2.72004641e-15,   4.55191440e-15],
       [  0.00000000e+00,  -5.55111512e-16]])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00517}{517}} of file \mbox{\hyperlink{linalg_2__matfuncs_8py_source}{\+\_\+matfuncs.\+py}}.



References \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00035}{\+\_\+asarray\+\_\+square()}}, \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00059}{\+\_\+maybe\+\_\+real()}}, and \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00214}{expm()}}.



Referenced by \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00595}{tanhm()}}.

\Hypertarget{namespacescipy_1_1linalg_1_1__matfuncs_a03ad72297d785e035af8ef4758d69ba8}\index{scipy.linalg.\_matfuncs@{scipy.linalg.\_matfuncs}!cosm@{cosm}}
\index{cosm@{cosm}!scipy.linalg.\_matfuncs@{scipy.linalg.\_matfuncs}}
\doxysubsubsection{\texorpdfstring{cosm()}{cosm()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1linalg_1_1__matfuncs_a03ad72297d785e035af8ef4758d69ba8} 
scipy.\+linalg.\+\_\+matfuncs.\+cosm (\begin{DoxyParamCaption}\item[{}]{A}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute the matrix cosine.

This routine uses expm to compute the matrix exponentials.

Parameters
----------
A : (N, N) array_like
    Input array

Returns
-------
cosm : (N, N) ndarray
    Matrix cosine of A

Examples
--------
>>> import numpy as np
>>> from scipy.linalg import expm, sinm, cosm

Euler's identity (exp(i*theta) = cos(theta) + i*sin(theta))
applied to a matrix:

>>> a = np.array([[1.0, 2.0], [-1.0, 3.0]])
>>> expm(1j*a)
array([[ 0.42645930+1.89217551j, -2.13721484-0.97811252j],
       [ 1.06860742+0.48905626j, -1.71075555+0.91406299j]])
>>> cosm(a) + 1j*sinm(a)
array([[ 0.42645930+1.89217551j, -2.13721484-0.97811252j],
       [ 1.06860742+0.48905626j, -1.71075555+0.91406299j]])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00398}{398}} of file \mbox{\hyperlink{linalg_2__matfuncs_8py_source}{\+\_\+matfuncs.\+py}}.



References \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00035}{\+\_\+asarray\+\_\+square()}}, and \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00214}{expm()}}.



Referenced by \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00478}{tanm()}}.

\Hypertarget{namespacescipy_1_1linalg_1_1__matfuncs_a9edbf3475cc0c5e6e7701aeae53e3e45}\index{scipy.linalg.\_matfuncs@{scipy.linalg.\_matfuncs}!expm@{expm}}
\index{expm@{expm}!scipy.linalg.\_matfuncs@{scipy.linalg.\_matfuncs}}
\doxysubsubsection{\texorpdfstring{expm()}{expm()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1linalg_1_1__matfuncs_a9edbf3475cc0c5e6e7701aeae53e3e45} 
scipy.\+linalg.\+\_\+matfuncs.\+expm (\begin{DoxyParamCaption}\item[{}]{A}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute the matrix exponential of an array.

Parameters
----------
A : ndarray
    Input with last two dimensions are square ``(..., n, n)``.

Returns
-------
eA : ndarray
    The resulting matrix exponential with the same shape of ``A``

Notes
-----
Implements the algorithm given in [1], which is essentially a Pade
approximation with a variable order that is decided based on the array
data.

For input with size ``n``, the memory usage is in the worst case in the
order of ``8*(n**2)``. If the input data is not of single and double
precision of real and complex dtypes, it is copied to a new array.

For cases ``n >= 400``, the exact 1-norm computation cost, breaks even with
1-norm estimation and from that point on the estimation scheme given in
[2] is used to decide on the approximation order.

References
----------
.. [1] Awad H. Al-Mohy and Nicholas J. Higham, (2009), "A New Scaling
       and Squaring Algorithm for the Matrix Exponential", SIAM J. Matrix
       Anal. Appl. 31(3):970-989, :doi:`10.1137/09074721X`

.. [2] Nicholas J. Higham and Francoise Tisseur (2000), "A Block Algorithm
       for Matrix 1-Norm Estimation, with an Application to 1-Norm
       Pseudospectra." SIAM J. Matrix Anal. Appl. 21(4):1185-1201,
       :doi:`10.1137/S0895479899356080`

Examples
--------
>>> import numpy as np
>>> from scipy.linalg import expm, sinm, cosm

Matrix version of the formula exp(0) = 1:

>>> expm(np.zeros((3, 2, 2)))
array([[[1., 0.],
        [0., 1.]],
<BLANKLINE>
       [[1., 0.],
        [0., 1.]],
<BLANKLINE>
       [[1., 0.],
        [0., 1.]]])

Euler's identity (exp(i*theta) = cos(theta) + i*sin(theta))
applied to a matrix:

>>> a = np.array([[1.0, 2.0], [-1.0, 3.0]])
>>> expm(1j*a)
array([[ 0.42645930+1.89217551j, -2.13721484-0.97811252j],
       [ 1.06860742+0.48905626j, -1.71075555+0.91406299j]])
>>> cosm(a) + 1j*sinm(a)
array([[ 0.42645930+1.89217551j, -2.13721484-0.97811252j],
       [ 1.06860742+0.48905626j, -1.71075555+0.91406299j]])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00214}{214}} of file \mbox{\hyperlink{linalg_2__matfuncs_8py_source}{\+\_\+matfuncs.\+py}}.



Referenced by \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00517}{coshm()}}, \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00398}{cosm()}}, \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00143}{logm()}}, \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00556}{sinhm()}}, and \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00438}{sinm()}}.

\Hypertarget{namespacescipy_1_1linalg_1_1__matfuncs_ab96d70c734b036dd8dbf7fb87e5978f1}\index{scipy.linalg.\_matfuncs@{scipy.linalg.\_matfuncs}!fractional\_matrix\_power@{fractional\_matrix\_power}}
\index{fractional\_matrix\_power@{fractional\_matrix\_power}!scipy.linalg.\_matfuncs@{scipy.linalg.\_matfuncs}}
\doxysubsubsection{\texorpdfstring{fractional\_matrix\_power()}{fractional\_matrix\_power()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1linalg_1_1__matfuncs_ab96d70c734b036dd8dbf7fb87e5978f1} 
scipy.\+linalg.\+\_\+matfuncs.\+fractional\+\_\+matrix\+\_\+power (\begin{DoxyParamCaption}\item[{}]{A}{, }\item[{}]{t}{}\end{DoxyParamCaption})}



Matrix functions. 

\begin{DoxyVerb}Compute the fractional power of a matrix.

Proceeds according to the discussion in section (6) of [1]_.

Parameters
----------
A : (N, N) array_like
    Matrix whose fractional power to evaluate.
t : float
    Fractional power.

Returns
-------
X : (N, N) array_like
    The fractional power of the matrix.

References
----------
.. [1] Nicholas J. Higham and Lijing lin (2011)
       "A Schur-Pade Algorithm for Fractional Powers of a Matrix."
       SIAM Journal on Matrix Analysis and Applications,
       32 (3). pp. 1056-1078. ISSN 0895-4798

Examples
--------
>>> import numpy as np
>>> from scipy.linalg import fractional_matrix_power
>>> a = np.array([[1.0, 3.0], [1.0, 4.0]])
>>> b = fractional_matrix_power(a, 0.5)
>>> b
array([[ 0.75592895,  1.13389342],
       [ 0.37796447,  1.88982237]])
>>> np.dot(b, b)      # Verify square root
array([[ 1.,  3.],
       [ 1.,  4.]])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00097}{97}} of file \mbox{\hyperlink{linalg_2__matfuncs_8py_source}{\+\_\+matfuncs.\+py}}.



References \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00035}{\+\_\+asarray\+\_\+square()}}, and \mbox{\hyperlink{__matfuncs__inv__ssq_8py_source_l00671}{scipy.\+linalg.\+\_\+matfuncs\+\_\+inv\+\_\+ssq.\+\_\+fractional\+\_\+matrix\+\_\+power()}}.

\Hypertarget{namespacescipy_1_1linalg_1_1__matfuncs_a1a713ca22800d9fe9c00a5608be2c99c}\index{scipy.linalg.\_matfuncs@{scipy.linalg.\_matfuncs}!funm@{funm}}
\index{funm@{funm}!scipy.linalg.\_matfuncs@{scipy.linalg.\_matfuncs}}
\doxysubsubsection{\texorpdfstring{funm()}{funm()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1linalg_1_1__matfuncs_a1a713ca22800d9fe9c00a5608be2c99c} 
scipy.\+linalg.\+\_\+matfuncs.\+funm (\begin{DoxyParamCaption}\item[{}]{A}{, }\item[{}]{func}{, }\item[{}]{disp}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Evaluate a matrix function specified by a callable.

Returns the value of matrix-valued function ``f`` at `A`. The
function ``f`` is an extension of the scalar-valued function `func`
to matrices.

Parameters
----------
A : (N, N) array_like
    Matrix at which to evaluate the function
func : callable
    Callable object that evaluates a scalar function f.
    Must be vectorized (eg. using vectorize).
disp : bool, optional
    Print warning if error in the result is estimated large
    instead of returning estimated error. (Default: True)

Returns
-------
funm : (N, N) ndarray
    Value of the matrix function specified by func evaluated at `A`
errest : float
    (if disp == False)

    1-norm of the estimated error, ||err||_1 / ||A||_1

Notes
-----
This function implements the general algorithm based on Schur decomposition
(Algorithm 9.1.1. in [1]_).

If the input matrix is known to be diagonalizable, then relying on the
eigendecomposition is likely to be faster. For example, if your matrix is
Hermitian, you can do

>>> from scipy.linalg import eigh
>>> def funm_herm(a, func, check_finite=False):
...     w, v = eigh(a, check_finite=check_finite)
...     ## if you further know that your matrix is positive semidefinite,
...     ## you can optionally guard against precision errors by doing
...     # w = np.maximum(w, 0)
...     w = func(w)
...     return (v * w).dot(v.conj().T)

References
----------
.. [1] Gene H. Golub, Charles F. van Loan, Matrix Computations 4th ed.

Examples
--------
>>> import numpy as np
>>> from scipy.linalg import funm
>>> a = np.array([[1.0, 3.0], [1.0, 4.0]])
>>> funm(a, lambda x: x*x)
array([[  4.,  15.],
       [  5.,  19.]])
>>> a.dot(a)
array([[  4.,  15.],
       [  5.,  19.]])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00634}{634}} of file \mbox{\hyperlink{linalg_2__matfuncs_8py_source}{\+\_\+matfuncs.\+py}}.



References \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00035}{\+\_\+asarray\+\_\+square()}}, \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00059}{\+\_\+maybe\+\_\+real()}}, \mbox{\hyperlink{__decomp__schur_8py_source_l00216}{scipy.\+linalg.\+\_\+decomp\+\_\+schur.\+rsf2csf()}}, \mbox{\hyperlink{__decomp__schur_8py_source_l00018}{scipy.\+linalg.\+\_\+decomp\+\_\+schur.\+schur()}}, and \mbox{\hyperlink{__special__matrices_8py_source_l00120}{scipy.\+linalg.\+\_\+special\+\_\+matrices.\+triu()}}.



Referenced by \mbox{\hyperlink{__matfuncs__inv__ssq_8py_source_l00671}{scipy.\+linalg.\+\_\+matfuncs\+\_\+inv\+\_\+ssq.\+\_\+fractional\+\_\+matrix\+\_\+power()}}, and \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00739}{signm()}}.

\Hypertarget{namespacescipy_1_1linalg_1_1__matfuncs_aeaab816e6d56905a12a502b211a5e7ff}\index{scipy.linalg.\_matfuncs@{scipy.linalg.\_matfuncs}!khatri\_rao@{khatri\_rao}}
\index{khatri\_rao@{khatri\_rao}!scipy.linalg.\_matfuncs@{scipy.linalg.\_matfuncs}}
\doxysubsubsection{\texorpdfstring{khatri\_rao()}{khatri\_rao()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1linalg_1_1__matfuncs_aeaab816e6d56905a12a502b211a5e7ff} 
scipy.\+linalg.\+\_\+matfuncs.\+khatri\+\_\+rao (\begin{DoxyParamCaption}\item[{}]{a}{, }\item[{}]{b}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Khatri-rao product

A column-wise Kronecker product of two matrices

Parameters
----------
a : (n, k) array_like
    Input array
b : (m, k) array_like
    Input array

Returns
-------
c:  (n*m, k) ndarray
    Khatri-rao product of `a` and `b`.

See Also
--------
kron : Kronecker product

Notes
-----
The mathematical definition of the Khatri-Rao product is:

.. math::

    (A_{ij}  \bigotimes B_{ij})_{ij}

which is the Kronecker product of every column of A and B, e.g.::

    c = np.vstack([np.kron(a[:, k], b[:, k]) for k in range(b.shape[1])]).T

Examples
--------
>>> import numpy as np
>>> from scipy import linalg
>>> a = np.array([[1, 2, 3], [4, 5, 6]])
>>> b = np.array([[3, 4, 5], [6, 7, 8], [2, 3, 9]])
>>> linalg.khatri_rao(a, b)
array([[ 3,  8, 15],
       [ 6, 14, 24],
       [ 2,  6, 27],
       [12, 20, 30],
       [24, 35, 48],
       [ 8, 15, 54]])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00819}{819}} of file \mbox{\hyperlink{linalg_2__matfuncs_8py_source}{\+\_\+matfuncs.\+py}}.

\Hypertarget{namespacescipy_1_1linalg_1_1__matfuncs_a4dc544afa3b784dda9f742dc92abc723}\index{scipy.linalg.\_matfuncs@{scipy.linalg.\_matfuncs}!logm@{logm}}
\index{logm@{logm}!scipy.linalg.\_matfuncs@{scipy.linalg.\_matfuncs}}
\doxysubsubsection{\texorpdfstring{logm()}{logm()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1linalg_1_1__matfuncs_a4dc544afa3b784dda9f742dc92abc723} 
scipy.\+linalg.\+\_\+matfuncs.\+logm (\begin{DoxyParamCaption}\item[{}]{A}{, }\item[{}]{disp}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute matrix logarithm.

The matrix logarithm is the inverse of
expm: expm(logm(`A`)) == `A`

Parameters
----------
A : (N, N) array_like
    Matrix whose logarithm to evaluate
disp : bool, optional
    Print warning if error in the result is estimated large
    instead of returning estimated error. (Default: True)

Returns
-------
logm : (N, N) ndarray
    Matrix logarithm of `A`
errest : float
    (if disp == False)

    1-norm of the estimated error, ||err||_1 / ||A||_1

References
----------
.. [1] Awad H. Al-Mohy and Nicholas J. Higham (2012)
       "Improved Inverse Scaling and Squaring Algorithms
       for the Matrix Logarithm."
       SIAM Journal on Scientific Computing, 34 (4). C152-C169.
       ISSN 1095-7197

.. [2] Nicholas J. Higham (2008)
       "Functions of Matrices: Theory and Computation"
       ISBN 978-0-898716-46-7

.. [3] Nicholas J. Higham and Lijing lin (2011)
       "A Schur-Pade Algorithm for Fractional Powers of a Matrix."
       SIAM Journal on Matrix Analysis and Applications,
       32 (3). pp. 1056-1078. ISSN 0895-4798

Examples
--------
>>> import numpy as np
>>> from scipy.linalg import logm, expm
>>> a = np.array([[1.0, 3.0], [1.0, 4.0]])
>>> b = logm(a)
>>> b
array([[-1.02571087,  2.05142174],
       [ 0.68380725,  1.02571087]])
>>> expm(b)         # Verify expm(logm(a)) returns a
array([[ 1.,  3.],
       [ 1.,  4.]])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00143}{143}} of file \mbox{\hyperlink{linalg_2__matfuncs_8py_source}{\+\_\+matfuncs.\+py}}.



References \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00035}{\+\_\+asarray\+\_\+square()}}, \mbox{\hyperlink{__matfuncs__inv__ssq_8py_source_l00840}{scipy.\+linalg.\+\_\+matfuncs\+\_\+inv\+\_\+ssq.\+\_\+logm()}}, \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00059}{\+\_\+maybe\+\_\+real()}}, and \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00214}{expm()}}.

\Hypertarget{namespacescipy_1_1linalg_1_1__matfuncs_a241dd03afab2072a15bdccb481bf5812}\index{scipy.linalg.\_matfuncs@{scipy.linalg.\_matfuncs}!signm@{signm}}
\index{signm@{signm}!scipy.linalg.\_matfuncs@{scipy.linalg.\_matfuncs}}
\doxysubsubsection{\texorpdfstring{signm()}{signm()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1linalg_1_1__matfuncs_a241dd03afab2072a15bdccb481bf5812} 
scipy.\+linalg.\+\_\+matfuncs.\+signm (\begin{DoxyParamCaption}\item[{}]{A}{, }\item[{}]{disp}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Matrix sign function.

Extension of the scalar sign(x) to matrices.

Parameters
----------
A : (N, N) array_like
    Matrix at which to evaluate the sign function
disp : bool, optional
    Print warning if error in the result is estimated large
    instead of returning estimated error. (Default: True)

Returns
-------
signm : (N, N) ndarray
    Value of the sign function at `A`
errest : float
    (if disp == False)

    1-norm of the estimated error, ||err||_1 / ||A||_1

Examples
--------
>>> from scipy.linalg import signm, eigvals
>>> a = [[1,2,3], [1,2,1], [1,1,1]]
>>> eigvals(a)
array([ 4.12488542+0.j, -0.76155718+0.j,  0.63667176+0.j])
>>> eigvals(signm(a))
array([-1.+0.j,  1.+0.j,  1.+0.j])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00739}{739}} of file \mbox{\hyperlink{linalg_2__matfuncs_8py_source}{\+\_\+matfuncs.\+py}}.



References \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00035}{\+\_\+asarray\+\_\+square()}}, \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00634}{funm()}}, \mbox{\hyperlink{linalg_2__basic_8py_source_l00903}{scipy.\+linalg.\+\_\+basic.\+inv()}}, and \mbox{\hyperlink{__decomp__svd_8py_source_l00014}{scipy.\+linalg.\+\_\+decomp\+\_\+svd.\+svd()}}.

\Hypertarget{namespacescipy_1_1linalg_1_1__matfuncs_ae5b85f6f126ab691a7864badfd995171}\index{scipy.linalg.\_matfuncs@{scipy.linalg.\_matfuncs}!sinhm@{sinhm}}
\index{sinhm@{sinhm}!scipy.linalg.\_matfuncs@{scipy.linalg.\_matfuncs}}
\doxysubsubsection{\texorpdfstring{sinhm()}{sinhm()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1linalg_1_1__matfuncs_ae5b85f6f126ab691a7864badfd995171} 
scipy.\+linalg.\+\_\+matfuncs.\+sinhm (\begin{DoxyParamCaption}\item[{}]{A}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute the hyperbolic matrix sine.

This routine uses expm to compute the matrix exponentials.

Parameters
----------
A : (N, N) array_like
    Input array.

Returns
-------
sinhm : (N, N) ndarray
    Hyperbolic matrix sine of `A`

Examples
--------
>>> import numpy as np
>>> from scipy.linalg import tanhm, sinhm, coshm
>>> a = np.array([[1.0, 3.0], [1.0, 4.0]])
>>> s = sinhm(a)
>>> s
array([[ 10.57300653,  39.28826594],
       [ 13.09608865,  49.86127247]])

Verify tanhm(a) = sinhm(a).dot(inv(coshm(a)))

>>> t = tanhm(a)
>>> c = coshm(a)
>>> t - s.dot(np.linalg.inv(c))
array([[  2.72004641e-15,   4.55191440e-15],
       [  0.00000000e+00,  -5.55111512e-16]])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00556}{556}} of file \mbox{\hyperlink{linalg_2__matfuncs_8py_source}{\+\_\+matfuncs.\+py}}.



References \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00035}{\+\_\+asarray\+\_\+square()}}, \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00059}{\+\_\+maybe\+\_\+real()}}, and \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00214}{expm()}}.



Referenced by \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00595}{tanhm()}}.

\Hypertarget{namespacescipy_1_1linalg_1_1__matfuncs_a8e99a09f6c589271840bfd95e5b486a2}\index{scipy.linalg.\_matfuncs@{scipy.linalg.\_matfuncs}!sinm@{sinm}}
\index{sinm@{sinm}!scipy.linalg.\_matfuncs@{scipy.linalg.\_matfuncs}}
\doxysubsubsection{\texorpdfstring{sinm()}{sinm()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1linalg_1_1__matfuncs_a8e99a09f6c589271840bfd95e5b486a2} 
scipy.\+linalg.\+\_\+matfuncs.\+sinm (\begin{DoxyParamCaption}\item[{}]{A}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute the matrix sine.

This routine uses expm to compute the matrix exponentials.

Parameters
----------
A : (N, N) array_like
    Input array.

Returns
-------
sinm : (N, N) ndarray
    Matrix sine of `A`

Examples
--------
>>> import numpy as np
>>> from scipy.linalg import expm, sinm, cosm

Euler's identity (exp(i*theta) = cos(theta) + i*sin(theta))
applied to a matrix:

>>> a = np.array([[1.0, 2.0], [-1.0, 3.0]])
>>> expm(1j*a)
array([[ 0.42645930+1.89217551j, -2.13721484-0.97811252j],
       [ 1.06860742+0.48905626j, -1.71075555+0.91406299j]])
>>> cosm(a) + 1j*sinm(a)
array([[ 0.42645930+1.89217551j, -2.13721484-0.97811252j],
       [ 1.06860742+0.48905626j, -1.71075555+0.91406299j]])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00438}{438}} of file \mbox{\hyperlink{linalg_2__matfuncs_8py_source}{\+\_\+matfuncs.\+py}}.



References \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00035}{\+\_\+asarray\+\_\+square()}}, and \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00214}{expm()}}.



Referenced by \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00478}{tanm()}}.

\Hypertarget{namespacescipy_1_1linalg_1_1__matfuncs_a4aa2595514d8229c828e71e95adbc282}\index{scipy.linalg.\_matfuncs@{scipy.linalg.\_matfuncs}!tanhm@{tanhm}}
\index{tanhm@{tanhm}!scipy.linalg.\_matfuncs@{scipy.linalg.\_matfuncs}}
\doxysubsubsection{\texorpdfstring{tanhm()}{tanhm()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1linalg_1_1__matfuncs_a4aa2595514d8229c828e71e95adbc282} 
scipy.\+linalg.\+\_\+matfuncs.\+tanhm (\begin{DoxyParamCaption}\item[{}]{A}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute the hyperbolic matrix tangent.

This routine uses expm to compute the matrix exponentials.

Parameters
----------
A : (N, N) array_like
    Input array

Returns
-------
tanhm : (N, N) ndarray
    Hyperbolic matrix tangent of `A`

Examples
--------
>>> import numpy as np
>>> from scipy.linalg import tanhm, sinhm, coshm
>>> a = np.array([[1.0, 3.0], [1.0, 4.0]])
>>> t = tanhm(a)
>>> t
array([[ 0.3428582 ,  0.51987926],
       [ 0.17329309,  0.86273746]])

Verify tanhm(a) = sinhm(a).dot(inv(coshm(a)))

>>> s = sinhm(a)
>>> c = coshm(a)
>>> t - s.dot(np.linalg.inv(c))
array([[  2.72004641e-15,   4.55191440e-15],
       [  0.00000000e+00,  -5.55111512e-16]])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00595}{595}} of file \mbox{\hyperlink{linalg_2__matfuncs_8py_source}{\+\_\+matfuncs.\+py}}.



References \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00035}{\+\_\+asarray\+\_\+square()}}, \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00059}{\+\_\+maybe\+\_\+real()}}, \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00517}{coshm()}}, \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00556}{sinhm()}}, and \mbox{\hyperlink{linalg_2__basic_8py_source_l00054}{scipy.\+linalg.\+\_\+basic.\+solve()}}.

\Hypertarget{namespacescipy_1_1linalg_1_1__matfuncs_ad78ae302b448227e7da621691243e3e4}\index{scipy.linalg.\_matfuncs@{scipy.linalg.\_matfuncs}!tanm@{tanm}}
\index{tanm@{tanm}!scipy.linalg.\_matfuncs@{scipy.linalg.\_matfuncs}}
\doxysubsubsection{\texorpdfstring{tanm()}{tanm()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1linalg_1_1__matfuncs_ad78ae302b448227e7da621691243e3e4} 
scipy.\+linalg.\+\_\+matfuncs.\+tanm (\begin{DoxyParamCaption}\item[{}]{A}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute the matrix tangent.

This routine uses expm to compute the matrix exponentials.

Parameters
----------
A : (N, N) array_like
    Input array.

Returns
-------
tanm : (N, N) ndarray
    Matrix tangent of `A`

Examples
--------
>>> import numpy as np
>>> from scipy.linalg import tanm, sinm, cosm
>>> a = np.array([[1.0, 3.0], [1.0, 4.0]])
>>> t = tanm(a)
>>> t
array([[ -2.00876993,  -8.41880636],
       [ -2.80626879, -10.42757629]])

Verify tanm(a) = sinm(a).dot(inv(cosm(a)))

>>> s = sinm(a)
>>> c = cosm(a)
>>> s.dot(np.linalg.inv(c))
array([[ -2.00876993,  -8.41880636],
       [ -2.80626879, -10.42757629]])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00478}{478}} of file \mbox{\hyperlink{linalg_2__matfuncs_8py_source}{\+\_\+matfuncs.\+py}}.



References \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00035}{\+\_\+asarray\+\_\+square()}}, \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00059}{\+\_\+maybe\+\_\+real()}}, \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00398}{cosm()}}, \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00438}{sinm()}}, and \mbox{\hyperlink{linalg_2__basic_8py_source_l00054}{scipy.\+linalg.\+\_\+basic.\+solve()}}.



\doxysubsection{Variable Documentation}
\Hypertarget{namespacescipy_1_1linalg_1_1__matfuncs_a8ff5879e17b489010d13b6e1c1b732a3}\index{scipy.linalg.\_matfuncs@{scipy.linalg.\_matfuncs}!\_\_all\_\_@{\_\_all\_\_}}
\index{\_\_all\_\_@{\_\_all\_\_}!scipy.linalg.\_matfuncs@{scipy.linalg.\_matfuncs}}
\doxysubsubsection{\texorpdfstring{\_\_all\_\_}{\_\_all\_\_}}
{\footnotesize\ttfamily \label{namespacescipy_1_1linalg_1_1__matfuncs_a8ff5879e17b489010d13b6e1c1b732a3} 
list scipy.\+linalg.\+\_\+matfuncs.\+\_\+\+\_\+all\+\_\+\+\_\+\hspace{0.3cm}{\ttfamily [private]}}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ [\textcolor{stringliteral}{'expm'},\ \textcolor{stringliteral}{'cosm'},\ \textcolor{stringliteral}{'sinm'},\ \textcolor{stringliteral}{'tanm'},\ \textcolor{stringliteral}{'coshm'},\ \textcolor{stringliteral}{'sinhm'},\ \textcolor{stringliteral}{'tanhm'},\ \textcolor{stringliteral}{'logm'},}
\DoxyCodeLine{00002\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'funm'},\ \textcolor{stringliteral}{'signm'},\ \textcolor{stringliteral}{'sqrtm'},\ \textcolor{stringliteral}{'fractional\_matrix\_power'},\ \textcolor{stringliteral}{'expm\_frechet'},}
\DoxyCodeLine{00003\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'expm\_cond'},\ \textcolor{stringliteral}{'khatri\_rao'}]}

\end{DoxyCode}


Definition at line \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00021}{21}} of file \mbox{\hyperlink{linalg_2__matfuncs_8py_source}{\+\_\+matfuncs.\+py}}.

\Hypertarget{namespacescipy_1_1linalg_1_1__matfuncs_acb829b26a93c85b6faab8111d76b6b2c}\index{scipy.linalg.\_matfuncs@{scipy.linalg.\_matfuncs}!\_array\_precision@{\_array\_precision}}
\index{\_array\_precision@{\_array\_precision}!scipy.linalg.\_matfuncs@{scipy.linalg.\_matfuncs}}
\doxysubsubsection{\texorpdfstring{\_array\_precision}{\_array\_precision}}
{\footnotesize\ttfamily \label{namespacescipy_1_1linalg_1_1__matfuncs_acb829b26a93c85b6faab8111d76b6b2c} 
dict scipy.\+linalg.\+\_\+matfuncs.\+\_\+array\+\_\+precision = \{\textquotesingle{}i\textquotesingle{}\+: 1, \textquotesingle{}l\textquotesingle{}\+: 1, \textquotesingle{}f\textquotesingle{}\+: 0, \textquotesingle{}d\textquotesingle{}\+: 1, \textquotesingle{}F\textquotesingle{}\+: 0, \textquotesingle{}D\textquotesingle{}\+: 1\}\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00028}{28}} of file \mbox{\hyperlink{linalg_2__matfuncs_8py_source}{\+\_\+matfuncs.\+py}}.

\Hypertarget{namespacescipy_1_1linalg_1_1__matfuncs_a836b45113aeaa4577c5a7d2fed5a5969}\index{scipy.linalg.\_matfuncs@{scipy.linalg.\_matfuncs}!eps@{eps}}
\index{eps@{eps}!scipy.linalg.\_matfuncs@{scipy.linalg.\_matfuncs}}
\doxysubsubsection{\texorpdfstring{eps}{eps}}
{\footnotesize\ttfamily \label{namespacescipy_1_1linalg_1_1__matfuncs_a836b45113aeaa4577c5a7d2fed5a5969} 
scipy.\+linalg.\+\_\+matfuncs.\+eps = np.\+finfo(\textquotesingle{}d\textquotesingle{}).eps}



Definition at line \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00025}{25}} of file \mbox{\hyperlink{linalg_2__matfuncs_8py_source}{\+\_\+matfuncs.\+py}}.

\Hypertarget{namespacescipy_1_1linalg_1_1__matfuncs_a1dcda5082d96e3a0d6ce409f93b72e71}\index{scipy.linalg.\_matfuncs@{scipy.linalg.\_matfuncs}!feps@{feps}}
\index{feps@{feps}!scipy.linalg.\_matfuncs@{scipy.linalg.\_matfuncs}}
\doxysubsubsection{\texorpdfstring{feps}{feps}}
{\footnotesize\ttfamily \label{namespacescipy_1_1linalg_1_1__matfuncs_a1dcda5082d96e3a0d6ce409f93b72e71} 
scipy.\+linalg.\+\_\+matfuncs.\+feps = np.\+finfo(\textquotesingle{}f\textquotesingle{}).eps}



Definition at line \mbox{\hyperlink{linalg_2__matfuncs_8py_source_l00026}{26}} of file \mbox{\hyperlink{linalg_2__matfuncs_8py_source}{\+\_\+matfuncs.\+py}}.

