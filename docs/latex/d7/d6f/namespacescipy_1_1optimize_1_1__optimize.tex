\doxysection{scipy.\+optimize.\+\_\+optimize Namespace Reference}
\hypertarget{namespacescipy_1_1optimize_1_1__optimize}{}\label{namespacescipy_1_1optimize_1_1__optimize}\index{scipy.optimize.\_optimize@{scipy.optimize.\_optimize}}
\doxysubsubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classscipy_1_1optimize_1_1__optimize_1_1__Brute__Wrapper}{\+\_\+\+Brute\+\_\+\+Wrapper}}
\item 
class \mbox{\hyperlink{classscipy_1_1optimize_1_1__optimize_1_1__LineSearchError}{\+\_\+\+Line\+Search\+Error}}
\item 
class \mbox{\hyperlink{classscipy_1_1optimize_1_1__optimize_1_1__MaxFuncCallError}{\+\_\+\+Max\+Func\+Call\+Error}}
\item 
class \mbox{\hyperlink{classscipy_1_1optimize_1_1__optimize_1_1BracketError}{Bracket\+Error}}
\item 
class \mbox{\hyperlink{classscipy_1_1optimize_1_1__optimize_1_1Brent}{Brent}}
\item 
class \mbox{\hyperlink{classscipy_1_1optimize_1_1__optimize_1_1MemoizeJac}{Memoize\+Jac}}
\item 
class \mbox{\hyperlink{classscipy_1_1optimize_1_1__optimize_1_1OptimizeResult}{Optimize\+Result}}
\item 
class \mbox{\hyperlink{classscipy_1_1optimize_1_1__optimize_1_1OptimizeWarning}{Optimize\+Warning}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__optimize_a9720f6e22ec7a6c85263edb52ffa463a}{\+\_\+indenter}} (s, n=0)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__optimize_a7b146471678d0a5a7821772d6e2bb236}{\+\_\+float\+\_\+formatter\+\_\+10}} (x)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__optimize_a16adb1174e785ba9b631bc91a8be27f0}{\+\_\+dict\+\_\+formatter}} (d, n=0, mplus=1, sorter=None)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__optimize_ad1f8fee294ebdb8f4608bd0fd21527e2}{\+\_\+wrap\+\_\+callback}} (callback, method=None)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__optimize_a15df8b8131f027070766bef3407058fe}{\+\_\+call\+\_\+callback\+\_\+maybe\+\_\+halt}} (callback, res)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__optimize_adb2a481bff6d99a8ce39d61a605474d2}{\+\_\+check\+\_\+unknown\+\_\+options}} (unknown\+\_\+options)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__optimize_a4617fe1820f4b4d06fd35f7530b5962e}{is\+\_\+finite\+\_\+scalar}} (x)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__optimize_a77867a3f237b7be985c2947451714929}{vecnorm}} (x, ord=2)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__optimize_ad73454f855569a9ca1a9979e3d9b7a0a}{\+\_\+prepare\+\_\+scalar\+\_\+function}} (fun, x0, jac=None, args=(), bounds=None, epsilon=None, finite\+\_\+diff\+\_\+rel\+\_\+step=None, hess=None)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__optimize_adf949eb8be2c742f97371a6adb8accac}{\+\_\+clip\+\_\+x\+\_\+for\+\_\+func}} (func, bounds)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__optimize_a8352decf7aa9c9c9b686a613eec05caa}{\+\_\+check\+\_\+clip\+\_\+x}} (x, bounds)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__optimize_a02e15f5b55789e1f63fd216733195454}{rosen}} (x)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__optimize_a54e7ddc9ff63c7eaa2b008492c9f7821}{rosen\+\_\+der}} (x)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__optimize_aaab0b0f1af6a0025d1ea4ab30b6412b1}{rosen\+\_\+hess}} (x)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__optimize_a531ebd72f83786f0ce75f3347ecb2449}{rosen\+\_\+hess\+\_\+prod}} (x, p)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__optimize_a0289ea1f45541e56b527dc7817c88bbd}{\+\_\+wrap\+\_\+scalar\+\_\+function}} (\mbox{\hyperlink{classfunction}{function}}, args)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__optimize_abf807e331a381a821ee49e99e63f6578}{\+\_\+wrap\+\_\+scalar\+\_\+function\+\_\+maxfun\+\_\+validation}} (\mbox{\hyperlink{classfunction}{function}}, args, maxfun)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__optimize_a1c8825f72fbb699b9d86a64dfd7f2d5b}{fmin}} (func, x0, args=(), xtol=1e-\/4, ftol=1e-\/4, maxiter=None, maxfun=None, full\+\_\+output=0, disp=1, retall=0, callback=None, initial\+\_\+simplex=None)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__optimize_a021f788937329bc7411d5a6b29a84173}{\+\_\+minimize\+\_\+neldermead}} (func, x0, args=(), callback=None, maxiter=None, maxfev=None, disp=False, return\+\_\+all=False, initial\+\_\+simplex=None, xatol=1e-\/4, fatol=1e-\/4, adaptive=False, bounds=None, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}unknown\+\_\+options)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__optimize_ab1bdcfcf9601a38ca22629dc3d93ef39}{approx\+\_\+fprime}} (xk, f, epsilon=\+\_\+epsilon, \texorpdfstring{$\ast$}{*}args)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__optimize_a5fba77c8a7356feafdaff564a7c39b48}{check\+\_\+grad}} (func, grad, x0, \texorpdfstring{$\ast$}{*}args, epsilon=\+\_\+epsilon, direction=\textquotesingle{}all\textquotesingle{}, seed=None)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__optimize_a11dbfcc1981be014e18da16c4f1b7545}{approx\+\_\+fhess\+\_\+p}} (x0, p, fprime, epsilon, \texorpdfstring{$\ast$}{*}args)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__optimize_a7199b6af73bdb0295d37336b3be8ed5a}{\+\_\+line\+\_\+search\+\_\+wolfe12}} (f, fprime, xk, pk, gfk, old\+\_\+fval, old\+\_\+old\+\_\+fval, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}kwargs)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__optimize_a7cca7c5cd6e2b781b6d706de4a3044dc}{fmin\+\_\+bfgs}} (f, x0, fprime=None, args=(), gtol=1e-\/5, norm=Inf, epsilon=\+\_\+epsilon, maxiter=None, full\+\_\+output=0, disp=1, retall=0, callback=None, xrtol=0)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__optimize_a48e3e5e1ea2eb7d140078e8b051964a1}{\+\_\+minimize\+\_\+bfgs}} (fun, x0, args=(), jac=None, callback=None, gtol=1e-\/5, norm=Inf, eps=\+\_\+epsilon, maxiter=None, disp=False, return\+\_\+all=False, finite\+\_\+diff\+\_\+rel\+\_\+step=None, xrtol=0, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}unknown\+\_\+options)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__optimize_a07e06f6c5b21aebfa2ca5e51736b74fa}{\+\_\+print\+\_\+success\+\_\+message\+\_\+or\+\_\+warn}} (warnflag, message, warntype=None)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__optimize_af6dce6d9178c7f8c0528157dc1b54df4}{fmin\+\_\+cg}} (f, x0, fprime=None, args=(), gtol=1e-\/5, norm=Inf, epsilon=\+\_\+epsilon, maxiter=None, full\+\_\+output=0, disp=1, retall=0, callback=None)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__optimize_a3191cd4252e97988cd6402c7c2286ac0}{\+\_\+minimize\+\_\+cg}} (fun, x0, args=(), jac=None, callback=None, gtol=1e-\/5, norm=Inf, eps=\+\_\+epsilon, maxiter=None, disp=False, return\+\_\+all=False, finite\+\_\+diff\+\_\+rel\+\_\+step=None, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}unknown\+\_\+options)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__optimize_ac1f87d4a3076d3d4579a03dfe3f32ddd}{fmin\+\_\+ncg}} (f, x0, fprime, fhess\+\_\+p=None, fhess=None, args=(), avextol=1e-\/5, epsilon=\+\_\+epsilon, maxiter=None, full\+\_\+output=0, disp=1, retall=0, callback=None)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__optimize_a0095fb8edd856194da3b0a1ca2d761cd}{\+\_\+minimize\+\_\+newtoncg}} (fun, x0, args=(), jac=None, hess=None, hessp=None, callback=None, xtol=1e-\/5, eps=\+\_\+epsilon, maxiter=None, disp=False, return\+\_\+all=False, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}unknown\+\_\+options)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__optimize_a86c632088d14f5b42c1e17998149d676}{fminbound}} (func, x1, x2, args=(), xtol=1e-\/5, maxfun=500, full\+\_\+output=0, disp=1)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__optimize_a71ba569fdc9f756b4a622c6fe4ff91da}{\+\_\+minimize\+\_\+scalar\+\_\+bounded}} (func, bounds, args=(), xatol=1e-\/5, maxiter=500, disp=0, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}unknown\+\_\+options)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__optimize_ab667dd7bd58227d18103e3e286969b71}{brent}} (func, args=(), brack=None, tol=1.\+48e-\/8, full\+\_\+output=0, maxiter=500)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__optimize_a97defae4d0b5c95d200370a81f9eebe7}{\+\_\+minimize\+\_\+scalar\+\_\+brent}} (func, brack=None, args=(), xtol=1.\+48e-\/8, maxiter=500, disp=0, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}unknown\+\_\+options)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__optimize_a4f74c3036679f7cddb38d24bb4ad22ee}{golden}} (func, args=(), brack=None, tol=\+\_\+epsilon, full\+\_\+output=0, maxiter=5000)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__optimize_a49ead78bfe447477b882bebc0daf62f6}{\+\_\+minimize\+\_\+scalar\+\_\+golden}} (func, brack=None, args=(), xtol=\+\_\+epsilon, maxiter=5000, disp=0, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}unknown\+\_\+options)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__optimize_aee61cc6cef1e91f845fff5cf0a8fc44f}{bracket}} (func, xa=0.\+0, xb=1.\+0, args=(), grow\+\_\+limit=110.\+0, maxiter=1000)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__optimize_a42153b668930aa7baa095578b0692a8b}{\+\_\+recover\+\_\+from\+\_\+bracket\+\_\+error}} (solver, fun, \mbox{\hyperlink{namespacescipy_1_1optimize_1_1__optimize_aee61cc6cef1e91f845fff5cf0a8fc44f}{bracket}}, args, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}options)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__optimize_a3b8429f36e8644a3d6523490a4633127}{\+\_\+line\+\_\+for\+\_\+search}} (x0, alpha, lower\+\_\+bound, upper\+\_\+bound)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__optimize_ab7fe737c35f3c1f34556e9e97b0ba35f}{\+\_\+linesearch\+\_\+powell}} (func, p, xi, tol=1e-\/3, lower\+\_\+bound=None, upper\+\_\+bound=None, fval=None)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__optimize_ab37e1a3656d4e065f5ea2f3acdd29b20}{fmin\+\_\+powell}} (func, x0, args=(), xtol=1e-\/4, ftol=1e-\/4, maxiter=None, maxfun=None, full\+\_\+output=0, disp=1, retall=0, callback=None, direc=None)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__optimize_a3b7569c6086976da8d1e928c31b43df8}{\+\_\+minimize\+\_\+powell}} (func, x0, args=(), callback=None, bounds=None, xtol=1e-\/4, ftol=1e-\/4, maxiter=None, maxfev=None, disp=False, direc=None, return\+\_\+all=False, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}unknown\+\_\+options)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__optimize_a058ffe84994a23e164037a4752b17d0c}{\+\_\+endprint}} (x, flag, fval, maxfun, xtol, disp)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__optimize_a98e856197a3ade6049ea4f05461669d8}{brute}} (func, ranges, args=(), Ns=20, full\+\_\+output=0, finish=\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__optimize_a1c8825f72fbb699b9d86a64dfd7f2d5b}{fmin}}, disp=False, workers=1)
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__optimize_a50f7c818d44ee4c953b28bcddbc326f1}{show\+\_\+options}} (solver=None, method=None, disp=\mbox{\hyperlink{classTrue}{True}})
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
list \mbox{\hyperlink{namespacescipy_1_1optimize_1_1__optimize_af3153e808d5fbacc198a82d30996cd54}{\+\_\+\+\_\+all\+\_\+\+\_\+}}
\item 
str \mbox{\hyperlink{namespacescipy_1_1optimize_1_1__optimize_ad43750b63b6897a1d6566cda5afd327e}{\+\_\+\+\_\+docformat\+\_\+\+\_\+}} = "{}restructuredtext en"{}
\item 
dict \mbox{\hyperlink{namespacescipy_1_1optimize_1_1__optimize_a09a2252518464e5a38ff3fcffce3e3dc}{\+\_\+status\+\_\+message}}
\item 
\mbox{\hyperlink{namespacescipy_1_1optimize_1_1__optimize_a8c8bc7126a371e035fd8e52aff856d71}{\+\_\+epsilon}} = sqrt(np.\+finfo(float).eps)
\end{DoxyCompactItemize}


\doxysubsection{Function Documentation}
\Hypertarget{namespacescipy_1_1optimize_1_1__optimize_a15df8b8131f027070766bef3407058fe}\index{scipy.optimize.\_optimize@{scipy.optimize.\_optimize}!\_call\_callback\_maybe\_halt@{\_call\_callback\_maybe\_halt}}
\index{\_call\_callback\_maybe\_halt@{\_call\_callback\_maybe\_halt}!scipy.optimize.\_optimize@{scipy.optimize.\_optimize}}
\doxysubsubsection{\texorpdfstring{\_call\_callback\_maybe\_halt()}{\_call\_callback\_maybe\_halt()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__optimize_a15df8b8131f027070766bef3407058fe} 
scipy.\+optimize.\+\_\+optimize.\+\_\+call\+\_\+callback\+\_\+maybe\+\_\+halt (\begin{DoxyParamCaption}\item[{}]{callback}{, }\item[{}]{res}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Call wrapped callback; return True if minimization should stop.

Parameters
----------
callback : callable or None
    A user-provided callback wrapped with `_wrap_callback`
res : OptimizeResult
    Information about the current iterate

Returns
-------
halt : bool
    True if minimization should stop
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__optimize_8py_source_l00156}{156}} of file \mbox{\hyperlink{__optimize_8py_source}{\+\_\+optimize.\+py}}.



Referenced by \mbox{\hyperlink{__optimize_8py_source_l01378}{\+\_\+minimize\+\_\+bfgs()}}, \mbox{\hyperlink{__optimize_8py_source_l01715}{\+\_\+minimize\+\_\+cg()}}, \mbox{\hyperlink{__lbfgsb__py_8py_source_l00216}{scipy.\+optimize.\+\_\+lbfgsb\+\_\+py.\+\_\+minimize\+\_\+lbfgsb()}}, \mbox{\hyperlink{__optimize_8py_source_l00764}{\+\_\+minimize\+\_\+neldermead()}}, \mbox{\hyperlink{__optimize_8py_source_l01975}{\+\_\+minimize\+\_\+newtoncg()}}, \mbox{\hyperlink{__optimize_8py_source_l03356}{\+\_\+minimize\+\_\+powell()}}, and \mbox{\hyperlink{__trustregion_8py_source_l00122}{scipy.\+optimize.\+\_\+trustregion.\+\_\+minimize\+\_\+trust\+\_\+region()}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__optimize_a8352decf7aa9c9c9b686a613eec05caa}\index{scipy.optimize.\_optimize@{scipy.optimize.\_optimize}!\_check\_clip\_x@{\_check\_clip\_x}}
\index{\_check\_clip\_x@{\_check\_clip\_x}!scipy.optimize.\_optimize@{scipy.optimize.\_optimize}}
\doxysubsubsection{\texorpdfstring{\_check\_clip\_x()}{\_check\_clip\_x()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__optimize_a8352decf7aa9c9c9b686a613eec05caa} 
scipy.\+optimize.\+\_\+optimize.\+\_\+check\+\_\+clip\+\_\+x (\begin{DoxyParamCaption}\item[{}]{x}{, }\item[{}]{bounds}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{__optimize_8py_source_l00402}{402}} of file \mbox{\hyperlink{__optimize_8py_source}{\+\_\+optimize.\+py}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__optimize_adb2a481bff6d99a8ce39d61a605474d2}\index{scipy.optimize.\_optimize@{scipy.optimize.\_optimize}!\_check\_unknown\_options@{\_check\_unknown\_options}}
\index{\_check\_unknown\_options@{\_check\_unknown\_options}!scipy.optimize.\_optimize@{scipy.optimize.\_optimize}}
\doxysubsubsection{\texorpdfstring{\_check\_unknown\_options()}{\_check\_unknown\_options()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__optimize_adb2a481bff6d99a8ce39d61a605474d2} 
scipy.\+optimize.\+\_\+optimize.\+\_\+check\+\_\+unknown\+\_\+options (\begin{DoxyParamCaption}\item[{}]{unknown\+\_\+options}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{__optimize_8py_source_l00267}{267}} of file \mbox{\hyperlink{__optimize_8py_source}{\+\_\+optimize.\+py}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__optimize_adf949eb8be2c742f97371a6adb8accac}\index{scipy.optimize.\_optimize@{scipy.optimize.\_optimize}!\_clip\_x\_for\_func@{\_clip\_x\_for\_func}}
\index{\_clip\_x\_for\_func@{\_clip\_x\_for\_func}!scipy.optimize.\_optimize@{scipy.optimize.\_optimize}}
\doxysubsubsection{\texorpdfstring{\_clip\_x\_for\_func()}{\_clip\_x\_for\_func()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__optimize_adf949eb8be2c742f97371a6adb8accac} 
scipy.\+optimize.\+\_\+optimize.\+\_\+clip\+\_\+x\+\_\+for\+\_\+func (\begin{DoxyParamCaption}\item[{}]{func}{, }\item[{}]{bounds}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{__optimize_8py_source_l00389}{389}} of file \mbox{\hyperlink{__optimize_8py_source}{\+\_\+optimize.\+py}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__optimize_a16adb1174e785ba9b631bc91a8be27f0}\index{scipy.optimize.\_optimize@{scipy.optimize.\_optimize}!\_dict\_formatter@{\_dict\_formatter}}
\index{\_dict\_formatter@{\_dict\_formatter}!scipy.optimize.\_optimize@{scipy.optimize.\_optimize}}
\doxysubsubsection{\texorpdfstring{\_dict\_formatter()}{\_dict\_formatter()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__optimize_a16adb1174e785ba9b631bc91a8be27f0} 
scipy.\+optimize.\+\_\+optimize.\+\_\+dict\+\_\+formatter (\begin{DoxyParamCaption}\item[{}]{d}{, }\item[{}]{n}{ = {\ttfamily 0}, }\item[{}]{mplus}{ = {\ttfamily 1}, }\item[{}]{sorter}{ = {\ttfamily None}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Pretty printer for dictionaries

`n` keeps track of the starting indentation;
lines are indented by this much after a line break.
`mplus` is additional left padding applied to keys
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__optimize_8py_source_l00107}{107}} of file \mbox{\hyperlink{__optimize_8py_source}{\+\_\+optimize.\+py}}.



References \mbox{\hyperlink{__optimize_8py_source_l00107}{\+\_\+dict\+\_\+formatter()}}, and \mbox{\hyperlink{__optimize_8py_source_l00085}{\+\_\+indenter()}}.



Referenced by \mbox{\hyperlink{__optimize_8py_source_l00107}{\+\_\+dict\+\_\+formatter()}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__optimize_a058ffe84994a23e164037a4752b17d0c}\index{scipy.optimize.\_optimize@{scipy.optimize.\_optimize}!\_endprint@{\_endprint}}
\index{\_endprint@{\_endprint}!scipy.optimize.\_optimize@{scipy.optimize.\_optimize}}
\doxysubsubsection{\texorpdfstring{\_endprint()}{\_endprint()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__optimize_a058ffe84994a23e164037a4752b17d0c} 
scipy.\+optimize.\+\_\+optimize.\+\_\+endprint (\begin{DoxyParamCaption}\item[{}]{x}{, }\item[{}]{flag}{, }\item[{}]{fval}{, }\item[{}]{maxfun}{, }\item[{}]{xtol}{, }\item[{}]{disp}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{__optimize_8py_source_l03596}{3596}} of file \mbox{\hyperlink{__optimize_8py_source}{\+\_\+optimize.\+py}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__optimize_a7b146471678d0a5a7821772d6e2bb236}\index{scipy.optimize.\_optimize@{scipy.optimize.\_optimize}!\_float\_formatter\_10@{\_float\_formatter\_10}}
\index{\_float\_formatter\_10@{\_float\_formatter\_10}!scipy.optimize.\_optimize@{scipy.optimize.\_optimize}}
\doxysubsubsection{\texorpdfstring{\_float\_formatter\_10()}{\_float\_formatter\_10()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__optimize_a7b146471678d0a5a7821772d6e2bb236} 
scipy.\+optimize.\+\_\+optimize.\+\_\+float\+\_\+formatter\+\_\+10 (\begin{DoxyParamCaption}\item[{}]{x}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Returns a string representation of a float with exactly ten characters
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__optimize_8py_source_l00094}{94}} of file \mbox{\hyperlink{__optimize_8py_source}{\+\_\+optimize.\+py}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__optimize_a9720f6e22ec7a6c85263edb52ffa463a}\index{scipy.optimize.\_optimize@{scipy.optimize.\_optimize}!\_indenter@{\_indenter}}
\index{\_indenter@{\_indenter}!scipy.optimize.\_optimize@{scipy.optimize.\_optimize}}
\doxysubsubsection{\texorpdfstring{\_indenter()}{\_indenter()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__optimize_a9720f6e22ec7a6c85263edb52ffa463a} 
scipy.\+optimize.\+\_\+optimize.\+\_\+indenter (\begin{DoxyParamCaption}\item[{}]{s}{, }\item[{}]{n}{ = {\ttfamily 0}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Ensures that lines after the first are indented by the specified amount
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__optimize_8py_source_l00085}{85}} of file \mbox{\hyperlink{__optimize_8py_source}{\+\_\+optimize.\+py}}.



Referenced by \mbox{\hyperlink{__optimize_8py_source_l00107}{\+\_\+dict\+\_\+formatter()}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__optimize_a3b8429f36e8644a3d6523490a4633127}\index{scipy.optimize.\_optimize@{scipy.optimize.\_optimize}!\_line\_for\_search@{\_line\_for\_search}}
\index{\_line\_for\_search@{\_line\_for\_search}!scipy.optimize.\_optimize@{scipy.optimize.\_optimize}}
\doxysubsubsection{\texorpdfstring{\_line\_for\_search()}{\_line\_for\_search()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__optimize_a3b8429f36e8644a3d6523490a4633127} 
scipy.\+optimize.\+\_\+optimize.\+\_\+line\+\_\+for\+\_\+search (\begin{DoxyParamCaption}\item[{}]{x0}{, }\item[{}]{alpha}{, }\item[{}]{lower\+\_\+bound}{, }\item[{}]{upper\+\_\+bound}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Given a parameter vector ``x0`` with length ``n`` and a direction
vector ``alpha`` with length ``n``, and lower and upper bounds on
each of the ``n`` parameters, what are the bounds on a scalar
``l`` such that ``lower_bound <= x0 + alpha * l <= upper_bound``.


Parameters
----------
x0 : np.array.
    The vector representing the current location.
    Note ``np.shape(x0) == (n,)``.
alpha : np.array.
    The vector representing the direction.
    Note ``np.shape(alpha) == (n,)``.
lower_bound : np.array.
    The lower bounds for each parameter in ``x0``. If the ``i``th
    parameter in ``x0`` is unbounded below, then ``lower_bound[i]``
    should be ``-np.inf``.
    Note ``np.shape(lower_bound) == (n,)``.
upper_bound : np.array.
    The upper bounds for each parameter in ``x0``. If the ``i``th
    parameter in ``x0`` is unbounded above, then ``upper_bound[i]``
    should be ``np.inf``.
    Note ``np.shape(upper_bound) == (n,)``.

Returns
-------
res : tuple ``(lmin, lmax)``
    The bounds for ``l`` such that
        ``lower_bound[i] <= x0[i] + alpha[i] * l <= upper_bound[i]``
    for all ``i``.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__optimize_8py_source_l03091}{3091}} of file \mbox{\hyperlink{__optimize_8py_source}{\+\_\+optimize.\+py}}.



Referenced by \mbox{\hyperlink{__optimize_8py_source_l03155}{\+\_\+linesearch\+\_\+powell()}}, and \mbox{\hyperlink{__optimize_8py_source_l03356}{\+\_\+minimize\+\_\+powell()}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__optimize_a7199b6af73bdb0295d37336b3be8ed5a}\index{scipy.optimize.\_optimize@{scipy.optimize.\_optimize}!\_line\_search\_wolfe12@{\_line\_search\_wolfe12}}
\index{\_line\_search\_wolfe12@{\_line\_search\_wolfe12}!scipy.optimize.\_optimize@{scipy.optimize.\_optimize}}
\doxysubsubsection{\texorpdfstring{\_line\_search\_wolfe12()}{\_line\_search\_wolfe12()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__optimize_a7199b6af73bdb0295d37336b3be8ed5a} 
scipy.\+optimize.\+\_\+optimize.\+\_\+line\+\_\+search\+\_\+wolfe12 (\begin{DoxyParamCaption}\item[{}]{f}{, }\item[{}]{fprime}{, }\item[{}]{xk}{, }\item[{}]{pk}{, }\item[{}]{gfk}{, }\item[{}]{old\+\_\+fval}{, }\item[{}]{old\+\_\+old\+\_\+fval}{, }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{kwargs}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Same as line_search_wolfe1, but fall back to line_search_wolfe2 if
suitable step length is not found, and raise an exception if a
suitable step length is not found.

Raises
------
_LineSearchError
    If no suitable step size is found
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__optimize_8py_source_l01199}{1199}} of file \mbox{\hyperlink{__optimize_8py_source}{\+\_\+optimize.\+py}}.



Referenced by \mbox{\hyperlink{__optimize_8py_source_l01378}{\+\_\+minimize\+\_\+bfgs()}}, \mbox{\hyperlink{__optimize_8py_source_l01715}{\+\_\+minimize\+\_\+cg()}}, and \mbox{\hyperlink{__optimize_8py_source_l01975}{\+\_\+minimize\+\_\+newtoncg()}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__optimize_ab7fe737c35f3c1f34556e9e97b0ba35f}\index{scipy.optimize.\_optimize@{scipy.optimize.\_optimize}!\_linesearch\_powell@{\_linesearch\_powell}}
\index{\_linesearch\_powell@{\_linesearch\_powell}!scipy.optimize.\_optimize@{scipy.optimize.\_optimize}}
\doxysubsubsection{\texorpdfstring{\_linesearch\_powell()}{\_linesearch\_powell()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__optimize_ab7fe737c35f3c1f34556e9e97b0ba35f} 
scipy.\+optimize.\+\_\+optimize.\+\_\+linesearch\+\_\+powell (\begin{DoxyParamCaption}\item[{}]{func}{, }\item[{}]{p}{, }\item[{}]{xi}{, }\item[{}]{tol}{ = {\ttfamily 1e-\/3}, }\item[{}]{lower\+\_\+bound}{ = {\ttfamily None}, }\item[{}]{upper\+\_\+bound}{ = {\ttfamily None}, }\item[{}]{fval}{ = {\ttfamily None}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Line-search algorithm using fminbound.

Find the minimium of the function ``func(x0 + alpha*direc)``.

lower_bound : np.array.
    The lower bounds for each parameter in ``x0``. If the ``i``th
    parameter in ``x0`` is unbounded below, then ``lower_bound[i]``
    should be ``-np.inf``.
    Note ``np.shape(lower_bound) == (n,)``.
upper_bound : np.array.
    The upper bounds for each parameter in ``x0``. If the ``i``th
    parameter in ``x0`` is unbounded above, then ``upper_bound[i]``
    should be ``np.inf``.
    Note ``np.shape(upper_bound) == (n,)``.
fval : number.
    ``fval`` is equal to ``func(p)``, the idea is just to avoid
    recomputing it so we can limit the ``fevals``.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__optimize_8py_source_l03154}{3154}} of file \mbox{\hyperlink{__optimize_8py_source}{\+\_\+optimize.\+py}}.



References \mbox{\hyperlink{__optimize_8py_source_l03091}{\+\_\+line\+\_\+for\+\_\+search()}}, \mbox{\hyperlink{__optimize_8py_source_l03155}{\+\_\+linesearch\+\_\+powell()}}, and \mbox{\hyperlink{__optimize_8py_source_l02245}{\+\_\+minimize\+\_\+scalar\+\_\+bounded()}}.



Referenced by \mbox{\hyperlink{__optimize_8py_source_l03155}{\+\_\+linesearch\+\_\+powell()}}, and \mbox{\hyperlink{__optimize_8py_source_l03356}{\+\_\+minimize\+\_\+powell()}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__optimize_a48e3e5e1ea2eb7d140078e8b051964a1}\index{scipy.optimize.\_optimize@{scipy.optimize.\_optimize}!\_minimize\_bfgs@{\_minimize\_bfgs}}
\index{\_minimize\_bfgs@{\_minimize\_bfgs}!scipy.optimize.\_optimize@{scipy.optimize.\_optimize}}
\doxysubsubsection{\texorpdfstring{\_minimize\_bfgs()}{\_minimize\_bfgs()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__optimize_a48e3e5e1ea2eb7d140078e8b051964a1} 
scipy.\+optimize.\+\_\+optimize.\+\_\+minimize\+\_\+bfgs (\begin{DoxyParamCaption}\item[{}]{fun}{, }\item[{}]{x0}{, }\item[{}]{args}{ = {\ttfamily ()}, }\item[{}]{jac}{ = {\ttfamily None}, }\item[{}]{callback}{ = {\ttfamily None}, }\item[{}]{gtol}{ = {\ttfamily 1e-\/5}, }\item[{}]{norm}{ = {\ttfamily Inf}, }\item[{}]{eps}{ = {\ttfamily \+\_\+epsilon}, }\item[{}]{maxiter}{ = {\ttfamily None}, }\item[{}]{disp}{ = {\ttfamily False}, }\item[{}]{return\+\_\+all}{ = {\ttfamily False}, }\item[{}]{finite\+\_\+diff\+\_\+rel\+\_\+step}{ = {\ttfamily None}, }\item[{}]{xrtol}{ = {\ttfamily 0}, }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{unknown\+\_\+options}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Minimization of scalar function of one or more variables using the
BFGS algorithm.

Options
-------
disp : bool
    Set to True to print convergence messages.
maxiter : int
    Maximum number of iterations to perform.
gtol : float
    Terminate successfully if gradient norm is less than `gtol`.
norm : float
    Order of norm (Inf is max, -Inf is min).
eps : float or ndarray
    If `jac is None` the absolute step size used for numerical
    approximation of the jacobian via forward differences.
return_all : bool, optional
    Set to True to return a list of the best solution at each of the
    iterations.
finite_diff_rel_step : None or array_like, optional
    If `jac in ['2-point', '3-point', 'cs']` the relative step size to
    use for numerical approximation of the jacobian. The absolute step
    size is computed as ``h = rel_step * sign(x) * max(1, abs(x))``,
    possibly adjusted to fit into the bounds. For ``method='3-point'``
    the sign of `h` is ignored. If None (default) then step is selected
    automatically.
xrtol : float, default: 0
    Relative tolerance for `x`. Terminate successfully if step size is
    less than ``xk * xrtol`` where ``xk`` is the current parameter vector.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__optimize_8py_source_l01375}{1375}} of file \mbox{\hyperlink{__optimize_8py_source}{\+\_\+optimize.\+py}}.



References \mbox{\hyperlink{__optimize_8py_source_l00156}{\+\_\+call\+\_\+callback\+\_\+maybe\+\_\+halt()}}, \mbox{\hyperlink{__optimize_8py_source_l01200}{\+\_\+line\+\_\+search\+\_\+wolfe12()}}, and \mbox{\hyperlink{__optimize_8py_source_l00297}{\+\_\+prepare\+\_\+scalar\+\_\+function()}}.



Referenced by \mbox{\hyperlink{__optimize_8py_source_l01246}{fmin\+\_\+bfgs()}}, and \mbox{\hyperlink{__minimize_8py_source_l00053}{scipy.\+optimize.\+\_\+minimize.\+minimize()}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__optimize_a3191cd4252e97988cd6402c7c2286ac0}\index{scipy.optimize.\_optimize@{scipy.optimize.\_optimize}!\_minimize\_cg@{\_minimize\_cg}}
\index{\_minimize\_cg@{\_minimize\_cg}!scipy.optimize.\_optimize@{scipy.optimize.\_optimize}}
\doxysubsubsection{\texorpdfstring{\_minimize\_cg()}{\_minimize\_cg()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__optimize_a3191cd4252e97988cd6402c7c2286ac0} 
scipy.\+optimize.\+\_\+optimize.\+\_\+minimize\+\_\+cg (\begin{DoxyParamCaption}\item[{}]{fun}{, }\item[{}]{x0}{, }\item[{}]{args}{ = {\ttfamily ()}, }\item[{}]{jac}{ = {\ttfamily None}, }\item[{}]{callback}{ = {\ttfamily None}, }\item[{}]{gtol}{ = {\ttfamily 1e-\/5}, }\item[{}]{norm}{ = {\ttfamily Inf}, }\item[{}]{eps}{ = {\ttfamily \+\_\+epsilon}, }\item[{}]{maxiter}{ = {\ttfamily None}, }\item[{}]{disp}{ = {\ttfamily False}, }\item[{}]{return\+\_\+all}{ = {\ttfamily False}, }\item[{}]{finite\+\_\+diff\+\_\+rel\+\_\+step}{ = {\ttfamily None}, }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{unknown\+\_\+options}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Minimization of scalar function of one or more variables using the
conjugate gradient algorithm.

Options
-------
disp : bool
    Set to True to print convergence messages.
maxiter : int
    Maximum number of iterations to perform.
gtol : float
    Gradient norm must be less than `gtol` before successful
    termination.
norm : float
    Order of norm (Inf is max, -Inf is min).
eps : float or ndarray
    If `jac is None` the absolute step size used for numerical
    approximation of the jacobian via forward differences.
return_all : bool, optional
    Set to True to return a list of the best solution at each of the
    iterations.
finite_diff_rel_step : None or array_like, optional
    If `jac in ['2-point', '3-point', 'cs']` the relative step size to
    use for numerical approximation of the jacobian. The absolute step
    size is computed as ``h = rel_step * sign(x) * max(1, abs(x))``,
    possibly adjusted to fit into the bounds. For ``method='3-point'``
    the sign of `h` is ignored. If None (default) then step is selected
    automatically.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__optimize_8py_source_l01712}{1712}} of file \mbox{\hyperlink{__optimize_8py_source}{\+\_\+optimize.\+py}}.



References \mbox{\hyperlink{__optimize_8py_source_l00156}{\+\_\+call\+\_\+callback\+\_\+maybe\+\_\+halt()}}, \mbox{\hyperlink{__optimize_8py_source_l01200}{\+\_\+line\+\_\+search\+\_\+wolfe12()}}, and \mbox{\hyperlink{__optimize_8py_source_l00297}{\+\_\+prepare\+\_\+scalar\+\_\+function()}}.



Referenced by \mbox{\hyperlink{__optimize_8py_source_l01538}{fmin\+\_\+cg()}}, and \mbox{\hyperlink{__minimize_8py_source_l00053}{scipy.\+optimize.\+\_\+minimize.\+minimize()}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__optimize_a021f788937329bc7411d5a6b29a84173}\index{scipy.optimize.\_optimize@{scipy.optimize.\_optimize}!\_minimize\_neldermead@{\_minimize\_neldermead}}
\index{\_minimize\_neldermead@{\_minimize\_neldermead}!scipy.optimize.\_optimize@{scipy.optimize.\_optimize}}
\doxysubsubsection{\texorpdfstring{\_minimize\_neldermead()}{\_minimize\_neldermead()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__optimize_a021f788937329bc7411d5a6b29a84173} 
scipy.\+optimize.\+\_\+optimize.\+\_\+minimize\+\_\+neldermead (\begin{DoxyParamCaption}\item[{}]{func}{, }\item[{}]{x0}{, }\item[{}]{args}{ = {\ttfamily ()}, }\item[{}]{callback}{ = {\ttfamily None}, }\item[{}]{maxiter}{ = {\ttfamily None}, }\item[{}]{maxfev}{ = {\ttfamily None}, }\item[{}]{disp}{ = {\ttfamily False}, }\item[{}]{return\+\_\+all}{ = {\ttfamily False}, }\item[{}]{initial\+\_\+simplex}{ = {\ttfamily None}, }\item[{}]{xatol}{ = {\ttfamily 1e-\/4}, }\item[{}]{fatol}{ = {\ttfamily 1e-\/4}, }\item[{}]{adaptive}{ = {\ttfamily False}, }\item[{}]{bounds}{ = {\ttfamily None}, }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{unknown\+\_\+options}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Minimization of scalar function of one or more variables using the
Nelder-Mead algorithm.

Options
-------
disp : bool
    Set to True to print convergence messages.
maxiter, maxfev : int
    Maximum allowed number of iterations and function evaluations.
    Will default to ``N*200``, where ``N`` is the number of
    variables, if neither `maxiter` or `maxfev` is set. If both
    `maxiter` and `maxfev` are set, minimization will stop at the
    first reached.
return_all : bool, optional
    Set to True to return a list of the best solution at each of the
    iterations.
initial_simplex : array_like of shape (N + 1, N)
    Initial simplex. If given, overrides `x0`.
    ``initial_simplex[j,:]`` should contain the coordinates of
    the jth vertex of the ``N+1`` vertices in the simplex, where
    ``N`` is the dimension.
xatol : float, optional
    Absolute error in xopt between iterations that is acceptable for
    convergence.
fatol : number, optional
    Absolute error in func(xopt) between iterations that is acceptable for
    convergence.
adaptive : bool, optional
    Adapt algorithm parameters to dimensionality of problem. Useful for
    high-dimensional minimization [1]_.
bounds : sequence or `Bounds`, optional
    Bounds on variables. There are two ways to specify the bounds:

        1. Instance of `Bounds` class.
        2. Sequence of ``(min, max)`` pairs for each element in `x`. None
           is used to specify no bound.

    Note that this just clips all vertices in simplex based on
    the bounds.

References
----------
.. [1] Gao, F. and Han, L.
   Implementing the Nelder-Mead simplex algorithm with adaptive
   parameters. 2012. Computational Optimization and Applications.
   51:1, pp. 259-277
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__optimize_8py_source_l00760}{760}} of file \mbox{\hyperlink{__optimize_8py_source}{\+\_\+optimize.\+py}}.



References \mbox{\hyperlink{__optimize_8py_source_l00156}{\+\_\+call\+\_\+callback\+\_\+maybe\+\_\+halt()}}.



Referenced by \mbox{\hyperlink{__optimize_8py_source_l00636}{fmin()}}, and \mbox{\hyperlink{__minimize_8py_source_l00053}{scipy.\+optimize.\+\_\+minimize.\+minimize()}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__optimize_a0095fb8edd856194da3b0a1ca2d761cd}\index{scipy.optimize.\_optimize@{scipy.optimize.\_optimize}!\_minimize\_newtoncg@{\_minimize\_newtoncg}}
\index{\_minimize\_newtoncg@{\_minimize\_newtoncg}!scipy.optimize.\_optimize@{scipy.optimize.\_optimize}}
\doxysubsubsection{\texorpdfstring{\_minimize\_newtoncg()}{\_minimize\_newtoncg()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__optimize_a0095fb8edd856194da3b0a1ca2d761cd} 
scipy.\+optimize.\+\_\+optimize.\+\_\+minimize\+\_\+newtoncg (\begin{DoxyParamCaption}\item[{}]{fun}{, }\item[{}]{x0}{, }\item[{}]{args}{ = {\ttfamily ()}, }\item[{}]{jac}{ = {\ttfamily None}, }\item[{}]{hess}{ = {\ttfamily None}, }\item[{}]{hessp}{ = {\ttfamily None}, }\item[{}]{callback}{ = {\ttfamily None}, }\item[{}]{xtol}{ = {\ttfamily 1e-\/5}, }\item[{}]{eps}{ = {\ttfamily \+\_\+epsilon}, }\item[{}]{maxiter}{ = {\ttfamily None}, }\item[{}]{disp}{ = {\ttfamily False}, }\item[{}]{return\+\_\+all}{ = {\ttfamily False}, }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{unknown\+\_\+options}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Minimization of scalar function of one or more variables using the
Newton-CG algorithm.

Note that the `jac` parameter (Jacobian) is required.

Options
-------
disp : bool
    Set to True to print convergence messages.
xtol : float
    Average relative error in solution `xopt` acceptable for
    convergence.
maxiter : int
    Maximum number of iterations to perform.
eps : float or ndarray
    If `hessp` is approximated, use this value for the step size.
return_all : bool, optional
    Set to True to return a list of the best solution at each of the
    iterations.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__optimize_8py_source_l01972}{1972}} of file \mbox{\hyperlink{__optimize_8py_source}{\+\_\+optimize.\+py}}.



References \mbox{\hyperlink{__optimize_8py_source_l00156}{\+\_\+call\+\_\+callback\+\_\+maybe\+\_\+halt()}}, \mbox{\hyperlink{__optimize_8py_source_l01200}{\+\_\+line\+\_\+search\+\_\+wolfe12()}}, and \mbox{\hyperlink{__optimize_8py_source_l00297}{\+\_\+prepare\+\_\+scalar\+\_\+function()}}.



Referenced by \mbox{\hyperlink{__optimize_8py_source_l01860}{fmin\+\_\+ncg()}}, and \mbox{\hyperlink{__minimize_8py_source_l00053}{scipy.\+optimize.\+\_\+minimize.\+minimize()}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__optimize_a3b7569c6086976da8d1e928c31b43df8}\index{scipy.optimize.\_optimize@{scipy.optimize.\_optimize}!\_minimize\_powell@{\_minimize\_powell}}
\index{\_minimize\_powell@{\_minimize\_powell}!scipy.optimize.\_optimize@{scipy.optimize.\_optimize}}
\doxysubsubsection{\texorpdfstring{\_minimize\_powell()}{\_minimize\_powell()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__optimize_a3b7569c6086976da8d1e928c31b43df8} 
scipy.\+optimize.\+\_\+optimize.\+\_\+minimize\+\_\+powell (\begin{DoxyParamCaption}\item[{}]{func}{, }\item[{}]{x0}{, }\item[{}]{args}{ = {\ttfamily ()}, }\item[{}]{callback}{ = {\ttfamily None}, }\item[{}]{bounds}{ = {\ttfamily None}, }\item[{}]{xtol}{ = {\ttfamily 1e-\/4}, }\item[{}]{ftol}{ = {\ttfamily 1e-\/4}, }\item[{}]{maxiter}{ = {\ttfamily None}, }\item[{}]{maxfev}{ = {\ttfamily None}, }\item[{}]{disp}{ = {\ttfamily False}, }\item[{}]{direc}{ = {\ttfamily None}, }\item[{}]{return\+\_\+all}{ = {\ttfamily False}, }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{unknown\+\_\+options}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Minimization of scalar function of one or more variables using the
modified Powell algorithm.

Parameters
----------
fun : callable
    The objective function to be minimized.

        ``fun(x, *args) -> float``

    where ``x`` is a 1-D array with shape (n,) and ``args``
    is a tuple of the fixed parameters needed to completely
    specify the function.
x0 : ndarray, shape (n,)
    Initial guess. Array of real elements of size (n,),
    where ``n`` is the number of independent variables.
args : tuple, optional
    Extra arguments passed to the objective function and its
    derivatives (`fun`, `jac` and `hess` functions).
method : str or callable, optional
    The present documentation is specific to ``method='powell'``, but other
    options are available. See documentation for `scipy.optimize.minimize`.
bounds : sequence or `Bounds`, optional
    Bounds on decision variables. There are two ways to specify the bounds:

        1. Instance of `Bounds` class.
        2. Sequence of ``(min, max)`` pairs for each element in `x`. None
           is used to specify no bound.

    If bounds are not provided, then an unbounded line search will be used.
    If bounds are provided and the initial guess is within the bounds, then
    every function evaluation throughout the minimization procedure will be
    within the bounds. If bounds are provided, the initial guess is outside
    the bounds, and `direc` is full rank (or left to default), then some
    function evaluations during the first iteration may be outside the
    bounds, but every function evaluation after the first iteration will be
    within the bounds. If `direc` is not full rank, then some parameters
    may not be optimized and the solution is not guaranteed to be within
    the bounds.

options : dict, optional
    A dictionary of solver options. All methods accept the following
    generic options:

        maxiter : int
            Maximum number of iterations to perform. Depending on the
            method each iteration may use several function evaluations.
        disp : bool
            Set to True to print convergence messages.

    See method-specific options for ``method='powell'`` below.
callback : callable, optional
    Called after each iteration. The signature is:

        ``callback(xk)``

    where ``xk`` is the current parameter vector.

Returns
-------
res : OptimizeResult
    The optimization result represented as a ``OptimizeResult`` object.
    Important attributes are: ``x`` the solution array, ``success`` a
    Boolean flag indicating if the optimizer exited successfully and
    ``message`` which describes the cause of the termination. See
    `OptimizeResult` for a description of other attributes.

Options
-------
disp : bool
    Set to True to print convergence messages.
xtol : float
    Relative error in solution `xopt` acceptable for convergence.
ftol : float
    Relative error in ``fun(xopt)`` acceptable for convergence.
maxiter, maxfev : int
    Maximum allowed number of iterations and function evaluations.
    Will default to ``N*1000``, where ``N`` is the number of
    variables, if neither `maxiter` or `maxfev` is set. If both
    `maxiter` and `maxfev` are set, minimization will stop at the
    first reached.
direc : ndarray
    Initial set of direction vectors for the Powell method.
return_all : bool, optional
    Set to True to return a list of the best solution at each of the
    iterations.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__optimize_8py_source_l03353}{3353}} of file \mbox{\hyperlink{__optimize_8py_source}{\+\_\+optimize.\+py}}.



References \mbox{\hyperlink{__optimize_8py_source_l00156}{\+\_\+call\+\_\+callback\+\_\+maybe\+\_\+halt()}}, \mbox{\hyperlink{__optimize_8py_source_l03091}{\+\_\+line\+\_\+for\+\_\+search()}}, and \mbox{\hyperlink{__optimize_8py_source_l03155}{\+\_\+linesearch\+\_\+powell()}}.



Referenced by \mbox{\hyperlink{__optimize_8py_source_l03213}{fmin\+\_\+powell()}}, and \mbox{\hyperlink{__minimize_8py_source_l00053}{scipy.\+optimize.\+\_\+minimize.\+minimize()}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__optimize_a71ba569fdc9f756b4a622c6fe4ff91da}\index{scipy.optimize.\_optimize@{scipy.optimize.\_optimize}!\_minimize\_scalar\_bounded@{\_minimize\_scalar\_bounded}}
\index{\_minimize\_scalar\_bounded@{\_minimize\_scalar\_bounded}!scipy.optimize.\_optimize@{scipy.optimize.\_optimize}}
\doxysubsubsection{\texorpdfstring{\_minimize\_scalar\_bounded()}{\_minimize\_scalar\_bounded()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__optimize_a71ba569fdc9f756b4a622c6fe4ff91da} 
scipy.\+optimize.\+\_\+optimize.\+\_\+minimize\+\_\+scalar\+\_\+bounded (\begin{DoxyParamCaption}\item[{}]{func}{, }\item[{}]{bounds}{, }\item[{}]{args}{ = {\ttfamily ()}, }\item[{}]{xatol}{ = {\ttfamily 1e-\/5}, }\item[{}]{maxiter}{ = {\ttfamily 500}, }\item[{}]{disp}{ = {\ttfamily 0}, }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{unknown\+\_\+options}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Options
-------
maxiter : int
    Maximum number of iterations to perform.
disp: int, optional
    If non-zero, print messages.
        0 : no message printing.
        1 : non-convergence notification messages only.
        2 : print a message on convergence too.
        3 : print iteration results.
xatol : float
    Absolute error in solution `xopt` acceptable for convergence.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__optimize_8py_source_l02243}{2243}} of file \mbox{\hyperlink{__optimize_8py_source}{\+\_\+optimize.\+py}}.



References \mbox{\hyperlink{__optimize_8py_source_l00276}{is\+\_\+finite\+\_\+scalar()}}.



Referenced by \mbox{\hyperlink{__optimize_8py_source_l03155}{\+\_\+linesearch\+\_\+powell()}}, \mbox{\hyperlink{__optimize_8py_source_l02153}{fminbound()}}, and \mbox{\hyperlink{__minimize_8py_source_l00755}{scipy.\+optimize.\+\_\+minimize.\+minimize\+\_\+scalar()}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__optimize_a97defae4d0b5c95d200370a81f9eebe7}\index{scipy.optimize.\_optimize@{scipy.optimize.\_optimize}!\_minimize\_scalar\_brent@{\_minimize\_scalar\_brent}}
\index{\_minimize\_scalar\_brent@{\_minimize\_scalar\_brent}!scipy.optimize.\_optimize@{scipy.optimize.\_optimize}}
\doxysubsubsection{\texorpdfstring{\_minimize\_scalar\_brent()}{\_minimize\_scalar\_brent()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__optimize_a97defae4d0b5c95d200370a81f9eebe7} 
scipy.\+optimize.\+\_\+optimize.\+\_\+minimize\+\_\+scalar\+\_\+brent (\begin{DoxyParamCaption}\item[{}]{func}{, }\item[{}]{brack}{ = {\ttfamily None}, }\item[{}]{args}{ = {\ttfamily ()}, }\item[{}]{xtol}{ = {\ttfamily 1.48e-\/8}, }\item[{}]{maxiter}{ = {\ttfamily 500}, }\item[{}]{disp}{ = {\ttfamily 0}, }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{unknown\+\_\+options}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Options
-------
maxiter : int
    Maximum number of iterations to perform.
xtol : float
    Relative error in solution `xopt` acceptable for convergence.
disp: int, optional
    If non-zero, print messages.
        0 : no message printing.
        1 : non-convergence notification messages only.
        2 : print a message on convergence too.
        3 : print iteration results.
Notes
-----
Uses inverse parabolic interpolation when possible to speed up
convergence of golden section method.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__optimize_8py_source_l02649}{2649}} of file \mbox{\hyperlink{__optimize_8py_source}{\+\_\+optimize.\+py}}.



Referenced by \mbox{\hyperlink{__optimize_8py_source_l02569}{brent()}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__optimize_a49ead78bfe447477b882bebc0daf62f6}\index{scipy.optimize.\_optimize@{scipy.optimize.\_optimize}!\_minimize\_scalar\_golden@{\_minimize\_scalar\_golden}}
\index{\_minimize\_scalar\_golden@{\_minimize\_scalar\_golden}!scipy.optimize.\_optimize@{scipy.optimize.\_optimize}}
\doxysubsubsection{\texorpdfstring{\_minimize\_scalar\_golden()}{\_minimize\_scalar\_golden()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__optimize_a49ead78bfe447477b882bebc0daf62f6} 
scipy.\+optimize.\+\_\+optimize.\+\_\+minimize\+\_\+scalar\+\_\+golden (\begin{DoxyParamCaption}\item[{}]{func}{, }\item[{}]{brack}{ = {\ttfamily None}, }\item[{}]{args}{ = {\ttfamily ()}, }\item[{}]{xtol}{ = {\ttfamily \+\_\+epsilon}, }\item[{}]{maxiter}{ = {\ttfamily 5000}, }\item[{}]{disp}{ = {\ttfamily 0}, }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{unknown\+\_\+options}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Options
-------
xtol : float
    Relative error in solution `xopt` acceptable for convergence.
maxiter : int
    Maximum number of iterations to perform.
disp: int, optional
    If non-zero, print messages.
        0 : no message printing.
        1 : non-convergence notification messages only.
        2 : print a message on convergence too.
        3 : print iteration results.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__optimize_8py_source_l02778}{2778}} of file \mbox{\hyperlink{__optimize_8py_source}{\+\_\+optimize.\+py}}.



References \mbox{\hyperlink{__optimize_8py_source_l02894}{bracket()}}.



Referenced by \mbox{\hyperlink{__optimize_8py_source_l02702}{golden()}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__optimize_ad73454f855569a9ca1a9979e3d9b7a0a}\index{scipy.optimize.\_optimize@{scipy.optimize.\_optimize}!\_prepare\_scalar\_function@{\_prepare\_scalar\_function}}
\index{\_prepare\_scalar\_function@{\_prepare\_scalar\_function}!scipy.optimize.\_optimize@{scipy.optimize.\_optimize}}
\doxysubsubsection{\texorpdfstring{\_prepare\_scalar\_function()}{\_prepare\_scalar\_function()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__optimize_ad73454f855569a9ca1a9979e3d9b7a0a} 
scipy.\+optimize.\+\_\+optimize.\+\_\+prepare\+\_\+scalar\+\_\+function (\begin{DoxyParamCaption}\item[{}]{fun}{, }\item[{}]{x0}{, }\item[{}]{jac}{ = {\ttfamily None}, }\item[{}]{args}{ = {\ttfamily ()}, }\item[{}]{bounds}{ = {\ttfamily None}, }\item[{}]{epsilon}{ = {\ttfamily None}, }\item[{}]{finite\+\_\+diff\+\_\+rel\+\_\+step}{ = {\ttfamily None}, }\item[{}]{hess}{ = {\ttfamily None}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Creates a ScalarFunction object for use with scalar minimizers
(BFGS/LBFGSB/SLSQP/TNC/CG/etc).

Parameters
----------
fun : callable
    The objective function to be minimized.

        ``fun(x, *args) -> float``

    where ``x`` is an 1-D array with shape (n,) and ``args``
    is a tuple of the fixed parameters needed to completely
    specify the function.
x0 : ndarray, shape (n,)
    Initial guess. Array of real elements of size (n,),
    where 'n' is the number of independent variables.
jac : {callable,  '2-point', '3-point', 'cs', None}, optional
    Method for computing the gradient vector. If it is a callable, it
    should be a function that returns the gradient vector:

        ``jac(x, *args) -> array_like, shape (n,)``

    If one of `{'2-point', '3-point', 'cs'}` is selected then the gradient
    is calculated with a relative step for finite differences. If `None`,
    then two-point finite differences with an absolute step is used.
args : tuple, optional
    Extra arguments passed to the objective function and its
    derivatives (`fun`, `jac` functions).
bounds : sequence, optional
    Bounds on variables. 'new-style' bounds are required.
eps : float or ndarray
    If `jac is None` the absolute step size used for numerical
    approximation of the jacobian via forward differences.
finite_diff_rel_step : None or array_like, optional
    If `jac in ['2-point', '3-point', 'cs']` the relative step size to
    use for numerical approximation of the jacobian. The absolute step
    size is computed as ``h = rel_step * sign(x0) * max(1, abs(x0))``,
    possibly adjusted to fit into the bounds. For ``method='3-point'``
    the sign of `h` is ignored. If None (default) then step is selected
    automatically.
hess : {callable,  '2-point', '3-point', 'cs', None}
    Computes the Hessian matrix. If it is callable, it should return the
    Hessian matrix:

        ``hess(x, *args) -> {LinearOperator, spmatrix, array}, (n, n)``

    Alternatively, the keywords {'2-point', '3-point', 'cs'} select a
    finite difference scheme for numerical estimation.
    Whenever the gradient is estimated via finite-differences, the Hessian
    cannot be estimated with options {'2-point', '3-point', 'cs'} and needs
    to be estimated using one of the quasi-Newton strategies.

Returns
-------
sf : ScalarFunction
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__optimize_8py_source_l00295}{295}} of file \mbox{\hyperlink{__optimize_8py_source}{\+\_\+optimize.\+py}}.



Referenced by \mbox{\hyperlink{__optimize_8py_source_l01378}{\+\_\+minimize\+\_\+bfgs()}}, \mbox{\hyperlink{__optimize_8py_source_l01715}{\+\_\+minimize\+\_\+cg()}}, \mbox{\hyperlink{__cobyla__py_8py_source_l00193}{scipy.\+optimize.\+\_\+cobyla\+\_\+py.\+\_\+minimize\+\_\+cobyla()}}, \mbox{\hyperlink{__lbfgsb__py_8py_source_l00216}{scipy.\+optimize.\+\_\+lbfgsb\+\_\+py.\+\_\+minimize\+\_\+lbfgsb()}}, \mbox{\hyperlink{__optimize_8py_source_l01975}{\+\_\+minimize\+\_\+newtoncg()}}, \mbox{\hyperlink{__slsqp__py_8py_source_l00218}{scipy.\+optimize.\+\_\+slsqp\+\_\+py.\+\_\+minimize\+\_\+slsqp()}}, \mbox{\hyperlink{__tnc_8py_source_l00288}{scipy.\+optimize.\+\_\+tnc.\+\_\+minimize\+\_\+tnc()}}, and \mbox{\hyperlink{__trustregion_8py_source_l00122}{scipy.\+optimize.\+\_\+trustregion.\+\_\+minimize\+\_\+trust\+\_\+region()}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__optimize_a07e06f6c5b21aebfa2ca5e51736b74fa}\index{scipy.optimize.\_optimize@{scipy.optimize.\_optimize}!\_print\_success\_message\_or\_warn@{\_print\_success\_message\_or\_warn}}
\index{\_print\_success\_message\_or\_warn@{\_print\_success\_message\_or\_warn}!scipy.optimize.\_optimize@{scipy.optimize.\_optimize}}
\doxysubsubsection{\texorpdfstring{\_print\_success\_message\_or\_warn()}{\_print\_success\_message\_or\_warn()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__optimize_a07e06f6c5b21aebfa2ca5e51736b74fa} 
scipy.\+optimize.\+\_\+optimize.\+\_\+print\+\_\+success\+\_\+message\+\_\+or\+\_\+warn (\begin{DoxyParamCaption}\item[{}]{warnflag}{, }\item[{}]{message}{, }\item[{}]{warntype}{ = {\ttfamily None}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{__optimize_8py_source_l01530}{1530}} of file \mbox{\hyperlink{__optimize_8py_source}{\+\_\+optimize.\+py}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__optimize_a42153b668930aa7baa095578b0692a8b}\index{scipy.optimize.\_optimize@{scipy.optimize.\_optimize}!\_recover\_from\_bracket\_error@{\_recover\_from\_bracket\_error}}
\index{\_recover\_from\_bracket\_error@{\_recover\_from\_bracket\_error}!scipy.optimize.\_optimize@{scipy.optimize.\_optimize}}
\doxysubsubsection{\texorpdfstring{\_recover\_from\_bracket\_error()}{\_recover\_from\_bracket\_error()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__optimize_a42153b668930aa7baa095578b0692a8b} 
scipy.\+optimize.\+\_\+optimize.\+\_\+recover\+\_\+from\+\_\+bracket\+\_\+error (\begin{DoxyParamCaption}\item[{}]{solver}{, }\item[{}]{fun}{, }\item[{}]{bracket}{, }\item[{}]{args}{, }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{options}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{__optimize_8py_source_l03057}{3057}} of file \mbox{\hyperlink{__optimize_8py_source}{\+\_\+optimize.\+py}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__optimize_ad1f8fee294ebdb8f4608bd0fd21527e2}\index{scipy.optimize.\_optimize@{scipy.optimize.\_optimize}!\_wrap\_callback@{\_wrap\_callback}}
\index{\_wrap\_callback@{\_wrap\_callback}!scipy.optimize.\_optimize@{scipy.optimize.\_optimize}}
\doxysubsubsection{\texorpdfstring{\_wrap\_callback()}{\_wrap\_callback()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__optimize_ad1f8fee294ebdb8f4608bd0fd21527e2} 
scipy.\+optimize.\+\_\+optimize.\+\_\+wrap\+\_\+callback (\begin{DoxyParamCaption}\item[{}]{callback}{, }\item[{}]{method}{ = {\ttfamily None}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Wrap a user-provided callback so that attributes can be attached.\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__optimize_8py_source_l00135}{135}} of file \mbox{\hyperlink{__optimize_8py_source}{\+\_\+optimize.\+py}}.



Referenced by \mbox{\hyperlink{__optimize_8py_source_l00636}{fmin()}}, \mbox{\hyperlink{__optimize_8py_source_l01246}{fmin\+\_\+bfgs()}}, \mbox{\hyperlink{__optimize_8py_source_l01538}{fmin\+\_\+cg()}}, \mbox{\hyperlink{__lbfgsb__py_8py_source_l00054}{scipy.\+optimize.\+\_\+lbfgsb\+\_\+py.\+fmin\+\_\+l\+\_\+bfgs\+\_\+b()}}, \mbox{\hyperlink{__optimize_8py_source_l01860}{fmin\+\_\+ncg()}}, \mbox{\hyperlink{__optimize_8py_source_l03213}{fmin\+\_\+powell()}}, and \mbox{\hyperlink{__minimize_8py_source_l00053}{scipy.\+optimize.\+\_\+minimize.\+minimize()}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__optimize_a0289ea1f45541e56b527dc7817c88bbd}\index{scipy.optimize.\_optimize@{scipy.optimize.\_optimize}!\_wrap\_scalar\_function@{\_wrap\_scalar\_function}}
\index{\_wrap\_scalar\_function@{\_wrap\_scalar\_function}!scipy.optimize.\_optimize@{scipy.optimize.\_optimize}}
\doxysubsubsection{\texorpdfstring{\_wrap\_scalar\_function()}{\_wrap\_scalar\_function()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__optimize_a0289ea1f45541e56b527dc7817c88bbd} 
scipy.\+optimize.\+\_\+optimize.\+\_\+wrap\+\_\+scalar\+\_\+function (\begin{DoxyParamCaption}\item[{}]{function}{, }\item[{}]{args}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{__optimize_8py_source_l00580}{580}} of file \mbox{\hyperlink{__optimize_8py_source}{\+\_\+optimize.\+py}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__optimize_abf807e331a381a821ee49e99e63f6578}\index{scipy.optimize.\_optimize@{scipy.optimize.\_optimize}!\_wrap\_scalar\_function\_maxfun\_validation@{\_wrap\_scalar\_function\_maxfun\_validation}}
\index{\_wrap\_scalar\_function\_maxfun\_validation@{\_wrap\_scalar\_function\_maxfun\_validation}!scipy.optimize.\_optimize@{scipy.optimize.\_optimize}}
\doxysubsubsection{\texorpdfstring{\_wrap\_scalar\_function\_maxfun\_validation()}{\_wrap\_scalar\_function\_maxfun\_validation()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__optimize_abf807e331a381a821ee49e99e63f6578} 
scipy.\+optimize.\+\_\+optimize.\+\_\+wrap\+\_\+scalar\+\_\+function\+\_\+maxfun\+\_\+validation (\begin{DoxyParamCaption}\item[{}]{function}{, }\item[{}]{args}{, }\item[{}]{maxfun}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{__optimize_8py_source_l00608}{608}} of file \mbox{\hyperlink{__optimize_8py_source}{\+\_\+optimize.\+py}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__optimize_a11dbfcc1981be014e18da16c4f1b7545}\index{scipy.optimize.\_optimize@{scipy.optimize.\_optimize}!approx\_fhess\_p@{approx\_fhess\_p}}
\index{approx\_fhess\_p@{approx\_fhess\_p}!scipy.optimize.\_optimize@{scipy.optimize.\_optimize}}
\doxysubsubsection{\texorpdfstring{approx\_fhess\_p()}{approx\_fhess\_p()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__optimize_a11dbfcc1981be014e18da16c4f1b7545} 
scipy.\+optimize.\+\_\+optimize.\+approx\+\_\+fhess\+\_\+p (\begin{DoxyParamCaption}\item[{}]{x0}{, }\item[{}]{p}{, }\item[{}]{fprime}{, }\item[{}]{epsilon}{, }\item[{\texorpdfstring{$\ast$}{*}}]{args}{}\end{DoxyParamCaption})}



Definition at line \mbox{\hyperlink{__optimize_8py_source_l01188}{1188}} of file \mbox{\hyperlink{__optimize_8py_source}{\+\_\+optimize.\+py}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__optimize_ab1bdcfcf9601a38ca22629dc3d93ef39}\index{scipy.optimize.\_optimize@{scipy.optimize.\_optimize}!approx\_fprime@{approx\_fprime}}
\index{approx\_fprime@{approx\_fprime}!scipy.optimize.\_optimize@{scipy.optimize.\_optimize}}
\doxysubsubsection{\texorpdfstring{approx\_fprime()}{approx\_fprime()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__optimize_ab1bdcfcf9601a38ca22629dc3d93ef39} 
scipy.\+optimize.\+\_\+optimize.\+approx\+\_\+fprime (\begin{DoxyParamCaption}\item[{}]{xk}{, }\item[{}]{f}{, }\item[{}]{epsilon}{ = {\ttfamily \+\_\+epsilon}, }\item[{\texorpdfstring{$\ast$}{*}}]{args}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Finite difference approximation of the derivatives of a
scalar or vector-valued function.

If a function maps from :math:`R^n` to :math:`R^m`, its derivatives form
an m-by-n matrix
called the Jacobian, where an element :math:`(i, j)` is a partial
derivative of f[i] with respect to ``xk[j]``.

Parameters
----------
xk : array_like
    The coordinate vector at which to determine the gradient of `f`.
f : callable
    Function of which to estimate the derivatives of. Has the signature
    ``f(xk, *args)`` where `xk` is the argument in the form of a 1-D array
    and `args` is a tuple of any additional fixed parameters needed to
    completely specify the function. The argument `xk` passed to this
    function is an ndarray of shape (n,) (never a scalar even if n=1).
    It must return a 1-D array_like of shape (m,) or a scalar.

    .. versionchanged:: 1.9.0
        `f` is now able to return a 1-D array-like, with the :math:`(m, n)`
        Jacobian being estimated.

epsilon : {float, array_like}, optional
    Increment to `xk` to use for determining the function gradient.
    If a scalar, uses the same finite difference delta for all partial
    derivatives. If an array, should contain one value per element of
    `xk`. Defaults to ``sqrt(np.finfo(float).eps)``, which is approximately
    1.49e-08.
\\*args : args, optional
    Any other arguments that are to be passed to `f`.

Returns
-------
jac : ndarray
    The partial derivatives of `f` to `xk`.

See Also
--------
check_grad : Check correctness of gradient function against approx_fprime.

Notes
-----
The function gradient is determined by the forward finite difference
formula::

             f(xk[i] + epsilon[i]) - f(xk[i])
    f'[i] = ---------------------------------
                        epsilon[i]

Examples
--------
>>> import numpy as np
>>> from scipy import optimize
>>> def func(x, c0, c1):
...     "Coordinate vector `x` should be an array of size two."
...     return c0 * x[0]**2 + c1*x[1]**2

>>> x = np.ones(2)
>>> c0, c1 = (1, 200)
>>> eps = np.sqrt(np.finfo(float).eps)
>>> optimize.approx_fprime(x, func, [eps, np.sqrt(200) * eps], c0, c1)
array([   2.        ,  400.00004198])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__optimize_8py_source_l01019}{1019}} of file \mbox{\hyperlink{__optimize_8py_source}{\+\_\+optimize.\+py}}.



Referenced by \mbox{\hyperlink{__optimize_8py_source_l01094}{check\+\_\+grad()}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__optimize_aee61cc6cef1e91f845fff5cf0a8fc44f}\index{scipy.optimize.\_optimize@{scipy.optimize.\_optimize}!bracket@{bracket}}
\index{bracket@{bracket}!scipy.optimize.\_optimize@{scipy.optimize.\_optimize}}
\doxysubsubsection{\texorpdfstring{bracket()}{bracket()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__optimize_aee61cc6cef1e91f845fff5cf0a8fc44f} 
scipy.\+optimize.\+\_\+optimize.\+bracket (\begin{DoxyParamCaption}\item[{}]{func}{, }\item[{}]{xa}{ = {\ttfamily 0.0}, }\item[{}]{xb}{ = {\ttfamily 1.0}, }\item[{}]{args}{ = {\ttfamily ()}, }\item[{}]{grow\+\_\+limit}{ = {\ttfamily 110.0}, }\item[{}]{maxiter}{ = {\ttfamily 1000}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Bracket the minimum of a function.

Given a function and distinct initial points, search in the
downhill direction (as defined by the initial points) and return
three points that bracket the minimum of the function.

Parameters
----------
func : callable f(x,*args)
    Objective function to minimize.
xa, xb : float, optional
    Initial points. Defaults `xa` to 0.0, and `xb` to 1.0.
    A local minimum need not be contained within this interval.
args : tuple, optional
    Additional arguments (if present), passed to `func`.
grow_limit : float, optional
    Maximum grow limit.  Defaults to 110.0
maxiter : int, optional
    Maximum number of iterations to perform. Defaults to 1000.

Returns
-------
xa, xb, xc : float
    Final points of the bracket.
fa, fb, fc : float
    Objective function values at the bracket points.
funcalls : int
    Number of function evaluations made.

Raises
------
BracketError
    If no valid bracket is found before the algorithm terminates.
    See notes for conditions of a valid bracket.

Notes
-----
The algorithm attempts to find three strictly ordered points (i.e.
:math:`x_a < x_b < x_c` or :math:`x_c < x_b < x_a`) satisfying
:math:`f(x_b) ≤ f(x_a)` and :math:`f(x_b) ≤ f(x_c)`, where one of the
inequalities must be satistfied strictly and all :math:`x_i` must be
finite.

Examples
--------
This function can find a downward convex region of a function:

>>> import numpy as np
>>> import matplotlib.pyplot as plt
>>> from scipy.optimize import bracket
>>> def f(x):
...     return 10*x**2 + 3*x + 5
>>> x = np.linspace(-2, 2)
>>> y = f(x)
>>> init_xa, init_xb = 0.1, 1
>>> xa, xb, xc, fa, fb, fc, funcalls = bracket(f, xa=init_xa, xb=init_xb)
>>> plt.axvline(x=init_xa, color="k", linestyle="--")
>>> plt.axvline(x=init_xb, color="k", linestyle="--")
>>> plt.plot(x, y, "-k")
>>> plt.plot(xa, fa, "bx")
>>> plt.plot(xb, fb, "rx")
>>> plt.plot(xc, fc, "bx")
>>> plt.show()

Note that both initial points were to the right of the minimum, and the
third point was found in the "downhill" direction: the direction
in which the function appeared to be decreasing (to the left).
The final points are strictly ordered, and the function value
at the middle point is less than the function values at the endpoints;
it follows that a minimum must lie within the bracket.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__optimize_8py_source_l02894}{2894}} of file \mbox{\hyperlink{__optimize_8py_source}{\+\_\+optimize.\+py}}.



Referenced by \mbox{\hyperlink{__optimize_8py_source_l02780}{\+\_\+minimize\+\_\+scalar\+\_\+golden()}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__optimize_ab667dd7bd58227d18103e3e286969b71}\index{scipy.optimize.\_optimize@{scipy.optimize.\_optimize}!brent@{brent}}
\index{brent@{brent}!scipy.optimize.\_optimize@{scipy.optimize.\_optimize}}
\doxysubsubsection{\texorpdfstring{brent()}{brent()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__optimize_ab667dd7bd58227d18103e3e286969b71} 
scipy.\+optimize.\+\_\+optimize.\+brent (\begin{DoxyParamCaption}\item[{}]{func}{, }\item[{}]{args}{ = {\ttfamily ()}, }\item[{}]{brack}{ = {\ttfamily None}, }\item[{}]{tol}{ = {\ttfamily 1.48e-\/8}, }\item[{}]{full\+\_\+output}{ = {\ttfamily 0}, }\item[{}]{maxiter}{ = {\ttfamily 500}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Given a function of one variable and a possible bracket, return
a local minimizer of the function isolated to a fractional precision
of tol.

Parameters
----------
func : callable f(x,*args)
    Objective function.
args : tuple, optional
    Additional arguments (if present).
brack : tuple, optional
    Either a triple ``(xa, xb, xc)`` satisfying ``xa < xb < xc`` and
    ``func(xb) < func(xa) and  func(xb) < func(xc)``, or a pair
    ``(xa, xb)`` to be used as initial points for a downhill bracket search
    (see `scipy.optimize.bracket`).
    The minimizer ``x`` will not necessarily satisfy ``xa <= x <= xb``.
tol : float, optional
    Relative error in solution `xopt` acceptable for convergence.
full_output : bool, optional
    If True, return all output args (xmin, fval, iter,
    funcalls).
maxiter : int, optional
    Maximum number of iterations in solution.

Returns
-------
xmin : ndarray
    Optimum point.
fval : float
    (Optional output) Optimum function value.
iter : int
    (Optional output) Number of iterations.
funcalls : int
    (Optional output) Number of objective function evaluations made.

See also
--------
minimize_scalar: Interface to minimization algorithms for scalar
    univariate functions. See the 'Brent' `method` in particular.

Notes
-----
Uses inverse parabolic interpolation when possible to speed up
convergence of golden section method.

Does not ensure that the minimum lies in the range specified by
`brack`. See `scipy.optimize.fminbound`.

Examples
--------
We illustrate the behaviour of the function when `brack` is of
size 2 and 3 respectively. In the case where `brack` is of the
form ``(xa, xb)``, we can see for the given values, the output does
not necessarily lie in the range ``(xa, xb)``.

>>> def f(x):
...     return (x-1)**2

>>> from scipy import optimize

>>> minimizer = optimize.brent(f, brack=(1, 2))
>>> minimizer
1
>>> res = optimize.brent(f, brack=(-1, 0.5, 2), full_output=True)
>>> xmin, fval, iter, funcalls = res
>>> f(xmin), fval
(0.0, 0.0)
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__optimize_8py_source_l02569}{2569}} of file \mbox{\hyperlink{__optimize_8py_source}{\+\_\+optimize.\+py}}.



References \mbox{\hyperlink{__optimize_8py_source_l02651}{\+\_\+minimize\+\_\+scalar\+\_\+brent()}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__optimize_a98e856197a3ade6049ea4f05461669d8}\index{scipy.optimize.\_optimize@{scipy.optimize.\_optimize}!brute@{brute}}
\index{brute@{brute}!scipy.optimize.\_optimize@{scipy.optimize.\_optimize}}
\doxysubsubsection{\texorpdfstring{brute()}{brute()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__optimize_a98e856197a3ade6049ea4f05461669d8} 
scipy.\+optimize.\+\_\+optimize.\+brute (\begin{DoxyParamCaption}\item[{}]{func}{, }\item[{}]{ranges}{, }\item[{}]{args}{ = {\ttfamily ()}, }\item[{}]{Ns}{ = {\ttfamily 20}, }\item[{}]{full\+\_\+output}{ = {\ttfamily 0}, }\item[{}]{finish}{ = {\ttfamily \mbox{\hyperlink{namespacescipy_1_1optimize_1_1__optimize_a1c8825f72fbb699b9d86a64dfd7f2d5b}{fmin}}}, }\item[{}]{disp}{ = {\ttfamily False}, }\item[{}]{workers}{ = {\ttfamily 1}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Minimize a function over a given range by brute force.

Uses the "brute force" method, i.e., computes the function's value
at each point of a multidimensional grid of points, to find the global
minimum of the function.

The function is evaluated everywhere in the range with the datatype of the
first call to the function, as enforced by the ``vectorize`` NumPy
function. The value and type of the function evaluation returned when
``full_output=True`` are affected in addition by the ``finish`` argument
(see Notes).

The brute force approach is inefficient because the number of grid points
increases exponentially - the number of grid points to evaluate is
``Ns ** len(x)``. Consequently, even with coarse grid spacing, even
moderately sized problems can take a long time to run, and/or run into
memory limitations.

Parameters
----------
func : callable
    The objective function to be minimized. Must be in the
    form ``f(x, *args)``, where ``x`` is the argument in
    the form of a 1-D array and ``args`` is a tuple of any
    additional fixed parameters needed to completely specify
    the function.
ranges : tuple
    Each component of the `ranges` tuple must be either a
    "slice object" or a range tuple of the form ``(low, high)``.
    The program uses these to create the grid of points on which
    the objective function will be computed. See `Note 2` for
    more detail.
args : tuple, optional
    Any additional fixed parameters needed to completely specify
    the function.
Ns : int, optional
    Number of grid points along the axes, if not otherwise
    specified. See `Note2`.
full_output : bool, optional
    If True, return the evaluation grid and the objective function's
    values on it.
finish : callable, optional
    An optimization function that is called with the result of brute force
    minimization as initial guess. `finish` should take `func` and
    the initial guess as positional arguments, and take `args` as
    keyword arguments. It may additionally take `full_output`
    and/or `disp` as keyword arguments. Use None if no "polishing"
    function is to be used. See Notes for more details.
disp : bool, optional
    Set to True to print convergence messages from the `finish` callable.
workers : int or map-like callable, optional
    If `workers` is an int the grid is subdivided into `workers`
    sections and evaluated in parallel (uses
    `multiprocessing.Pool <multiprocessing>`).
    Supply `-1` to use all cores available to the Process.
    Alternatively supply a map-like callable, such as
    `multiprocessing.Pool.map` for evaluating the grid in parallel.
    This evaluation is carried out as ``workers(func, iterable)``.
    Requires that `func` be pickleable.

    .. versionadded:: 1.3.0

Returns
-------
x0 : ndarray
    A 1-D array containing the coordinates of a point at which the
    objective function had its minimum value. (See `Note 1` for
    which point is returned.)
fval : float
    Function value at the point `x0`. (Returned when `full_output` is
    True.)
grid : tuple
    Representation of the evaluation grid. It has the same
    length as `x0`. (Returned when `full_output` is True.)
Jout : ndarray
    Function values at each point of the evaluation
    grid, i.e., ``Jout = func(*grid)``. (Returned
    when `full_output` is True.)

See Also
--------
basinhopping, differential_evolution

Notes
-----
*Note 1*: The program finds the gridpoint at which the lowest value
of the objective function occurs. If `finish` is None, that is the
point returned. When the global minimum occurs within (or not very far
outside) the grid's boundaries, and the grid is fine enough, that
point will be in the neighborhood of the global minimum.

However, users often employ some other optimization program to
"polish" the gridpoint values, i.e., to seek a more precise
(local) minimum near `brute's` best gridpoint.
The `brute` function's `finish` option provides a convenient way to do
that. Any polishing program used must take `brute's` output as its
initial guess as a positional argument, and take `brute's` input values
for `args` as keyword arguments, otherwise an error will be raised.
It may additionally take `full_output` and/or `disp` as keyword arguments.

`brute` assumes that the `finish` function returns either an
`OptimizeResult` object or a tuple in the form:
``(xmin, Jmin, ... , statuscode)``, where ``xmin`` is the minimizing
value of the argument, ``Jmin`` is the minimum value of the objective
function, "..." may be some other returned values (which are not used
by `brute`), and ``statuscode`` is the status code of the `finish` program.

Note that when `finish` is not None, the values returned are those
of the `finish` program, *not* the gridpoint ones. Consequently,
while `brute` confines its search to the input grid points,
the `finish` program's results usually will not coincide with any
gridpoint, and may fall outside the grid's boundary. Thus, if a
minimum only needs to be found over the provided grid points, make
sure to pass in `finish=None`.

*Note 2*: The grid of points is a `numpy.mgrid` object.
For `brute` the `ranges` and `Ns` inputs have the following effect.
Each component of the `ranges` tuple can be either a slice object or a
two-tuple giving a range of values, such as (0, 5). If the component is a
slice object, `brute` uses it directly. If the component is a two-tuple
range, `brute` internally converts it to a slice object that interpolates
`Ns` points from its low-value to its high-value, inclusive.

Examples
--------
We illustrate the use of `brute` to seek the global minimum of a function
of two variables that is given as the sum of a positive-definite
quadratic and two deep "Gaussian-shaped" craters. Specifically, define
the objective function `f` as the sum of three other functions,
``f = f1 + f2 + f3``. We suppose each of these has a signature
``(z, *params)``, where ``z = (x, y)``,  and ``params`` and the functions
are as defined below.

>>> import numpy as np
>>> params = (2, 3, 7, 8, 9, 10, 44, -1, 2, 26, 1, -2, 0.5)
>>> def f1(z, *params):
...     x, y = z
...     a, b, c, d, e, f, g, h, i, j, k, l, scale = params
...     return (a * x**2 + b * x * y + c * y**2 + d*x + e*y + f)

>>> def f2(z, *params):
...     x, y = z
...     a, b, c, d, e, f, g, h, i, j, k, l, scale = params
...     return (-g*np.exp(-((x-h)**2 + (y-i)**2) / scale))

>>> def f3(z, *params):
...     x, y = z
...     a, b, c, d, e, f, g, h, i, j, k, l, scale = params
...     return (-j*np.exp(-((x-k)**2 + (y-l)**2) / scale))

>>> def f(z, *params):
...     return f1(z, *params) + f2(z, *params) + f3(z, *params)

Thus, the objective function may have local minima near the minimum
of each of the three functions of which it is composed. To
use `fmin` to polish its gridpoint result, we may then continue as
follows:

>>> rranges = (slice(-4, 4, 0.25), slice(-4, 4, 0.25))
>>> from scipy import optimize
>>> resbrute = optimize.brute(f, rranges, args=params, full_output=True,
...                           finish=optimize.fmin)
>>> resbrute[0]  # global minimum
array([-1.05665192,  1.80834843])
>>> resbrute[1]  # function value at global minimum
-3.4085818767

Note that if `finish` had been set to None, we would have gotten the
gridpoint [-1.0 1.75] where the rounded function value is -2.892.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__optimize_8py_source_l03614}{3614}} of file \mbox{\hyperlink{__optimize_8py_source}{\+\_\+optimize.\+py}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__optimize_a5fba77c8a7356feafdaff564a7c39b48}\index{scipy.optimize.\_optimize@{scipy.optimize.\_optimize}!check\_grad@{check\_grad}}
\index{check\_grad@{check\_grad}!scipy.optimize.\_optimize@{scipy.optimize.\_optimize}}
\doxysubsubsection{\texorpdfstring{check\_grad()}{check\_grad()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__optimize_a5fba77c8a7356feafdaff564a7c39b48} 
scipy.\+optimize.\+\_\+optimize.\+check\+\_\+grad (\begin{DoxyParamCaption}\item[{}]{func}{, }\item[{}]{grad}{, }\item[{}]{x0}{, }\item[{\texorpdfstring{$\ast$}{*}}]{args}{, }\item[{}]{epsilon}{ = {\ttfamily \+\_\+epsilon}, }\item[{}]{direction}{ = {\ttfamily \textquotesingle{}all\textquotesingle{}}, }\item[{}]{seed}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Check the correctness of a gradient function by comparing it against a
(forward) finite-difference approximation of the gradient.

Parameters
----------
func : callable ``func(x0, *args)``
    Function whose derivative is to be checked.
grad : callable ``grad(x0, *args)``
    Jacobian of `func`.
x0 : ndarray
    Points to check `grad` against forward difference approximation of grad
    using `func`.
args : \\*args, optional
    Extra arguments passed to `func` and `grad`.
epsilon : float, optional
    Step size used for the finite difference approximation. It defaults to
    ``sqrt(np.finfo(float).eps)``, which is approximately 1.49e-08.
direction : str, optional
    If set to ``'random'``, then gradients along a random vector
    are used to check `grad` against forward difference approximation
    using `func`. By default it is ``'all'``, in which case, all
    the one hot direction vectors are considered to check `grad`.
    If `func` is a vector valued function then only ``'all'`` can be used.
seed : {None, int, `numpy.random.Generator`, `numpy.random.RandomState`}, optional
    If `seed` is None (or `np.random`), the `numpy.random.RandomState`
    singleton is used.
    If `seed` is an int, a new ``RandomState`` instance is used,
    seeded with `seed`.
    If `seed` is already a ``Generator`` or ``RandomState`` instance then
    that instance is used.
    Specify `seed` for reproducing the return value from this function.
    The random numbers generated with this seed affect the random vector
    along which gradients are computed to check ``grad``. Note that `seed`
    is only used when `direction` argument is set to `'random'`.

Returns
-------
err : float
    The square root of the sum of squares (i.e., the 2-norm) of the
    difference between ``grad(x0, *args)`` and the finite difference
    approximation of `grad` using func at the points `x0`.

See Also
--------
approx_fprime

Examples
--------
>>> import numpy as np
>>> def func(x):
...     return x[0]**2 - 0.5 * x[1]**3
>>> def grad(x):
...     return [2 * x[0], -1.5 * x[1]**2]
>>> from scipy.optimize import check_grad
>>> check_grad(func, grad, [1.5, -1.5])
2.9802322387695312e-08  # may vary
>>> rng = np.random.default_rng()
>>> check_grad(func, grad, [1.5, -1.5],
...             direction='random', seed=rng)
2.9802322387695312e-08
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__optimize_8py_source_l01093}{1093}} of file \mbox{\hyperlink{__optimize_8py_source}{\+\_\+optimize.\+py}}.



References \mbox{\hyperlink{__optimize_8py_source_l01019}{approx\+\_\+fprime()}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__optimize_a1c8825f72fbb699b9d86a64dfd7f2d5b}\index{scipy.optimize.\_optimize@{scipy.optimize.\_optimize}!fmin@{fmin}}
\index{fmin@{fmin}!scipy.optimize.\_optimize@{scipy.optimize.\_optimize}}
\doxysubsubsection{\texorpdfstring{fmin()}{fmin()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__optimize_a1c8825f72fbb699b9d86a64dfd7f2d5b} 
scipy.\+optimize.\+\_\+optimize.\+fmin (\begin{DoxyParamCaption}\item[{}]{func}{, }\item[{}]{x0}{, }\item[{}]{args}{ = {\ttfamily ()}, }\item[{}]{xtol}{ = {\ttfamily 1e-\/4}, }\item[{}]{ftol}{ = {\ttfamily 1e-\/4}, }\item[{}]{maxiter}{ = {\ttfamily None}, }\item[{}]{maxfun}{ = {\ttfamily None}, }\item[{}]{full\+\_\+output}{ = {\ttfamily 0}, }\item[{}]{disp}{ = {\ttfamily 1}, }\item[{}]{retall}{ = {\ttfamily 0}, }\item[{}]{callback}{ = {\ttfamily None}, }\item[{}]{initial\+\_\+simplex}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Minimize a function using the downhill simplex algorithm.

This algorithm only uses function values, not derivatives or second
derivatives.

Parameters
----------
func : callable func(x,*args)
    The objective function to be minimized.
x0 : ndarray
    Initial guess.
args : tuple, optional
    Extra arguments passed to func, i.e., ``f(x,*args)``.
xtol : float, optional
    Absolute error in xopt between iterations that is acceptable for
    convergence.
ftol : number, optional
    Absolute error in func(xopt) between iterations that is acceptable for
    convergence.
maxiter : int, optional
    Maximum number of iterations to perform.
maxfun : number, optional
    Maximum number of function evaluations to make.
full_output : bool, optional
    Set to True if fopt and warnflag outputs are desired.
disp : bool, optional
    Set to True to print convergence messages.
retall : bool, optional
    Set to True to return list of solutions at each iteration.
callback : callable, optional
    Called after each iteration, as callback(xk), where xk is the
    current parameter vector.
initial_simplex : array_like of shape (N + 1, N), optional
    Initial simplex. If given, overrides `x0`.
    ``initial_simplex[j,:]`` should contain the coordinates of
    the jth vertex of the ``N+1`` vertices in the simplex, where
    ``N`` is the dimension.

Returns
-------
xopt : ndarray
    Parameter that minimizes function.
fopt : float
    Value of function at minimum: ``fopt = func(xopt)``.
iter : int
    Number of iterations performed.
funcalls : int
    Number of function calls made.
warnflag : int
    1 : Maximum number of function evaluations made.
    2 : Maximum number of iterations reached.
allvecs : list
    Solution at each iteration.

See also
--------
minimize: Interface to minimization algorithms for multivariate
    functions. See the 'Nelder-Mead' `method` in particular.

Notes
-----
Uses a Nelder-Mead simplex algorithm to find the minimum of function of
one or more variables.

This algorithm has a long history of successful use in applications.
But it will usually be slower than an algorithm that uses first or
second derivative information. In practice, it can have poor
performance in high-dimensional problems and is not robust to
minimizing complicated functions. Additionally, there currently is no
complete theory describing when the algorithm will successfully
converge to the minimum, or how fast it will if it does. Both the ftol and
xtol criteria must be met for convergence.

Examples
--------
>>> def f(x):
...     return x**2

>>> from scipy import optimize

>>> minimum = optimize.fmin(f, 1)
Optimization terminated successfully.
         Current function value: 0.000000
         Iterations: 17
         Function evaluations: 34
>>> minimum[0]
-8.8817841970012523e-16

References
----------
.. [1] Nelder, J.A. and Mead, R. (1965), "A simplex method for function
       minimization", The Computer Journal, 7, pp. 308-313

.. [2] Wright, M.H. (1996), "Direct Search Methods: Once Scorned, Now
       Respectable", in Numerical Analysis 1995, Proceedings of the
       1995 Dundee Biennial Conference in Numerical Analysis, D.F.
       Griffiths and G.A. Watson (Eds.), Addison Wesley Longman,
       Harlow, UK, pp. 191-208.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__optimize_8py_source_l00635}{635}} of file \mbox{\hyperlink{__optimize_8py_source}{\+\_\+optimize.\+py}}.



References \mbox{\hyperlink{__optimize_8py_source_l00764}{\+\_\+minimize\+\_\+neldermead()}}, and \mbox{\hyperlink{__optimize_8py_source_l00135}{\+\_\+wrap\+\_\+callback()}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__optimize_a7cca7c5cd6e2b781b6d706de4a3044dc}\index{scipy.optimize.\_optimize@{scipy.optimize.\_optimize}!fmin\_bfgs@{fmin\_bfgs}}
\index{fmin\_bfgs@{fmin\_bfgs}!scipy.optimize.\_optimize@{scipy.optimize.\_optimize}}
\doxysubsubsection{\texorpdfstring{fmin\_bfgs()}{fmin\_bfgs()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__optimize_a7cca7c5cd6e2b781b6d706de4a3044dc} 
scipy.\+optimize.\+\_\+optimize.\+fmin\+\_\+bfgs (\begin{DoxyParamCaption}\item[{}]{f}{, }\item[{}]{x0}{, }\item[{}]{fprime}{ = {\ttfamily None}, }\item[{}]{args}{ = {\ttfamily ()}, }\item[{}]{gtol}{ = {\ttfamily 1e-\/5}, }\item[{}]{norm}{ = {\ttfamily Inf}, }\item[{}]{epsilon}{ = {\ttfamily \+\_\+epsilon}, }\item[{}]{maxiter}{ = {\ttfamily None}, }\item[{}]{full\+\_\+output}{ = {\ttfamily 0}, }\item[{}]{disp}{ = {\ttfamily 1}, }\item[{}]{retall}{ = {\ttfamily 0}, }\item[{}]{callback}{ = {\ttfamily None}, }\item[{}]{xrtol}{ = {\ttfamily 0}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Minimize a function using the BFGS algorithm.

Parameters
----------
f : callable ``f(x,*args)``
    Objective function to be minimized.
x0 : ndarray
    Initial guess.
fprime : callable ``f'(x,*args)``, optional
    Gradient of f.
args : tuple, optional
    Extra arguments passed to f and fprime.
gtol : float, optional
    Terminate successfully if gradient norm is less than `gtol`
norm : float, optional
    Order of norm (Inf is max, -Inf is min)
epsilon : int or ndarray, optional
    If `fprime` is approximated, use this value for the step size.
callback : callable, optional
    An optional user-supplied function to call after each
    iteration. Called as ``callback(xk)``, where ``xk`` is the
    current parameter vector.
maxiter : int, optional
    Maximum number of iterations to perform.
full_output : bool, optional
    If True, return ``fopt``, ``func_calls``, ``grad_calls``, and
    ``warnflag`` in addition to ``xopt``.
disp : bool, optional
    Print convergence message if True.
retall : bool, optional
    Return a list of results at each iteration if True.
xrtol : float, default: 0
    Relative tolerance for `x`. Terminate successfully if step
    size is less than ``xk * xrtol`` where ``xk`` is the current
    parameter vector.

Returns
-------
xopt : ndarray
    Parameters which minimize f, i.e., ``f(xopt) == fopt``.
fopt : float
    Minimum value.
gopt : ndarray
    Value of gradient at minimum, f'(xopt), which should be near 0.
Bopt : ndarray
    Value of 1/f''(xopt), i.e., the inverse Hessian matrix.
func_calls : int
    Number of function_calls made.
grad_calls : int
    Number of gradient calls made.
warnflag : integer
    1 : Maximum number of iterations exceeded.
    2 : Gradient and/or function calls not changing.
    3 : NaN result encountered.
allvecs : list
    The value of `xopt` at each iteration. Only returned if `retall` is
    True.

Notes
-----
Optimize the function, `f`, whose gradient is given by `fprime`
using the quasi-Newton method of Broyden, Fletcher, Goldfarb,
and Shanno (BFGS).

See Also
--------
minimize: Interface to minimization algorithms for multivariate
    functions. See ``method='BFGS'`` in particular.

References
----------
Wright, and Nocedal 'Numerical Optimization', 1999, p. 198.

Examples
--------
>>> import numpy as np
>>> from scipy.optimize import fmin_bfgs
>>> def quadratic_cost(x, Q):
...     return x @ Q @ x
...
>>> x0 = np.array([-3, -4])
>>> cost_weight =  np.diag([1., 10.])
>>> # Note that a trailing comma is necessary for a tuple with single element
>>> fmin_bfgs(quadratic_cost, x0, args=(cost_weight,))
Optimization terminated successfully.
        Current function value: 0.000000
        Iterations: 7                   # may vary
        Function evaluations: 24        # may vary
        Gradient evaluations: 8         # may vary
array([ 2.85169950e-06, -4.61820139e-07])

>>> def quadratic_cost_grad(x, Q):
...     return 2 * Q @ x
...
>>> fmin_bfgs(quadratic_cost, x0, quadratic_cost_grad, args=(cost_weight,))
Optimization terminated successfully.
        Current function value: 0.000000
        Iterations: 7
        Function evaluations: 8
        Gradient evaluations: 8
array([ 2.85916637e-06, -4.54371951e-07])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__optimize_8py_source_l01244}{1244}} of file \mbox{\hyperlink{__optimize_8py_source}{\+\_\+optimize.\+py}}.



References \mbox{\hyperlink{__optimize_8py_source_l01378}{\+\_\+minimize\+\_\+bfgs()}}, and \mbox{\hyperlink{__optimize_8py_source_l00135}{\+\_\+wrap\+\_\+callback()}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__optimize_af6dce6d9178c7f8c0528157dc1b54df4}\index{scipy.optimize.\_optimize@{scipy.optimize.\_optimize}!fmin\_cg@{fmin\_cg}}
\index{fmin\_cg@{fmin\_cg}!scipy.optimize.\_optimize@{scipy.optimize.\_optimize}}
\doxysubsubsection{\texorpdfstring{fmin\_cg()}{fmin\_cg()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__optimize_af6dce6d9178c7f8c0528157dc1b54df4} 
scipy.\+optimize.\+\_\+optimize.\+fmin\+\_\+cg (\begin{DoxyParamCaption}\item[{}]{f}{, }\item[{}]{x0}{, }\item[{}]{fprime}{ = {\ttfamily None}, }\item[{}]{args}{ = {\ttfamily ()}, }\item[{}]{gtol}{ = {\ttfamily 1e-\/5}, }\item[{}]{norm}{ = {\ttfamily Inf}, }\item[{}]{epsilon}{ = {\ttfamily \+\_\+epsilon}, }\item[{}]{maxiter}{ = {\ttfamily None}, }\item[{}]{full\+\_\+output}{ = {\ttfamily 0}, }\item[{}]{disp}{ = {\ttfamily 1}, }\item[{}]{retall}{ = {\ttfamily 0}, }\item[{}]{callback}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Minimize a function using a nonlinear conjugate gradient algorithm.

Parameters
----------
f : callable, ``f(x, *args)``
    Objective function to be minimized. Here `x` must be a 1-D array of
    the variables that are to be changed in the search for a minimum, and
    `args` are the other (fixed) parameters of `f`.
x0 : ndarray
    A user-supplied initial estimate of `xopt`, the optimal value of `x`.
    It must be a 1-D array of values.
fprime : callable, ``fprime(x, *args)``, optional
    A function that returns the gradient of `f` at `x`. Here `x` and `args`
    are as described above for `f`. The returned value must be a 1-D array.
    Defaults to None, in which case the gradient is approximated
    numerically (see `epsilon`, below).
args : tuple, optional
    Parameter values passed to `f` and `fprime`. Must be supplied whenever
    additional fixed parameters are needed to completely specify the
    functions `f` and `fprime`.
gtol : float, optional
    Stop when the norm of the gradient is less than `gtol`.
norm : float, optional
    Order to use for the norm of the gradient
    (``-np.inf`` is min, ``np.inf`` is max).
epsilon : float or ndarray, optional
    Step size(s) to use when `fprime` is approximated numerically. Can be a
    scalar or a 1-D array. Defaults to ``sqrt(eps)``, with eps the
    floating point machine precision.  Usually ``sqrt(eps)`` is about
    1.5e-8.
maxiter : int, optional
    Maximum number of iterations to perform. Default is ``200 * len(x0)``.
full_output : bool, optional
    If True, return `fopt`, `func_calls`, `grad_calls`, and `warnflag` in
    addition to `xopt`.  See the Returns section below for additional
    information on optional return values.
disp : bool, optional
    If True, return a convergence message, followed by `xopt`.
retall : bool, optional
    If True, add to the returned values the results of each iteration.
callback : callable, optional
    An optional user-supplied function, called after each iteration.
    Called as ``callback(xk)``, where ``xk`` is the current value of `x0`.

Returns
-------
xopt : ndarray
    Parameters which minimize f, i.e., ``f(xopt) == fopt``.
fopt : float, optional
    Minimum value found, f(xopt). Only returned if `full_output` is True.
func_calls : int, optional
    The number of function_calls made. Only returned if `full_output`
    is True.
grad_calls : int, optional
    The number of gradient calls made. Only returned if `full_output` is
    True.
warnflag : int, optional
    Integer value with warning status, only returned if `full_output` is
    True.

    0 : Success.

    1 : The maximum number of iterations was exceeded.

    2 : Gradient and/or function calls were not changing. May indicate
        that precision was lost, i.e., the routine did not converge.

    3 : NaN result encountered.

allvecs : list of ndarray, optional
    List of arrays, containing the results at each iteration.
    Only returned if `retall` is True.

See Also
--------
minimize : common interface to all `scipy.optimize` algorithms for
           unconstrained and constrained minimization of multivariate
           functions. It provides an alternative way to call
           ``fmin_cg``, by specifying ``method='CG'``.

Notes
-----
This conjugate gradient algorithm is based on that of Polak and Ribiere
[1]_.

Conjugate gradient methods tend to work better when:

1. `f` has a unique global minimizing point, and no local minima or
   other stationary points,
2. `f` is, at least locally, reasonably well approximated by a
   quadratic function of the variables,
3. `f` is continuous and has a continuous gradient,
4. `fprime` is not too large, e.g., has a norm less than 1000,
5. The initial guess, `x0`, is reasonably close to `f` 's global
   minimizing point, `xopt`.

References
----------
.. [1] Wright & Nocedal, "Numerical Optimization", 1999, pp. 120-122.

Examples
--------
Example 1: seek the minimum value of the expression
``a*u**2 + b*u*v + c*v**2 + d*u + e*v + f`` for given values
of the parameters and an initial guess ``(u, v) = (0, 0)``.

>>> import numpy as np
>>> args = (2, 3, 7, 8, 9, 10)  # parameter values
>>> def f(x, *args):
...     u, v = x
...     a, b, c, d, e, f = args
...     return a*u**2 + b*u*v + c*v**2 + d*u + e*v + f
>>> def gradf(x, *args):
...     u, v = x
...     a, b, c, d, e, f = args
...     gu = 2*a*u + b*v + d     # u-component of the gradient
...     gv = b*u + 2*c*v + e     # v-component of the gradient
...     return np.asarray((gu, gv))
>>> x0 = np.asarray((0, 0))  # Initial guess.
>>> from scipy import optimize
>>> res1 = optimize.fmin_cg(f, x0, fprime=gradf, args=args)
Optimization terminated successfully.
         Current function value: 1.617021
         Iterations: 4
         Function evaluations: 8
         Gradient evaluations: 8
>>> res1
array([-1.80851064, -0.25531915])

Example 2: solve the same problem using the `minimize` function.
(This `myopts` dictionary shows all of the available options,
although in practice only non-default values would be needed.
The returned value will be a dictionary.)

>>> opts = {'maxiter' : None,    # default value.
...         'disp' : True,    # non-default value.
...         'gtol' : 1e-5,    # default value.
...         'norm' : np.inf,  # default value.
...         'eps' : 1.4901161193847656e-08}  # default value.
>>> res2 = optimize.minimize(f, x0, jac=gradf, args=args,
...                          method='CG', options=opts)
Optimization terminated successfully.
        Current function value: 1.617021
        Iterations: 4
        Function evaluations: 8
        Gradient evaluations: 8
>>> res2.x  # minimum found
array([-1.80851064, -0.25531915])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__optimize_8py_source_l01537}{1537}} of file \mbox{\hyperlink{__optimize_8py_source}{\+\_\+optimize.\+py}}.



References \mbox{\hyperlink{__optimize_8py_source_l01715}{\+\_\+minimize\+\_\+cg()}}, and \mbox{\hyperlink{__optimize_8py_source_l00135}{\+\_\+wrap\+\_\+callback()}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__optimize_ac1f87d4a3076d3d4579a03dfe3f32ddd}\index{scipy.optimize.\_optimize@{scipy.optimize.\_optimize}!fmin\_ncg@{fmin\_ncg}}
\index{fmin\_ncg@{fmin\_ncg}!scipy.optimize.\_optimize@{scipy.optimize.\_optimize}}
\doxysubsubsection{\texorpdfstring{fmin\_ncg()}{fmin\_ncg()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__optimize_ac1f87d4a3076d3d4579a03dfe3f32ddd} 
scipy.\+optimize.\+\_\+optimize.\+fmin\+\_\+ncg (\begin{DoxyParamCaption}\item[{}]{f}{, }\item[{}]{x0}{, }\item[{}]{fprime}{, }\item[{}]{fhess\+\_\+p}{ = {\ttfamily None}, }\item[{}]{fhess}{ = {\ttfamily None}, }\item[{}]{args}{ = {\ttfamily ()}, }\item[{}]{avextol}{ = {\ttfamily 1e-\/5}, }\item[{}]{epsilon}{ = {\ttfamily \+\_\+epsilon}, }\item[{}]{maxiter}{ = {\ttfamily None}, }\item[{}]{full\+\_\+output}{ = {\ttfamily 0}, }\item[{}]{disp}{ = {\ttfamily 1}, }\item[{}]{retall}{ = {\ttfamily 0}, }\item[{}]{callback}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Unconstrained minimization of a function using the Newton-CG method.

Parameters
----------
f : callable ``f(x, *args)``
    Objective function to be minimized.
x0 : ndarray
    Initial guess.
fprime : callable ``f'(x, *args)``
    Gradient of f.
fhess_p : callable ``fhess_p(x, p, *args)``, optional
    Function which computes the Hessian of f times an
    arbitrary vector, p.
fhess : callable ``fhess(x, *args)``, optional
    Function to compute the Hessian matrix of f.
args : tuple, optional
    Extra arguments passed to f, fprime, fhess_p, and fhess
    (the same set of extra arguments is supplied to all of
    these functions).
epsilon : float or ndarray, optional
    If fhess is approximated, use this value for the step size.
callback : callable, optional
    An optional user-supplied function which is called after
    each iteration. Called as callback(xk), where xk is the
    current parameter vector.
avextol : float, optional
    Convergence is assumed when the average relative error in
    the minimizer falls below this amount.
maxiter : int, optional
    Maximum number of iterations to perform.
full_output : bool, optional
    If True, return the optional outputs.
disp : bool, optional
    If True, print convergence message.
retall : bool, optional
    If True, return a list of results at each iteration.

Returns
-------
xopt : ndarray
    Parameters which minimize f, i.e., ``f(xopt) == fopt``.
fopt : float
    Value of the function at xopt, i.e., ``fopt = f(xopt)``.
fcalls : int
    Number of function calls made.
gcalls : int
    Number of gradient calls made.
hcalls : int
    Number of Hessian calls made.
warnflag : int
    Warnings generated by the algorithm.
    1 : Maximum number of iterations exceeded.
    2 : Line search failure (precision loss).
    3 : NaN result encountered.
allvecs : list
    The result at each iteration, if retall is True (see below).

See also
--------
minimize: Interface to minimization algorithms for multivariate
    functions. See the 'Newton-CG' `method` in particular.

Notes
-----
Only one of `fhess_p` or `fhess` need to be given.  If `fhess`
is provided, then `fhess_p` will be ignored. If neither `fhess`
nor `fhess_p` is provided, then the hessian product will be
approximated using finite differences on `fprime`. `fhess_p`
must compute the hessian times an arbitrary vector. If it is not
given, finite-differences on `fprime` are used to compute
it.

Newton-CG methods are also called truncated Newton methods. This
function differs from scipy.optimize.fmin_tnc because

1. scipy.optimize.fmin_ncg is written purely in Python using NumPy
    and scipy while scipy.optimize.fmin_tnc calls a C function.
2. scipy.optimize.fmin_ncg is only for unconstrained minimization
    while scipy.optimize.fmin_tnc is for unconstrained minimization
    or box constrained minimization. (Box constraints give
    lower and upper bounds for each variable separately.)

References
----------
Wright & Nocedal, 'Numerical Optimization', 1999, p. 140.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__optimize_8py_source_l01858}{1858}} of file \mbox{\hyperlink{__optimize_8py_source}{\+\_\+optimize.\+py}}.



References \mbox{\hyperlink{__optimize_8py_source_l01975}{\+\_\+minimize\+\_\+newtoncg()}}, and \mbox{\hyperlink{__optimize_8py_source_l00135}{\+\_\+wrap\+\_\+callback()}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__optimize_ab37e1a3656d4e065f5ea2f3acdd29b20}\index{scipy.optimize.\_optimize@{scipy.optimize.\_optimize}!fmin\_powell@{fmin\_powell}}
\index{fmin\_powell@{fmin\_powell}!scipy.optimize.\_optimize@{scipy.optimize.\_optimize}}
\doxysubsubsection{\texorpdfstring{fmin\_powell()}{fmin\_powell()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__optimize_ab37e1a3656d4e065f5ea2f3acdd29b20} 
scipy.\+optimize.\+\_\+optimize.\+fmin\+\_\+powell (\begin{DoxyParamCaption}\item[{}]{func}{, }\item[{}]{x0}{, }\item[{}]{args}{ = {\ttfamily ()}, }\item[{}]{xtol}{ = {\ttfamily 1e-\/4}, }\item[{}]{ftol}{ = {\ttfamily 1e-\/4}, }\item[{}]{maxiter}{ = {\ttfamily None}, }\item[{}]{maxfun}{ = {\ttfamily None}, }\item[{}]{full\+\_\+output}{ = {\ttfamily 0}, }\item[{}]{disp}{ = {\ttfamily 1}, }\item[{}]{retall}{ = {\ttfamily 0}, }\item[{}]{callback}{ = {\ttfamily None}, }\item[{}]{direc}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Minimize a function using modified Powell's method.

This method only uses function values, not derivatives.

Parameters
----------
func : callable f(x,*args)
    Objective function to be minimized.
x0 : ndarray
    Initial guess.
args : tuple, optional
    Extra arguments passed to func.
xtol : float, optional
    Line-search error tolerance.
ftol : float, optional
    Relative error in ``func(xopt)`` acceptable for convergence.
maxiter : int, optional
    Maximum number of iterations to perform.
maxfun : int, optional
    Maximum number of function evaluations to make.
full_output : bool, optional
    If True, ``fopt``, ``xi``, ``direc``, ``iter``, ``funcalls``, and
    ``warnflag`` are returned.
disp : bool, optional
    If True, print convergence messages.
retall : bool, optional
    If True, return a list of the solution at each iteration.
callback : callable, optional
    An optional user-supplied function, called after each
    iteration.  Called as ``callback(xk)``, where ``xk`` is the
    current parameter vector.
direc : ndarray, optional
    Initial fitting step and parameter order set as an (N, N) array, where N
    is the number of fitting parameters in `x0`. Defaults to step size 1.0
    fitting all parameters simultaneously (``np.eye((N, N))``). To
    prevent initial consideration of values in a step or to change initial
    step size, set to 0 or desired step size in the Jth position in the Mth
    block, where J is the position in `x0` and M is the desired evaluation
    step, with steps being evaluated in index order. Step size and ordering
    will change freely as minimization proceeds.

Returns
-------
xopt : ndarray
    Parameter which minimizes `func`.
fopt : number
    Value of function at minimum: ``fopt = func(xopt)``.
direc : ndarray
    Current direction set.
iter : int
    Number of iterations.
funcalls : int
    Number of function calls made.
warnflag : int
    Integer warning flag:
        1 : Maximum number of function evaluations.
        2 : Maximum number of iterations.
        3 : NaN result encountered.
        4 : The result is out of the provided bounds.
allvecs : list
    List of solutions at each iteration.

See also
--------
minimize: Interface to unconstrained minimization algorithms for
    multivariate functions. See the 'Powell' method in particular.

Notes
-----
Uses a modification of Powell's method to find the minimum of
a function of N variables. Powell's method is a conjugate
direction method.

The algorithm has two loops. The outer loop merely iterates over the inner
loop. The inner loop minimizes over each current direction in the direction
set. At the end of the inner loop, if certain conditions are met, the
direction that gave the largest decrease is dropped and replaced with the
difference between the current estimated x and the estimated x from the
beginning of the inner-loop.

The technical conditions for replacing the direction of greatest
increase amount to checking that

1. No further gain can be made along the direction of greatest increase
   from that iteration.
2. The direction of greatest increase accounted for a large sufficient
   fraction of the decrease in the function value from that iteration of
   the inner loop.

References
----------
Powell M.J.D. (1964) An efficient method for finding the minimum of a
function of several variables without calculating derivatives,
Computer Journal, 7 (2):155-162.

Press W., Teukolsky S.A., Vetterling W.T., and Flannery B.P.:
Numerical Recipes (any edition), Cambridge University Press

Examples
--------
>>> def f(x):
...     return x**2

>>> from scipy import optimize

>>> minimum = optimize.fmin_powell(f, -1)
Optimization terminated successfully.
         Current function value: 0.000000
         Iterations: 2
         Function evaluations: 16
>>> minimum
array(0.0)
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__optimize_8py_source_l03211}{3211}} of file \mbox{\hyperlink{__optimize_8py_source}{\+\_\+optimize.\+py}}.



References \mbox{\hyperlink{__optimize_8py_source_l03356}{\+\_\+minimize\+\_\+powell()}}, and \mbox{\hyperlink{__optimize_8py_source_l00135}{\+\_\+wrap\+\_\+callback()}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__optimize_a86c632088d14f5b42c1e17998149d676}\index{scipy.optimize.\_optimize@{scipy.optimize.\_optimize}!fminbound@{fminbound}}
\index{fminbound@{fminbound}!scipy.optimize.\_optimize@{scipy.optimize.\_optimize}}
\doxysubsubsection{\texorpdfstring{fminbound()}{fminbound()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__optimize_a86c632088d14f5b42c1e17998149d676} 
scipy.\+optimize.\+\_\+optimize.\+fminbound (\begin{DoxyParamCaption}\item[{}]{func}{, }\item[{}]{x1}{, }\item[{}]{x2}{, }\item[{}]{args}{ = {\ttfamily ()}, }\item[{}]{xtol}{ = {\ttfamily 1e-\/5}, }\item[{}]{maxfun}{ = {\ttfamily 500}, }\item[{}]{full\+\_\+output}{ = {\ttfamily 0}, }\item[{}]{disp}{ = {\ttfamily 1}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Bounded minimization for scalar functions.

Parameters
----------
func : callable f(x,*args)
    Objective function to be minimized (must accept and return scalars).
x1, x2 : float or array scalar
    Finite optimization bounds.
args : tuple, optional
    Extra arguments passed to function.
xtol : float, optional
    The convergence tolerance.
maxfun : int, optional
    Maximum number of function evaluations allowed.
full_output : bool, optional
    If True, return optional outputs.
disp : int, optional
    If non-zero, print messages.
        0 : no message printing.
        1 : non-convergence notification messages only.
        2 : print a message on convergence too.
        3 : print iteration results.


Returns
-------
xopt : ndarray
    Parameters (over given interval) which minimize the
    objective function.
fval : number
    (Optional output) The function value evaluated at the minimizer.
ierr : int
    (Optional output) An error flag (0 if converged, 1 if maximum number of
    function calls reached).
numfunc : int
    (Optional output) The number of function calls made.

See also
--------
minimize_scalar: Interface to minimization algorithms for scalar
    univariate functions. See the 'Bounded' `method` in particular.

Notes
-----
Finds a local minimizer of the scalar function `func` in the
interval x1 < xopt < x2 using Brent's method. (See `brent`
for auto-bracketing.)

References
----------
.. [1] Forsythe, G.E., M. A. Malcolm, and C. B. Moler. "Computer Methods
       for Mathematical Computations." Prentice-Hall Series in Automatic
       Computation 259 (1977).
.. [2] Brent, Richard P. Algorithms for Minimization Without Derivatives.
       Courier Corporation, 2013.

Examples
--------
`fminbound` finds the minimizer of the function in the given range.
The following examples illustrate this.

>>> from scipy import optimize
>>> def f(x):
...     return (x-1)**2
>>> minimizer = optimize.fminbound(f, -4, 4)
>>> minimizer
1.0
>>> minimum = f(minimizer)
>>> minimum
0.0
>>> res = optimize.fminbound(f, 3, 4, full_output=True)
>>> minimizer, fval, ierr, numfunc = res
>>> minimizer
3.000005960860986
>>> minimum = f(minimizer)
>>> minimum, fval
(4.000023843479476, 4.000023843479476)
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__optimize_8py_source_l02152}{2152}} of file \mbox{\hyperlink{__optimize_8py_source}{\+\_\+optimize.\+py}}.



References \mbox{\hyperlink{__optimize_8py_source_l02245}{\+\_\+minimize\+\_\+scalar\+\_\+bounded()}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__optimize_a4f74c3036679f7cddb38d24bb4ad22ee}\index{scipy.optimize.\_optimize@{scipy.optimize.\_optimize}!golden@{golden}}
\index{golden@{golden}!scipy.optimize.\_optimize@{scipy.optimize.\_optimize}}
\doxysubsubsection{\texorpdfstring{golden()}{golden()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__optimize_a4f74c3036679f7cddb38d24bb4ad22ee} 
scipy.\+optimize.\+\_\+optimize.\+golden (\begin{DoxyParamCaption}\item[{}]{func}{, }\item[{}]{args}{ = {\ttfamily ()}, }\item[{}]{brack}{ = {\ttfamily None}, }\item[{}]{tol}{ = {\ttfamily \+\_\+epsilon}, }\item[{}]{full\+\_\+output}{ = {\ttfamily 0}, }\item[{}]{maxiter}{ = {\ttfamily 5000}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the minimizer of a function of one variable using the golden section
method.

Given a function of one variable and a possible bracketing interval,
return a minimizer of the function isolated to a fractional precision of
tol.

Parameters
----------
func : callable func(x,*args)
    Objective function to minimize.
args : tuple, optional
    Additional arguments (if present), passed to func.
brack : tuple, optional
    Either a triple ``(xa, xb, xc)`` where ``xa < xb < xc`` and
    ``func(xb) < func(xa) and  func(xb) < func(xc)``, or a pair (xa, xb)
    to be used as initial points for a downhill bracket search (see
    `scipy.optimize.bracket`).
    The minimizer ``x`` will not necessarily satisfy ``xa <= x <= xb``.
tol : float, optional
    x tolerance stop criterion
full_output : bool, optional
    If True, return optional outputs.
maxiter : int
    Maximum number of iterations to perform.

Returns
-------
xmin : ndarray
    Optimum point.
fval : float
    (Optional output) Optimum function value.
funcalls : int
    (Optional output) Number of objective function evaluations made.

See also
--------
minimize_scalar: Interface to minimization algorithms for scalar
    univariate functions. See the 'Golden' `method` in particular.

Notes
-----
Uses analog of bisection method to decrease the bracketed
interval.

Examples
--------
We illustrate the behaviour of the function when `brack` is of
size 2 and 3, respectively. In the case where `brack` is of the
form (xa,xb), we can see for the given values, the output need
not necessarily lie in the range ``(xa, xb)``.

>>> def f(x):
...     return (x-1)**2

>>> from scipy import optimize

>>> minimizer = optimize.golden(f, brack=(1, 2))
>>> minimizer
1
>>> res = optimize.golden(f, brack=(-1, 0.5, 2), full_output=True)
>>> xmin, fval, funcalls = res
>>> f(xmin), fval
(9.925165290385052e-18, 9.925165290385052e-18)
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__optimize_8py_source_l02701}{2701}} of file \mbox{\hyperlink{__optimize_8py_source}{\+\_\+optimize.\+py}}.



References \mbox{\hyperlink{__optimize_8py_source_l02780}{\+\_\+minimize\+\_\+scalar\+\_\+golden()}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__optimize_a4617fe1820f4b4d06fd35f7530b5962e}\index{scipy.optimize.\_optimize@{scipy.optimize.\_optimize}!is\_finite\_scalar@{is\_finite\_scalar}}
\index{is\_finite\_scalar@{is\_finite\_scalar}!scipy.optimize.\_optimize@{scipy.optimize.\_optimize}}
\doxysubsubsection{\texorpdfstring{is\_finite\_scalar()}{is\_finite\_scalar()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__optimize_a4617fe1820f4b4d06fd35f7530b5962e} 
scipy.\+optimize.\+\_\+optimize.\+is\+\_\+finite\+\_\+scalar (\begin{DoxyParamCaption}\item[{}]{x}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Test whether `x` is either a finite scalar or a finite array scalar.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__optimize_8py_source_l00276}{276}} of file \mbox{\hyperlink{__optimize_8py_source}{\+\_\+optimize.\+py}}.



Referenced by \mbox{\hyperlink{__optimize_8py_source_l02245}{\+\_\+minimize\+\_\+scalar\+\_\+bounded()}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__optimize_a02e15f5b55789e1f63fd216733195454}\index{scipy.optimize.\_optimize@{scipy.optimize.\_optimize}!rosen@{rosen}}
\index{rosen@{rosen}!scipy.optimize.\_optimize@{scipy.optimize.\_optimize}}
\doxysubsubsection{\texorpdfstring{rosen()}{rosen()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__optimize_a02e15f5b55789e1f63fd216733195454} 
scipy.\+optimize.\+\_\+optimize.\+rosen (\begin{DoxyParamCaption}\item[{}]{x}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}The Rosenbrock function.

The function computed is::

    sum(100.0*(x[1:] - x[:-1]**2.0)**2.0 + (1 - x[:-1])**2.0)

Parameters
----------
x : array_like
    1-D array of points at which the Rosenbrock function is to be computed.

Returns
-------
f : float
    The value of the Rosenbrock function.

See Also
--------
rosen_der, rosen_hess, rosen_hess_prod

Examples
--------
>>> import numpy as np
>>> from scipy.optimize import rosen
>>> X = 0.1 * np.arange(10)
>>> rosen(X)
76.56

For higher-dimensional input ``rosen`` broadcasts.
In the following example, we use this to plot a 2D landscape.
Note that ``rosen_hess`` does not broadcast in this manner.

>>> import matplotlib.pyplot as plt
>>> from mpl_toolkits.mplot3d import Axes3D
>>> x = np.linspace(-1, 1, 50)
>>> X, Y = np.meshgrid(x, x)
>>> ax = plt.subplot(111, projection='3d')
>>> ax.plot_surface(X, Y, rosen([X, Y]))
>>> plt.show()
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__optimize_8py_source_l00412}{412}} of file \mbox{\hyperlink{__optimize_8py_source}{\+\_\+optimize.\+py}}.



Referenced by \mbox{\hyperlink{test____shgo_8py_source_l01014}{scipy.\+optimize.\+tests.\+test\+\_\+\+\_\+shgo.\+Test\+Shgo\+Failures.\+test\+\_\+6\+\_\+1\+\_\+lower\+\_\+known\+\_\+f\+\_\+min()}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__optimize_a54e7ddc9ff63c7eaa2b008492c9f7821}\index{scipy.optimize.\_optimize@{scipy.optimize.\_optimize}!rosen\_der@{rosen\_der}}
\index{rosen\_der@{rosen\_der}!scipy.optimize.\_optimize@{scipy.optimize.\_optimize}}
\doxysubsubsection{\texorpdfstring{rosen\_der()}{rosen\_der()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__optimize_a54e7ddc9ff63c7eaa2b008492c9f7821} 
scipy.\+optimize.\+\_\+optimize.\+rosen\+\_\+der (\begin{DoxyParamCaption}\item[{}]{x}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}The derivative (i.e. gradient) of the Rosenbrock function.

Parameters
----------
x : array_like
    1-D array of points at which the derivative is to be computed.

Returns
-------
rosen_der : (N,) ndarray
    The gradient of the Rosenbrock function at `x`.

See Also
--------
rosen, rosen_hess, rosen_hess_prod

Examples
--------
>>> import numpy as np
>>> from scipy.optimize import rosen_der
>>> X = 0.1 * np.arange(9)
>>> rosen_der(X)
array([ -2. ,  10.6,  15.6,  13.4,   6.4,  -3. , -12.4, -19.4,  62. ])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__optimize_8py_source_l00460}{460}} of file \mbox{\hyperlink{__optimize_8py_source}{\+\_\+optimize.\+py}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__optimize_aaab0b0f1af6a0025d1ea4ab30b6412b1}\index{scipy.optimize.\_optimize@{scipy.optimize.\_optimize}!rosen\_hess@{rosen\_hess}}
\index{rosen\_hess@{rosen\_hess}!scipy.optimize.\_optimize@{scipy.optimize.\_optimize}}
\doxysubsubsection{\texorpdfstring{rosen\_hess()}{rosen\_hess()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__optimize_aaab0b0f1af6a0025d1ea4ab30b6412b1} 
scipy.\+optimize.\+\_\+optimize.\+rosen\+\_\+hess (\begin{DoxyParamCaption}\item[{}]{x}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}The Hessian matrix of the Rosenbrock function.

Parameters
----------
x : array_like
    1-D array of points at which the Hessian matrix is to be computed.

Returns
-------
rosen_hess : ndarray
    The Hessian matrix of the Rosenbrock function at `x`.

See Also
--------
rosen, rosen_der, rosen_hess_prod

Examples
--------
>>> import numpy as np
>>> from scipy.optimize import rosen_hess
>>> X = 0.1 * np.arange(4)
>>> rosen_hess(X)
array([[-38.,   0.,   0.,   0.],
       [  0., 134., -40.,   0.],
       [  0., -40., 130., -80.],
       [  0.,   0., -80., 200.]])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__optimize_8py_source_l00499}{499}} of file \mbox{\hyperlink{__optimize_8py_source}{\+\_\+optimize.\+py}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__optimize_a531ebd72f83786f0ce75f3347ecb2449}\index{scipy.optimize.\_optimize@{scipy.optimize.\_optimize}!rosen\_hess\_prod@{rosen\_hess\_prod}}
\index{rosen\_hess\_prod@{rosen\_hess\_prod}!scipy.optimize.\_optimize@{scipy.optimize.\_optimize}}
\doxysubsubsection{\texorpdfstring{rosen\_hess\_prod()}{rosen\_hess\_prod()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__optimize_a531ebd72f83786f0ce75f3347ecb2449} 
scipy.\+optimize.\+\_\+optimize.\+rosen\+\_\+hess\+\_\+prod (\begin{DoxyParamCaption}\item[{}]{x}{, }\item[{}]{p}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Product of the Hessian matrix of the Rosenbrock function with a vector.

Parameters
----------
x : array_like
    1-D array of points at which the Hessian matrix is to be computed.
p : array_like
    1-D array, the vector to be multiplied by the Hessian matrix.

Returns
-------
rosen_hess_prod : ndarray
    The Hessian matrix of the Rosenbrock function at `x` multiplied
    by the vector `p`.

See Also
--------
rosen, rosen_der, rosen_hess

Examples
--------
>>> import numpy as np
>>> from scipy.optimize import rosen_hess_prod
>>> X = 0.1 * np.arange(9)
>>> p = 0.5 * np.arange(9)
>>> rosen_hess_prod(X, p)
array([  -0.,   27.,  -10.,  -95., -192., -265., -278., -195., -180.])
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__optimize_8py_source_l00539}{539}} of file \mbox{\hyperlink{__optimize_8py_source}{\+\_\+optimize.\+py}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__optimize_a50f7c818d44ee4c953b28bcddbc326f1}\index{scipy.optimize.\_optimize@{scipy.optimize.\_optimize}!show\_options@{show\_options}}
\index{show\_options@{show\_options}!scipy.optimize.\_optimize@{scipy.optimize.\_optimize}}
\doxysubsubsection{\texorpdfstring{show\_options()}{show\_options()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__optimize_a50f7c818d44ee4c953b28bcddbc326f1} 
scipy.\+optimize.\+\_\+optimize.\+show\+\_\+options (\begin{DoxyParamCaption}\item[{}]{solver}{ = {\ttfamily None}, }\item[{}]{method}{ = {\ttfamily None}, }\item[{}]{disp}{ = {\ttfamily \mbox{\hyperlink{classTrue}{True}}}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Show documentation for additional options of optimization solvers.

These are method-specific options that can be supplied through the
``options`` dict.

Parameters
----------
solver : str
    Type of optimization solver. One of 'minimize', 'minimize_scalar',
    'root', 'root_scalar', 'linprog', or 'quadratic_assignment'.
method : str, optional
    If not given, shows all methods of the specified solver. Otherwise,
    show only the options for the specified method. Valid values
    corresponds to methods' names of respective solver (e.g., 'BFGS' for
    'minimize').
disp : bool, optional
    Whether to print the result rather than returning it.

Returns
-------
text
    Either None (for disp=True) or the text string (disp=False)

Notes
-----
The solver-specific methods are:

`scipy.optimize.minimize`

- :ref:`Nelder-Mead <optimize.minimize-neldermead>`
- :ref:`Powell      <optimize.minimize-powell>`
- :ref:`CG          <optimize.minimize-cg>`
- :ref:`BFGS        <optimize.minimize-bfgs>`
- :ref:`Newton-CG   <optimize.minimize-newtoncg>`
- :ref:`L-BFGS-B    <optimize.minimize-lbfgsb>`
- :ref:`TNC         <optimize.minimize-tnc>`
- :ref:`COBYLA      <optimize.minimize-cobyla>`
- :ref:`SLSQP       <optimize.minimize-slsqp>`
- :ref:`dogleg      <optimize.minimize-dogleg>`
- :ref:`trust-ncg   <optimize.minimize-trustncg>`

`scipy.optimize.root`

- :ref:`hybr              <optimize.root-hybr>`
- :ref:`lm                <optimize.root-lm>`
- :ref:`broyden1          <optimize.root-broyden1>`
- :ref:`broyden2          <optimize.root-broyden2>`
- :ref:`anderson          <optimize.root-anderson>`
- :ref:`linearmixing      <optimize.root-linearmixing>`
- :ref:`diagbroyden       <optimize.root-diagbroyden>`
- :ref:`excitingmixing    <optimize.root-excitingmixing>`
- :ref:`krylov            <optimize.root-krylov>`
- :ref:`df-sane           <optimize.root-dfsane>`

`scipy.optimize.minimize_scalar`

- :ref:`brent       <optimize.minimize_scalar-brent>`
- :ref:`golden      <optimize.minimize_scalar-golden>`
- :ref:`bounded     <optimize.minimize_scalar-bounded>`

`scipy.optimize.root_scalar`

- :ref:`bisect  <optimize.root_scalar-bisect>`
- :ref:`brentq  <optimize.root_scalar-brentq>`
- :ref:`brenth  <optimize.root_scalar-brenth>`
- :ref:`ridder  <optimize.root_scalar-ridder>`
- :ref:`toms748 <optimize.root_scalar-toms748>`
- :ref:`newton  <optimize.root_scalar-newton>`
- :ref:`secant  <optimize.root_scalar-secant>`
- :ref:`halley  <optimize.root_scalar-halley>`

`scipy.optimize.linprog`

- :ref:`simplex           <optimize.linprog-simplex>`
- :ref:`interior-point    <optimize.linprog-interior-point>`
- :ref:`revised simplex   <optimize.linprog-revised_simplex>`
- :ref:`highs             <optimize.linprog-highs>`
- :ref:`highs-ds          <optimize.linprog-highs-ds>`
- :ref:`highs-ipm         <optimize.linprog-highs-ipm>`

`scipy.optimize.quadratic_assignment`

- :ref:`faq             <optimize.qap-faq>`
- :ref:`2opt            <optimize.qap-2opt>`

Examples
--------
We can print documentations of a solver in stdout:

>>> from scipy.optimize import show_options
>>> show_options(solver="minimize")
...

Specifying a method is possible:

>>> show_options(solver="minimize", method="Nelder-Mead")
...

We can also get the documentations as a string:

>>> show_options(solver="minimize", method="Nelder-Mead", disp=False)
Minimization of scalar function of one or more variables using the ...
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{__optimize_8py_source_l03890}{3890}} of file \mbox{\hyperlink{__optimize_8py_source}{\+\_\+optimize.\+py}}.



References \mbox{\hyperlink{__optimize_8py_source_l03890}{show\+\_\+options()}}.



Referenced by \mbox{\hyperlink{__optimize_8py_source_l03890}{show\+\_\+options()}}, and \mbox{\hyperlink{scipy_2optimize_2tests_2test__optimize_8py_source_l02814}{scipy.\+optimize.\+tests.\+test\+\_\+optimize.\+test\+\_\+equal\+\_\+bounds()}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__optimize_a77867a3f237b7be985c2947451714929}\index{scipy.optimize.\_optimize@{scipy.optimize.\_optimize}!vecnorm@{vecnorm}}
\index{vecnorm@{vecnorm}!scipy.optimize.\_optimize@{scipy.optimize.\_optimize}}
\doxysubsubsection{\texorpdfstring{vecnorm()}{vecnorm()}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__optimize_a77867a3f237b7be985c2947451714929} 
scipy.\+optimize.\+\_\+optimize.\+vecnorm (\begin{DoxyParamCaption}\item[{}]{x}{, }\item[{}]{ord}{ = {\ttfamily 2}}\end{DoxyParamCaption})}



Definition at line \mbox{\hyperlink{__optimize_8py_source_l00286}{286}} of file \mbox{\hyperlink{__optimize_8py_source}{\+\_\+optimize.\+py}}.



\doxysubsection{Variable Documentation}
\Hypertarget{namespacescipy_1_1optimize_1_1__optimize_af3153e808d5fbacc198a82d30996cd54}\index{scipy.optimize.\_optimize@{scipy.optimize.\_optimize}!\_\_all\_\_@{\_\_all\_\_}}
\index{\_\_all\_\_@{\_\_all\_\_}!scipy.optimize.\_optimize@{scipy.optimize.\_optimize}}
\doxysubsubsection{\texorpdfstring{\_\_all\_\_}{\_\_all\_\_}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__optimize_af3153e808d5fbacc198a82d30996cd54} 
list scipy.\+optimize.\+\_\+optimize.\+\_\+\+\_\+all\+\_\+\+\_\+\hspace{0.3cm}{\ttfamily [private]}}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ [\textcolor{stringliteral}{'fmin'},\ \textcolor{stringliteral}{'fmin\_powell'},\ \textcolor{stringliteral}{'fmin\_bfgs'},\ \textcolor{stringliteral}{'fmin\_ncg'},\ \textcolor{stringliteral}{'fmin\_cg'},}
\DoxyCodeLine{00002\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'fminbound'},\ \textcolor{stringliteral}{'brent'},\ \textcolor{stringliteral}{'golden'},\ \textcolor{stringliteral}{'bracket'},\ \textcolor{stringliteral}{'rosen'},\ \textcolor{stringliteral}{'rosen\_der'},}
\DoxyCodeLine{00003\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'rosen\_hess'},\ \textcolor{stringliteral}{'rosen\_hess\_prod'},\ \textcolor{stringliteral}{'brute'},\ \textcolor{stringliteral}{'approx\_fprime'},}
\DoxyCodeLine{00004\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'line\_search'},\ \textcolor{stringliteral}{'check\_grad'},\ \textcolor{stringliteral}{'OptimizeResult'},\ \textcolor{stringliteral}{'show\_options'},}
\DoxyCodeLine{00005\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'OptimizeWarning'}]}

\end{DoxyCode}


Definition at line \mbox{\hyperlink{__optimize_8py_source_l00020}{20}} of file \mbox{\hyperlink{__optimize_8py_source}{\+\_\+optimize.\+py}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__optimize_ad43750b63b6897a1d6566cda5afd327e}\index{scipy.optimize.\_optimize@{scipy.optimize.\_optimize}!\_\_docformat\_\_@{\_\_docformat\_\_}}
\index{\_\_docformat\_\_@{\_\_docformat\_\_}!scipy.optimize.\_optimize@{scipy.optimize.\_optimize}}
\doxysubsubsection{\texorpdfstring{\_\_docformat\_\_}{\_\_docformat\_\_}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__optimize_ad43750b63b6897a1d6566cda5afd327e} 
str scipy.\+optimize.\+\_\+optimize.\+\_\+\+\_\+docformat\+\_\+\+\_\+ = "{}restructuredtext en"{}\hspace{0.3cm}{\ttfamily [private]}}



Definition at line \mbox{\hyperlink{__optimize_8py_source_l00026}{26}} of file \mbox{\hyperlink{__optimize_8py_source}{\+\_\+optimize.\+py}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__optimize_a8c8bc7126a371e035fd8e52aff856d71}\index{scipy.optimize.\_optimize@{scipy.optimize.\_optimize}!\_epsilon@{\_epsilon}}
\index{\_epsilon@{\_epsilon}!scipy.optimize.\_optimize@{scipy.optimize.\_optimize}}
\doxysubsubsection{\texorpdfstring{\_epsilon}{\_epsilon}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__optimize_a8c8bc7126a371e035fd8e52aff856d71} 
scipy.\+optimize.\+\_\+optimize.\+\_\+epsilon = sqrt(np.\+finfo(float).eps)\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{__optimize_8py_source_l00283}{283}} of file \mbox{\hyperlink{__optimize_8py_source}{\+\_\+optimize.\+py}}.

\Hypertarget{namespacescipy_1_1optimize_1_1__optimize_a09a2252518464e5a38ff3fcffce3e3dc}\index{scipy.optimize.\_optimize@{scipy.optimize.\_optimize}!\_status\_message@{\_status\_message}}
\index{\_status\_message@{\_status\_message}!scipy.optimize.\_optimize@{scipy.optimize.\_optimize}}
\doxysubsubsection{\texorpdfstring{\_status\_message}{\_status\_message}}
{\footnotesize\ttfamily \label{namespacescipy_1_1optimize_1_1__optimize_a09a2252518464e5a38ff3fcffce3e3dc} 
dict scipy.\+optimize.\+\_\+optimize.\+\_\+status\+\_\+message\hspace{0.3cm}{\ttfamily [protected]}}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ \{\textcolor{stringliteral}{'success'}:\ \textcolor{stringliteral}{'Optimization\ terminated\ successfully.'},}
\DoxyCodeLine{00002\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'maxfev'}:\ \textcolor{stringliteral}{'Maximum\ number\ of\ function\ evaluations\ has\ '}}
\DoxyCodeLine{00003\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'been\ exceeded.'},}
\DoxyCodeLine{00004\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'maxiter'}:\ \textcolor{stringliteral}{'Maximum\ number\ of\ iterations\ has\ been\ '}}
\DoxyCodeLine{00005\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'exceeded.'},}
\DoxyCodeLine{00006\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'pr\_loss'}:\ \textcolor{stringliteral}{'Desired\ error\ not\ necessarily\ achieved\ due\ '}}
\DoxyCodeLine{00007\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'to\ precision\ loss.'},}
\DoxyCodeLine{00008\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'nan'}:\ \textcolor{stringliteral}{'NaN\ result\ encountered.'},}
\DoxyCodeLine{00009\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'out\_of\_bounds'}:\ \textcolor{stringliteral}{'The\ result\ is\ outside\ of\ the\ provided\ '}}
\DoxyCodeLine{00010\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'bounds.'}\}}

\end{DoxyCode}


Definition at line \mbox{\hyperlink{__optimize_8py_source_l00046}{46}} of file \mbox{\hyperlink{__optimize_8py_source}{\+\_\+optimize.\+py}}.

