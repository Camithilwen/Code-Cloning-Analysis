<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Code Cloning Analysis: scipy.linalg._basic Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Code Cloning Analysis
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d8/df3/namespacescipy_1_1linalg_1_1__basic.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">scipy.linalg._basic Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae1df65d9545835366e2b31a1fcff7243" id="r_ae1df65d9545835366e2b31a1fcff7243"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1df65d9545835366e2b31a1fcff7243">_solve_check</a> (n, info, lamch=None, rcond=None)</td></tr>
<tr class="separator:ae1df65d9545835366e2b31a1fcff7243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1556f2f4b542ddccc68f580395d6c110" id="r_a1556f2f4b542ddccc68f580395d6c110"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1556f2f4b542ddccc68f580395d6c110">solve</a> (a, b, lower=False, overwrite_a=False, overwrite_b=False, check_finite=<a class="el" href="../../d8/d0b/classTrue.html">True</a>, assume_a='gen', transposed=False)</td></tr>
<tr class="separator:a1556f2f4b542ddccc68f580395d6c110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ebf69aafbab343a582ea7441b8eebe1" id="r_a0ebf69aafbab343a582ea7441b8eebe1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ebf69aafbab343a582ea7441b8eebe1">solve_triangular</a> (a, b, trans=0, lower=False, unit_diagonal=False, overwrite_b=False, check_finite=<a class="el" href="../../d8/d0b/classTrue.html">True</a>)</td></tr>
<tr class="separator:a0ebf69aafbab343a582ea7441b8eebe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac02f4acec8b4e87fc786930661a61e9c" id="r_ac02f4acec8b4e87fc786930661a61e9c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac02f4acec8b4e87fc786930661a61e9c">solve_banded</a> (l_and_u, ab, b, overwrite_ab=False, overwrite_b=False, check_finite=<a class="el" href="../../d8/d0b/classTrue.html">True</a>)</td></tr>
<tr class="separator:ac02f4acec8b4e87fc786930661a61e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a424ac351c88519ec403e156cf825f" id="r_a80a424ac351c88519ec403e156cf825f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80a424ac351c88519ec403e156cf825f">solveh_banded</a> (ab, b, overwrite_ab=False, overwrite_b=False, lower=False, check_finite=<a class="el" href="../../d8/d0b/classTrue.html">True</a>)</td></tr>
<tr class="separator:a80a424ac351c88519ec403e156cf825f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa0a809357e4f6af2a1ca9252de7e89d" id="r_aaa0a809357e4f6af2a1ca9252de7e89d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa0a809357e4f6af2a1ca9252de7e89d">solve_toeplitz</a> (c_or_cr, b, check_finite=<a class="el" href="../../d8/d0b/classTrue.html">True</a>)</td></tr>
<tr class="separator:aaa0a809357e4f6af2a1ca9252de7e89d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab607415c7afb8cfd4e44d9c511539491" id="r_ab607415c7afb8cfd4e44d9c511539491"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab607415c7afb8cfd4e44d9c511539491">_get_axis_len</a> (aname, a, axis)</td></tr>
<tr class="separator:ab607415c7afb8cfd4e44d9c511539491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dcc964a58db08fcf7179c91657abb1e" id="r_a1dcc964a58db08fcf7179c91657abb1e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1dcc964a58db08fcf7179c91657abb1e">solve_circulant</a> (c, b, singular='raise', tol=None, caxis=-1, baxis=0, outaxis=0)</td></tr>
<tr class="separator:a1dcc964a58db08fcf7179c91657abb1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd1fe25cb9553c34356d69a8055f6c81" id="r_acd1fe25cb9553c34356d69a8055f6c81"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd1fe25cb9553c34356d69a8055f6c81">inv</a> (a, overwrite_a=False, check_finite=<a class="el" href="../../d8/d0b/classTrue.html">True</a>)</td></tr>
<tr class="separator:acd1fe25cb9553c34356d69a8055f6c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a64c16a907f334b37020c3db1af2a4" id="r_a16a64c16a907f334b37020c3db1af2a4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16a64c16a907f334b37020c3db1af2a4">det</a> (a, overwrite_a=False, check_finite=<a class="el" href="../../d8/d0b/classTrue.html">True</a>)</td></tr>
<tr class="separator:a16a64c16a907f334b37020c3db1af2a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae339af002324f7cb4bb893c90ef8bdd7" id="r_ae339af002324f7cb4bb893c90ef8bdd7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae339af002324f7cb4bb893c90ef8bdd7">lstsq</a> (a, b, cond=None, overwrite_a=False, overwrite_b=False, check_finite=<a class="el" href="../../d8/d0b/classTrue.html">True</a>, lapack_driver=None)</td></tr>
<tr class="separator:ae339af002324f7cb4bb893c90ef8bdd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97ec828515cdb5d103a6a188a5f20736" id="r_a97ec828515cdb5d103a6a188a5f20736"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97ec828515cdb5d103a6a188a5f20736">pinv</a> (a, atol=None, rtol=None, return_rank=False, check_finite=<a class="el" href="../../d8/d0b/classTrue.html">True</a>, cond=None, rcond=None)</td></tr>
<tr class="separator:a97ec828515cdb5d103a6a188a5f20736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a449efcf0d221ed1c60ad13680a1e7f17" id="r_a449efcf0d221ed1c60ad13680a1e7f17"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a449efcf0d221ed1c60ad13680a1e7f17">pinvh</a> (a, atol=None, rtol=None, lower=<a class="el" href="../../d8/d0b/classTrue.html">True</a>, return_rank=False, check_finite=<a class="el" href="../../d8/d0b/classTrue.html">True</a>)</td></tr>
<tr class="separator:a449efcf0d221ed1c60ad13680a1e7f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57bd21f408415af3c400d75e0dbe3b8e" id="r_a57bd21f408415af3c400d75e0dbe3b8e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57bd21f408415af3c400d75e0dbe3b8e">matrix_balance</a> (A, permute=<a class="el" href="../../d8/d0b/classTrue.html">True</a>, scale=<a class="el" href="../../d8/d0b/classTrue.html">True</a>, separate=False, overwrite_a=False)</td></tr>
<tr class="separator:a57bd21f408415af3c400d75e0dbe3b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6959880d7b5b5271effe39d19d780ac3" id="r_a6959880d7b5b5271effe39d19d780ac3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6959880d7b5b5271effe39d19d780ac3">_validate_args_for_toeplitz_ops</a> (c_or_cr, b, check_finite, keep_b_shape, enforce_square=<a class="el" href="../../d8/d0b/classTrue.html">True</a>)</td></tr>
<tr class="separator:a6959880d7b5b5271effe39d19d780ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5916cf56041809a8d8fc176c8a72038c" id="r_a5916cf56041809a8d8fc176c8a72038c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5916cf56041809a8d8fc176c8a72038c">matmul_toeplitz</a> (c_or_cr, x, check_finite=False, workers=None)</td></tr>
<tr class="separator:a5916cf56041809a8d8fc176c8a72038c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a9361f3c7ea298ff7f1db770ff5502683" id="r_a9361f3c7ea298ff7f1db770ff5502683"><td class="memItemLeft" align="right" valign="top">list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9361f3c7ea298ff7f1db770ff5502683">__all__</a></td></tr>
<tr class="separator:a9361f3c7ea298ff7f1db770ff5502683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173dda446ebdc35f737df7f1a8abb9bd" id="r_a173dda446ebdc35f737df7f1a8abb9bd"><td class="memItemLeft" align="right" valign="top">dict&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a173dda446ebdc35f737df7f1a8abb9bd">lapack_cast_dict</a></td></tr>
<tr class="separator:a173dda446ebdc35f737df7f1a8abb9bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86596f567fe32523d12b4fe39d115492" id="r_a86596f567fe32523d12b4fe39d115492"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86596f567fe32523d12b4fe39d115492">default_lapack_driver</a></td></tr>
<tr class="separator:a86596f567fe32523d12b4fe39d115492"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ab607415c7afb8cfd4e44d9c511539491" name="ab607415c7afb8cfd4e44d9c511539491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab607415c7afb8cfd4e44d9c511539491">&#9670;&#160;</a></span>_get_axis_len()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._basic._get_axis_len </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>aname</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>axis</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d6/dda/linalg_2__basic_8py_source.html#l00695">695</a> of file <a class="el" href="../../d6/dda/linalg_2__basic_8py_source.html">_basic.py</a>.</p>

</div>
</div>
<a id="ae1df65d9545835366e2b31a1fcff7243" name="ae1df65d9545835366e2b31a1fcff7243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1df65d9545835366e2b31a1fcff7243">&#9670;&#160;</a></span>_solve_check()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._basic._solve_check </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>info</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>lamch</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>rcond</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment"> Check arguments during the different steps of the solution phase </pre> 
<p class="definition">Definition at line <a class="el" href="../../d6/dda/linalg_2__basic_8py_source.html#l00035">35</a> of file <a class="el" href="../../d6/dda/linalg_2__basic_8py_source.html">_basic.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d6/dda/linalg_2__basic_8py_source.html#l00054">solve()</a>.</p>

</div>
</div>
<a id="a6959880d7b5b5271effe39d19d780ac3" name="a6959880d7b5b5271effe39d19d780ac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6959880d7b5b5271effe39d19d780ac3">&#9670;&#160;</a></span>_validate_args_for_toeplitz_ops()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._basic._validate_args_for_toeplitz_ops </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>c_or_cr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>check_finite</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>keep_b_shape</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>enforce_square</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d8/d0b/classTrue.html">True</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Validate arguments and format inputs for toeplitz functions

Parameters
----------
c_or_cr : array_like or tuple of (array_like, array_like)
    The vector ``c``, or a tuple of arrays (``c``, ``r``). Whatever the
    actual shape of ``c``, it will be converted to a 1-D array. If not
    supplied, ``r = conjugate(c)`` is assumed; in this case, if c[0] is
    real, the Toeplitz matrix is Hermitian. r[0] is ignored; the first row
    of the Toeplitz matrix is ``[c[0], r[1:]]``. Whatever the actual shape
    of ``r``, it will be converted to a 1-D array.
b : (M,) or (M, K) array_like
    Right-hand side in ``T x = b``.
check_finite : bool
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (result entirely NaNs) if the inputs do contain infinities or NaNs.
keep_b_shape : bool
    Whether to convert a (M,) dimensional b into a (M, 1) dimensional
    matrix.
enforce_square : bool, optional
    If True (default), this verifies that the Toeplitz matrix is square.

Returns
-------
r : array
    1d array corresponding to the first row of the Toeplitz matrix.
c: array
    1d array corresponding to the first column of the Toeplitz matrix.
b: array
    (M,), (M, 1) or (M, K) dimensional array, post validation,
    corresponding to ``b``.
dtype: numpy datatype
    ``dtype`` stores the datatype of ``r``, ``c`` and ``b``. If any of
    ``r``, ``c`` or ``b`` are complex, ``dtype`` is ``np.complex128``,
    otherwise, it is ``np.float``.
b_shape: tuple
    Shape of ``b`` after passing it through ``_asarray_validated``.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d6/dda/linalg_2__basic_8py_source.html#l01706">1706</a> of file <a class="el" href="../../d6/dda/linalg_2__basic_8py_source.html">_basic.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d6/dda/linalg_2__basic_8py_source.html#l01779">matmul_toeplitz()</a>, and <a class="el" href="../../d6/dda/linalg_2__basic_8py_source.html#l00604">solve_toeplitz()</a>.</p>

</div>
</div>
<a id="a16a64c16a907f334b37020c3db1af2a4" name="a16a64c16a907f334b37020c3db1af2a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16a64c16a907f334b37020c3db1af2a4">&#9670;&#160;</a></span>det()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._basic.det </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>overwrite_a</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>check_finite</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d8/d0b/classTrue.html">True</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the determinant of a matrix

The determinant is a scalar that is a function of the associated square
matrix coefficients. The determinant value is zero for singular matrices.

Parameters
----------
a : (..., M, M) array_like
    Input array to compute determinants for.
overwrite_a : bool, optional
    Allow overwriting data in a (may enhance performance).
check_finite : bool, optional
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
det : (...) float or complex
    Determinant of `a`. For stacked arrays, a scalar is returned for each
    (m, m) slice in the last two dimensions of the input. For example, an
    input of shape (p, q, m, m) will produce a result of shape (p, q). If
    all dimensions are 1 a scalar is returned regardless of ndim.

Notes
-----
The determinant is computed by performing an LU factorization of the
input with LAPACK routine 'getrf', and then calculating the product of
diagonal entries of the U factor.

Even the input array is single precision (float32 or complex64), the result
will be returned in double precision (float64 or complex128) to prevent
overflows.

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy import linalg
&gt;&gt;&gt; a = np.array([[1,2,3], [4,5,6], [7,8,9]])  # A singular matrix
&gt;&gt;&gt; linalg.det(a)
0.0
&gt;&gt;&gt; b = np.array([[0,2,3], [4,5,6], [7,8,9]])
&gt;&gt;&gt; linalg.det(b)
3.0
&gt;&gt;&gt; # An array with the shape (3, 2, 2, 2)
&gt;&gt;&gt; c = np.array([[[[1., 2.], [3., 4.]],
...                [[5., 6.], [7., 8.]]],
...               [[[9., 10.], [11., 12.]],
...                [[13., 14.], [15., 16.]]],
...               [[[17., 18.], [19., 20.]],
...                [[21., 22.], [23., 24.]]]])
&gt;&gt;&gt; linalg.det(c)  # The resulting shape is (3, 2)
array([[-2., -2.],
       [-2., -2.],
       [-2., -2.]])
&gt;&gt;&gt; linalg.det(c[0, 0])  # Confirm the (0, 0) slice, [[1, 2], [3, 4]]
-2.0
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d6/dda/linalg_2__basic_8py_source.html#l00981">981</a> of file <a class="el" href="../../d6/dda/linalg_2__basic_8py_source.html">_basic.py</a>.</p>

<p class="reference">References <a class="el" href="../../da/d34/scipy_2linalg_2__misc_8py_source.html#l00181">scipy.linalg._misc._datacopied()</a>.</p>

</div>
</div>
<a id="acd1fe25cb9553c34356d69a8055f6c81" name="acd1fe25cb9553c34356d69a8055f6c81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd1fe25cb9553c34356d69a8055f6c81">&#9670;&#160;</a></span>inv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._basic.inv </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>overwrite_a</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>check_finite</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d8/d0b/classTrue.html">True</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the inverse of a matrix.

Parameters
----------
a : array_like
    Square matrix to be inverted.
overwrite_a : bool, optional
    Discard data in `a` (may improve performance). Default is False.
check_finite : bool, optional
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
ainv : ndarray
    Inverse of the matrix `a`.

Raises
------
LinAlgError
    If `a` is singular.
ValueError
    If `a` is not square, or not 2D.

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy import linalg
&gt;&gt;&gt; a = np.array([[1., 2.], [3., 4.]])
&gt;&gt;&gt; linalg.inv(a)
array([[-2. ,  1. ],
       [ 1.5, -0.5]])
&gt;&gt;&gt; np.dot(a, linalg.inv(a))
array([[ 1.,  0.],
       [ 0.,  1.]])
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d6/dda/linalg_2__basic_8py_source.html#l00903">903</a> of file <a class="el" href="../../d6/dda/linalg_2__basic_8py_source.html">_basic.py</a>.</p>

<p class="reference">References <a class="el" href="../../d0/d0c/lapack_8py_source.html#l00979">scipy.linalg.lapack._compute_lwork()</a>, <a class="el" href="../../da/d34/scipy_2linalg_2__misc_8py_source.html#l00181">scipy.linalg._misc._datacopied()</a>, and <a class="el" href="../../d0/d0c/lapack_8py_source.html#l00882">scipy.linalg.lapack.get_lapack_funcs()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d3/dd9/__solvers_8py_source.html#l00221">scipy.linalg._solvers._solve_discrete_lyapunov_bilinear()</a>, <a class="el" href="../../d6/d8b/linalg_2__matfuncs_8py_source.html#l00739">scipy.linalg._matfuncs.signm()</a>, <a class="el" href="../../da/da6/test__lapack_8py_source.html#l01327">scipy.linalg.tests.test_lapack.test_pftri()</a>, and <a class="el" href="../../da/da6/test__lapack_8py_source.html#l02783">scipy.linalg.tests.test_lapack.test_ptsvx()</a>.</p>

</div>
</div>
<a id="ae339af002324f7cb4bb893c90ef8bdd7" name="ae339af002324f7cb4bb893c90ef8bdd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae339af002324f7cb4bb893c90ef8bdd7">&#9670;&#160;</a></span>lstsq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._basic.lstsq </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>cond</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>overwrite_a</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>overwrite_b</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>check_finite</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d8/d0b/classTrue.html">True</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>lapack_driver</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute least-squares solution to equation Ax = b.

Compute a vector x such that the 2-norm ``|b - A x|`` is minimized.

Parameters
----------
a : (M, N) array_like
    Left-hand side array
b : (M,) or (M, K) array_like
    Right hand side array
cond : float, optional
    Cutoff for 'small' singular values; used to determine effective
    rank of a. Singular values smaller than
    ``cond * largest_singular_value`` are considered zero.
overwrite_a : bool, optional
    Discard data in `a` (may enhance performance). Default is False.
overwrite_b : bool, optional
    Discard data in `b` (may enhance performance). Default is False.
check_finite : bool, optional
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.
lapack_driver : str, optional
    Which LAPACK driver is used to solve the least-squares problem.
    Options are ``'gelsd'``, ``'gelsy'``, ``'gelss'``. Default
    (``'gelsd'``) is a good choice.  However, ``'gelsy'`` can be slightly
    faster on many problems.  ``'gelss'`` was used historically.  It is
    generally slow but uses less memory.

    .. versionadded:: 0.17.0

Returns
-------
x : (N,) or (N, K) ndarray
    Least-squares solution.
residues : (K,) ndarray or float
    Square of the 2-norm for each column in ``b - a x``, if ``M &gt; N`` and
    ``ndim(A) == n`` (returns a scalar if ``b`` is 1-D). Otherwise a
    (0,)-shaped array is returned.
rank : int
    Effective rank of `a`.
s : (min(M, N),) ndarray or None
    Singular values of `a`. The condition number of ``a`` is
    ``s[0] / s[-1]``.

Raises
------
LinAlgError
    If computation does not converge.

ValueError
    When parameters are not compatible.

See Also
--------
scipy.optimize.nnls : linear least squares with non-negativity constraint

Notes
-----
When ``'gelsy'`` is used as a driver, `residues` is set to a (0,)-shaped
array and `s` is always ``None``.

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy.linalg import lstsq
&gt;&gt;&gt; import matplotlib.pyplot as plt

Suppose we have the following data:

&gt;&gt;&gt; x = np.array([1, 2.5, 3.5, 4, 5, 7, 8.5])
&gt;&gt;&gt; y = np.array([0.3, 1.1, 1.5, 2.0, 3.2, 6.6, 8.6])

We want to fit a quadratic polynomial of the form ``y = a + b*x**2``
to this data.  We first form the "design matrix" M, with a constant
column of 1s and a column containing ``x**2``:

&gt;&gt;&gt; M = x[:, np.newaxis]**[0, 2]
&gt;&gt;&gt; M
array([[  1.  ,   1.  ],
       [  1.  ,   6.25],
       [  1.  ,  12.25],
       [  1.  ,  16.  ],
       [  1.  ,  25.  ],
       [  1.  ,  49.  ],
       [  1.  ,  72.25]])

We want to find the least-squares solution to ``M.dot(p) = y``,
where ``p`` is a vector with length 2 that holds the parameters
``a`` and ``b``.

&gt;&gt;&gt; p, res, rnk, s = lstsq(M, y)
&gt;&gt;&gt; p
array([ 0.20925829,  0.12013861])

Plot the data and the fitted curve.

&gt;&gt;&gt; plt.plot(x, y, 'o', label='data')
&gt;&gt;&gt; xx = np.linspace(0, 9, 101)
&gt;&gt;&gt; yy = p[0] + p[1]*xx**2
&gt;&gt;&gt; plt.plot(xx, yy, label='least squares fit, $y = a + bx^2$')
&gt;&gt;&gt; plt.xlabel('x')
&gt;&gt;&gt; plt.ylabel('y')
&gt;&gt;&gt; plt.legend(framealpha=1, shadow=True)
&gt;&gt;&gt; plt.grid(alpha=0.25)
&gt;&gt;&gt; plt.show()
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d6/dda/linalg_2__basic_8py_source.html#l01113">1113</a> of file <a class="el" href="../../d6/dda/linalg_2__basic_8py_source.html">_basic.py</a>.</p>

<p class="reference">References <a class="el" href="../../d0/d0c/lapack_8py_source.html#l00979">scipy.linalg.lapack._compute_lwork()</a>, <a class="el" href="../../da/d34/scipy_2linalg_2__misc_8py_source.html#l00181">scipy.linalg._misc._datacopied()</a>, and <a class="el" href="../../d0/d0c/lapack_8py_source.html#l00882">scipy.linalg.lapack.get_lapack_funcs()</a>.</p>

</div>
</div>
<a id="a5916cf56041809a8d8fc176c8a72038c" name="a5916cf56041809a8d8fc176c8a72038c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5916cf56041809a8d8fc176c8a72038c">&#9670;&#160;</a></span>matmul_toeplitz()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._basic.matmul_toeplitz </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>c_or_cr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>check_finite</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>workers</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Efficient Toeplitz Matrix-Matrix Multiplication using FFT

This function returns the matrix multiplication between a Toeplitz
matrix and a dense matrix.

The Toeplitz matrix has constant diagonals, with c as its first column
and r as its first row. If r is not given, ``r == conjugate(c)`` is
assumed.

Parameters
----------
c_or_cr : array_like or tuple of (array_like, array_like)
    The vector ``c``, or a tuple of arrays (``c``, ``r``). Whatever the
    actual shape of ``c``, it will be converted to a 1-D array. If not
    supplied, ``r = conjugate(c)`` is assumed; in this case, if c[0] is
    real, the Toeplitz matrix is Hermitian. r[0] is ignored; the first row
    of the Toeplitz matrix is ``[c[0], r[1:]]``. Whatever the actual shape
    of ``r``, it will be converted to a 1-D array.
x : (M,) or (M, K) array_like
    Matrix with which to multiply.
check_finite : bool, optional
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (result entirely NaNs) if the inputs do contain infinities or NaNs.
workers : int, optional
    To pass to scipy.fft.fft and ifft. Maximum number of workers to use
    for parallel computation. If negative, the value wraps around from
    ``os.cpu_count()``. See scipy.fft.fft for more details.

Returns
-------
T @ x : (M,) or (M, K) ndarray
    The result of the matrix multiplication ``T @ x``. Shape of return
    matches shape of `x`.

See Also
--------
toeplitz : Toeplitz matrix
solve_toeplitz : Solve a Toeplitz system using Levinson Recursion

Notes
-----
The Toeplitz matrix is embedded in a circulant matrix and the FFT is used
to efficiently calculate the matrix-matrix product.

Because the computation is based on the FFT, integer inputs will
result in floating point outputs.  This is unlike NumPy's `matmul`,
which preserves the data type of the input.

This is partly based on the implementation that can be found in [1]_,
licensed under the MIT license. More information about the method can be
found in reference [2]_. References [3]_ and [4]_ have more reference
implementations in Python.

.. versionadded:: 1.6.0

References
----------
.. [1] Jacob R Gardner, Geoff Pleiss, David Bindel, Kilian
   Q Weinberger, Andrew Gordon Wilson, "GPyTorch: Blackbox Matrix-Matrix
   Gaussian Process Inference with GPU Acceleration" with contributions
   from Max Balandat and Ruihan Wu. Available online:
   https://github.com/cornellius-gp/gpytorch

.. [2] J. Demmel, P. Koev, and X. Li, "A Brief Survey of Direct Linear
   Solvers". In Z. Bai, J. Demmel, J. Dongarra, A. Ruhe, and H. van der
   Vorst, editors. Templates for the Solution of Algebraic Eigenvalue
   Problems: A Practical Guide. SIAM, Philadelphia, 2000. Available at:
   http://www.netlib.org/utk/people/JackDongarra/etemplates/node384.html

.. [3] R. Scheibler, E. Bezzam, I. Dokmanic, Pyroomacoustics: A Python
   package for audio room simulations and array processing algorithms,
   Proc. IEEE ICASSP, Calgary, CA, 2018.
   https://github.com/LCAV/pyroomacoustics/blob/pypi-release/
   pyroomacoustics/adaptive/util.py

.. [4] Marano S, Edwards B, Ferrari G and Fah D (2017), "Fitting
   Earthquake Spectra: Colored Noise and Incomplete Data", Bulletin of
   the Seismological Society of America., January, 2017. Vol. 107(1),
   pp. 276-291.

Examples
--------
Multiply the Toeplitz matrix T with matrix x::

        [ 1 -1 -2 -3]       [1 10]
    T = [ 3  1 -1 -2]   x = [2 11]
        [ 6  3  1 -1]       [2 11]
        [10  6  3  1]       [5 19]

To specify the Toeplitz matrix, only the first column and the first
row are needed.

&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; c = np.array([1, 3, 6, 10])    # First column of T
&gt;&gt;&gt; r = np.array([1, -1, -2, -3])  # First row of T
&gt;&gt;&gt; x = np.array([[1, 10], [2, 11], [2, 11], [5, 19]])

&gt;&gt;&gt; from scipy.linalg import toeplitz, matmul_toeplitz
&gt;&gt;&gt; matmul_toeplitz((c, r), x)
array([[-20., -80.],
       [ -7.,  -8.],
       [  9.,  85.],
       [ 33., 218.]])

Check the result by creating the full Toeplitz matrix and
multiplying it by ``x``.

&gt;&gt;&gt; toeplitz(c, r) @ x
array([[-20, -80],
       [ -7,  -8],
       [  9,  85],
       [ 33, 218]])

The full matrix is never formed explicitly, so this routine
is suitable for very large Toeplitz matrices.

&gt;&gt;&gt; n = 1000000
&gt;&gt;&gt; matmul_toeplitz([1] + [0]*(n-1), np.ones(n))
array([1., 1., 1., ..., 1., 1., 1.])
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d6/dda/linalg_2__basic_8py_source.html#l01779">1779</a> of file <a class="el" href="../../d6/dda/linalg_2__basic_8py_source.html">_basic.py</a>.</p>

<p class="reference">References <a class="el" href="../../d6/dda/linalg_2__basic_8py_source.html#l01707">_validate_args_for_toeplitz_ops()</a>.</p>

</div>
</div>
<a id="a57bd21f408415af3c400d75e0dbe3b8e" name="a57bd21f408415af3c400d75e0dbe3b8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57bd21f408415af3c400d75e0dbe3b8e">&#9670;&#160;</a></span>matrix_balance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._basic.matrix_balance </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>permute</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d8/d0b/classTrue.html">True</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>scale</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d8/d0b/classTrue.html">True</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>separate</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>overwrite_a</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute a diagonal similarity transformation for row/column balancing.

The balancing tries to equalize the row and column 1-norms by applying
a similarity transformation such that the magnitude variation of the
matrix entries is reflected to the scaling matrices.

Moreover, if enabled, the matrix is first permuted to isolate the upper
triangular parts of the matrix and, again if scaling is also enabled,
only the remaining subblocks are subjected to scaling.

The balanced matrix satisfies the following equality

.. math::

                    B = T^{-1} A T

The scaling coefficients are approximated to the nearest power of 2
to avoid round-off errors.

Parameters
----------
A : (n, n) array_like
    Square data matrix for the balancing.
permute : bool, optional
    The selector to define whether permutation of A is also performed
    prior to scaling.
scale : bool, optional
    The selector to turn on and off the scaling. If False, the matrix
    will not be scaled.
separate : bool, optional
    This switches from returning a full matrix of the transformation
    to a tuple of two separate 1-D permutation and scaling arrays.
overwrite_a : bool, optional
    This is passed to xGEBAL directly. Essentially, overwrites the result
    to the data. It might increase the space efficiency. See LAPACK manual
    for details. This is False by default.

Returns
-------
B : (n, n) ndarray
    Balanced matrix
T : (n, n) ndarray
    A possibly permuted diagonal matrix whose nonzero entries are
    integer powers of 2 to avoid numerical truncation errors.
scale, perm : (n,) ndarray
    If ``separate`` keyword is set to True then instead of the array
    ``T`` above, the scaling and the permutation vectors are given
    separately as a tuple without allocating the full array ``T``.

Notes
-----
This algorithm is particularly useful for eigenvalue and matrix
decompositions and in many cases it is already called by various
LAPACK routines.

The algorithm is based on the well-known technique of [1]_ and has
been modified to account for special cases. See [2]_ for details
which have been implemented since LAPACK v3.5.0. Before this version
there are corner cases where balancing can actually worsen the
conditioning. See [3]_ for such examples.

The code is a wrapper around LAPACK's xGEBAL routine family for matrix
balancing.

.. versionadded:: 0.19.0

References
----------
.. [1] B.N. Parlett and C. Reinsch, "Balancing a Matrix for
   Calculation of Eigenvalues and Eigenvectors", Numerische Mathematik,
   Vol.13(4), 1969, :doi:`10.1007/BF02165404`
.. [2] R. James, J. Langou, B.R. Lowery, "On matrix balancing and
   eigenvector computation", 2014, :arxiv:`1401.5766`
.. [3] D.S. Watkins. A case where balancing is harmful.
   Electron. Trans. Numer. Anal, Vol.23, 2006.

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy import linalg
&gt;&gt;&gt; x = np.array([[1,2,0], [9,1,0.01], [1,2,10*np.pi]])

&gt;&gt;&gt; y, permscale = linalg.matrix_balance(x)
&gt;&gt;&gt; np.abs(x).sum(axis=0) / np.abs(x).sum(axis=1)
array([ 3.66666667,  0.4995005 ,  0.91312162])

&gt;&gt;&gt; np.abs(y).sum(axis=0) / np.abs(y).sum(axis=1)
array([ 1.2       ,  1.27041742,  0.92658316])  # may vary

&gt;&gt;&gt; permscale  # only powers of 2 (0.5 == 2^(-1))
array([[  0.5,   0. ,  0. ],  # may vary
       [  0. ,   1. ,  0. ],
       [  0. ,   0. ,  1. ]])
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d6/dda/linalg_2__basic_8py_source.html#l01560">1560</a> of file <a class="el" href="../../d6/dda/linalg_2__basic_8py_source.html">_basic.py</a>.</p>

<p class="reference">References <a class="el" href="../../d0/d0c/lapack_8py_source.html#l00882">scipy.linalg.lapack.get_lapack_funcs()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d3/dd9/__solvers_8py_source.html#l00328">scipy.linalg._solvers.solve_continuous_are()</a>, and <a class="el" href="../../d3/dd9/__solvers_8py_source.html#l00533">scipy.linalg._solvers.solve_discrete_are()</a>.</p>

</div>
</div>
<a id="a97ec828515cdb5d103a6a188a5f20736" name="a97ec828515cdb5d103a6a188a5f20736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97ec828515cdb5d103a6a188a5f20736">&#9670;&#160;</a></span>pinv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._basic.pinv </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>atol</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>rtol</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>return_rank</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>check_finite</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d8/d0b/classTrue.html">True</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>cond</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>rcond</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the (Moore-Penrose) pseudo-inverse of a matrix.

Calculate a generalized inverse of a matrix using its
singular-value decomposition ``U @ S @ V`` in the economy mode and picking
up only the columns/rows that are associated with significant singular
values.

If ``s`` is the maximum singular value of ``a``, then the
significance cut-off value is determined by ``atol + rtol * s``. Any
singular value below this value is assumed insignificant.

Parameters
----------
a : (M, N) array_like
    Matrix to be pseudo-inverted.
atol : float, optional
    Absolute threshold term, default value is 0.

    .. versionadded:: 1.7.0

rtol : float, optional
    Relative threshold term, default value is ``max(M, N) * eps`` where
    ``eps`` is the machine precision value of the datatype of ``a``.

    .. versionadded:: 1.7.0

return_rank : bool, optional
    If True, return the effective rank of the matrix.
check_finite : bool, optional
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.
cond, rcond : float, optional
    In older versions, these values were meant to be used as ``atol`` with
    ``rtol=0``. If both were given ``rcond`` overwrote ``cond`` and hence
    the code was not correct. Thus using these are strongly discouraged and
    the tolerances above are recommended instead. In fact, if provided,
    atol, rtol takes precedence over these keywords.

    .. versionchanged:: 1.7.0
        Deprecated in favor of ``rtol`` and ``atol`` parameters above and
        will be removed in future versions of SciPy.

    .. versionchanged:: 1.3.0
        Previously the default cutoff value was just ``eps*f`` where ``f``
        was ``1e3`` for single precision and ``1e6`` for double precision.

Returns
-------
B : (N, M) ndarray
    The pseudo-inverse of matrix `a`.
rank : int
    The effective rank of the matrix. Returned if `return_rank` is True.

Raises
------
LinAlgError
    If SVD computation does not converge.

See Also
--------
pinvh : Moore-Penrose pseudoinverse of a hermititan matrix.

Notes
-----
If ``A`` is invertible then the Moore-Penrose pseudoinverse is exactly
the inverse of ``A`` [1]_. If ``A`` is not invertible then the
Moore-Penrose pseudoinverse computes the ``x`` solution to ``Ax = b`` such
that ``||Ax - b||`` is minimized [1]_.

References
----------
.. [1] Penrose, R. (1956). On best approximate solutions of linear matrix
       equations. Mathematical Proceedings of the Cambridge Philosophical
       Society, 52(1), 17-19. doi:10.1017/S0305004100030929

Examples
--------

Given an ``m x n`` matrix ``A`` and an ``n x m`` matrix ``B`` the four
Moore-Penrose conditions are:

1. ``ABA = A`` (``B`` is a generalized inverse of ``A``),
2. ``BAB = B`` (``A`` is a generalized inverse of ``B``),
3. ``(AB)* = AB`` (``AB`` is hermitian),
4. ``(BA)* = BA`` (``BA`` is hermitian) [1]_.

Here, ``A*`` denotes the conjugate transpose. The Moore-Penrose
pseudoinverse is a unique ``B`` that satisfies all four of these
conditions and exists for any ``A``. Note that, unlike the standard
matrix inverse, ``A`` does not have to be square or have
independant columns/rows.

As an example, we can calculate the Moore-Penrose pseudoinverse of a
random non-square matrix and verify it satisfies the four conditions.

&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy import linalg
&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; A = rng.standard_normal((9, 6))
&gt;&gt;&gt; B = linalg.pinv(A)
&gt;&gt;&gt; np.allclose(A @ B @ A, A)  # Condition 1
True
&gt;&gt;&gt; np.allclose(B @ A @ B, B)  # Condition 2
True
&gt;&gt;&gt; np.allclose((A @ B).conj().T, A @ B)  # Condition 3
True
&gt;&gt;&gt; np.allclose((B @ A).conj().T, B @ A)  # Condition 4
True
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d6/dda/linalg_2__basic_8py_source.html#l01319">1319</a> of file <a class="el" href="../../d6/dda/linalg_2__basic_8py_source.html">_basic.py</a>.</p>

</div>
</div>
<a id="a449efcf0d221ed1c60ad13680a1e7f17" name="a449efcf0d221ed1c60ad13680a1e7f17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a449efcf0d221ed1c60ad13680a1e7f17">&#9670;&#160;</a></span>pinvh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._basic.pinvh </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>atol</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>rtol</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>lower</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d8/d0b/classTrue.html">True</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>return_rank</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>check_finite</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d8/d0b/classTrue.html">True</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the (Moore-Penrose) pseudo-inverse of a Hermitian matrix.

Calculate a generalized inverse of a complex Hermitian/real symmetric
matrix using its eigenvalue decomposition and including all eigenvalues
with 'large' absolute value.

Parameters
----------
a : (N, N) array_like
    Real symmetric or complex hermetian matrix to be pseudo-inverted

atol : float, optional
    Absolute threshold term, default value is 0.

    .. versionadded:: 1.7.0

rtol : float, optional
    Relative threshold term, default value is ``N * eps`` where
    ``eps`` is the machine precision value of the datatype of ``a``.

    .. versionadded:: 1.7.0

lower : bool, optional
    Whether the pertinent array data is taken from the lower or upper
    triangle of `a`. (Default: lower)
return_rank : bool, optional
    If True, return the effective rank of the matrix.
check_finite : bool, optional
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
B : (N, N) ndarray
    The pseudo-inverse of matrix `a`.
rank : int
    The effective rank of the matrix.  Returned if `return_rank` is True.

Raises
------
LinAlgError
    If eigenvalue algorithm does not converge.

See Also
--------
pinv : Moore-Penrose pseudoinverse of a matrix.

Examples
--------

For a more detailed example see `pinv`.

&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy.linalg import pinvh
&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; a = rng.standard_normal((9, 6))
&gt;&gt;&gt; a = np.dot(a, a.T)
&gt;&gt;&gt; B = pinvh(a)
&gt;&gt;&gt; np.allclose(a, a @ B @ a)
True
&gt;&gt;&gt; np.allclose(B, B @ a @ B)
True
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d6/dda/linalg_2__basic_8py_source.html#l01467">1467</a> of file <a class="el" href="../../d6/dda/linalg_2__basic_8py_source.html">_basic.py</a>.</p>

</div>
</div>
<a id="a1556f2f4b542ddccc68f580395d6c110" name="a1556f2f4b542ddccc68f580395d6c110"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1556f2f4b542ddccc68f580395d6c110">&#9670;&#160;</a></span>solve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._basic.solve </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>lower</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>overwrite_a</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>overwrite_b</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>check_finite</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d8/d0b/classTrue.html">True</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>assume_a</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'gen'</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>transposed</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solves the linear equation set ``a @ x == b`` for the unknown ``x``
for square `a` matrix.

If the data matrix is known to be a particular type then supplying the
corresponding string to ``assume_a`` key chooses the dedicated solver.
The available options are

===================  ========
 generic matrix       'gen'
 symmetric            'sym'
 hermitian            'her'
 positive definite    'pos'
===================  ========

If omitted, ``'gen'`` is the default structure.

The datatype of the arrays define which solver is called regardless
of the values. In other words, even when the complex array entries have
precisely zero imaginary parts, the complex solver will be called based
on the data type of the array.

Parameters
----------
a : (N, N) array_like
    Square input data
b : (N, NRHS) array_like
    Input data for the right hand side.
lower : bool, default: False
    Ignored if ``assume_a == 'gen'`` (the default). If True, the
    calculation uses only the data in the lower triangle of `a`;
    entries above the diagonal are ignored. If False (default), the
    calculation uses only the data in the upper triangle of `a`; entries
    below the diagonal are ignored.
overwrite_a : bool, default: False
    Allow overwriting data in `a` (may enhance performance).
overwrite_b : bool, default: False
    Allow overwriting data in `b` (may enhance performance).
check_finite : bool, default: True
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.
assume_a : str, {'gen', 'sym', 'her', 'pos'}
    Valid entries are explained above.
transposed : bool, default: False
    If True, solve ``a.T @ x == b``. Raises `NotImplementedError`
    for complex `a`.

Returns
-------
x : (N, NRHS) ndarray
    The solution array.

Raises
------
ValueError
    If size mismatches detected or input a is not square.
LinAlgError
    If the matrix is singular.
LinAlgWarning
    If an ill-conditioned input a is detected.
NotImplementedError
    If transposed is True and input a is a complex matrix.

Notes
-----
If the input b matrix is a 1-D array with N elements, when supplied
together with an NxN input a, it is assumed as a valid column vector
despite the apparent size mismatch. This is compatible with the
numpy.dot() behavior and the returned result is still 1-D array.

The generic, symmetric, Hermitian and positive definite solutions are
obtained via calling ?GESV, ?SYSV, ?HESV, and ?POSV routines of
LAPACK respectively.

Examples
--------
Given `a` and `b`, solve for `x`:

&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; a = np.array([[3, 2, 0], [1, -1, 0], [0, 5, 1]])
&gt;&gt;&gt; b = np.array([2, 4, -1])
&gt;&gt;&gt; from scipy import linalg
&gt;&gt;&gt; x = linalg.solve(a, b)
&gt;&gt;&gt; x
array([ 2., -2.,  9.])
&gt;&gt;&gt; np.dot(a, x) == b
array([ True,  True,  True], dtype=bool)
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d6/dda/linalg_2__basic_8py_source.html#l00052">52</a> of file <a class="el" href="../../d6/dda/linalg_2__basic_8py_source.html">_basic.py</a>.</p>

<p class="reference">References <a class="el" href="../../d0/d0c/lapack_8py_source.html#l00979">scipy.linalg.lapack._compute_lwork()</a>, <a class="el" href="../../da/d34/scipy_2linalg_2__misc_8py_source.html#l00181">scipy.linalg._misc._datacopied()</a>, <a class="el" href="../../d6/dda/linalg_2__basic_8py_source.html#l00035">_solve_check()</a>, and <a class="el" href="../../d0/d0c/lapack_8py_source.html#l00882">scipy.linalg.lapack.get_lapack_funcs()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d3/dd9/__solvers_8py_source.html#l00206">scipy.linalg._solvers._solve_discrete_lyapunov_direct()</a>, <a class="el" href="../../d6/d8b/linalg_2__matfuncs_8py_source.html#l00595">scipy.linalg._matfuncs.tanhm()</a>, <a class="el" href="../../d6/d8b/linalg_2__matfuncs_8py_source.html#l00478">scipy.linalg._matfuncs.tanm()</a>, <a class="el" href="../../da/da6/test__lapack_8py_source.html#l01359">scipy.linalg.tests.test_lapack.test_pftrs()</a>, <a class="el" href="../../da/da6/test__lapack_8py_source.html#l02783">scipy.linalg.tests.test_lapack.test_ptsvx()</a>, and <a class="el" href="../../da/da6/test__lapack_8py_source.html#l01102">scipy.linalg.tests.test_lapack.test_tfsm()</a>.</p>

</div>
</div>
<a id="ac02f4acec8b4e87fc786930661a61e9c" name="ac02f4acec8b4e87fc786930661a61e9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac02f4acec8b4e87fc786930661a61e9c">&#9670;&#160;</a></span>solve_banded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._basic.solve_banded </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>l_and_u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>ab</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>overwrite_ab</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>overwrite_b</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>check_finite</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d8/d0b/classTrue.html">True</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solve the equation a x = b for x, assuming a is banded matrix.

The matrix a is stored in `ab` using the matrix diagonal ordered form::

    ab[u + i - j, j] == a[i,j]

Example of `ab` (shape of a is (6,6), `u` =1, `l` =2)::

    *    a01  a12  a23  a34  a45
    a00  a11  a22  a33  a44  a55
    a10  a21  a32  a43  a54   *
    a20  a31  a42  a53   *    *

Parameters
----------
(l, u) : (integer, integer)
    Number of non-zero lower and upper diagonals
ab : (`l` + `u` + 1, M) array_like
    Banded matrix
b : (M,) or (M, K) array_like
    Right-hand side
overwrite_ab : bool, optional
    Discard data in `ab` (may enhance performance)
overwrite_b : bool, optional
    Discard data in `b` (may enhance performance)
check_finite : bool, optional
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
x : (M,) or (M, K) ndarray
    The solution to the system a x = b. Returned shape depends on the
    shape of `b`.

Examples
--------
Solve the banded system a x = b, where::

        [5  2 -1  0  0]       [0]
        [1  4  2 -1  0]       [1]
    a = [0  1  3  2 -1]   b = [2]
        [0  0  1  2  2]       [2]
        [0  0  0  1  1]       [3]

There is one nonzero diagonal below the main diagonal (l = 1), and
two above (u = 2). The diagonal banded form of the matrix is::

         [*  * -1 -1 -1]
    ab = [*  2  2  2  2]
         [5  4  3  2  1]
         [1  1  1  1  *]

&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy.linalg import solve_banded
&gt;&gt;&gt; ab = np.array([[0,  0, -1, -1, -1],
...                [0,  2,  2,  2,  2],
...                [5,  4,  3,  2,  1],
...                [1,  1,  1,  1,  0]])
&gt;&gt;&gt; b = np.array([0, 1, 2, 2, 3])
&gt;&gt;&gt; x = solve_banded((1, 2), ab, b)
&gt;&gt;&gt; x
array([-2.37288136,  3.93220339, -4.        ,  4.3559322 , -1.3559322 ])
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d6/dda/linalg_2__basic_8py_source.html#l00362">362</a> of file <a class="el" href="../../d6/dda/linalg_2__basic_8py_source.html">_basic.py</a>.</p>

<p class="reference">References <a class="el" href="../../da/d34/scipy_2linalg_2__misc_8py_source.html#l00181">scipy.linalg._misc._datacopied()</a>, and <a class="el" href="../../d0/d0c/lapack_8py_source.html#l00882">scipy.linalg.lapack.get_lapack_funcs()</a>.</p>

</div>
</div>
<a id="a1dcc964a58db08fcf7179c91657abb1e" name="a1dcc964a58db08fcf7179c91657abb1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dcc964a58db08fcf7179c91657abb1e">&#9670;&#160;</a></span>solve_circulant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._basic.solve_circulant </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>singular</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'raise'</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>tol</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>caxis</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>baxis</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>outaxis</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solve C x = b for x, where C is a circulant matrix.

`C` is the circulant matrix associated with the vector `c`.

The system is solved by doing division in Fourier space. The
calculation is::

    x = ifft(fft(b) / fft(c))

where `fft` and `ifft` are the fast Fourier transform and its inverse,
respectively. For a large vector `c`, this is *much* faster than
solving the system with the full circulant matrix.

Parameters
----------
c : array_like
    The coefficients of the circulant matrix.
b : array_like
    Right-hand side matrix in ``a x = b``.
singular : str, optional
    This argument controls how a near singular circulant matrix is
    handled.  If `singular` is "raise" and the circulant matrix is
    near singular, a `LinAlgError` is raised. If `singular` is
    "lstsq", the least squares solution is returned. Default is "raise".
tol : float, optional
    If any eigenvalue of the circulant matrix has an absolute value
    that is less than or equal to `tol`, the matrix is considered to be
    near singular. If not given, `tol` is set to::

        tol = abs_eigs.max() * abs_eigs.size * np.finfo(np.float64).eps

    where `abs_eigs` is the array of absolute values of the eigenvalues
    of the circulant matrix.
caxis : int
    When `c` has dimension greater than 1, it is viewed as a collection
    of circulant vectors. In this case, `caxis` is the axis of `c` that
    holds the vectors of circulant coefficients.
baxis : int
    When `b` has dimension greater than 1, it is viewed as a collection
    of vectors. In this case, `baxis` is the axis of `b` that holds the
    right-hand side vectors.
outaxis : int
    When `c` or `b` are multidimensional, the value returned by
    `solve_circulant` is multidimensional. In this case, `outaxis` is
    the axis of the result that holds the solution vectors.

Returns
-------
x : ndarray
    Solution to the system ``C x = b``.

Raises
------
LinAlgError
    If the circulant matrix associated with `c` is near singular.

See Also
--------
circulant : circulant matrix

Notes
-----
For a 1-D vector `c` with length `m`, and an array `b`
with shape ``(m, ...)``,

    solve_circulant(c, b)

returns the same result as

    solve(circulant(c), b)

where `solve` and `circulant` are from `scipy.linalg`.

.. versionadded:: 0.16.0

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy.linalg import solve_circulant, solve, circulant, lstsq

&gt;&gt;&gt; c = np.array([2, 2, 4])
&gt;&gt;&gt; b = np.array([1, 2, 3])
&gt;&gt;&gt; solve_circulant(c, b)
array([ 0.75, -0.25,  0.25])

Compare that result to solving the system with `scipy.linalg.solve`:

&gt;&gt;&gt; solve(circulant(c), b)
array([ 0.75, -0.25,  0.25])

A singular example:

&gt;&gt;&gt; c = np.array([1, 1, 0, 0])
&gt;&gt;&gt; b = np.array([1, 2, 3, 4])

Calling ``solve_circulant(c, b)`` will raise a `LinAlgError`.  For the
least square solution, use the option ``singular='lstsq'``:

&gt;&gt;&gt; solve_circulant(c, b, singular='lstsq')
array([ 0.25,  1.25,  2.25,  1.25])

Compare to `scipy.linalg.lstsq`:

&gt;&gt;&gt; x, resid, rnk, s = lstsq(circulant(c), b)
&gt;&gt;&gt; x
array([ 0.25,  1.25,  2.25,  1.25])

A broadcasting example:

Suppose we have the vectors of two circulant matrices stored in an array
with shape (2, 5), and three `b` vectors stored in an array with shape
(3, 5).  For example,

&gt;&gt;&gt; c = np.array([[1.5, 2, 3, 0, 0], [1, 1, 4, 3, 2]])
&gt;&gt;&gt; b = np.arange(15).reshape(-1, 5)

We want to solve all combinations of circulant matrices and `b` vectors,
with the result stored in an array with shape (2, 3, 5). When we
disregard the axes of `c` and `b` that hold the vectors of coefficients,
the shapes of the collections are (2,) and (3,), respectively, which are
not compatible for broadcasting. To have a broadcast result with shape
(2, 3), we add a trivial dimension to `c`: ``c[:, np.newaxis, :]`` has
shape (2, 1, 5). The last dimension holds the coefficients of the
circulant matrices, so when we call `solve_circulant`, we can use the
default ``caxis=-1``. The coefficients of the `b` vectors are in the last
dimension of the array `b`, so we use ``baxis=-1``. If we use the
default `outaxis`, the result will have shape (5, 2, 3), so we'll use
``outaxis=-1`` to put the solution vectors in the last dimension.

&gt;&gt;&gt; x = solve_circulant(c[:, np.newaxis, :], b, baxis=-1, outaxis=-1)
&gt;&gt;&gt; x.shape
(2, 3, 5)
&gt;&gt;&gt; np.set_printoptions(precision=3)  # For compact output of numbers.
&gt;&gt;&gt; x
array([[[-0.118,  0.22 ,  1.277, -0.142,  0.302],
        [ 0.651,  0.989,  2.046,  0.627,  1.072],
        [ 1.42 ,  1.758,  2.816,  1.396,  1.841]],
       [[ 0.401,  0.304,  0.694, -0.867,  0.377],
        [ 0.856,  0.758,  1.149, -0.412,  0.831],
        [ 1.31 ,  1.213,  1.603,  0.042,  1.286]]])

Check by solving one pair of `c` and `b` vectors (cf. ``x[1, 1, :]``):

&gt;&gt;&gt; solve_circulant(c[1], b[1, :])
array([ 0.856,  0.758,  1.149, -0.412,  0.831])
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d6/dda/linalg_2__basic_8py_source.html#l00704">704</a> of file <a class="el" href="../../d6/dda/linalg_2__basic_8py_source.html">_basic.py</a>.</p>

</div>
</div>
<a id="aaa0a809357e4f6af2a1ca9252de7e89d" name="aaa0a809357e4f6af2a1ca9252de7e89d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa0a809357e4f6af2a1ca9252de7e89d">&#9670;&#160;</a></span>solve_toeplitz()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._basic.solve_toeplitz </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>c_or_cr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>check_finite</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d8/d0b/classTrue.html">True</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solve a Toeplitz system using Levinson Recursion

The Toeplitz matrix has constant diagonals, with c as its first column
and r as its first row. If r is not given, ``r == conjugate(c)`` is
assumed.

Parameters
----------
c_or_cr : array_like or tuple of (array_like, array_like)
    The vector ``c``, or a tuple of arrays (``c``, ``r``). Whatever the
    actual shape of ``c``, it will be converted to a 1-D array. If not
    supplied, ``r = conjugate(c)`` is assumed; in this case, if c[0] is
    real, the Toeplitz matrix is Hermitian. r[0] is ignored; the first row
    of the Toeplitz matrix is ``[c[0], r[1:]]``. Whatever the actual shape
    of ``r``, it will be converted to a 1-D array.
b : (M,) or (M, K) array_like
    Right-hand side in ``T x = b``.
check_finite : bool, optional
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (result entirely NaNs) if the inputs do contain infinities or NaNs.

Returns
-------
x : (M,) or (M, K) ndarray
    The solution to the system ``T x = b``. Shape of return matches shape
    of `b`.

See Also
--------
toeplitz : Toeplitz matrix

Notes
-----
The solution is computed using Levinson-Durbin recursion, which is faster
than generic least-squares methods, but can be less numerically stable.

Examples
--------
Solve the Toeplitz system T x = b, where::

        [ 1 -1 -2 -3]       [1]
    T = [ 3  1 -1 -2]   b = [2]
        [ 6  3  1 -1]       [2]
        [10  6  3  1]       [5]

To specify the Toeplitz matrix, only the first column and the first
row are needed.

&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; c = np.array([1, 3, 6, 10])    # First column of T
&gt;&gt;&gt; r = np.array([1, -1, -2, -3])  # First row of T
&gt;&gt;&gt; b = np.array([1, 2, 2, 5])

&gt;&gt;&gt; from scipy.linalg import solve_toeplitz, toeplitz
&gt;&gt;&gt; x = solve_toeplitz((c, r), b)
&gt;&gt;&gt; x
array([ 1.66666667, -1.        , -2.66666667,  2.33333333])

Check the result by creating the full Toeplitz matrix and
multiplying it by `x`.  We should get `b`.

&gt;&gt;&gt; T = toeplitz(c, r)
&gt;&gt;&gt; T.dot(x)
array([ 1.,  2.,  2.,  5.])
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d6/dda/linalg_2__basic_8py_source.html#l00604">604</a> of file <a class="el" href="../../d6/dda/linalg_2__basic_8py_source.html">_basic.py</a>.</p>

<p class="reference">References <a class="el" href="../../d6/dda/linalg_2__basic_8py_source.html#l01707">_validate_args_for_toeplitz_ops()</a>.</p>

</div>
</div>
<a id="a0ebf69aafbab343a582ea7441b8eebe1" name="a0ebf69aafbab343a582ea7441b8eebe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ebf69aafbab343a582ea7441b8eebe1">&#9670;&#160;</a></span>solve_triangular()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._basic.solve_triangular </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>trans</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>lower</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>unit_diagonal</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>overwrite_b</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>check_finite</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d8/d0b/classTrue.html">True</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solve the equation `a x = b` for `x`, assuming a is a triangular matrix.

Parameters
----------
a : (M, M) array_like
    A triangular matrix
b : (M,) or (M, N) array_like
    Right-hand side matrix in `a x = b`
lower : bool, optional
    Use only data contained in the lower triangle of `a`.
    Default is to use upper triangle.
trans : {0, 1, 2, 'N', 'T', 'C'}, optional
    Type of system to solve:

    ========  =========
    trans     system
    ========  =========
    0 or 'N'  a x  = b
    1 or 'T'  a^T x = b
    2 or 'C'  a^H x = b
    ========  =========
unit_diagonal : bool, optional
    If True, diagonal elements of `a` are assumed to be 1 and
    will not be referenced.
overwrite_b : bool, optional
    Allow overwriting data in `b` (may enhance performance)
check_finite : bool, optional
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
x : (M,) or (M, N) ndarray
    Solution to the system `a x = b`.  Shape of return matches `b`.

Raises
------
LinAlgError
    If `a` is singular

Notes
-----
.. versionadded:: 0.9.0

Examples
--------
Solve the lower triangular system a x = b, where::

         [3  0  0  0]       [4]
    a =  [2  1  0  0]   b = [2]
         [1  0  1  0]       [4]
         [1  1  1  1]       [2]

&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy.linalg import solve_triangular
&gt;&gt;&gt; a = np.array([[3, 0, 0, 0], [2, 1, 0, 0], [1, 0, 1, 0], [1, 1, 1, 1]])
&gt;&gt;&gt; b = np.array([4, 2, 4, 2])
&gt;&gt;&gt; x = solve_triangular(a, b, lower=True)
&gt;&gt;&gt; x
array([ 1.33333333, -0.66666667,  2.66666667, -1.33333333])
&gt;&gt;&gt; a.dot(x)  # Check the result
array([ 4.,  2.,  4.,  2.])
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d6/dda/linalg_2__basic_8py_source.html#l00265">265</a> of file <a class="el" href="../../d6/dda/linalg_2__basic_8py_source.html">_basic.py</a>.</p>

<p class="reference">References <a class="el" href="../../da/d34/scipy_2linalg_2__misc_8py_source.html#l00181">scipy.linalg._misc._datacopied()</a>, and <a class="el" href="../../d0/d0c/lapack_8py_source.html#l00882">scipy.linalg.lapack.get_lapack_funcs()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d6/db8/__matfuncs__inv__ssq_8py_source.html#l00467">scipy.linalg._matfuncs_inv_ssq._fractional_power_pade()</a>, <a class="el" href="../../d6/db8/__matfuncs__inv__ssq_8py_source.html#l00721">scipy.linalg._matfuncs_inv_ssq._logm_triu()</a>, <a class="el" href="../../d3/dd9/__solvers_8py_source.html#l00328">scipy.linalg._solvers.solve_continuous_are()</a>, <a class="el" href="../../d3/dd9/__solvers_8py_source.html#l00533">scipy.linalg._solvers.solve_discrete_are()</a>, <a class="el" href="../../db/df6/scipy_2linalg_2tests_2test__basic_8py_source.html#l00878">scipy.linalg.tests.test_basic.TestSolveTriangular.test_check_finite()</a>, <a class="el" href="../../db/df6/scipy_2linalg_2tests_2test__basic_8py_source.html#l00828">scipy.linalg.tests.test_basic.TestSolveTriangular.test_simple()</a>, and <a class="el" href="../../db/df6/scipy_2linalg_2tests_2test__basic_8py_source.html#l00849">scipy.linalg.tests.test_basic.TestSolveTriangular.test_simple_complex()</a>.</p>

</div>
</div>
<a id="a80a424ac351c88519ec403e156cf825f" name="a80a424ac351c88519ec403e156cf825f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80a424ac351c88519ec403e156cf825f">&#9670;&#160;</a></span>solveh_banded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._basic.solveh_banded </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>ab</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>overwrite_ab</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>overwrite_b</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>lower</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>check_finite</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d8/d0b/classTrue.html">True</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solve equation a x = b. a is Hermitian positive-definite banded matrix.

Uses Thomas' Algorithm, which is more efficient than standard LU
factorization, but should only be used for Hermitian positive-definite
matrices.

The matrix ``a`` is stored in `ab` either in lower diagonal or upper
diagonal ordered form:

    ab[u + i - j, j] == a[i,j]        (if upper form; i &lt;= j)
    ab[    i - j, j] == a[i,j]        (if lower form; i &gt;= j)

Example of `ab` (shape of ``a`` is (6, 6), number of upper diagonals,
``u`` =2)::

    upper form:
    *   *   a02 a13 a24 a35
    *   a01 a12 a23 a34 a45
    a00 a11 a22 a33 a44 a55

    lower form:
    a00 a11 a22 a33 a44 a55
    a10 a21 a32 a43 a54 *
    a20 a31 a42 a53 *   *

Cells marked with * are not used.

Parameters
----------
ab : (``u`` + 1, M) array_like
    Banded matrix
b : (M,) or (M, K) array_like
    Right-hand side
overwrite_ab : bool, optional
    Discard data in `ab` (may enhance performance)
overwrite_b : bool, optional
    Discard data in `b` (may enhance performance)
lower : bool, optional
    Is the matrix in the lower form. (Default is upper form)
check_finite : bool, optional
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
x : (M,) or (M, K) ndarray
    The solution to the system ``a x = b``. Shape of return matches shape
    of `b`.

Notes
-----
In the case of a non-positive definite matrix ``a``, the solver
`solve_banded` may be used.

Examples
--------
Solve the banded system ``A x = b``, where::

        [ 4  2 -1  0  0  0]       [1]
        [ 2  5  2 -1  0  0]       [2]
    A = [-1  2  6  2 -1  0]   b = [2]
        [ 0 -1  2  7  2 -1]       [3]
        [ 0  0 -1  2  8  2]       [3]
        [ 0  0  0 -1  2  9]       [3]

&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy.linalg import solveh_banded

``ab`` contains the main diagonal and the nonzero diagonals below the
main diagonal. That is, we use the lower form:

&gt;&gt;&gt; ab = np.array([[ 4,  5,  6,  7, 8, 9],
...                [ 2,  2,  2,  2, 2, 0],
...                [-1, -1, -1, -1, 0, 0]])
&gt;&gt;&gt; b = np.array([1, 2, 2, 3, 3, 3])
&gt;&gt;&gt; x = solveh_banded(ab, b, lower=True)
&gt;&gt;&gt; x
array([ 0.03431373,  0.45938375,  0.05602241,  0.47759104,  0.17577031,
        0.34733894])


Solve the Hermitian banded system ``H x = b``, where::

        [ 8   2-1j   0     0  ]        [ 1  ]
    H = [2+1j  5     1j    0  ]    b = [1+1j]
        [ 0   -1j    9   -2-1j]        [1-2j]
        [ 0    0   -2+1j   6  ]        [ 0  ]

In this example, we put the upper diagonals in the array ``hb``:

&gt;&gt;&gt; hb = np.array([[0, 2-1j, 1j, -2-1j],
...                [8,  5,    9,   6  ]])
&gt;&gt;&gt; b = np.array([1, 1+1j, 1-2j, 0])
&gt;&gt;&gt; x = solveh_banded(hb, b)
&gt;&gt;&gt; x
array([ 0.07318536-0.02939412j,  0.11877624+0.17696461j,
        0.10077984-0.23035393j, -0.00479904-0.09358128j])
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d6/dda/linalg_2__basic_8py_source.html#l00470">470</a> of file <a class="el" href="../../d6/dda/linalg_2__basic_8py_source.html">_basic.py</a>.</p>

<p class="reference">References <a class="el" href="../../da/d34/scipy_2linalg_2__misc_8py_source.html#l00181">scipy.linalg._misc._datacopied()</a>, and <a class="el" href="../../d0/d0c/lapack_8py_source.html#l00882">scipy.linalg.lapack.get_lapack_funcs()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a9361f3c7ea298ff7f1db770ff5502683" name="a9361f3c7ea298ff7f1db770ff5502683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9361f3c7ea298ff7f1db770ff5502683">&#9670;&#160;</a></span>__all__</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">list scipy.linalg._basic.__all__</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  [<span class="stringliteral">&#39;solve&#39;</span>, <span class="stringliteral">&#39;solve_triangular&#39;</span>, <span class="stringliteral">&#39;solveh_banded&#39;</span>, <span class="stringliteral">&#39;solve_banded&#39;</span>,</div>
<div class="line"><span class="lineno">    2</span>           <span class="stringliteral">&#39;solve_toeplitz&#39;</span>, <span class="stringliteral">&#39;solve_circulant&#39;</span>, <span class="stringliteral">&#39;inv&#39;</span>, <span class="stringliteral">&#39;det&#39;</span>, <span class="stringliteral">&#39;lstsq&#39;</span>,</div>
<div class="line"><span class="lineno">    3</span>           <span class="stringliteral">&#39;pinv&#39;</span>, <span class="stringliteral">&#39;pinvh&#39;</span>, <span class="stringliteral">&#39;matrix_balance&#39;</span>, <span class="stringliteral">&#39;matmul_toeplitz&#39;</span>]</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="../../d6/dda/linalg_2__basic_8py_source.html#l00018">18</a> of file <a class="el" href="../../d6/dda/linalg_2__basic_8py_source.html">_basic.py</a>.</p>

</div>
</div>
<a id="a86596f567fe32523d12b4fe39d115492" name="a86596f567fe32523d12b4fe39d115492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86596f567fe32523d12b4fe39d115492">&#9670;&#160;</a></span>default_lapack_driver</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._basic.default_lapack_driver</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d6/dda/linalg_2__basic_8py_source.html#l01316">1316</a> of file <a class="el" href="../../d6/dda/linalg_2__basic_8py_source.html">_basic.py</a>.</p>

</div>
</div>
<a id="a173dda446ebdc35f737df7f1a8abb9bd" name="a173dda446ebdc35f737df7f1a8abb9bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a173dda446ebdc35f737df7f1a8abb9bd">&#9670;&#160;</a></span>lapack_cast_dict</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dict scipy.linalg._basic.lapack_cast_dict</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  {x: <span class="stringliteral">&#39;&#39;</span>.join([y <span class="keywordflow">for</span> y <span class="keywordflow">in</span> <span class="stringliteral">&#39;fdFD&#39;</span> <span class="keywordflow">if</span> np.can_cast(x, y)])</div>
<div class="line"><span class="lineno">    2</span>                    <span class="keywordflow">for</span> x <span class="keywordflow">in</span> np.typecodes[<span class="stringliteral">&#39;All&#39;</span>]}</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="../../d6/dda/linalg_2__basic_8py_source.html#l00030">30</a> of file <a class="el" href="../../d6/dda/linalg_2__basic_8py_source.html">_basic.py</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../db/d0f/namespacescipy.html">scipy</a></li><li class="navelem"><a class="el" href="../../dd/dd4/namespacescipy_1_1linalg.html">linalg</a></li><li class="navelem"><a class="el" href="../../d8/df3/namespacescipy_1_1linalg_1_1__basic.html">_basic</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
