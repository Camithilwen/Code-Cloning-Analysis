<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Code Cloning Analysis: sklearn.externals.array_api_extra._lib._funcs Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Code Cloning Analysis
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d6/d51/namespacesklearn_1_1externals_1_1array__api__extra_1_1__lib_1_1__funcs.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">sklearn.externals.array_api_extra._lib._funcs Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a97ea18c8a5db22130bf7a7483766249f" id="r_a97ea18c8a5db22130bf7a7483766249f"><td class="memItemLeft" align="right" valign="top">Array&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97ea18c8a5db22130bf7a7483766249f">apply_where</a> (Array cond, Array|tuple[Array,...] args, Callable[..., Array] f1, Callable[..., Array] f2, *, ModuleType|None xp=None)</td></tr>
<tr class="separator:a97ea18c8a5db22130bf7a7483766249f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e8bc8f4e94759b2f06da9e3525a5b2a" id="r_a2e8bc8f4e94759b2f06da9e3525a5b2a"><td class="memItemLeft" align="right" valign="top">Array&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e8bc8f4e94759b2f06da9e3525a5b2a">apply_where</a> (Array cond, Array|tuple[Array,...] args, Callable[..., Array] f1, *, Array|complex fill_value, ModuleType|None xp=None)</td></tr>
<tr class="separator:a2e8bc8f4e94759b2f06da9e3525a5b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e54f56acde142efc59740289edd76ac" id="r_a3e54f56acde142efc59740289edd76ac"><td class="memItemLeft" align="right" valign="top">Array&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e54f56acde142efc59740289edd76ac">apply_where</a> (Array cond, Array|tuple[Array,...] args, Callable[..., Array] f1, Callable[..., Array]|None f2=None, *, Array|complex|None fill_value=None, ModuleType|None xp=None)</td></tr>
<tr class="separator:a3e54f56acde142efc59740289edd76ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad59c32abe808a5b6d9ef917de61c998" id="r_aad59c32abe808a5b6d9ef917de61c998"><td class="memItemLeft" align="right" valign="top">Array&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad59c32abe808a5b6d9ef917de61c998">_apply_where</a> (Array cond, Callable[..., Array] f1, Callable[..., Array]|None f2, Array|int|float|complex|bool|None fill_value, *Array args, ModuleType xp)</td></tr>
<tr class="separator:aad59c32abe808a5b6d9ef917de61c998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab66046cf8038959689ba1a169fbba97" id="r_aab66046cf8038959689ba1a169fbba97"><td class="memItemLeft" align="right" valign="top">Array&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab66046cf8038959689ba1a169fbba97">atleast_nd</a> (Array x, *, int ndim, ModuleType|None xp=None)</td></tr>
<tr class="separator:aab66046cf8038959689ba1a169fbba97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a770af3a01f3679e73704264371083fa3" id="r_a770af3a01f3679e73704264371083fa3"><td class="memItemLeft" align="right" valign="top">tuple[int|None,...]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a770af3a01f3679e73704264371083fa3">broadcast_shapes</a> (*tuple[float|None,...] shapes)</td></tr>
<tr class="separator:a770af3a01f3679e73704264371083fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab38b9bf58316a531d10b7ce5cbc7f89a" id="r_ab38b9bf58316a531d10b7ce5cbc7f89a"><td class="memItemLeft" align="right" valign="top">Array&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab38b9bf58316a531d10b7ce5cbc7f89a">cov</a> (Array m, *, ModuleType|None xp=None)</td></tr>
<tr class="separator:ab38b9bf58316a531d10b7ce5cbc7f89a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ef63862111270fef008e29785c0456" id="r_a41ef63862111270fef008e29785c0456"><td class="memItemLeft" align="right" valign="top">Array&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41ef63862111270fef008e29785c0456">create_diagonal</a> (Array x, *, int offset=0, ModuleType|None xp=None)</td></tr>
<tr class="separator:a41ef63862111270fef008e29785c0456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a909a63d37f598849fa60c894eaf66657" id="r_a909a63d37f598849fa60c894eaf66657"><td class="memItemLeft" align="right" valign="top">Array&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a909a63d37f598849fa60c894eaf66657">expand_dims</a> (Array a, *, int|tuple[int,...] axis=(0,), ModuleType|None xp=None)</td></tr>
<tr class="separator:a909a63d37f598849fa60c894eaf66657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeeb4dbd2f73b3c9aa74f3f4b0a5e598" id="r_afeeb4dbd2f73b3c9aa74f3f4b0a5e598"><td class="memItemLeft" align="right" valign="top">Array&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afeeb4dbd2f73b3c9aa74f3f4b0a5e598">isclose</a> (Array|complex a, Array|complex b, *, float rtol=1e-05, float atol=1e-08, bool equal_nan=False, ModuleType xp)</td></tr>
<tr class="separator:afeeb4dbd2f73b3c9aa74f3f4b0a5e598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a576d8bb5e9e8f58499dc0b9cbe74b6f2" id="r_a576d8bb5e9e8f58499dc0b9cbe74b6f2"><td class="memItemLeft" align="right" valign="top">Array&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a576d8bb5e9e8f58499dc0b9cbe74b6f2">kron</a> (Array|complex a, Array|complex b, *, ModuleType|None xp=None)</td></tr>
<tr class="separator:a576d8bb5e9e8f58499dc0b9cbe74b6f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19160096f53f6d58a4b9dd1bc8f0f5cc" id="r_a19160096f53f6d58a4b9dd1bc8f0f5cc"><td class="memItemLeft" align="right" valign="top">Array&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19160096f53f6d58a4b9dd1bc8f0f5cc">nunique</a> (Array x, *, ModuleType|None xp=None)</td></tr>
<tr class="separator:a19160096f53f6d58a4b9dd1bc8f0f5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1fac5a134ba0fa5c17e320fcb90ef3d" id="r_aa1fac5a134ba0fa5c17e320fcb90ef3d"><td class="memItemLeft" align="right" valign="top">Array&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1fac5a134ba0fa5c17e320fcb90ef3d">pad</a> (Array x, int|tuple[int, int]|Sequence[tuple[int, int]] pad_width, *, complex constant_values=0, ModuleType xp)</td></tr>
<tr class="separator:aa1fac5a134ba0fa5c17e320fcb90ef3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a875cbd949cc4f9404833c1ad5d901a4b" id="r_a875cbd949cc4f9404833c1ad5d901a4b"><td class="memItemLeft" align="right" valign="top">Array&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a875cbd949cc4f9404833c1ad5d901a4b">setdiff1d</a> (Array|complex x1, Array|complex x2, *, bool assume_unique=False, ModuleType|None xp=None)</td></tr>
<tr class="separator:a875cbd949cc4f9404833c1ad5d901a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0664b4c8084d7d5927d115e01a248b0b" id="r_a0664b4c8084d7d5927d115e01a248b0b"><td class="memItemLeft" align="right" valign="top">Array&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0664b4c8084d7d5927d115e01a248b0b">sinc</a> (Array x, *, ModuleType|None xp=None)</td></tr>
<tr class="separator:a0664b4c8084d7d5927d115e01a248b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:abefb7cb6ab22e3d87e75ca91d66ee75f" id="r_abefb7cb6ab22e3d87e75ca91d66ee75f"><td class="memItemLeft" align="right" valign="top">list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abefb7cb6ab22e3d87e75ca91d66ee75f">__all__</a></td></tr>
<tr class="separator:abefb7cb6ab22e3d87e75ca91d66ee75f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Array-agnostic implementations for the public API.</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="aad59c32abe808a5b6d9ef917de61c998" name="aad59c32abe808a5b6d9ef917de61c998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad59c32abe808a5b6d9ef917de61c998">&#9670;&#160;</a></span>_apply_where()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> Array sklearn.externals.array_api_extra._lib._funcs._apply_where </td>
          <td>(</td>
          <td class="paramtype">Array</td>          <td class="paramname"><span class="paramname"><em>cond</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable[..., Array]</td>          <td class="paramname"><span class="paramname"><em>f1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable[..., Array] | None</td>          <td class="paramname"><span class="paramname"><em>f2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array | int | float | complex | bool | None</td>          <td class="paramname"><span class="paramname"><em>fill_value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*Array</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ModuleType</td>          <td class="paramname"><span class="paramname"><em>xp</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Helper of `apply_where`. On Dask, this runs on a single chunk.</pre> 
<p class="definition">Definition at line <a class="el" href="../../d1/d3f/__funcs_8py_source.html#l00145">145</a> of file <a class="el" href="../../d1/d3f/__funcs_8py_source.html">_funcs.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d1/d3f/__funcs_8py_source.html#l00068">apply_where()</a>.</p>

</div>
</div>
<a id="a2e8bc8f4e94759b2f06da9e3525a5b2a" name="a2e8bc8f4e94759b2f06da9e3525a5b2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e8bc8f4e94759b2f06da9e3525a5b2a">&#9670;&#160;</a></span>apply_where() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Array sklearn.externals.array_api_extra._lib._funcs.apply_where </td>
          <td>(</td>
          <td class="paramtype">Array</td>          <td class="paramname"><span class="paramname"><em>cond</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array | tuple[Array, ...]</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable[..., Array]</td>          <td class="paramname"><span class="paramname"><em>f1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array | complex</td>          <td class="paramname"><span class="paramname"><em>fill_value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ModuleType | None </td>          <td class="paramname"><span class="paramname"><em>xp</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d1/d3f/__funcs_8py_source.html#l00048">48</a> of file <a class="el" href="../../d1/d3f/__funcs_8py_source.html">_funcs.py</a>.</p>

</div>
</div>
<a id="a97ea18c8a5db22130bf7a7483766249f" name="a97ea18c8a5db22130bf7a7483766249f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97ea18c8a5db22130bf7a7483766249f">&#9670;&#160;</a></span>apply_where() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Array sklearn.externals.array_api_extra._lib._funcs.apply_where </td>
          <td>(</td>
          <td class="paramtype">Array</td>          <td class="paramname"><span class="paramname"><em>cond</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array | tuple[Array, ...]</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable[..., Array]</td>          <td class="paramname"><span class="paramname"><em>f1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable[..., Array]</td>          <td class="paramname"><span class="paramname"><em>f2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ModuleType | None </td>          <td class="paramname"><span class="paramname"><em>xp</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d1/d3f/__funcs_8py_source.html#l00036">36</a> of file <a class="el" href="../../d1/d3f/__funcs_8py_source.html">_funcs.py</a>.</p>

</div>
</div>
<a id="a3e54f56acde142efc59740289edd76ac" name="a3e54f56acde142efc59740289edd76ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e54f56acde142efc59740289edd76ac">&#9670;&#160;</a></span>apply_where() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Array sklearn.externals.array_api_extra._lib._funcs.apply_where </td>
          <td>(</td>
          <td class="paramtype">Array</td>          <td class="paramname"><span class="paramname"><em>cond</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array | tuple[Array, ...]</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable[..., Array]</td>          <td class="paramname"><span class="paramname"><em>f1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable[..., Array] | None </td>          <td class="paramname"><span class="paramname"><em>f2</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array | complex | None </td>          <td class="paramname"><span class="paramname"><em>fill_value</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ModuleType | None </td>          <td class="paramname"><span class="paramname"><em>xp</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Run one of two elementwise functions depending on a condition.

Equivalent to ``f1(*args) if cond else fill_value`` performed elementwise
when `fill_value` is defined, otherwise to ``f1(*args) if cond else f2(*args)``.

Parameters
----------
cond : array
    The condition, expressed as a boolean array.
args : Array or tuple of Arrays
    Argument(s) to `f1` (and `f2`). Must be broadcastable with `cond`.
f1 : callable
    Elementwise function of `args`, returning a single array.
    Where `cond` is True, output will be ``f1(arg0[cond], arg1[cond], ...)``.
f2 : callable, optional
    Elementwise function of `args`, returning a single array.
    Where `cond` is False, output will be ``f2(arg0[cond], arg1[cond], ...)``.
    Mutually exclusive with `fill_value`.
fill_value : Array or scalar, optional
    If provided, value with which to fill output array where `cond` is False.
    It does not need to be scalar; it needs however to be broadcastable with
    `cond` and `args`.
    Mutually exclusive with `f2`. You must provide one or the other.
xp : array_namespace, optional
    The standard-compatible namespace for `cond` and `args`. Default: infer.

Returns
-------
Array
    An array with elements from the output of `f1` where `cond` is True and either
    the output of `f2` or `fill_value` where `cond` is False. The returned array has
    data type determined by type promotion rules between the output of `f1` and
    either `fill_value` or the output of `f2`.

Notes
-----
``xp.where(cond, f1(*args), f2(*args))`` requires explicitly evaluating `f1` even
when `cond` is False, and `f2` when cond is True. This function evaluates each
function only for their matching condition, if the backend allows for it.

On Dask, `f1` and `f2` are applied to the individual chunks and should use functions
from the namespace of the chunks.

Examples
--------
&gt;&gt;&gt; import array_api_strict as xp
&gt;&gt;&gt; import array_api_extra as xpx
&gt;&gt;&gt; a = xp.asarray([5, 4, 3])
&gt;&gt;&gt; b = xp.asarray([0, 2, 2])
&gt;&gt;&gt; def f(a, b):
...     return a // b
&gt;&gt;&gt; xpx.apply_where(b != 0, (a, b), f, fill_value=xp.nan)
array([ nan,  2., 1.])
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d1/d3f/__funcs_8py_source.html#l00059">59</a> of file <a class="el" href="../../d1/d3f/__funcs_8py_source.html">_funcs.py</a>.</p>

<p class="reference">References <a class="el" href="../../d1/d3f/__funcs_8py_source.html#l00152">_apply_where()</a>.</p>

</div>
</div>
<a id="aab66046cf8038959689ba1a169fbba97" name="aab66046cf8038959689ba1a169fbba97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab66046cf8038959689ba1a169fbba97">&#9670;&#160;</a></span>atleast_nd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Array sklearn.externals.array_api_extra._lib._funcs.atleast_nd </td>
          <td>(</td>
          <td class="paramtype">Array</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ndim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ModuleType | None </td>          <td class="paramname"><span class="paramname"><em>xp</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Recursively expand the dimension of an array to at least `ndim`.

Parameters
----------
x : array
    Input array.
ndim : int
    The minimum number of dimensions for the result.
xp : array_namespace, optional
    The standard-compatible namespace for `x`. Default: infer.

Returns
-------
array
    An array with ``res.ndim`` &gt;= `ndim`.
    If ``x.ndim`` &gt;= `ndim`, `x` is returned.
    If ``x.ndim`` &lt; `ndim`, `x` is expanded by prepending new axes
    until ``res.ndim`` equals `ndim`.

Examples
--------
&gt;&gt;&gt; import array_api_strict as xp
&gt;&gt;&gt; import array_api_extra as xpx
&gt;&gt;&gt; x = xp.asarray([1])
&gt;&gt;&gt; xpx.atleast_nd(x, ndim=3, xp=xp)
Array([[[1]]], dtype=array_api_strict.int64)

&gt;&gt;&gt; x = xp.asarray([[[1, 2],
...                  [3, 4]]])
&gt;&gt;&gt; xpx.atleast_nd(x, ndim=1, xp=xp) is x
True
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d1/d3f/__funcs_8py_source.html#l00177">177</a> of file <a class="el" href="../../d1/d3f/__funcs_8py_source.html">_funcs.py</a>.</p>

<p class="reference">References <a class="el" href="../../d1/d3f/__funcs_8py_source.html#l00177">atleast_nd()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d1/d3f/__funcs_8py_source.html#l00177">atleast_nd()</a>, and <a class="el" href="../../d1/d3f/__funcs_8py_source.html#l00283">cov()</a>.</p>

</div>
</div>
<a id="a770af3a01f3679e73704264371083fa3" name="a770af3a01f3679e73704264371083fa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a770af3a01f3679e73704264371083fa3">&#9670;&#160;</a></span>broadcast_shapes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[int | None, ...] sklearn.externals.array_api_extra._lib._funcs.broadcast_shapes </td>
          <td>(</td>
          <td class="paramtype">*tuple[float | None, ...]</td>          <td class="paramname"><span class="paramname"><em>shapes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the shape of the broadcasted arrays.

Duplicates :func:`numpy.broadcast_shapes`, with additional support for
None and NaN sizes.

This is equivalent to ``xp.broadcast_arrays(arr1, arr2, ...)[0].shape``
without needing to worry about the backend potentially deep copying
the arrays.

Parameters
----------
*shapes : tuple[int | None, ...]
    Shapes of the arrays to broadcast.

Returns
-------
tuple[int | None, ...]
    The shape of the broadcasted arrays.

See Also
--------
numpy.broadcast_shapes : Equivalent NumPy function.
array_api.broadcast_arrays : Function to broadcast actual arrays.

Notes
-----
This function accepts the Array API's ``None`` for unknown sizes,
as well as Dask's non-standard ``math.nan``.
Regardless of input, the output always contains ``None`` for unknown sizes.

Examples
--------
&gt;&gt;&gt; import array_api_extra as xpx
&gt;&gt;&gt; xpx.broadcast_shapes((2, 3), (2, 1))
(2, 3)
&gt;&gt;&gt; xpx.broadcast_shapes((4, 2, 3), (2, 1), (1, 3))
(4, 2, 3)
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d1/d3f/__funcs_8py_source.html#l00222">222</a> of file <a class="el" href="../../d1/d3f/__funcs_8py_source.html">_funcs.py</a>.</p>

</div>
</div>
<a id="ab38b9bf58316a531d10b7ce5cbc7f89a" name="ab38b9bf58316a531d10b7ce5cbc7f89a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab38b9bf58316a531d10b7ce5cbc7f89a">&#9670;&#160;</a></span>cov()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Array sklearn.externals.array_api_extra._lib._funcs.cov </td>
          <td>(</td>
          <td class="paramtype">Array</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ModuleType | None </td>          <td class="paramname"><span class="paramname"><em>xp</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Estimate a covariance matrix.

Covariance indicates the level to which two variables vary together.
If we examine N-dimensional samples, :math:`X = [x_1, x_2, ... x_N]^T`,
then the covariance matrix element :math:`C_{ij}` is the covariance of
:math:`x_i` and :math:`x_j`. The element :math:`C_{ii}` is the variance
of :math:`x_i`.

This provides a subset of the functionality of ``numpy.cov``.

Parameters
----------
m : array
    A 1-D or 2-D array containing multiple variables and observations.
    Each row of `m` represents a variable, and each column a single
    observation of all those variables.
xp : array_namespace, optional
    The standard-compatible namespace for `m`. Default: infer.

Returns
-------
array
    The covariance matrix of the variables.

Examples
--------
&gt;&gt;&gt; import array_api_strict as xp
&gt;&gt;&gt; import array_api_extra as xpx

Consider two variables, :math:`x_0` and :math:`x_1`, which
correlate perfectly, but in opposite directions:

&gt;&gt;&gt; x = xp.asarray([[0, 2], [1, 1], [2, 0]]).T
&gt;&gt;&gt; x
Array([[0, 1, 2],
       [2, 1, 0]], dtype=array_api_strict.int64)

Note how :math:`x_0` increases while :math:`x_1` decreases. The covariance
matrix shows this clearly:

&gt;&gt;&gt; xpx.cov(x, xp=xp)
Array([[ 1., -1.],
       [-1.,  1.]], dtype=array_api_strict.float64)

Note that element :math:`C_{0,1}`, which shows the correlation between
:math:`x_0` and :math:`x_1`, is negative.

Further, note how `x` and `y` are combined:

&gt;&gt;&gt; x = xp.asarray([-2.1, -1,  4.3])
&gt;&gt;&gt; y = xp.asarray([3,  1.1,  0.12])
&gt;&gt;&gt; X = xp.stack((x, y), axis=0)
&gt;&gt;&gt; xpx.cov(X, xp=xp)
Array([[11.71      , -4.286     ],
       [-4.286     ,  2.14413333]], dtype=array_api_strict.float64)

&gt;&gt;&gt; xpx.cov(x, xp=xp)
Array(11.71, dtype=array_api_strict.float64)

&gt;&gt;&gt; xpx.cov(y, xp=xp)
Array(2.14413333, dtype=array_api_strict.float64)
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d1/d3f/__funcs_8py_source.html#l00283">283</a> of file <a class="el" href="../../d1/d3f/__funcs_8py_source.html">_funcs.py</a>.</p>

<p class="reference">References <a class="el" href="../../d1/d3f/__funcs_8py_source.html#l00177">atleast_nd()</a>.</p>

</div>
</div>
<a id="a41ef63862111270fef008e29785c0456" name="a41ef63862111270fef008e29785c0456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41ef63862111270fef008e29785c0456">&#9670;&#160;</a></span>create_diagonal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Array sklearn.externals.array_api_extra._lib._funcs.create_diagonal </td>
          <td>(</td>
          <td class="paramtype">Array</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ModuleType | None </td>          <td class="paramname"><span class="paramname"><em>xp</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Construct a diagonal array.

Parameters
----------
x : array
    An array having shape ``(*batch_dims, k)``.
offset : int, optional
    Offset from the leading diagonal (default is ``0``).
    Use positive ints for diagonals above the leading diagonal,
    and negative ints for diagonals below the leading diagonal.
xp : array_namespace, optional
    The standard-compatible namespace for `x`. Default: infer.

Returns
-------
array
    An array having shape ``(*batch_dims, k+abs(offset), k+abs(offset))`` with `x`
    on the diagonal (offset by `offset`).

Examples
--------
&gt;&gt;&gt; import array_api_strict as xp
&gt;&gt;&gt; import array_api_extra as xpx
&gt;&gt;&gt; x = xp.asarray([2, 4, 8])

&gt;&gt;&gt; xpx.create_diagonal(x, xp=xp)
Array([[2, 0, 0],
       [0, 4, 0],
       [0, 0, 8]], dtype=array_api_strict.int64)

&gt;&gt;&gt; xpx.create_diagonal(x, offset=-2, xp=xp)
Array([[0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0],
       [2, 0, 0, 0, 0],
       [0, 4, 0, 0, 0],
       [0, 0, 8, 0, 0]], dtype=array_api_strict.int64)
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d1/d3f/__funcs_8py_source.html#l00377">377</a> of file <a class="el" href="../../d1/d3f/__funcs_8py_source.html">_funcs.py</a>.</p>

</div>
</div>
<a id="a909a63d37f598849fa60c894eaf66657" name="a909a63d37f598849fa60c894eaf66657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a909a63d37f598849fa60c894eaf66657">&#9670;&#160;</a></span>expand_dims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Array sklearn.externals.array_api_extra._lib._funcs.expand_dims </td>
          <td>(</td>
          <td class="paramtype">Array</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | tuple[int, ...] </td>          <td class="paramname"><span class="paramname"><em>axis</em></span><span class="paramdefsep"> = </span><span class="paramdefval">(0,)</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ModuleType | None </td>          <td class="paramname"><span class="paramname"><em>xp</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Expand the shape of an array.

Insert (a) new axis/axes that will appear at the position(s) specified by
`axis` in the expanded array shape.

This is ``xp.expand_dims`` for `axis` an int *or a tuple of ints*.
Roughly equivalent to ``numpy.expand_dims`` for NumPy arrays.

Parameters
----------
a : array
    Array to have its shape expanded.
axis : int or tuple of ints, optional
    Position(s) in the expanded axes where the new axis (or axes) is/are placed.
    If multiple positions are provided, they should be unique (note that a position
    given by a positive index could also be referred to by a negative index -
    that will also result in an error).
    Default: ``(0,)``.
xp : array_namespace, optional
    The standard-compatible namespace for `a`. Default: infer.

Returns
-------
array
    `a` with an expanded shape.

Examples
--------
&gt;&gt;&gt; import array_api_strict as xp
&gt;&gt;&gt; import array_api_extra as xpx
&gt;&gt;&gt; x = xp.asarray([1, 2])
&gt;&gt;&gt; x.shape
(2,)

The following is equivalent to ``x[xp.newaxis, :]`` or ``x[xp.newaxis]``:

&gt;&gt;&gt; y = xpx.expand_dims(x, axis=0, xp=xp)
&gt;&gt;&gt; y
Array([[1, 2]], dtype=array_api_strict.int64)
&gt;&gt;&gt; y.shape
(1, 2)

The following is equivalent to ``x[:, xp.newaxis]``:

&gt;&gt;&gt; y = xpx.expand_dims(x, axis=1, xp=xp)
&gt;&gt;&gt; y
Array([[1],
       [2]], dtype=array_api_strict.int64)
&gt;&gt;&gt; y.shape
(2, 1)

``axis`` may also be a tuple:

&gt;&gt;&gt; y = xpx.expand_dims(x, axis=(0, 1), xp=xp)
&gt;&gt;&gt; y
Array([[[1, 2]]], dtype=array_api_strict.int64)

&gt;&gt;&gt; y = xpx.expand_dims(x, axis=(2, 0), xp=xp)
&gt;&gt;&gt; y
Array([[[1],
        [2]]], dtype=array_api_strict.int64)
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d1/d3f/__funcs_8py_source.html#l00440">440</a> of file <a class="el" href="../../d1/d3f/__funcs_8py_source.html">_funcs.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d1/d3f/__funcs_8py_source.html#l00579">kron()</a>.</p>

</div>
</div>
<a id="afeeb4dbd2f73b3c9aa74f3f4b0a5e598" name="afeeb4dbd2f73b3c9aa74f3f4b0a5e598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeeb4dbd2f73b3c9aa74f3f4b0a5e598">&#9670;&#160;</a></span>isclose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Array sklearn.externals.array_api_extra._lib._funcs.isclose </td>
          <td>(</td>
          <td class="paramtype">Array | complex</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array | complex</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float </td>          <td class="paramname"><span class="paramname"><em>rtol</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1e-05</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float </td>          <td class="paramname"><span class="paramname"><em>atol</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1e-08</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>          <td class="paramname"><span class="paramname"><em>equal_nan</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ModuleType</td>          <td class="paramname"><span class="paramname"><em>xp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">See docstring in array_api_extra._delegation.</pre> 
<p class="definition">Definition at line <a class="el" href="../../d1/d3f/__funcs_8py_source.html#l00526">526</a> of file <a class="el" href="../../d1/d3f/__funcs_8py_source.html">_funcs.py</a>.</p>

</div>
</div>
<a id="a576d8bb5e9e8f58499dc0b9cbe74b6f2" name="a576d8bb5e9e8f58499dc0b9cbe74b6f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a576d8bb5e9e8f58499dc0b9cbe74b6f2">&#9670;&#160;</a></span>kron()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Array sklearn.externals.array_api_extra._lib._funcs.kron </td>
          <td>(</td>
          <td class="paramtype">Array | complex</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array | complex</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ModuleType | None </td>          <td class="paramname"><span class="paramname"><em>xp</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Kronecker product of two arrays.

Computes the Kronecker product, a composite array made of blocks of the
second array scaled by the first.

Equivalent to ``numpy.kron`` for NumPy arrays.

Parameters
----------
a, b : Array | int | float | complex
    Input arrays or scalars. At least one must be an array.
xp : array_namespace, optional
    The standard-compatible namespace for `a` and `b`. Default: infer.

Returns
-------
array
    The Kronecker product of `a` and `b`.

Notes
-----
The function assumes that the number of dimensions of `a` and `b`
are the same, if necessary prepending the smallest with ones.
If ``a.shape = (r0,r1,..,rN)`` and ``b.shape = (s0,s1,...,sN)``,
the Kronecker product has shape ``(r0*s0, r1*s1, ..., rN*SN)``.
The elements are products of elements from `a` and `b`, organized
explicitly by::

    kron(a,b)[k0,k1,...,kN] = a[i0,i1,...,iN] * b[j0,j1,...,jN]

where::

    kt = it * st + jt,  t = 0,...,N

In the common 2-D case (N=1), the block structure can be visualized::

    [[ a[0,0]*b,   a[0,1]*b,  ... , a[0,-1]*b  ],
     [  ...                              ...   ],
     [ a[-1,0]*b,  a[-1,1]*b, ... , a[-1,-1]*b ]]

Examples
--------
&gt;&gt;&gt; import array_api_strict as xp
&gt;&gt;&gt; import array_api_extra as xpx
&gt;&gt;&gt; xpx.kron(xp.asarray([1, 10, 100]), xp.asarray([5, 6, 7]), xp=xp)
Array([  5,   6,   7,  50,  60,  70, 500,
       600, 700], dtype=array_api_strict.int64)

&gt;&gt;&gt; xpx.kron(xp.asarray([5, 6, 7]), xp.asarray([1, 10, 100]), xp=xp)
Array([  5,  50, 500,   6,  60, 600,   7,
        70, 700], dtype=array_api_strict.int64)

&gt;&gt;&gt; xpx.kron(xp.eye(2), xp.ones((2, 2)), xp=xp)
Array([[1., 1., 0., 0.],
       [1., 1., 0., 0.],
       [0., 0., 1., 1.],
       [0., 0., 1., 1.]], dtype=array_api_strict.float64)

&gt;&gt;&gt; a = xp.reshape(xp.arange(100), (2, 5, 2, 5))
&gt;&gt;&gt; b = xp.reshape(xp.arange(24), (2, 3, 4))
&gt;&gt;&gt; c = xpx.kron(a, b, xp=xp)
&gt;&gt;&gt; c.shape
(2, 10, 6, 20)
&gt;&gt;&gt; I = (1, 3, 0, 2)
&gt;&gt;&gt; J = (0, 2, 1)
&gt;&gt;&gt; J1 = (0,) + J             # extend to ndim=4
&gt;&gt;&gt; S1 = (1,) + b.shape
&gt;&gt;&gt; K = tuple(xp.asarray(I) * xp.asarray(S1) + xp.asarray(J1))
&gt;&gt;&gt; c[K] == a[I]*b[J]
Array(True, dtype=array_api_strict.bool)
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d1/d3f/__funcs_8py_source.html#l00573">573</a> of file <a class="el" href="../../d1/d3f/__funcs_8py_source.html">_funcs.py</a>.</p>

<p class="reference">References <a class="el" href="../../d1/d3f/__funcs_8py_source.html#l00442">expand_dims()</a>.</p>

</div>
</div>
<a id="a19160096f53f6d58a4b9dd1bc8f0f5cc" name="a19160096f53f6d58a4b9dd1bc8f0f5cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19160096f53f6d58a4b9dd1bc8f0f5cc">&#9670;&#160;</a></span>nunique()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Array sklearn.externals.array_api_extra._lib._funcs.nunique </td>
          <td>(</td>
          <td class="paramtype">Array</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ModuleType | None </td>          <td class="paramname"><span class="paramname"><em>xp</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Count the number of unique elements in an array.

Compatible with JAX and Dask, whose laziness would be otherwise
problematic.

Parameters
----------
x : Array
    Input array.
xp : array_namespace, optional
    The standard-compatible namespace for `x`. Default: infer.

Returns
-------
array: 0-dimensional integer array
    The number of unique elements in `x`. It can be lazy.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d1/d3f/__funcs_8py_source.html#l00685">685</a> of file <a class="el" href="../../d1/d3f/__funcs_8py_source.html">_funcs.py</a>.</p>

</div>
</div>
<a id="aa1fac5a134ba0fa5c17e320fcb90ef3d" name="aa1fac5a134ba0fa5c17e320fcb90ef3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1fac5a134ba0fa5c17e320fcb90ef3d">&#9670;&#160;</a></span>pad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Array sklearn.externals.array_api_extra._lib._funcs.pad </td>
          <td>(</td>
          <td class="paramtype">Array</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | tuple[int, int] | Sequence[tuple[int, int]]</td>          <td class="paramname"><span class="paramname"><em>pad_width</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">complex </td>          <td class="paramname"><span class="paramname"><em>constant_values</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ModuleType</td>          <td class="paramname"><span class="paramname"><em>xp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">See docstring in `array_api_extra._delegation.py`.</pre> 
<p class="definition">Definition at line <a class="el" href="../../d1/d3f/__funcs_8py_source.html#l00721">721</a> of file <a class="el" href="../../d1/d3f/__funcs_8py_source.html">_funcs.py</a>.</p>

</div>
</div>
<a id="a875cbd949cc4f9404833c1ad5d901a4b" name="a875cbd949cc4f9404833c1ad5d901a4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a875cbd949cc4f9404833c1ad5d901a4b">&#9670;&#160;</a></span>setdiff1d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Array sklearn.externals.array_api_extra._lib._funcs.setdiff1d </td>
          <td>(</td>
          <td class="paramtype">Array | complex</td>          <td class="paramname"><span class="paramname"><em>x1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array | complex</td>          <td class="paramname"><span class="paramname"><em>x2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>          <td class="paramname"><span class="paramname"><em>assume_unique</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ModuleType | None </td>          <td class="paramname"><span class="paramname"><em>xp</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find the set difference of two arrays.

Return the unique values in `x1` that are not in `x2`.

Parameters
----------
x1 : array | int | float | complex | bool
    Input array.
x2 : array
    Input comparison array.
assume_unique : bool
    If ``True``, the input arrays are both assumed to be unique, which
    can speed up the calculation. Default is ``False``.
xp : array_namespace, optional
    The standard-compatible namespace for `x1` and `x2`. Default: infer.

Returns
-------
array
    1D array of values in `x1` that are not in `x2`. The result
    is sorted when `assume_unique` is ``False``, but otherwise only sorted
    if the input is sorted.

Examples
--------
&gt;&gt;&gt; import array_api_strict as xp
&gt;&gt;&gt; import array_api_extra as xpx

&gt;&gt;&gt; x1 = xp.asarray([1, 2, 3, 2, 4, 1])
&gt;&gt;&gt; x2 = xp.asarray([3, 4, 5, 6])
&gt;&gt;&gt; xpx.setdiff1d(x1, x2, xp=xp)
Array([1, 2], dtype=array_api_strict.int64)
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d1/d3f/__funcs_8py_source.html#l00772">772</a> of file <a class="el" href="../../d1/d3f/__funcs_8py_source.html">_funcs.py</a>.</p>

</div>
</div>
<a id="a0664b4c8084d7d5927d115e01a248b0b" name="a0664b4c8084d7d5927d115e01a248b0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0664b4c8084d7d5927d115e01a248b0b">&#9670;&#160;</a></span>sinc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Array sklearn.externals.array_api_extra._lib._funcs.sinc </td>
          <td>(</td>
          <td class="paramtype">Array</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ModuleType | None </td>          <td class="paramname"><span class="paramname"><em>xp</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the normalized sinc function.

The sinc function is equal to :math:`\sin(\pi x)/(\pi x)` for any argument
:math:`x\ne 0`. ``sinc(0)`` takes the limit value 1, making ``sinc`` not
only everywhere continuous but also infinitely differentiable.

.. note::

    Note the normalization factor of ``pi`` used in the definition.
    This is the most commonly used definition in signal processing.
    Use ``sinc(x / xp.pi)`` to obtain the unnormalized sinc function
    :math:`\sin(x)/x` that is more common in mathematics.

Parameters
----------
x : array
    Array (possibly multi-dimensional) of values for which to calculate
    ``sinc(x)``. Must have a real floating point dtype.
xp : array_namespace, optional
    The standard-compatible namespace for `x`. Default: infer.

Returns
-------
array
    ``sinc(x)`` calculated elementwise, which has the same shape as the input.

Notes
-----
The name sinc is short for "sine cardinal" or "sinus cardinalis".

The sinc function is used in various signal processing applications,
including in anti-aliasing, in the construction of a Lanczos resampling
filter, and in interpolation.

For bandlimited interpolation of discrete-time signals, the ideal
interpolation kernel is proportional to the sinc function.

References
----------
#. Weisstein, Eric W. "Sinc Function." From MathWorld--A Wolfram Web
   Resource. https://mathworld.wolfram.com/SincFunction.html
#. Wikipedia, "Sinc function",
   https://en.wikipedia.org/wiki/Sinc_function

Examples
--------
&gt;&gt;&gt; import array_api_strict as xp
&gt;&gt;&gt; import array_api_extra as xpx
&gt;&gt;&gt; x = xp.linspace(-4, 4, 41)
&gt;&gt;&gt; xpx.sinc(x, xp=xp)
Array([-3.89817183e-17, -4.92362781e-02,
       -8.40918587e-02, -8.90384387e-02,
       -5.84680802e-02,  3.89817183e-17,
        6.68206631e-02,  1.16434881e-01,
        1.26137788e-01,  8.50444803e-02,
       -3.89817183e-17, -1.03943254e-01,
       -1.89206682e-01, -2.16236208e-01,
       -1.55914881e-01,  3.89817183e-17,
        2.33872321e-01,  5.04551152e-01,
        7.56826729e-01,  9.35489284e-01,
        1.00000000e+00,  9.35489284e-01,
        7.56826729e-01,  5.04551152e-01,
        2.33872321e-01,  3.89817183e-17,
       -1.55914881e-01, -2.16236208e-01,
       -1.89206682e-01, -1.03943254e-01,
       -3.89817183e-17,  8.50444803e-02,
        1.26137788e-01,  1.16434881e-01,
        6.68206631e-02,  3.89817183e-17,
       -5.84680802e-02, -8.90384387e-02,
       -8.40918587e-02, -4.92362781e-02,
       -3.89817183e-17], dtype=array_api_strict.float64)
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d1/d3f/__funcs_8py_source.html#l00829">829</a> of file <a class="el" href="../../d1/d3f/__funcs_8py_source.html">_funcs.py</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="abefb7cb6ab22e3d87e75ca91d66ee75f" name="abefb7cb6ab22e3d87e75ca91d66ee75f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abefb7cb6ab22e3d87e75ca91d66ee75f">&#9670;&#160;</a></span>__all__</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">list sklearn.externals.array_api_extra._lib._funcs.__all__</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  [</div>
<div class="line"><span class="lineno">    2</span>    <span class="stringliteral">&quot;apply_where&quot;</span>,</div>
<div class="line"><span class="lineno">    3</span>    <span class="stringliteral">&quot;atleast_nd&quot;</span>,</div>
<div class="line"><span class="lineno">    4</span>    <span class="stringliteral">&quot;broadcast_shapes&quot;</span>,</div>
<div class="line"><span class="lineno">    5</span>    <span class="stringliteral">&quot;cov&quot;</span>,</div>
<div class="line"><span class="lineno">    6</span>    <span class="stringliteral">&quot;create_diagonal&quot;</span>,</div>
<div class="line"><span class="lineno">    7</span>    <span class="stringliteral">&quot;expand_dims&quot;</span>,</div>
<div class="line"><span class="lineno">    8</span>    <span class="stringliteral">&quot;kron&quot;</span>,</div>
<div class="line"><span class="lineno">    9</span>    <span class="stringliteral">&quot;nunique&quot;</span>,</div>
<div class="line"><span class="lineno">   10</span>    <span class="stringliteral">&quot;pad&quot;</span>,</div>
<div class="line"><span class="lineno">   11</span>    <span class="stringliteral">&quot;setdiff1d&quot;</span>,</div>
<div class="line"><span class="lineno">   12</span>    <span class="stringliteral">&quot;sinc&quot;</span>,</div>
<div class="line"><span class="lineno">   13</span>]</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="../../d1/d3f/__funcs_8py_source.html#l00020">20</a> of file <a class="el" href="../../d1/d3f/__funcs_8py_source.html">_funcs.py</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d6/d1d/namespacesklearn.html">sklearn</a></li><li class="navelem"><a class="el" href="../../d0/d75/namespacesklearn_1_1externals.html">externals</a></li><li class="navelem"><a class="el" href="../../dd/d4e/namespacesklearn_1_1externals_1_1array__api__extra.html">array_api_extra</a></li><li class="navelem"><a class="el" href="../../db/d16/namespacesklearn_1_1externals_1_1array__api__extra_1_1__lib.html">_lib</a></li><li class="navelem"><a class="el" href="../../d6/d51/namespacesklearn_1_1externals_1_1array__api__extra_1_1__lib_1_1__funcs.html">_funcs</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
