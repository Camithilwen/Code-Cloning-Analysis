<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Code Cloning Analysis: scipy.stats._morestats Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Code Cloning Analysis
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d6/d08/namespacescipy_1_1stats_1_1__morestats.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">scipy.stats._morestats Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d8c/classscipy_1_1stats_1_1__morestats_1_1__ABW.html">_ABW</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dfa/classscipy_1_1stats_1_1__morestats_1_1DirectionalStats.html">DirectionalStats</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa18cb0ea658376fef0b14314b7681611" id="r_aa18cb0ea658376fef0b14314b7681611"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa18cb0ea658376fef0b14314b7681611">bayes_mvs</a> (data, alpha=0.90)</td></tr>
<tr class="separator:aa18cb0ea658376fef0b14314b7681611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba1b41e7416dd9f4537909f6f4fb98f8" id="r_aba1b41e7416dd9f4537909f6f4fb98f8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba1b41e7416dd9f4537909f6f4fb98f8">mvsdist</a> (data)</td></tr>
<tr class="separator:aba1b41e7416dd9f4537909f6f4fb98f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4240a80fd709860b5a63acf219991dcf" id="r_a4240a80fd709860b5a63acf219991dcf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4240a80fd709860b5a63acf219991dcf">kstat</a> (data, n=2)</td></tr>
<tr class="separator:a4240a80fd709860b5a63acf219991dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a9f133ef967d3f334ef8b7fc573983" id="r_ab8a9f133ef967d3f334ef8b7fc573983"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8a9f133ef967d3f334ef8b7fc573983">kstatvar</a> (data, n=2)</td></tr>
<tr class="separator:ab8a9f133ef967d3f334ef8b7fc573983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcfc50b779d664d1fcc5437ae81b2118" id="r_abcfc50b779d664d1fcc5437ae81b2118"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abcfc50b779d664d1fcc5437ae81b2118">_calc_uniform_order_statistic_medians</a> (n)</td></tr>
<tr class="separator:abcfc50b779d664d1fcc5437ae81b2118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15d1e13676d4afb1f3b54f0451af4a54" id="r_a15d1e13676d4afb1f3b54f0451af4a54"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15d1e13676d4afb1f3b54f0451af4a54">_parse_dist_kw</a> (dist, enforce_subclass=<a class="el" href="../../d8/d0b/classTrue.html">True</a>)</td></tr>
<tr class="separator:a15d1e13676d4afb1f3b54f0451af4a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac665132057e03a14ff3bb554fdc27555" id="r_ac665132057e03a14ff3bb554fdc27555"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac665132057e03a14ff3bb554fdc27555">_add_axis_labels_title</a> (plot, xlabel, ylabel, title)</td></tr>
<tr class="separator:ac665132057e03a14ff3bb554fdc27555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a762e91cdcf4bede4a0ace1d96b091" id="r_ad0a762e91cdcf4bede4a0ace1d96b091"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0a762e91cdcf4bede4a0ace1d96b091">probplot</a> (x, sparams=(), dist='norm', fit=<a class="el" href="../../d8/d0b/classTrue.html">True</a>, plot=None, rvalue=False)</td></tr>
<tr class="separator:ad0a762e91cdcf4bede4a0ace1d96b091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f28fe29e196c4bfe59e5619f859946f" id="r_a3f28fe29e196c4bfe59e5619f859946f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f28fe29e196c4bfe59e5619f859946f">ppcc_max</a> (x, brack=(0.0, 1.0), dist='tukeylambda')</td></tr>
<tr class="separator:a3f28fe29e196c4bfe59e5619f859946f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac92883d23651fe5aa26beaef7c55a5ce" id="r_ac92883d23651fe5aa26beaef7c55a5ce"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac92883d23651fe5aa26beaef7c55a5ce">ppcc_plot</a> (x, a, b, dist='tukeylambda', plot=None, N=80)</td></tr>
<tr class="separator:ac92883d23651fe5aa26beaef7c55a5ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d168816d9c396b378a0d0d15544b56" id="r_a93d168816d9c396b378a0d0d15544b56"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93d168816d9c396b378a0d0d15544b56">boxcox_llf</a> (lmb, data)</td></tr>
<tr class="separator:a93d168816d9c396b378a0d0d15544b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c8a5a2adc6fc9bd197a0e3109734353" id="r_a9c8a5a2adc6fc9bd197a0e3109734353"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c8a5a2adc6fc9bd197a0e3109734353">_boxcox_conf_interval</a> (x, lmax, alpha)</td></tr>
<tr class="separator:a9c8a5a2adc6fc9bd197a0e3109734353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8927cc8608f6decd26a9fe23214071e1" id="r_a8927cc8608f6decd26a9fe23214071e1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8927cc8608f6decd26a9fe23214071e1">boxcox</a> (x, lmbda=None, alpha=None, optimizer=None)</td></tr>
<tr class="separator:a8927cc8608f6decd26a9fe23214071e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e99833f0ddea425698e0590079d2d9" id="r_ae6e99833f0ddea425698e0590079d2d9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6e99833f0ddea425698e0590079d2d9">boxcox_normmax</a> (x, brack=None, method='<a class="el" href="../../da/d20/namespacescipy_1_1stats_1_1__stats__py.html#a8b002f05757020441e68edf9441f3c7f">pearsonr</a>', optimizer=None)</td></tr>
<tr class="separator:ae6e99833f0ddea425698e0590079d2d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a8b65fc912abb046b5556527b32f09d" id="r_a0a8b65fc912abb046b5556527b32f09d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a8b65fc912abb046b5556527b32f09d">_normplot</a> (method, x, la, lb, plot=None, N=80)</td></tr>
<tr class="separator:a0a8b65fc912abb046b5556527b32f09d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91186ccc31cc60f13d65ab705c006a4f" id="r_a91186ccc31cc60f13d65ab705c006a4f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91186ccc31cc60f13d65ab705c006a4f">boxcox_normplot</a> (x, la, lb, plot=None, N=80)</td></tr>
<tr class="separator:a91186ccc31cc60f13d65ab705c006a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b302a2d21bd578ba3ff828a99000b6d" id="r_a0b302a2d21bd578ba3ff828a99000b6d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b302a2d21bd578ba3ff828a99000b6d">yeojohnson</a> (x, lmbda=None)</td></tr>
<tr class="separator:a0b302a2d21bd578ba3ff828a99000b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94eddca00d1a762d16c27be928ed4fd2" id="r_a94eddca00d1a762d16c27be928ed4fd2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94eddca00d1a762d16c27be928ed4fd2">_yeojohnson_transform</a> (x, lmbda)</td></tr>
<tr class="separator:a94eddca00d1a762d16c27be928ed4fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae07ef1cbf1d88998be1d88789ac21135" id="r_ae07ef1cbf1d88998be1d88789ac21135"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae07ef1cbf1d88998be1d88789ac21135">yeojohnson_llf</a> (lmb, data)</td></tr>
<tr class="separator:ae07ef1cbf1d88998be1d88789ac21135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e11fd74ac89acf7920558617d8aa708" id="r_a7e11fd74ac89acf7920558617d8aa708"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e11fd74ac89acf7920558617d8aa708">yeojohnson_normmax</a> (x, brack=(-2, 2))</td></tr>
<tr class="separator:a7e11fd74ac89acf7920558617d8aa708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac40ff897f481883c947ea2fe777cb0f1" id="r_ac40ff897f481883c947ea2fe777cb0f1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac40ff897f481883c947ea2fe777cb0f1">yeojohnson_normplot</a> (x, la, lb, plot=None, N=80)</td></tr>
<tr class="separator:ac40ff897f481883c947ea2fe777cb0f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada353fe6934760152d3262990c5559c7" id="r_ada353fe6934760152d3262990c5559c7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada353fe6934760152d3262990c5559c7">shapiro</a> (x)</td></tr>
<tr class="separator:ada353fe6934760152d3262990c5559c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace3cdc76959a8d9ffcc7967db44a2c9d" id="r_ace3cdc76959a8d9ffcc7967db44a2c9d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace3cdc76959a8d9ffcc7967db44a2c9d">_weibull_fit_check</a> (params, x)</td></tr>
<tr class="separator:ace3cdc76959a8d9ffcc7967db44a2c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff42d8e60ef8d4a2e3e243fed9061df" id="r_a5ff42d8e60ef8d4a2e3e243fed9061df"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ff42d8e60ef8d4a2e3e243fed9061df">anderson</a> (x, dist='norm')</td></tr>
<tr class="separator:a5ff42d8e60ef8d4a2e3e243fed9061df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b8bfd0f7f8a99f24676999a1d6a1081" id="r_a9b8bfd0f7f8a99f24676999a1d6a1081"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b8bfd0f7f8a99f24676999a1d6a1081">_anderson_ksamp_midrank</a> (samples, Z, Zstar, k, n, N)</td></tr>
<tr class="separator:a9b8bfd0f7f8a99f24676999a1d6a1081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f372073d70d2d3a3e33676d615c0d72" id="r_a0f372073d70d2d3a3e33676d615c0d72"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f372073d70d2d3a3e33676d615c0d72">_anderson_ksamp_right</a> (samples, Z, Zstar, k, n, N)</td></tr>
<tr class="separator:a0f372073d70d2d3a3e33676d615c0d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af79e4786d193296d8337d4d138fde02b" id="r_af79e4786d193296d8337d4d138fde02b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af79e4786d193296d8337d4d138fde02b">anderson_ksamp</a> (samples, midrank=<a class="el" href="../../d8/d0b/classTrue.html">True</a>)</td></tr>
<tr class="separator:af79e4786d193296d8337d4d138fde02b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf0b043d4a34d9afcc7b63c4d80757e" id="r_a5cf0b043d4a34d9afcc7b63c4d80757e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5cf0b043d4a34d9afcc7b63c4d80757e">ansari</a> (x, y, alternative='two-sided')</td></tr>
<tr class="separator:a5cf0b043d4a34d9afcc7b63c4d80757e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ab9423e7e286b7c52654cf7333e897" id="r_a96ab9423e7e286b7c52654cf7333e897"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96ab9423e7e286b7c52654cf7333e897">bartlett</a> (*samples)</td></tr>
<tr class="separator:a96ab9423e7e286b7c52654cf7333e897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa23262638e4d8d639649530a5a7cf2d8" id="r_aa23262638e4d8d639649530a5a7cf2d8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa23262638e4d8d639649530a5a7cf2d8">levene</a> (*samples, center='median', proportiontocut=0.05)</td></tr>
<tr class="separator:aa23262638e4d8d639649530a5a7cf2d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9decd286dafd3e07427ade8321b3228c" id="r_a9decd286dafd3e07427ade8321b3228c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9decd286dafd3e07427ade8321b3228c">binom_test</a> (x, n=None, p=0.5, alternative='two-sided')</td></tr>
<tr class="separator:a9decd286dafd3e07427ade8321b3228c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8927546ed57b93755671f7132e54de2b" id="r_a8927546ed57b93755671f7132e54de2b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8927546ed57b93755671f7132e54de2b">_apply_func</a> (x, g, func)</td></tr>
<tr class="separator:a8927546ed57b93755671f7132e54de2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a978e827467d79fbfe254eea650472601" id="r_a978e827467d79fbfe254eea650472601"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a978e827467d79fbfe254eea650472601">fligner</a> (*samples, center='median', proportiontocut=0.05)</td></tr>
<tr class="separator:a978e827467d79fbfe254eea650472601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa8d37c155924a7c55dd9b66af6a0b2" id="r_adaa8d37c155924a7c55dd9b66af6a0b2"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adaa8d37c155924a7c55dd9b66af6a0b2">_mood_inner_lc</a> (xy, x, diffs, sorted_xy, n, m, N)</td></tr>
<tr class="separator:adaa8d37c155924a7c55dd9b66af6a0b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2a8c126360ffed1a47ea5ef24d67463" id="r_aa2a8c126360ffed1a47ea5ef24d67463"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa2a8c126360ffed1a47ea5ef24d67463">mood</a> (x, y, axis=0, alternative=&quot;two-sided&quot;)</td></tr>
<tr class="separator:aa2a8c126360ffed1a47ea5ef24d67463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a2739e0b0f2ef66fdfd2131664be94b" id="r_a6a2739e0b0f2ef66fdfd2131664be94b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a2739e0b0f2ef66fdfd2131664be94b">wilcoxon_result_unpacker</a> (res)</td></tr>
<tr class="separator:a6a2739e0b0f2ef66fdfd2131664be94b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66cb6178c9c02363490ed746438f8857" id="r_a66cb6178c9c02363490ed746438f8857"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66cb6178c9c02363490ed746438f8857">wilcoxon_result_object</a> (statistic, pvalue, zstatistic=None)</td></tr>
<tr class="separator:a66cb6178c9c02363490ed746438f8857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e6e371f0b3b6c73d4f678f59017343f" id="r_a5e6e371f0b3b6c73d4f678f59017343f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e6e371f0b3b6c73d4f678f59017343f">wilcoxon_outputs</a> (kwds)</td></tr>
<tr class="separator:a5e6e371f0b3b6c73d4f678f59017343f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf6be93729b9052a8ffa98d5a17f96f6" id="r_acf6be93729b9052a8ffa98d5a17f96f6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf6be93729b9052a8ffa98d5a17f96f6">wilcoxon</a> (x, y=None, zero_method=&quot;wilcox&quot;, correction=False, alternative=&quot;two-sided&quot;, method='auto')</td></tr>
<tr class="separator:acf6be93729b9052a8ffa98d5a17f96f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d69aee9a069d7a4cec2d2cc5ab55a6" id="r_aa9d69aee9a069d7a4cec2d2cc5ab55a6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9d69aee9a069d7a4cec2d2cc5ab55a6">median_test</a> (*samples, ties='below', correction=<a class="el" href="../../d8/d0b/classTrue.html">True</a>, lambda_=1, nan_policy='propagate')</td></tr>
<tr class="separator:aa9d69aee9a069d7a4cec2d2cc5ab55a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12523f3a8245cb3c28fb18704daff0ab" id="r_a12523f3a8245cb3c28fb18704daff0ab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12523f3a8245cb3c28fb18704daff0ab">_circfuncs_common</a> (samples, high, low, nan_policy='propagate')</td></tr>
<tr class="separator:a12523f3a8245cb3c28fb18704daff0ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39d886f881520f6b73d7bff6f071854" id="r_ad39d886f881520f6b73d7bff6f071854"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad39d886f881520f6b73d7bff6f071854">circmean</a> (samples, high=2 *pi, low=0, axis=None, nan_policy='propagate')</td></tr>
<tr class="separator:ad39d886f881520f6b73d7bff6f071854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b2d677962cb55b72b6eee1d4e84b79" id="r_ab2b2d677962cb55b72b6eee1d4e84b79"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2b2d677962cb55b72b6eee1d4e84b79">circvar</a> (samples, high=2 *pi, low=0, axis=None, nan_policy='propagate')</td></tr>
<tr class="separator:ab2b2d677962cb55b72b6eee1d4e84b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39e9339f87efa51e62139f66b9ec8fd6" id="r_a39e9339f87efa51e62139f66b9ec8fd6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39e9339f87efa51e62139f66b9ec8fd6">circstd</a> (samples, high=2 *pi, low=0, axis=None, nan_policy='propagate', *, normalize=False)</td></tr>
<tr class="separator:a39e9339f87efa51e62139f66b9ec8fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad264a00b701706f101fd11dd7bf4dfcc" id="r_ad264a00b701706f101fd11dd7bf4dfcc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad264a00b701706f101fd11dd7bf4dfcc">directional_stats</a> (samples, *, axis=0, normalize=<a class="el" href="../../d8/d0b/classTrue.html">True</a>)</td></tr>
<tr class="separator:ad264a00b701706f101fd11dd7bf4dfcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b6b5ed85f5460b956acdf054d182b69" id="r_a8b6b5ed85f5460b956acdf054d182b69"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b6b5ed85f5460b956acdf054d182b69">false_discovery_control</a> (ps, *, axis=0, method='bh')</td></tr>
<tr class="separator:a8b6b5ed85f5460b956acdf054d182b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:abf0f4fd772467873380775de27d522b8" id="r_abf0f4fd772467873380775de27d522b8"><td class="memItemLeft" align="right" valign="top">list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf0f4fd772467873380775de27d522b8">__all__</a></td></tr>
<tr class="separator:abf0f4fd772467873380775de27d522b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c7e806ff86e4c65ae6c3bb01070277d" id="r_a4c7e806ff86e4c65ae6c3bb01070277d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c7e806ff86e4c65ae6c3bb01070277d">Mean</a> = <a class="el" href="../../d7/d51/classnamedtuple.html">namedtuple</a>('Mean', ('statistic', '<a class="el" href="../../db/de6/classminmax.html">minmax</a>'))</td></tr>
<tr class="separator:a4c7e806ff86e4c65ae6c3bb01070277d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab3ea6ff622d79893687564827860de" id="r_abab3ea6ff622d79893687564827860de"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abab3ea6ff622d79893687564827860de">Variance</a> = <a class="el" href="../../d7/d51/classnamedtuple.html">namedtuple</a>('Variance', ('statistic', '<a class="el" href="../../db/de6/classminmax.html">minmax</a>'))</td></tr>
<tr class="separator:abab3ea6ff622d79893687564827860de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e0efb5926c36511cd250ae4ad4f517" id="r_ae5e0efb5926c36511cd250ae4ad4f517"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5e0efb5926c36511cd250ae4ad4f517">Std_dev</a> = <a class="el" href="../../d7/d51/classnamedtuple.html">namedtuple</a>('Std_dev', ('statistic', '<a class="el" href="../../db/de6/classminmax.html">minmax</a>'))</td></tr>
<tr class="separator:ae5e0efb5926c36511cd250ae4ad4f517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee599c9ef5b9c5cb6169a4073e4f652d" id="r_aee599c9ef5b9c5cb6169a4073e4f652d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee599c9ef5b9c5cb6169a4073e4f652d">ShapiroResult</a> = <a class="el" href="../../d7/d51/classnamedtuple.html">namedtuple</a>('ShapiroResult', ('statistic', 'pvalue'))</td></tr>
<tr class="separator:aee599c9ef5b9c5cb6169a4073e4f652d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd2ed9760a5b98dbc3fd333fc804528" id="r_a7cd2ed9760a5b98dbc3fd333fc804528"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7cd2ed9760a5b98dbc3fd333fc804528">_Avals_norm</a> = array([0.576, 0.656, 0.787, 0.918, 1.092])</td></tr>
<tr class="separator:a7cd2ed9760a5b98dbc3fd333fc804528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8549d509c0d1eeba1b065cbdf4639966" id="r_a8549d509c0d1eeba1b065cbdf4639966"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8549d509c0d1eeba1b065cbdf4639966">_Avals_expon</a> = array([0.922, 1.078, 1.341, 1.606, 1.957])</td></tr>
<tr class="separator:a8549d509c0d1eeba1b065cbdf4639966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a7e585a2cdac83e1d7baba82b355ecd" id="r_a4a7e585a2cdac83e1d7baba82b355ecd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a7e585a2cdac83e1d7baba82b355ecd">_Avals_gumbel</a> = array([0.474, 0.637, 0.757, 0.877, 1.038])</td></tr>
<tr class="separator:a4a7e585a2cdac83e1d7baba82b355ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa81d3b78fe67a51c6bea0ef06599d68b" id="r_aa81d3b78fe67a51c6bea0ef06599d68b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa81d3b78fe67a51c6bea0ef06599d68b">_Avals_logistic</a> = array([0.426, 0.563, 0.660, 0.769, 0.906, 1.010])</td></tr>
<tr class="separator:aa81d3b78fe67a51c6bea0ef06599d68b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10992db1e056da85f3087e90be78b5d3" id="r_a10992db1e056da85f3087e90be78b5d3"><td class="memItemLeft" align="right" valign="top">list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10992db1e056da85f3087e90be78b5d3">_Avals_weibull</a></td></tr>
<tr class="separator:a10992db1e056da85f3087e90be78b5d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5395ce168ae4cbc09a446fc54f69f47a" id="r_a5395ce168ae4cbc09a446fc54f69f47a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5395ce168ae4cbc09a446fc54f69f47a">_cvals_weibull</a> = np.linspace(0, 0.5, 11)</td></tr>
<tr class="separator:a5395ce168ae4cbc09a446fc54f69f47a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace023ed646db4e070b167dd34d0c1112" id="r_ace023ed646db4e070b167dd34d0c1112"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace023ed646db4e070b167dd34d0c1112">_get_As_weibull</a></td></tr>
<tr class="separator:ace023ed646db4e070b167dd34d0c1112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c2b948cf1b0b7f3e3a89f732d46a158" id="r_a4c2b948cf1b0b7f3e3a89f732d46a158"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c2b948cf1b0b7f3e3a89f732d46a158">AndersonResult</a></td></tr>
<tr class="separator:a4c2b948cf1b0b7f3e3a89f732d46a158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0d6fdc5a2cc8ffd86eb87a38bfa5ff" id="r_a0d0d6fdc5a2cc8ffd86eb87a38bfa5ff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d0d6fdc5a2cc8ffd86eb87a38bfa5ff">Anderson_ksampResult</a></td></tr>
<tr class="separator:a0d0d6fdc5a2cc8ffd86eb87a38bfa5ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2ca11a242ed6b7363bbcd987cb99719" id="r_ac2ca11a242ed6b7363bbcd987cb99719"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2ca11a242ed6b7363bbcd987cb99719">AnsariResult</a> = <a class="el" href="../../d7/d51/classnamedtuple.html">namedtuple</a>('AnsariResult', ('statistic', 'pvalue'))</td></tr>
<tr class="separator:ac2ca11a242ed6b7363bbcd987cb99719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07abc5dc6f5050cd6d367147d07ceab8" id="r_a07abc5dc6f5050cd6d367147d07ceab8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07abc5dc6f5050cd6d367147d07ceab8">_abw_state</a> = <a class="el" href="../../db/d8c/classscipy_1_1stats_1_1__morestats_1_1__ABW.html">_ABW</a>()</td></tr>
<tr class="separator:a07abc5dc6f5050cd6d367147d07ceab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a554d0b4564651ac511f77b4db7cedcbc" id="r_a554d0b4564651ac511f77b4db7cedcbc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a554d0b4564651ac511f77b4db7cedcbc">BartlettResult</a> = <a class="el" href="../../d7/d51/classnamedtuple.html">namedtuple</a>('BartlettResult', ('statistic', 'pvalue'))</td></tr>
<tr class="separator:a554d0b4564651ac511f77b4db7cedcbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aa85627e72f7e9cfaa3289858b4070b" id="r_a3aa85627e72f7e9cfaa3289858b4070b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3aa85627e72f7e9cfaa3289858b4070b">LeveneResult</a> = <a class="el" href="../../d7/d51/classnamedtuple.html">namedtuple</a>('LeveneResult', ('statistic', 'pvalue'))</td></tr>
<tr class="separator:a3aa85627e72f7e9cfaa3289858b4070b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5984334ae4ec091c625db36e4df5a0fc" id="r_a5984334ae4ec091c625db36e4df5a0fc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5984334ae4ec091c625db36e4df5a0fc">FlignerResult</a> = <a class="el" href="../../d7/d51/classnamedtuple.html">namedtuple</a>('FlignerResult', ('statistic', 'pvalue'))</td></tr>
<tr class="separator:a5984334ae4ec091c625db36e4df5a0fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55dc3765613b9ba274d8c8020459cf47" id="r_a55dc3765613b9ba274d8c8020459cf47"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55dc3765613b9ba274d8c8020459cf47">WilcoxonResult</a> = _make_tuple_bunch('WilcoxonResult', ['statistic', 'pvalue'])</td></tr>
<tr class="separator:a55dc3765613b9ba274d8c8020459cf47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6759d232a7b56059c1560724f99919cb" id="r_a6759d232a7b56059c1560724f99919cb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6759d232a7b56059c1560724f99919cb">MedianTestResult</a></td></tr>
<tr class="separator:a6759d232a7b56059c1560724f99919cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ac665132057e03a14ff3bb554fdc27555" name="ac665132057e03a14ff3bb554fdc27555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac665132057e03a14ff3bb554fdc27555">&#9670;&#160;</a></span>_add_axis_labels_title()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats._add_axis_labels_title </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>plot</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>xlabel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>ylabel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>title</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Helper function to add axes labels and a title to stats plots.</pre> 
<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l00466">466</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../db/d84/__morestats_8py_source.html#l01284">_normplot()</a>, <a class="el" href="../../db/d84/__morestats_8py_source.html#l00736">ppcc_plot()</a>, and <a class="el" href="../../db/d84/__morestats_8py_source.html#l00485">probplot()</a>.</p>

</div>
</div>
<a id="a9b8bfd0f7f8a99f24676999a1d6a1081" name="a9b8bfd0f7f8a99f24676999a1d6a1081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b8bfd0f7f8a99f24676999a1d6a1081">&#9670;&#160;</a></span>_anderson_ksamp_midrank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats._anderson_ksamp_midrank </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>samples</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>Z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>Zstar</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>N</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Compute A2akN equation 7 of Scholz and Stephens.

Parameters
----------
samples : sequence of 1-D array_like
    Array of sample arrays.
Z : array_like
    Sorted array of all observations.
Zstar : array_like
    Sorted array of unique observations.
k : int
    Number of samples.
n : array_like
    Number of observations in each sample.
N : int
    Total number of observations.

Returns
-------
A2aKN : float
    The A2aKN statistics of Scholz and Stephens 1987.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l02200">2200</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../db/d84/__morestats_8py_source.html#l02285">anderson_ksamp()</a>.</p>

</div>
</div>
<a id="a0f372073d70d2d3a3e33676d615c0d72" name="a0f372073d70d2d3a3e33676d615c0d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f372073d70d2d3a3e33676d615c0d72">&#9670;&#160;</a></span>_anderson_ksamp_right()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats._anderson_ksamp_right </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>samples</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>Z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>Zstar</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>N</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Compute A2akN equation 6 of Scholz &amp; Stephens.

Parameters
----------
samples : sequence of 1-D array_like
    Array of sample arrays.
Z : array_like
    Sorted array of all observations.
Zstar : array_like
    Sorted array of unique observations.
k : int
    Number of samples.
n : array_like
    Number of observations in each sample.
N : int
    Total number of observations.

Returns
-------
A2KN : float
    The A2KN statistics of Scholz and Stephens 1987.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l02243">2243</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../db/d84/__morestats_8py_source.html#l02285">anderson_ksamp()</a>.</p>

</div>
</div>
<a id="a8927546ed57b93755671f7132e54de2b" name="a8927546ed57b93755671f7132e54de2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8927546ed57b93755671f7132e54de2b">&#9670;&#160;</a></span>_apply_func()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats._apply_func </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l03294">3294</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

</div>
</div>
<a id="a9c8a5a2adc6fc9bd197a0e3109734353" name="a9c8a5a2adc6fc9bd197a0e3109734353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c8a5a2adc6fc9bd197a0e3109734353">&#9670;&#160;</a></span>_boxcox_conf_interval()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats._boxcox_conf_interval </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>lmax</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>alpha</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l00938">938</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

</div>
</div>
<a id="abcfc50b779d664d1fcc5437ae81b2118" name="abcfc50b779d664d1fcc5437ae81b2118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcfc50b779d664d1fcc5437ae81b2118">&#9670;&#160;</a></span>_calc_uniform_order_statistic_medians()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats._calc_uniform_order_statistic_medians </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Approximations of uniform order statistic medians.

Parameters
----------
n : int
    Sample size.

Returns
-------
v : 1d float array
    Approximations of the order statistic medians.

References
----------
.. [1] James J. Filliben, "The Probability Plot Correlation Coefficient
       Test for Normality", Technometrics, Vol. 17, pp. 111-117, 1975.

Examples
--------
Order statistics of the uniform distribution on the unit interval
are marginally distributed according to beta distributions.
The expectations of these order statistic are evenly spaced across
the interval, but the distributions are skewed in a way that
pushes the medians slightly towards the endpoints of the unit interval:

&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; n = 4
&gt;&gt;&gt; k = np.arange(1, n+1)
&gt;&gt;&gt; from scipy.stats import beta
&gt;&gt;&gt; a = k
&gt;&gt;&gt; b = n-k+1
&gt;&gt;&gt; beta.mean(a, b)
array([0.2, 0.4, 0.6, 0.8])
&gt;&gt;&gt; beta.median(a, b)
array([0.15910358, 0.38572757, 0.61427243, 0.84089642])

The Filliben approximation uses the exact medians of the smallest
and greatest order statistics, and the remaining medians are approximated
by points spread evenly across a sub-interval of the unit interval:

&gt;&gt;&gt; from scipy.stats._morestats import _calc_uniform_order_statistic_medians
&gt;&gt;&gt; _calc_uniform_order_statistic_medians(n)
array([0.15910358, 0.38545246, 0.61454754, 0.84089642])

This plot shows the skewed distributions of the order statistics
of a sample of size four from a uniform distribution on the unit interval:

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; x = np.linspace(0.0, 1.0, num=50, endpoint=True)
&gt;&gt;&gt; pdfs = [beta.pdf(x, a[i], b[i]) for i in range(n)]
&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; plt.plot(x, pdfs[0], x, pdfs[1], x, pdfs[2], x, pdfs[3])
</pre> 
<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l00372">372</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../db/d84/__morestats_8py_source.html#l01116">boxcox_normmax()</a>, <a class="el" href="../../db/d84/__morestats_8py_source.html#l00648">ppcc_max()</a>, and <a class="el" href="../../db/d84/__morestats_8py_source.html#l00485">probplot()</a>.</p>

</div>
</div>
<a id="a12523f3a8245cb3c28fb18704daff0ab" name="a12523f3a8245cb3c28fb18704daff0ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12523f3a8245cb3c28fb18704daff0ab">&#9670;&#160;</a></span>_circfuncs_common()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats._circfuncs_common </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>samples</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>high</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>low</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>nan_policy</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'propagate'</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l04410">4410</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

</div>
</div>
<a id="adaa8d37c155924a7c55dd9b66af6a0b2" name="adaa8d37c155924a7c55dd9b66af6a0b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaa8d37c155924a7c55dd9b66af6a0b2">&#9670;&#160;</a></span>_mood_inner_lc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> float scipy.stats._morestats._mood_inner_lc </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>xy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>diffs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>sorted_xy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>N</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l03584">3584</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

</div>
</div>
<a id="a0a8b65fc912abb046b5556527b32f09d" name="a0a8b65fc912abb046b5556527b32f09d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a8b65fc912abb046b5556527b32f09d">&#9670;&#160;</a></span>_normplot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats._normplot </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>method</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>la</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>lb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>plot</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>N</em></span><span class="paramdefsep"> = </span><span class="paramdefval">80</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Compute parameters for a Box-Cox or Yeo-Johnson normality plot,
optionally show it.

See `boxcox_normplot` or `yeojohnson_normplot` for details.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l01284">1284</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

<p class="reference">References <a class="el" href="../../db/d84/__morestats_8py_source.html#l00466">_add_axis_labels_title()</a>, and <a class="el" href="../../db/d84/__morestats_8py_source.html#l00485">probplot()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../db/d84/__morestats_8py_source.html#l01326">boxcox_normplot()</a>, and <a class="el" href="../../db/d84/__morestats_8py_source.html#l01669">yeojohnson_normplot()</a>.</p>

</div>
</div>
<a id="a15d1e13676d4afb1f3b54f0451af4a54" name="a15d1e13676d4afb1f3b54f0451af4a54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15d1e13676d4afb1f3b54f0451af4a54">&#9670;&#160;</a></span>_parse_dist_kw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats._parse_dist_kw </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>dist</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>enforce_subclass</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d8/d0b/classTrue.html">True</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Parse `dist` keyword.

Parameters
----------
dist : str or stats.distributions instance.
    Several functions take `dist` as a keyword, hence this utility
    function.
enforce_subclass : bool, optional
    If True (default), `dist` needs to be a
    `_distn_infrastructure.rv_generic` instance.
    It can sometimes be useful to set this keyword to False, if a function
    wants to accept objects that just look somewhat like such an instance
    (for example, they have a ``ppf`` method).
</pre> 
<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l00435">435</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../db/d84/__morestats_8py_source.html#l00648">ppcc_max()</a>, and <a class="el" href="../../db/d84/__morestats_8py_source.html#l00485">probplot()</a>.</p>

</div>
</div>
<a id="ace3cdc76959a8d9ffcc7967db44a2c9d" name="ace3cdc76959a8d9ffcc7967db44a2c9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace3cdc76959a8d9ffcc7967db44a2c9d">&#9670;&#160;</a></span>_weibull_fit_check()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats._weibull_fit_check </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>params</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l01925">1925</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

</div>
</div>
<a id="a94eddca00d1a762d16c27be928ed4fd2" name="a94eddca00d1a762d16c27be928ed4fd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94eddca00d1a762d16c27be928ed4fd2">&#9670;&#160;</a></span>_yeojohnson_transform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats._yeojohnson_transform </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>lmbda</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Returns `x` transformed by the Yeo-Johnson power transform with given
parameter `lmbda`.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l01485">1485</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../db/d84/__morestats_8py_source.html#l01394">yeojohnson()</a>, and <a class="el" href="../../db/d84/__morestats_8py_source.html#l01507">yeojohnson_llf()</a>.</p>

</div>
</div>
<a id="a5ff42d8e60ef8d4a2e3e243fed9061df" name="a5ff42d8e60ef8d4a2e3e243fed9061df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ff42d8e60ef8d4a2e3e243fed9061df">&#9670;&#160;</a></span>anderson()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.anderson </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>dist</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'norm'</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Anderson-Darling test for data coming from a particular distribution.

The Anderson-Darling test tests the null hypothesis that a sample is
drawn from a population that follows a particular distribution.
For the Anderson-Darling test, the critical values depend on
which distribution is being tested against.  This function works
for normal, exponential, logistic, weibull_min, or Gumbel (Extreme Value
Type I) distributions.

Parameters
----------
x : array_like
    Array of sample data.
dist : {'norm', 'expon', 'logistic', 'gumbel', 'gumbel_l', 'gumbel_r', 'extreme1', 'weibull_min'}, optional
    The type of distribution to test against.  The default is 'norm'.
    The names 'extreme1', 'gumbel_l' and 'gumbel' are synonyms for the
    same distribution.

Returns
-------
result : AndersonResult
    An object with the following attributes:

    statistic : float
        The Anderson-Darling test statistic.
    critical_values : list
        The critical values for this distribution.
    significance_level : list
        The significance levels for the corresponding critical values
        in percents.  The function returns critical values for a
        differing set of significance levels depending on the
        distribution that is being tested against.
    fit_result : `~scipy.stats._result_classes.FitResult`
        An object containing the results of fitting the distribution to
        the data.

See Also
--------
kstest : The Kolmogorov-Smirnov test for goodness-of-fit.

Notes
-----
Critical values provided are for the following significance levels:

normal/exponential
    15%, 10%, 5%, 2.5%, 1%
logistic
    25%, 10%, 5%, 2.5%, 1%, 0.5%
gumbel_l / gumbel_r
    25%, 10%, 5%, 2.5%, 1%
weibull_min
    50%, 25%, 15%, 10%, 5%, 2.5%, 1%, 0.5%

If the returned statistic is larger than these critical values then
for the corresponding significance level, the null hypothesis that
the data come from the chosen distribution can be rejected.
The returned statistic is referred to as 'A2' in the references.

For `weibull_min`, maximum likelihood estimation is known to be
challenging. If the test returns successfully, then the first order
conditions for a maximum likehood estimate have been verified and
the critical values correspond relatively well to the significance levels,
provided that the sample is sufficiently large (&gt;10 observations [7]).
However, for some data - especially data with no left tail - `anderson`
is likely to result in an error message. In this case, consider
performing a custom goodness of fit test using
`scipy.stats.monte_carlo_test`.

References
----------
.. [1] https://www.itl.nist.gov/div898/handbook/prc/section2/prc213.htm
.. [2] Stephens, M. A. (1974). EDF Statistics for Goodness of Fit and
       Some Comparisons, Journal of the American Statistical Association,
       Vol. 69, pp. 730-737.
.. [3] Stephens, M. A. (1976). Asymptotic Results for Goodness-of-Fit
       Statistics with Unknown Parameters, Annals of Statistics, Vol. 4,
       pp. 357-369.
.. [4] Stephens, M. A. (1977). Goodness of Fit for the Extreme Value
       Distribution, Biometrika, Vol. 64, pp. 583-588.
.. [5] Stephens, M. A. (1977). Goodness of Fit with Special Reference
       to Tests for Exponentiality , Technical Report No. 262,
       Department of Statistics, Stanford University, Stanford, CA.
.. [6] Stephens, M. A. (1979). Tests of Fit for the Logistic Distribution
       Based on the Empirical Distribution Function, Biometrika, Vol. 66,
       pp. 591-595.
.. [7] Richard A. Lockhart and Michael A. Stephens "Estimation and Tests of
       Fit for the Three-Parameter Weibull Distribution"
       Journal of the Royal Statistical Society.Series B(Methodological)
       Vol. 56, No. 3 (1994), pp. 491-500, Table 0.

Examples
--------
Test the null hypothesis that a random sample was drawn from a normal
distribution (with unspecified mean and standard deviation).

&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy.stats import anderson
&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; data = rng.random(size=35)
&gt;&gt;&gt; res = anderson(data)
&gt;&gt;&gt; res.statistic
0.8398018749744764
&gt;&gt;&gt; res.critical_values
array([0.527, 0.6  , 0.719, 0.839, 0.998])
&gt;&gt;&gt; res.significance_level
array([15. , 10. ,  5. ,  2.5,  1. ])

The value of the statistic (barely) exceeds the critical value associated
with a significance level of 2.5%, so the null hypothesis may be rejected
at a significance level of 2.5%, but not at a significance level of 1%.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l01995">1995</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

</div>
</div>
<a id="af79e4786d193296d8337d4d138fde02b" name="af79e4786d193296d8337d4d138fde02b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af79e4786d193296d8337d4d138fde02b">&#9670;&#160;</a></span>anderson_ksamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.anderson_ksamp </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>samples</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>midrank</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d8/d0b/classTrue.html">True</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The Anderson-Darling test for k-samples.

The k-sample Anderson-Darling test is a modification of the
one-sample Anderson-Darling test. It tests the null hypothesis
that k-samples are drawn from the same population without having
to specify the distribution function of that population. The
critical values depend on the number of samples.

Parameters
----------
samples : sequence of 1-D array_like
    Array of sample data in arrays.
midrank : bool, optional
    Type of Anderson-Darling test which is computed. Default
    (True) is the midrank test applicable to continuous and
    discrete populations. If False, the right side empirical
    distribution is used.

Returns
-------
res : Anderson_ksampResult
    An object containing attributes:

    statistic : float
        Normalized k-sample Anderson-Darling test statistic.
    critical_values : array
        The critical values for significance levels 25%, 10%, 5%, 2.5%, 1%,
        0.5%, 0.1%.
    pvalue : float
        The approximate p-value of the test. The value is floored / capped
        at 0.1% / 25%.

Raises
------
ValueError
    If less than 2 samples are provided, a sample is empty, or no
    distinct observations are in the samples.

See Also
--------
ks_2samp : 2 sample Kolmogorov-Smirnov test
anderson : 1 sample Anderson-Darling test

Notes
-----
[1]_ defines three versions of the k-sample Anderson-Darling test:
one for continuous distributions and two for discrete
distributions, in which ties between samples may occur. The
default of this routine is to compute the version based on the
midrank empirical distribution function. This test is applicable
to continuous and discrete data. If midrank is set to False, the
right side empirical distribution is used for a test for discrete
data. According to [1]_, the two discrete test statistics differ
only slightly if a few collisions due to round-off errors occur in
the test not adjusted for ties between samples.

The critical values corresponding to the significance levels from 0.01
to 0.25 are taken from [1]_. p-values are floored / capped
at 0.1% / 25%. Since the range of critical values might be extended in
future releases, it is recommended not to test ``p == 0.25``, but rather
``p &gt;= 0.25`` (analogously for the lower bound).

.. versionadded:: 0.14.0

References
----------
.. [1] Scholz, F. W and Stephens, M. A. (1987), K-Sample
       Anderson-Darling Tests, Journal of the American Statistical
       Association, Vol. 82, pp. 918-924.

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; res = stats.anderson_ksamp([rng.normal(size=50),
... rng.normal(loc=0.5, size=30)])
&gt;&gt;&gt; res.statistic, res.pvalue
(1.974403288713695, 0.04991293614572478)
&gt;&gt;&gt; res.critical_values
array([0.325, 1.226, 1.961, 2.718, 3.752, 4.592, 6.546])

The null hypothesis that the two random samples come from the same
distribution can be rejected at the 5% level because the returned
test value is greater than the critical value for 5% (1.961) but
not at the 2.5% level. The interpolation gives an approximate
p-value of 4.99%.

&gt;&gt;&gt; res = stats.anderson_ksamp([rng.normal(size=50),
... rng.normal(size=30), rng.normal(size=20)])
&gt;&gt;&gt; res.statistic, res.pvalue
(-0.29103725200789504, 0.25)
&gt;&gt;&gt; res.critical_values
array([ 0.44925884,  1.3052767 ,  1.9434184 ,  2.57696569,  3.41634856,
  4.07210043, 5.56419101])

The null hypothesis cannot be rejected for three samples from an
identical distribution. The reported p-value (25%) has been capped and
may not be very accurate (since it corresponds to the value 0.449
whereas the statistic is -0.291).
</pre> 
<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l02285">2285</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

<p class="reference">References <a class="el" href="../../db/d84/__morestats_8py_source.html#l02200">_anderson_ksamp_midrank()</a>, and <a class="el" href="../../db/d84/__morestats_8py_source.html#l02243">_anderson_ksamp_right()</a>.</p>

</div>
</div>
<a id="a5cf0b043d4a34d9afcc7b63c4d80757e" name="a5cf0b043d4a34d9afcc7b63c4d80757e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cf0b043d4a34d9afcc7b63c4d80757e">&#9670;&#160;</a></span>ansari()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.ansari </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>alternative</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'two-sided'</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Perform the Ansari-Bradley test for equal scale parameters.

The Ansari-Bradley test ([1]_, [2]_) is a non-parametric test
for the equality of the scale parameter of the distributions
from which two samples were drawn. The null hypothesis states that
the ratio of the scale of the distribution underlying `x` to the scale
of the distribution underlying `y` is 1.

Parameters
----------
x, y : array_like
    Arrays of sample data.
alternative : {'two-sided', 'less', 'greater'}, optional
    Defines the alternative hypothesis. Default is 'two-sided'.
    The following options are available:

    * 'two-sided': the ratio of scales is not equal to 1.
    * 'less': the ratio of scales is less than 1.
    * 'greater': the ratio of scales is greater than 1.

    .. versionadded:: 1.7.0

Returns
-------
statistic : float
    The Ansari-Bradley test statistic.
pvalue : float
    The p-value of the hypothesis test.

See Also
--------
fligner : A non-parametric test for the equality of k variances
mood : A non-parametric test for the equality of two scale parameters

Notes
-----
The p-value given is exact when the sample sizes are both less than
55 and there are no ties, otherwise a normal approximation for the
p-value is used.

References
----------
.. [1] Ansari, A. R. and Bradley, R. A. (1960) Rank-sum tests for
       dispersions, Annals of Mathematical Statistics, 31, 1174-1189.
.. [2] Sprent, Peter and N.C. Smeeton.  Applied nonparametric
       statistical methods.  3rd ed. Chapman and Hall/CRC. 2001.
       Section 5.8.2.
.. [3] Nathaniel E. Helwig "Nonparametric Dispersion and Equality
       Tests" at http://users.stat.umn.edu/~helwig/notes/npde-Notes.pdf

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy.stats import ansari
&gt;&gt;&gt; rng = np.random.default_rng()

For these examples, we'll create three random data sets.  The first
two, with sizes 35 and 25, are drawn from a normal distribution with
mean 0 and standard deviation 2.  The third data set has size 25 and
is drawn from a normal distribution with standard deviation 1.25.

&gt;&gt;&gt; x1 = rng.normal(loc=0, scale=2, size=35)
&gt;&gt;&gt; x2 = rng.normal(loc=0, scale=2, size=25)
&gt;&gt;&gt; x3 = rng.normal(loc=0, scale=1.25, size=25)

First we apply `ansari` to `x1` and `x2`.  These samples are drawn
from the same distribution, so we expect the Ansari-Bradley test
should not lead us to conclude that the scales of the distributions
are different.

&gt;&gt;&gt; ansari(x1, x2)
AnsariResult(statistic=541.0, pvalue=0.9762532927399098)

With a p-value close to 1, we cannot conclude that there is a
significant difference in the scales (as expected).

Now apply the test to `x1` and `x3`:

&gt;&gt;&gt; ansari(x1, x3)
AnsariResult(statistic=425.0, pvalue=0.0003087020407974518)

The probability of observing such an extreme value of the statistic
under the null hypothesis of equal scales is only 0.03087%. We take this
as evidence against the null hypothesis in favor of the alternative:
the scales of the distributions from which the samples were drawn
are not equal.

We can use the `alternative` parameter to perform a one-tailed test.
In the above example, the scale of `x1` is greater than `x3` and so
the ratio of scales of `x1` and `x3` is greater than 1. This means
that the p-value when ``alternative='greater'`` should be near 0 and
hence we should be able to reject the null hypothesis:

&gt;&gt;&gt; ansari(x1, x3, alternative='greater')
AnsariResult(statistic=425.0, pvalue=0.0001543510203987259)

As we can see, the p-value is indeed quite low. Use of
``alternative='less'`` should thus yield a large p-value:

&gt;&gt;&gt; ansari(x1, x3, alternative='less')
AnsariResult(statistic=425.0, pvalue=0.9998643258449039)
</pre> 
<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l02511">2511</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

<p class="reference">References <a class="el" href="../../df/da7/__stats__py_8py_source.html#l01415">scipy.stats._stats_py._normtest_finish()</a>.</p>

</div>
</div>
<a id="a96ab9423e7e286b7c52654cf7333e897" name="a96ab9423e7e286b7c52654cf7333e897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96ab9423e7e286b7c52654cf7333e897">&#9670;&#160;</a></span>bartlett()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.bartlett </td>
          <td>(</td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em>samples</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Perform Bartlett's test for equal variances.

Bartlett's test tests the null hypothesis that all input samples
are from populations with equal variances.  For samples
from significantly non-normal populations, Levene's test
`levene` is more robust.

Parameters
----------
sample1, sample2, ... : array_like
    arrays of sample data.  Only 1d arrays are accepted, they may have
    different lengths.

Returns
-------
statistic : float
    The test statistic.
pvalue : float
    The p-value of the test.

See Also
--------
fligner : A non-parametric test for the equality of k variances
levene : A robust parametric test for equality of k variances

Notes
-----
Conover et al. (1981) examine many of the existing parametric and
nonparametric tests by extensive simulations and they conclude that the
tests proposed by Fligner and Killeen (1976) and Levene (1960) appear to be
superior in terms of robustness of departures from normality and power
([3]_).

References
----------
.. [1]  https://www.itl.nist.gov/div898/handbook/eda/section3/eda357.htm
.. [2]  Snedecor, George W. and Cochran, William G. (1989), Statistical
          Methods, Eighth Edition, Iowa State University Press.
.. [3] Park, C. and Lindsay, B. G. (1999). Robust Scale Estimation and
       Hypothesis Testing based on Quadratic Inference Function. Technical
       Report #99-03, Center for Likelihood Studies, Pennsylvania State
       University.
.. [4] Bartlett, M. S. (1937). Properties of Sufficiency and Statistical
       Tests. Proceedings of the Royal Society of London. Series A,
       Mathematical and Physical Sciences, Vol. 160, No.901, pp. 268-282.
.. [5] C.I. BLISS (1952), The Statistics of Bioassay: With Special
       Reference to the Vitamins, pp 499-503,
       :doi:`10.1016/C2013-0-12584-6`.
.. [6] B. Phipson and G. K. Smyth. "Permutation P-values Should Never Be
       Zero: Calculating Exact P-values When Permutations Are Randomly
       Drawn." Statistical Applications in Genetics and Molecular Biology
       9.1 (2010).
.. [7] Ludbrook, J., &amp; Dudley, H. (1998). Why permutation tests are
       superior to t and F tests in biomedical research. The American
       Statistician, 52(2), 127-132.

Examples
--------
In [5]_, the influence of vitamin C on the tooth growth of guinea pigs
was investigated. In a control study, 60 subjects were divided into
small dose, medium dose, and large dose groups that received
daily doses of 0.5, 1.0 and 2.0 mg of vitamin C, respectively.
After 42 days, the tooth growth was measured.

The ``small_dose``, ``medium_dose``, and ``large_dose`` arrays below record
tooth growth measurements of the three groups in microns.

&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; small_dose = np.array([
...     4.2, 11.5, 7.3, 5.8, 6.4, 10, 11.2, 11.2, 5.2, 7,
...     15.2, 21.5, 17.6, 9.7, 14.5, 10, 8.2, 9.4, 16.5, 9.7
... ])
&gt;&gt;&gt; medium_dose = np.array([
...     16.5, 16.5, 15.2, 17.3, 22.5, 17.3, 13.6, 14.5, 18.8, 15.5,
...     19.7, 23.3, 23.6, 26.4, 20, 25.2, 25.8, 21.2, 14.5, 27.3
... ])
&gt;&gt;&gt; large_dose = np.array([
...     23.6, 18.5, 33.9, 25.5, 26.4, 32.5, 26.7, 21.5, 23.3, 29.5,
...     25.5, 26.4, 22.4, 24.5, 24.8, 30.9, 26.4, 27.3, 29.4, 23
... ])

The `bartlett` statistic is sensitive to differences in variances
between the samples.

&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; res = stats.bartlett(small_dose, medium_dose, large_dose)
&gt;&gt;&gt; res.statistic
0.6654670663030519

The value of the statistic tends to be high when there is a large
difference in variances.

We can test for inequality of variance among the groups by comparing the
observed value of the statistic against the null distribution: the
distribution of statistic values derived under the null hypothesis that
the population variances of the three groups are equal.

For this test, the null distribution follows the chi-square distribution
as shown below.

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; k = 3  # number of samples
&gt;&gt;&gt; dist = stats.chi2(df=k-1)
&gt;&gt;&gt; val = np.linspace(0, 5, 100)
&gt;&gt;&gt; pdf = dist.pdf(val)
&gt;&gt;&gt; fig, ax = plt.subplots(figsize=(8, 5))
&gt;&gt;&gt; def plot(ax):  # we'll re-use this
...     ax.plot(val, pdf, color='C0')
...     ax.set_title("Bartlett Test Null Distribution")
...     ax.set_xlabel("statistic")
...     ax.set_ylabel("probability density")
...     ax.set_xlim(0, 5)
...     ax.set_ylim(0, 1)
&gt;&gt;&gt; plot(ax)
&gt;&gt;&gt; plt.show()

The comparison is quantified by the p-value: the proportion of values in
the null distribution greater than or equal to the observed value of the
statistic.

&gt;&gt;&gt; fig, ax = plt.subplots(figsize=(8, 5))
&gt;&gt;&gt; plot(ax)
&gt;&gt;&gt; pvalue = dist.sf(res.statistic)
&gt;&gt;&gt; annotation = (f'p-value={pvalue:.3f}\n(shaded area)')
&gt;&gt;&gt; props = dict(facecolor='black', width=1, headwidth=5, headlength=8)
&gt;&gt;&gt; _ = ax.annotate(annotation, (1.5, 0.22), (2.25, 0.3), arrowprops=props)
&gt;&gt;&gt; i = val &gt;= res.statistic
&gt;&gt;&gt; ax.fill_between(val[i], y1=0, y2=pdf[i], color='C0')
&gt;&gt;&gt; plt.show()

&gt;&gt;&gt; res.pvalue
0.71696121509966

If the p-value is "small" - that is, if there is a low probability of
sampling data from distributions with identical variances that produces
such an extreme value of the statistic - this may be taken as evidence
against the null hypothesis in favor of the alternative: the variances of
the groups are not equal. Note that:

- The inverse is not true; that is, the test is not used to provide
  evidence for the null hypothesis.
- The threshold for values that will be considered "small" is a choice that
  should be made before the data is analyzed [6]_ with consideration of the
  risks of both false positives (incorrectly rejecting the null hypothesis)
  and false negatives (failure to reject a false null hypothesis).
- Small p-values are not evidence for a *large* effect; rather, they can
  only provide evidence for a "significant" effect, meaning that they are
  unlikely to have occurred under the null hypothesis.

Note that the chi-square distribution provides the null distribution
when the observations are normally distributed. For small samples
drawn from non-normal populations, it may be more appropriate to
perform a
permutation test: Under the null hypothesis that all three samples were
drawn from the same population, each of the measurements is equally likely
to have been observed in any of the three samples. Therefore, we can form
a randomized null distribution by calculating the statistic under many
randomly-generated partitionings of the observations into the three
samples.

&gt;&gt;&gt; def statistic(*samples):
...     return stats.bartlett(*samples).statistic
&gt;&gt;&gt; ref = stats.permutation_test(
...     (small_dose, medium_dose, large_dose), statistic,
...     permutation_type='independent', alternative='greater'
... )
&gt;&gt;&gt; fig, ax = plt.subplots(figsize=(8, 5))
&gt;&gt;&gt; plot(ax)
&gt;&gt;&gt; bins = np.linspace(0, 5, 25)
&gt;&gt;&gt; ax.hist(
...     ref.null_distribution, bins=bins, density=True, facecolor="C1"
... )
&gt;&gt;&gt; ax.legend(['aymptotic approximation\n(many observations)',
...            'randomized null distribution'])
&gt;&gt;&gt; plot(ax)
&gt;&gt;&gt; plt.show()

&gt;&gt;&gt; ref.pvalue  # randomized test p-value
0.5387  # may vary

Note that there is significant disagreement between the p-value calculated
here and the asymptotic approximation returned by `bartlett` above.
The statistical inferences that can be drawn rigorously from a permutation
test are limited; nonetheless, they may be the preferred approach in many
circumstances [7]_.

Following is another generic example where the null hypothesis would be
rejected.

Test whether the lists `a`, `b` and `c` come from populations
with equal variances.

&gt;&gt;&gt; a = [8.88, 9.12, 9.04, 8.98, 9.00, 9.08, 9.01, 8.85, 9.06, 8.99]
&gt;&gt;&gt; b = [8.88, 8.95, 9.29, 9.44, 9.15, 9.58, 8.36, 9.18, 8.67, 9.05]
&gt;&gt;&gt; c = [8.95, 9.12, 8.95, 8.85, 9.03, 8.84, 9.07, 8.98, 8.86, 8.98]
&gt;&gt;&gt; stat, p = stats.bartlett(a, b, c)
&gt;&gt;&gt; p
1.1254782518834628e-05

The very small p-value suggests that the populations do not have equal
variances.

This is not surprising, given that the sample variance of `b` is much
larger than that of `a` and `c`:

&gt;&gt;&gt; [np.var(x, ddof=1) for x in [a, b, c]]
[0.007054444444444413, 0.13073888888888888, 0.008890000000000002]
</pre> 
<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l02674">2674</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

</div>
</div>
<a id="aa18cb0ea658376fef0b14314b7681611" name="aa18cb0ea658376fef0b14314b7681611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa18cb0ea658376fef0b14314b7681611">&#9670;&#160;</a></span>bayes_mvs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.bayes_mvs </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>alpha</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.90</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">    Bayesian confidence intervals for the mean, var, and std.

    Parameters
    ----------
    data : array_like
        Input data, if multi-dimensional it is flattened to 1-D by `bayes_mvs`.
        Requires 2 or more data points.
    alpha : float, optional
        Probability that the returned confidence interval contains
        the true parameter.

    Returns
    -------
    mean_cntr, var_cntr, std_cntr : tuple
        The three results are for the mean, variance and standard deviation,
        respectively.  Each result is a tuple of the form::

            (center, (lower, upper))

        with `center` the mean of the conditional pdf of the value given the
        data, and `(lower, upper)` a confidence interval, centered on the
        median, containing the estimate to a probability ``alpha``.

    See Also
    --------
    mvsdist

    Notes
    -----
    Each tuple of mean, variance, and standard deviation estimates represent
    the (center, (lower, upper)) with center the mean of the conditional pdf
    of the value given the data and (lower, upper) is a confidence interval
    centered on the median, containing the estimate to a probability
    ``alpha``.

    Converts data to 1-D and assumes all data has the same mean and variance.
    Uses Jeffrey's prior for variance and std.

    Equivalent to ``tuple((x.mean(), x.interval(alpha)) for x in mvsdist(dat))``

    References
    ----------
    T.E. Oliphant, "A Bayesian perspective on estimating mean, variance, and
    standard-deviation from data", https://scholarsarchive.byu.edu/facpub/278,
    2006.

    Examples
    --------
    First a basic example to demonstrate the outputs:

    &gt;&gt;&gt; from scipy import stats
    &gt;&gt;&gt; data = [6, 9, 12, 7, 8, 8, 13]
    &gt;&gt;&gt; mean, var, std = stats.bayes_mvs(data)
    &gt;&gt;&gt; mean
    Mean(statistic=9.0, minmax=(7.103650222612533, 10.896349777387467))
    &gt;&gt;&gt; var
    Variance(statistic=10.0, minmax=(3.176724206..., 24.45910382...))
    &gt;&gt;&gt; std
    Std_dev(statistic=2.9724954732045084, minmax=(1.7823367265645143, 4.945614605014631))

    Now we generate some normally distributed random data, and get estimates of
    mean and standard deviation with 95% confidence intervals for those
    estimates:

    &gt;&gt;&gt; n_samples = 100000
    &gt;&gt;&gt; data = stats.norm.rvs(size=n_samples)
    &gt;&gt;&gt; res_mean, res_var, res_std = stats.bayes_mvs(data, alpha=0.95)

    &gt;&gt;&gt; import matplotlib.pyplot as plt
    &gt;&gt;&gt; fig = plt.figure()
    &gt;&gt;&gt; ax = fig.add_subplot(111)
    &gt;&gt;&gt; ax.hist(data, bins=100, density=True, label='Histogram of data')
    &gt;&gt;&gt; ax.vlines(res_mean.statistic, 0, 0.5, colors='r', label='Estimated mean')
    &gt;&gt;&gt; ax.axvspan(res_mean.minmax[0],res_mean.minmax[1], facecolor='r',
    ...            alpha=0.2, label=r'Estimated mean (95% limits)')
    &gt;&gt;&gt; ax.vlines(res_std.statistic, 0, 0.5, colors='g', label='Estimated scale')
    &gt;&gt;&gt; ax.axvspan(res_std.minmax[0],res_std.minmax[1], facecolor='g', alpha=0.2,
    ...            label=r'Estimated scale (95% limits)')

    &gt;&gt;&gt; ax.legend(fontsize=10)
    &gt;&gt;&gt; ax.set_xlim([-4, 4])
    &gt;&gt;&gt; ax.set_ylim([0, 0.5])
    &gt;&gt;&gt; plt.show()
</pre> 
<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l00045">45</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

<p class="reference">References <a class="el" href="../../db/d84/__morestats_8py_source.html#l00144">mvsdist()</a>.</p>

</div>
</div>
<a id="a9decd286dafd3e07427ade8321b3228c" name="a9decd286dafd3e07427ade8321b3228c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9decd286dafd3e07427ade8321b3228c">&#9670;&#160;</a></span>binom_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.binom_test </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>p</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.5</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>alternative</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'two-sided'</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Perform a test that the probability of success is p.

This is an exact, two-sided test of the null hypothesis
that the probability of success in a Bernoulli experiment
is `p`.

.. deprecated:: 1.10.0
    `binom_test` is deprecated in favour of `binomtest` and will
    be removed in Scipy 1.12.0.

Parameters
----------
x : int or array_like
    The number of successes, or if x has length 2, it is the
    number of successes and the number of failures.
n : int
    The number of trials.  This is ignored if x gives both the
    number of successes and failures.
p : float, optional
    The hypothesized probability of success.  ``0 &lt;= p &lt;= 1``. The
    default value is ``p = 0.5``.
alternative : {'two-sided', 'greater', 'less'}, optional
    Indicates the alternative hypothesis. The default value is
    'two-sided'.

Returns
-------
p-value : float
    The p-value of the hypothesis test.

References
----------
.. [1] https://en.wikipedia.org/wiki/Binomial_test

Examples
--------
&gt;&gt;&gt; from scipy import stats

A car manufacturer claims that no more than 10% of their cars are unsafe.
15 cars are inspected for safety, 3 were found to be unsafe. Test the
manufacturer's claim:

&gt;&gt;&gt; stats.binom_test(3, n=15, p=0.1, alternative='greater')
0.18406106910639114

The null hypothesis cannot be rejected at the 5% level of significance
because the returned p-value is greater than the critical value of 5%.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l03197">3197</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

</div>
</div>
<a id="a8927cc8608f6decd26a9fe23214071e1" name="a8927cc8608f6decd26a9fe23214071e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8927cc8608f6decd26a9fe23214071e1">&#9670;&#160;</a></span>boxcox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.boxcox </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>lmbda</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>alpha</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>optimizer</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a dataset transformed by a Box-Cox power transformation.

Parameters
----------
x : ndarray
    Input array to be transformed.

    If `lmbda` is not None, this is an alias of
    `scipy.special.boxcox`.
    Returns nan if ``x &lt; 0``; returns -inf if ``x == 0 and lmbda &lt; 0``.

    If `lmbda` is None, array must be positive, 1-dimensional, and
    non-constant.

lmbda : scalar, optional
    If `lmbda` is None (default), find the value of `lmbda` that maximizes
    the log-likelihood function and return it as the second output
    argument.

    If `lmbda` is not None, do the transformation for that value.

alpha : float, optional
    If `lmbda` is None and `alpha` is not None (default), return the
    ``100 * (1-alpha)%`` confidence  interval for `lmbda` as the third
    output argument. Must be between 0.0 and 1.0.

    If `lmbda` is not None, `alpha` is ignored.
optimizer : callable, optional
    If `lmbda` is None, `optimizer` is the scalar optimizer used to find
    the value of `lmbda` that minimizes the negative log-likelihood
    function. `optimizer` is a callable that accepts one argument:

    fun : callable
        The objective function, which evaluates the negative
        log-likelihood function at a provided value of `lmbda`

    and returns an object, such as an instance of
    `scipy.optimize.OptimizeResult`, which holds the optimal value of
    `lmbda` in an attribute `x`.

    See the example in `boxcox_normmax` or the documentation of
    `scipy.optimize.minimize_scalar` for more information.

    If `lmbda` is not None, `optimizer` is ignored.

Returns
-------
boxcox : ndarray
    Box-Cox power transformed array.
maxlog : float, optional
    If the `lmbda` parameter is None, the second returned argument is
    the `lmbda` that maximizes the log-likelihood function.
(min_ci, max_ci) : tuple of float, optional
    If `lmbda` parameter is None and `alpha` is not None, this returned
    tuple of floats represents the minimum and maximum confidence limits
    given `alpha`.

See Also
--------
probplot, boxcox_normplot, boxcox_normmax, boxcox_llf

Notes
-----
The Box-Cox transform is given by::

    y = (x**lmbda - 1) / lmbda,  for lmbda != 0
        log(x),                  for lmbda = 0

`boxcox` requires the input data to be positive.  Sometimes a Box-Cox
transformation provides a shift parameter to achieve this; `boxcox` does
not.  Such a shift parameter is equivalent to adding a positive constant to
`x` before calling `boxcox`.

The confidence limits returned when `alpha` is provided give the interval
where:

.. math::

    llf(\hat{\lambda}) - llf(\lambda) &lt; \frac{1}{2}\chi^2(1 - \alpha, 1),

with ``llf`` the log-likelihood function and :math:`\chi^2` the chi-squared
function.

References
----------
G.E.P. Box and D.R. Cox, "An Analysis of Transformations", Journal of the
Royal Statistical Society B, 26, 211-252 (1964).

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; import matplotlib.pyplot as plt

We generate some random variates from a non-normal distribution and make a
probability plot for it, to show it is non-normal in the tails:

&gt;&gt;&gt; fig = plt.figure()
&gt;&gt;&gt; ax1 = fig.add_subplot(211)
&gt;&gt;&gt; x = stats.loggamma.rvs(5, size=500) + 5
&gt;&gt;&gt; prob = stats.probplot(x, dist=stats.norm, plot=ax1)
&gt;&gt;&gt; ax1.set_xlabel('')
&gt;&gt;&gt; ax1.set_title('Probplot against normal distribution')

We now use `boxcox` to transform the data so it's closest to normal:

&gt;&gt;&gt; ax2 = fig.add_subplot(212)
&gt;&gt;&gt; xt, _ = stats.boxcox(x)
&gt;&gt;&gt; prob = stats.probplot(xt, dist=stats.norm, plot=ax2)
&gt;&gt;&gt; ax2.set_title('Probplot after Box-Cox transformation')

&gt;&gt;&gt; plt.show()
</pre> 
<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l00973">973</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

<p class="reference">References <a class="el" href="../../db/d84/__morestats_8py_source.html#l00973">boxcox()</a>, and <a class="el" href="../../db/d84/__morestats_8py_source.html#l01116">boxcox_normmax()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../db/d84/__morestats_8py_source.html#l00973">boxcox()</a>, and <a class="el" href="../../db/d84/__morestats_8py_source.html#l01116">boxcox_normmax()</a>.</p>

</div>
</div>
<a id="a93d168816d9c396b378a0d0d15544b56" name="a93d168816d9c396b378a0d0d15544b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93d168816d9c396b378a0d0d15544b56">&#9670;&#160;</a></span>boxcox_llf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.boxcox_llf </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>lmb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The boxcox log-likelihood function.

Parameters
----------
lmb : scalar
    Parameter for Box-Cox transformation.  See `boxcox` for details.
data : array_like
    Data to calculate Box-Cox log-likelihood for.  If `data` is
    multi-dimensional, the log-likelihood is calculated along the first
    axis.

Returns
-------
llf : float or ndarray
    Box-Cox log-likelihood of `data` given `lmb`.  A float for 1-D `data`,
    an array otherwise.

See Also
--------
boxcox, probplot, boxcox_normplot, boxcox_normmax

Notes
-----
The Box-Cox log-likelihood function is defined here as

.. math::

    llf = (\lambda - 1) \sum_i(\log(x_i)) -
          N/2 \log(\sum_i (y_i - \bar{y})^2 / N),

where ``y`` is the Box-Cox transformed input data ``x``.

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; from mpl_toolkits.axes_grid1.inset_locator import inset_axes

Generate some random variates and calculate Box-Cox log-likelihood values
for them for a range of ``lmbda`` values:

&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; x = stats.loggamma.rvs(5, loc=10, size=1000, random_state=rng)
&gt;&gt;&gt; lmbdas = np.linspace(-2, 10)
&gt;&gt;&gt; llf = np.zeros(lmbdas.shape, dtype=float)
&gt;&gt;&gt; for ii, lmbda in enumerate(lmbdas):
...     llf[ii] = stats.boxcox_llf(lmbda, x)

Also find the optimal lmbda value with `boxcox`:

&gt;&gt;&gt; x_most_normal, lmbda_optimal = stats.boxcox(x)

Plot the log-likelihood as function of lmbda.  Add the optimal lmbda as a
horizontal line to check that that's really the optimum:

&gt;&gt;&gt; fig = plt.figure()
&gt;&gt;&gt; ax = fig.add_subplot(111)
&gt;&gt;&gt; ax.plot(lmbdas, llf, 'b.-')
&gt;&gt;&gt; ax.axhline(stats.boxcox_llf(lmbda_optimal, x), color='r')
&gt;&gt;&gt; ax.set_xlabel('lmbda parameter')
&gt;&gt;&gt; ax.set_ylabel('Box-Cox log-likelihood')

Now add some probability plots to show that where the log-likelihood is
maximized the data transformed with `boxcox` looks closest to normal:

&gt;&gt;&gt; locs = [3, 10, 4]  # 'lower left', 'center', 'lower right'
&gt;&gt;&gt; for lmbda, loc in zip([-1, lmbda_optimal, 9], locs):
...     xt = stats.boxcox(x, lmbda=lmbda)
...     (osm, osr), (slope, intercept, r_sq) = stats.probplot(xt)
...     ax_inset = inset_axes(ax, width="20%", height="20%", loc=loc)
...     ax_inset.plot(osm, osr, 'c.', osm, slope*osm + intercept, 'k-')
...     ax_inset.set_xticklabels([])
...     ax_inset.set_yticklabels([])
...     ax_inset.set_title(r'$\lambda=%1.2f$' % lmbda)

&gt;&gt;&gt; plt.show()
</pre> 
<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l00839">839</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

<p class="reference">References <a class="el" href="../../db/d84/__morestats_8py_source.html#l00839">boxcox_llf()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../db/d84/__morestats_8py_source.html#l00839">boxcox_llf()</a>, and <a class="el" href="../../db/d84/__morestats_8py_source.html#l01116">boxcox_normmax()</a>.</p>

</div>
</div>
<a id="ae6e99833f0ddea425698e0590079d2d9" name="ae6e99833f0ddea425698e0590079d2d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6e99833f0ddea425698e0590079d2d9">&#9670;&#160;</a></span>boxcox_normmax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.boxcox_normmax </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>brack</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>method</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'<a class="el" href="../../da/d20/namespacescipy_1_1stats_1_1__stats__py.html#a8b002f05757020441e68edf9441f3c7f">pearsonr</a>'</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>optimizer</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute optimal Box-Cox transform parameter for input data.

Parameters
----------
x : array_like
    Input array.
brack : 2-tuple, optional, default (-2.0, 2.0)
     The starting interval for a downhill bracket search for the default
     `optimize.brent` solver. Note that this is in most cases not
     critical; the final result is allowed to be outside this bracket.
     If `optimizer` is passed, `brack` must be None.
method : str, optional
    The method to determine the optimal transform parameter (`boxcox`
    ``lmbda`` parameter). Options are:

    'pearsonr'  (default)
        Maximizes the Pearson correlation coefficient between
        ``y = boxcox(x)`` and the expected values for ``y`` if `x` would be
        normally-distributed.

    'mle'
        Minimizes the log-likelihood `boxcox_llf`.  This is the method used
        in `boxcox`.

    'all'
        Use all optimization methods available, and return all results.
        Useful to compare different methods.
optimizer : callable, optional
    `optimizer` is a callable that accepts one argument:

    fun : callable
        The objective function to be optimized. `fun` accepts one argument,
        the Box-Cox transform parameter `lmbda`, and returns the negative
        log-likelihood function at the provided value. The job of `optimizer`
        is to find the value of `lmbda` that minimizes `fun`.

    and returns an object, such as an instance of
    `scipy.optimize.OptimizeResult`, which holds the optimal value of
    `lmbda` in an attribute `x`.

    See the example below or the documentation of
    `scipy.optimize.minimize_scalar` for more information.

Returns
-------
maxlog : float or ndarray
    The optimal transform parameter found.  An array instead of a scalar
    for ``method='all'``.

See Also
--------
boxcox, boxcox_llf, boxcox_normplot, scipy.optimize.minimize_scalar

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; import matplotlib.pyplot as plt

We can generate some data and determine the optimal ``lmbda`` in various
ways:

&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; x = stats.loggamma.rvs(5, size=30, random_state=rng) + 5
&gt;&gt;&gt; y, lmax_mle = stats.boxcox(x)
&gt;&gt;&gt; lmax_pearsonr = stats.boxcox_normmax(x)

&gt;&gt;&gt; lmax_mle
2.217563431465757
&gt;&gt;&gt; lmax_pearsonr
2.238318660200961
&gt;&gt;&gt; stats.boxcox_normmax(x, method='all')
array([2.23831866, 2.21756343])

&gt;&gt;&gt; fig = plt.figure()
&gt;&gt;&gt; ax = fig.add_subplot(111)
&gt;&gt;&gt; prob = stats.boxcox_normplot(x, -10, 10, plot=ax)
&gt;&gt;&gt; ax.axvline(lmax_mle, color='r')
&gt;&gt;&gt; ax.axvline(lmax_pearsonr, color='g', ls='--')

&gt;&gt;&gt; plt.show()

Alternatively, we can define our own `optimizer` function. Suppose we
are only interested in values of `lmbda` on the interval [6, 7], we
want to use `scipy.optimize.minimize_scalar` with ``method='bounded'``,
and we want to use tighter tolerances when optimizing the log-likelihood
function. To do this, we define a function that accepts positional argument
`fun` and uses `scipy.optimize.minimize_scalar` to minimize `fun` subject
to the provided bounds and tolerances:

&gt;&gt;&gt; from scipy import optimize
&gt;&gt;&gt; options = {'xatol': 1e-12}  # absolute tolerance on `x`
&gt;&gt;&gt; def optimizer(fun):
...     return optimize.minimize_scalar(fun, bounds=(6, 7),
...                                     method="bounded", options=options)
&gt;&gt;&gt; stats.boxcox_normmax(x, optimizer=optimizer)
6.000...
</pre> 
<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l01116">1116</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

<p class="reference">References <a class="el" href="../../db/d84/__morestats_8py_source.html#l00372">_calc_uniform_order_statistic_medians()</a>, <a class="el" href="../../db/d84/__morestats_8py_source.html#l00973">boxcox()</a>, and <a class="el" href="../../db/d84/__morestats_8py_source.html#l00839">boxcox_llf()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../db/d84/__morestats_8py_source.html#l00973">boxcox()</a>.</p>

</div>
</div>
<a id="a91186ccc31cc60f13d65ab705c006a4f" name="a91186ccc31cc60f13d65ab705c006a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91186ccc31cc60f13d65ab705c006a4f">&#9670;&#160;</a></span>boxcox_normplot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.boxcox_normplot </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>la</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>lb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>plot</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>N</em></span><span class="paramdefsep"> = </span><span class="paramdefval">80</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute parameters for a Box-Cox normality plot, optionally show it.

A Box-Cox normality plot shows graphically what the best transformation
parameter is to use in `boxcox` to obtain a distribution that is close
to normal.

Parameters
----------
x : array_like
    Input array.
la, lb : scalar
    The lower and upper bounds for the ``lmbda`` values to pass to `boxcox`
    for Box-Cox transformations.  These are also the limits of the
    horizontal axis of the plot if that is generated.
plot : object, optional
    If given, plots the quantiles and least squares fit.
    `plot` is an object that has to have methods "plot" and "text".
    The `matplotlib.pyplot` module or a Matplotlib Axes object can be used,
    or a custom object with the same methods.
    Default is None, which means that no plot is created.
N : int, optional
    Number of points on the horizontal axis (equally distributed from
    `la` to `lb`).

Returns
-------
lmbdas : ndarray
    The ``lmbda`` values for which a Box-Cox transform was done.
ppcc : ndarray
    Probability Plot Correlelation Coefficient, as obtained from `probplot`
    when fitting the Box-Cox transformed input `x` against a normal
    distribution.

See Also
--------
probplot, boxcox, boxcox_normmax, boxcox_llf, ppcc_max

Notes
-----
Even if `plot` is given, the figure is not shown or saved by
`boxcox_normplot`; ``plt.show()`` or ``plt.savefig('figname.png')``
should be used after calling `probplot`.

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; import matplotlib.pyplot as plt

Generate some non-normally distributed data, and create a Box-Cox plot:

&gt;&gt;&gt; x = stats.loggamma.rvs(5, size=500) + 5
&gt;&gt;&gt; fig = plt.figure()
&gt;&gt;&gt; ax = fig.add_subplot(111)
&gt;&gt;&gt; prob = stats.boxcox_normplot(x, -20, 20, plot=ax)

Determine and plot the optimal ``lmbda`` to transform ``x`` and plot it in
the same plot:

&gt;&gt;&gt; _, maxlog = stats.boxcox(x)
&gt;&gt;&gt; ax.axvline(maxlog, color='r')

&gt;&gt;&gt; plt.show()
</pre> 
<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l01326">1326</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

<p class="reference">References <a class="el" href="../../db/d84/__morestats_8py_source.html#l01284">_normplot()</a>.</p>

</div>
</div>
<a id="ad39d886f881520f6b73d7bff6f071854" name="ad39d886f881520f6b73d7bff6f071854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad39d886f881520f6b73d7bff6f071854">&#9670;&#160;</a></span>circmean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.circmean </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>samples</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>high</em></span><span class="paramdefsep"> = </span><span class="paramdefval">2*pi</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>low</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>axis</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>nan_policy</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'propagate'</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the circular mean for samples in a range.

Parameters
----------
samples : array_like
    Input array.
high : float or int, optional
    High boundary for the sample range. Default is ``2*pi``.
low : float or int, optional
    Low boundary for the sample range. Default is 0.
axis : int, optional
    Axis along which means are computed. The default is to compute
    the mean of the flattened array.
nan_policy : {'propagate', 'raise', 'omit'}, optional
    Defines how to handle when input contains nan. 'propagate' returns nan,
    'raise' throws an error, 'omit' performs the calculations ignoring nan
    values. Default is 'propagate'.

Returns
-------
circmean : float
    Circular mean.

See Also
--------
circstd : Circular standard deviation.
circvar : Circular variance.

Examples
--------
For simplicity, all angles are printed out in degrees.

&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy.stats import circmean
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; angles = np.deg2rad(np.array([20, 30, 330]))
&gt;&gt;&gt; circmean = circmean(angles)
&gt;&gt;&gt; np.rad2deg(circmean)
7.294976657784009

&gt;&gt;&gt; mean = angles.mean()
&gt;&gt;&gt; np.rad2deg(mean)
126.66666666666666

Plot and compare the circular mean against the arithmetic mean.

&gt;&gt;&gt; plt.plot(np.cos(np.linspace(0, 2*np.pi, 500)),
...          np.sin(np.linspace(0, 2*np.pi, 500)),
...          c='k')
&gt;&gt;&gt; plt.scatter(np.cos(angles), np.sin(angles), c='k')
&gt;&gt;&gt; plt.scatter(np.cos(circmean), np.sin(circmean), c='b',
...             label='circmean')
&gt;&gt;&gt; plt.scatter(np.cos(mean), np.sin(mean), c='r', label='mean')
&gt;&gt;&gt; plt.legend()
&gt;&gt;&gt; plt.axis('equal')
&gt;&gt;&gt; plt.show()
</pre> 
<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l04434">4434</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

</div>
</div>
<a id="a39e9339f87efa51e62139f66b9ec8fd6" name="a39e9339f87efa51e62139f66b9ec8fd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39e9339f87efa51e62139f66b9ec8fd6">&#9670;&#160;</a></span>circstd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.circstd </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>samples</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>high</em></span><span class="paramdefsep"> = </span><span class="paramdefval">2*pi</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>low</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>axis</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>nan_policy</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'propagate'</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>normalize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the circular standard deviation for samples assumed to be in the
range [low to high].

Parameters
----------
samples : array_like
    Input array.
high : float or int, optional
    High boundary for the sample range. Default is ``2*pi``.
low : float or int, optional
    Low boundary for the sample range. Default is 0.
axis : int, optional
    Axis along which standard deviations are computed. The default is
    to compute the standard deviation of the flattened array.
nan_policy : {'propagate', 'raise', 'omit'}, optional
    Defines how to handle when input contains nan. 'propagate' returns nan,
    'raise' throws an error, 'omit' performs the calculations ignoring nan
    values. Default is 'propagate'.
normalize : boolean, optional
    If True, the returned value is equal to ``sqrt(-2*log(R))`` and does
    not depend on the variable units. If False (default), the returned
    value is scaled by ``((high-low)/(2*pi))``.

Returns
-------
circstd : float
    Circular standard deviation.

See Also
--------
circmean : Circular mean.
circvar : Circular variance.

Notes
-----
This uses a definition of circular standard deviation from [1]_.
Essentially, the calculation is as follows.

.. code-block:: python

    import numpy as np
    C = np.cos(samples).mean()
    S = np.sin(samples).mean()
    R = np.sqrt(C**2 + S**2)
    l = 2*np.pi / (high-low)
    circstd = np.sqrt(-2*np.log(R)) / l

In the limit of small angles, it returns a number close to the 'linear'
standard deviation.

References
----------
.. [1] Mardia, K. V. (1972). 2. In *Statistics of Directional Data*
   (pp. 18-24). Academic Press. :doi:`10.1016/C2013-0-07425-7`.

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy.stats import circstd
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; samples_1 = np.array([0.072, -0.158, 0.077, 0.108, 0.286,
...                       0.133, -0.473, -0.001, -0.348, 0.131])
&gt;&gt;&gt; samples_2 = np.array([0.111, -0.879, 0.078, 0.733, 0.421,
...                       0.104, -0.136, -0.867,  0.012,  0.105])
&gt;&gt;&gt; circstd_1 = circstd(samples_1)
&gt;&gt;&gt; circstd_2 = circstd(samples_2)

Plot the samples.

&gt;&gt;&gt; fig, (left, right) = plt.subplots(ncols=2)
&gt;&gt;&gt; for image in (left, right):
...     image.plot(np.cos(np.linspace(0, 2*np.pi, 500)),
...                np.sin(np.linspace(0, 2*np.pi, 500)),
...                c='k')
...     image.axis('equal')
...     image.axis('off')
&gt;&gt;&gt; left.scatter(np.cos(samples_1), np.sin(samples_1), c='k', s=15)
&gt;&gt;&gt; left.set_title(f"circular std: {np.round(circstd_1, 2)!r}")
&gt;&gt;&gt; right.plot(np.cos(np.linspace(0, 2*np.pi, 500)),
...            np.sin(np.linspace(0, 2*np.pi, 500)),
...            c='k')
&gt;&gt;&gt; right.scatter(np.cos(samples_2), np.sin(samples_2), c='k', s=15)
&gt;&gt;&gt; right.set_title(f"circular std: {np.round(circstd_2, 2)!r}")
&gt;&gt;&gt; plt.show()
</pre> 
<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l04614">4614</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

</div>
</div>
<a id="ab2b2d677962cb55b72b6eee1d4e84b79" name="ab2b2d677962cb55b72b6eee1d4e84b79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2b2d677962cb55b72b6eee1d4e84b79">&#9670;&#160;</a></span>circvar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.circvar </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>samples</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>high</em></span><span class="paramdefsep"> = </span><span class="paramdefval">2*pi</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>low</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>axis</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>nan_policy</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'propagate'</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the circular variance for samples assumed to be in a range.

Parameters
----------
samples : array_like
    Input array.
high : float or int, optional
    High boundary for the sample range. Default is ``2*pi``.
low : float or int, optional
    Low boundary for the sample range. Default is 0.
axis : int, optional
    Axis along which variances are computed. The default is to compute
    the variance of the flattened array.
nan_policy : {'propagate', 'raise', 'omit'}, optional
    Defines how to handle when input contains nan. 'propagate' returns nan,
    'raise' throws an error, 'omit' performs the calculations ignoring nan
    values. Default is 'propagate'.

Returns
-------
circvar : float
    Circular variance.

See Also
--------
circmean : Circular mean.
circstd : Circular standard deviation.

Notes
-----
This uses the following definition of circular variance: ``1-R``, where
``R`` is the mean resultant vector. The
returned value is in the range [0, 1], 0 standing for no variance, and 1
for a large variance. In the limit of small angles, this value is similar
to half the 'linear' variance.

References
----------
.. [1] Fisher, N.I. *Statistical analysis of circular data*. Cambridge
      University Press, 1993.

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy.stats import circvar
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; samples_1 = np.array([0.072, -0.158, 0.077, 0.108, 0.286,
...                       0.133, -0.473, -0.001, -0.348, 0.131])
&gt;&gt;&gt; samples_2 = np.array([0.111, -0.879, 0.078, 0.733, 0.421,
...                       0.104, -0.136, -0.867,  0.012,  0.105])
&gt;&gt;&gt; circvar_1 = circvar(samples_1)
&gt;&gt;&gt; circvar_2 = circvar(samples_2)

Plot the samples.

&gt;&gt;&gt; fig, (left, right) = plt.subplots(ncols=2)
&gt;&gt;&gt; for image in (left, right):
...     image.plot(np.cos(np.linspace(0, 2*np.pi, 500)),
...                np.sin(np.linspace(0, 2*np.pi, 500)),
...                c='k')
...     image.axis('equal')
...     image.axis('off')
&gt;&gt;&gt; left.scatter(np.cos(samples_1), np.sin(samples_1), c='k', s=15)
&gt;&gt;&gt; left.set_title(f"circular variance: {np.round(circvar_1, 2)!r}")
&gt;&gt;&gt; right.scatter(np.cos(samples_2), np.sin(samples_2), c='k', s=15)
&gt;&gt;&gt; right.set_title(f"circular variance: {np.round(circvar_2, 2)!r}")
&gt;&gt;&gt; plt.show()
</pre> 
<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l04526">4526</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

</div>
</div>
<a id="ad264a00b701706f101fd11dd7bf4dfcc" name="ad264a00b701706f101fd11dd7bf4dfcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad264a00b701706f101fd11dd7bf4dfcc">&#9670;&#160;</a></span>directional_stats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.directional_stats </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>samples</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>axis</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>normalize</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d8/d0b/classTrue.html">True</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Computes sample statistics for directional data.

Computes the directional mean (also called the mean direction vector) and
mean resultant length of a sample of vectors.

The directional mean is a measure of "preferred direction" of vector data.
It is analogous to the sample mean, but it is for use when the length of
the data is irrelevant (e.g. unit vectors).

The mean resultant length is a value between 0 and 1 used to quantify the
dispersion of directional data: the smaller the mean resultant length, the
greater the dispersion. Several definitions of directional variance
involving the mean resultant length are given in [1]_ and [2]_.

Parameters
----------
samples : array_like
    Input array. Must be at least two-dimensional, and the last axis of the
    input must correspond with the dimensionality of the vector space.
    When the input is exactly two dimensional, this means that each row
    of the data is a vector observation.
axis : int, default: 0
    Axis along which the directional mean is computed.
normalize: boolean, default: True
    If True, normalize the input to ensure that each observation is a
    unit vector. It the observations are already unit vectors, consider
    setting this to False to avoid unnecessary computation.

Returns
-------
res : DirectionalStats
    An object containing attributes:

    mean_direction : ndarray
        Directional mean.
    mean_resultant_length : ndarray
        The mean resultant length [1]_.

See Also
--------
circmean: circular mean; i.e. directional mean for 2D *angles*
circvar: circular variance; i.e. directional variance for 2D *angles*

Notes
-----
This uses a definition of directional mean from [1]_.
Assuming the observations are unit vectors, the calculation is as follows.

.. code-block:: python

    mean = samples.mean(axis=0)
    mean_resultant_length = np.linalg.norm(mean)
    mean_direction = mean / mean_resultant_length

This definition is appropriate for *directional* data (i.e. vector data
for which the magnitude of each observation is irrelevant) but not
for *axial* data (i.e. vector data for which the magnitude and *sign* of
each observation is irrelevant).

Several definitions of directional variance involving the mean resultant
length ``R`` have been proposed, including ``1 - R`` [1]_, ``1 - R**2``
[2]_, and ``2 * (1 - R)`` [2]_. Rather than choosing one, this function
returns ``R`` as attribute `mean_resultant_length` so the user can compute
their preferred measure of dispersion.

References
----------
.. [1] Mardia, Jupp. (2000). *Directional Statistics*
   (p. 163). Wiley.

.. [2] https://en.wikipedia.org/wiki/Directional_statistics

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy.stats import directional_stats
&gt;&gt;&gt; data = np.array([[3, 4],    # first observation, 2D vector space
...                  [6, -8]])  # second observation
&gt;&gt;&gt; dirstats = directional_stats(data)
&gt;&gt;&gt; dirstats.mean_direction
array([1., 0.])

In contrast, the regular sample mean of the vectors would be influenced
by the magnitude of each observation. Furthermore, the result would not be
a unit vector.

&gt;&gt;&gt; data.mean(axis=0)
array([4.5, -2.])

An exemplary use case for `directional_stats` is to find a *meaningful*
center for a set of observations on a sphere, e.g. geographical locations.

&gt;&gt;&gt; data = np.array([[0.8660254, 0.5, 0.],
...                  [0.8660254, -0.5, 0.]])
&gt;&gt;&gt; dirstats = directional_stats(data)
&gt;&gt;&gt; dirstats.mean_direction
array([1., 0., 0.])

The regular sample mean on the other hand yields a result which does not
lie on the surface of the sphere.

&gt;&gt;&gt; data.mean(axis=0)
array([0.8660254, 0., 0.])

The function also returns the mean resultant length, which
can be used to calculate a directional variance. For example, using the
definition ``Var(z) = 1 - R`` from [2]_ where ``R`` is the
mean resultant length, we can calculate the directional variance of the
vectors in the above example as:

&gt;&gt;&gt; 1 - dirstats.mean_resultant_length
0.13397459716167093
</pre> 
<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l04733">4733</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../df/d62/__multivariate_8py_source.html#l06743">scipy.stats._multivariate.vonmises_fisher_gen.fit()</a>.</p>

</div>
</div>
<a id="a8b6b5ed85f5460b956acdf054d182b69" name="a8b6b5ed85f5460b956acdf054d182b69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b6b5ed85f5460b956acdf054d182b69">&#9670;&#160;</a></span>false_discovery_control()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.false_discovery_control </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>ps</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>axis</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>method</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'bh'</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Adjust p-values to control the false discovery rate.

The false discovery rate (FDR) is the expected proportion of rejected null
hypotheses that are actually true.
If the null hypothesis is rejected when the *adjusted* p-value falls below
a specified level, the false discovery rate is controlled at that level.

Parameters
----------
ps : 1D array_like
    The p-values to adjust. Elements must be real numbers between 0 and 1.
axis : int
    The axis along which to perform the adjustment. The adjustment is
    performed independently along each axis-slice. If `axis` is None, `ps`
    is raveled before performing the adjustment.
method : {'bh', 'by'}
    The false discovery rate control procedure to apply: ``'bh'`` is for
    Benjamini-Hochberg [1]_ (Eq. 1), ``'by'`` is for Benjaminini-Yekutieli
    [2]_ (Theorem 1.3). The latter is more conservative, but it is
    guaranteed to control the FDR even when the p-values are not from
    independent tests.

Returns
-------
ps_adusted : array_like
    The adjusted p-values. If the null hypothesis is rejected where these
    fall below a specified level, the false discovery rate is controlled
    at that level.

See Also
--------
combine_pvalues
statsmodels.stats.multitest.multipletests

Notes
-----
In multiple hypothesis testing, false discovery control procedures tend to
offer higher power than familywise error rate control procedures (e.g.
Bonferroni correction [1]_).

If the p-values correspond with independent tests (or tests with
"positive regression dependencies" [2]_), rejecting null hypotheses
corresponding with Benjamini-Hochberg-adjusted p-values below :math:`q`
controls the false discovery rate at a level less than or equal to
:math:`q m_0 / m`, where :math:`m_0` is the number of true null hypotheses
and :math:`m` is the total number of null hypotheses tested. The same is
true even for dependent tests when the p-values are adjusted accorded to
the more conservative Benjaminini-Yekutieli procedure.

The adjusted p-values produced by this function are comparable to those
produced by the R function ``p.adjust`` and the statsmodels function
`statsmodels.stats.multitest.multipletests`. Please consider the latter
for more advanced methods of multiple comparison correction.

References
----------
.. [1] Benjamini, Yoav, and Yosef Hochberg. "Controlling the false
       discovery rate: a practical and powerful approach to multiple
       testing." Journal of the Royal statistical society: series B
       (Methodological) 57.1 (1995): 289-300.

.. [2] Benjamini, Yoav, and Daniel Yekutieli. "The control of the false
       discovery rate in multiple testing under dependency." Annals of
       statistics (2001): 1165-1188.

.. [3] TileStats. FDR - Benjamini-Hochberg explained - Youtube.
       https://www.youtube.com/watch?v=rZKa4tW2NKs.

.. [4] Neuhaus, Karl-Ludwig, et al. "Improved thrombolysis in acute
       myocardial infarction with front-loaded administration of alteplase:
       results of the rt-PA-APSAC patency study (TAPS)." Journal of the
       American College of Cardiology 19.5 (1992): 885-891.

Examples
--------
We follow the example from [1]_.

    Thrombolysis with recombinant tissue-type plasminogen activator (rt-PA)
    and anisoylated plasminogen streptokinase activator (APSAC) in
    myocardial infarction has been proved to reduce mortality. [4]_
    investigated the effects of a new front-loaded administration of rt-PA
    versus those obtained with a standard regimen of APSAC, in a randomized
    multicentre trial in 421 patients with acute myocardial infarction.

There were four families of hypotheses tested in the study, the last of
which was "cardiac and other events after the start of thrombolitic
treatment". FDR control may be desired in this family of hypotheses
because it would not be appropriate to conclude that the front-loaded
treatment is better if it is merely equivalent to the previous treatment.

The p-values corresponding with the 15 hypotheses in this family were

&gt;&gt;&gt; ps = [0.0001, 0.0004, 0.0019, 0.0095, 0.0201, 0.0278, 0.0298, 0.0344,
...       0.0459, 0.3240, 0.4262, 0.5719, 0.6528, 0.7590, 1.000]

If the chosen significance level is 0.05, we may be tempted to reject the
null hypotheses for the tests corresponding with the first nine p-values,
as the first nine p-values fall below the chosen significance level.
However, this would ignore the problem of "multiplicity": if we fail to
correct for the fact that multiple comparisons are being performed, we
are more likely to incorrectly reject true null hypotheses.

One approach to the multiplicity problem is to control the family-wise
error rate (FWER), that is, the rate at which the null hypothesis is
rejected when it is actually true. A common procedure of this kind is the
Bonferroni correction [1]_.  We begin by multiplying the p-values by the
number of hypotheses tested.

&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; np.array(ps) * len(ps)
array([1.5000e-03, 6.0000e-03, 2.8500e-02, 1.4250e-01, 3.0150e-01,
       4.1700e-01, 4.4700e-01, 5.1600e-01, 6.8850e-01, 4.8600e+00,
       6.3930e+00, 8.5785e+00, 9.7920e+00, 1.1385e+01, 1.5000e+01])

To control the FWER at 5%, we reject only the hypotheses corresponding
with adjusted p-values less than 0.05. In this case, only the hypotheses
corresponding with the first three p-values can be rejected. According to
[1]_, these three hypotheses concerned "allergic reaction" and "two
different aspects of bleeding."

An alternative approach is to control the false discovery rate: the
expected fraction of rejected null hypotheses that are actually true. The
advantage of this approach is that it typically affords greater power: an
increased rate of rejecting the null hypothesis when it is indeed false. To
control the false discovery rate at 5%, we apply the Benjamini-Hochberg
p-value adjustment.

&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; stats.false_discovery_control(ps)
array([0.0015    , 0.003     , 0.0095    , 0.035625  , 0.0603    ,
       0.06385714, 0.06385714, 0.0645    , 0.0765    , 0.486     ,
       0.58118182, 0.714875  , 0.75323077, 0.81321429, 1.        ])

Now, the first *four* adjusted p-values fall below 0.05, so we would reject
the null hypotheses corresponding with these *four* p-values. Rejection
of the fourth null hypothesis was particularly important to the original
study as it led to the conclusion that the new treatment had a
"substantially lower in-hospital mortality rate."
</pre> 
<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l04863">4863</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

</div>
</div>
<a id="a978e827467d79fbfe254eea650472601" name="a978e827467d79fbfe254eea650472601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a978e827467d79fbfe254eea650472601">&#9670;&#160;</a></span>fligner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.fligner </td>
          <td>(</td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em>samples</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>center</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'median'</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>proportiontocut</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.05</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Perform Fligner-Killeen test for equality of variance.

Fligner's test tests the null hypothesis that all input samples
are from populations with equal variances.  Fligner-Killeen's test is
distribution free when populations are identical [2]_.

Parameters
----------
sample1, sample2, ... : array_like
    Arrays of sample data.  Need not be the same length.
center : {'mean', 'median', 'trimmed'}, optional
    Keyword argument controlling which function of the data is used in
    computing the test statistic.  The default is 'median'.
proportiontocut : float, optional
    When `center` is 'trimmed', this gives the proportion of data points
    to cut from each end. (See `scipy.stats.trim_mean`.)
    Default is 0.05.

Returns
-------
statistic : float
    The test statistic.
pvalue : float
    The p-value for the hypothesis test.

See Also
--------
bartlett : A parametric test for equality of k variances in normal samples
levene : A robust parametric test for equality of k variances

Notes
-----
As with Levene's test there are three variants of Fligner's test that
differ by the measure of central tendency used in the test.  See `levene`
for more information.

Conover et al. (1981) examine many of the existing parametric and
nonparametric tests by extensive simulations and they conclude that the
tests proposed by Fligner and Killeen (1976) and Levene (1960) appear to be
superior in terms of robustness of departures from normality and power
[3]_.

References
----------
.. [1] Park, C. and Lindsay, B. G. (1999). Robust Scale Estimation and
       Hypothesis Testing based on Quadratic Inference Function. Technical
       Report #99-03, Center for Likelihood Studies, Pennsylvania State
       University.
       https://cecas.clemson.edu/~cspark/cv/paper/qif/draftqif2.pdf
.. [2] Fligner, M.A. and Killeen, T.J. (1976). Distribution-free two-sample
       tests for scale. 'Journal of the American Statistical Association.'
       71(353), 210-213.
.. [3] Park, C. and Lindsay, B. G. (1999). Robust Scale Estimation and
       Hypothesis Testing based on Quadratic Inference Function. Technical
       Report #99-03, Center for Likelihood Studies, Pennsylvania State
       University.
.. [4] Conover, W. J., Johnson, M. E. and Johnson M. M. (1981). A
       comparative study of tests for homogeneity of variances, with
       applications to the outer continental shelf biding data.
       Technometrics, 23(4), 351-361.
.. [5] C.I. BLISS (1952), The Statistics of Bioassay: With Special
       Reference to the Vitamins, pp 499-503,
       :doi:`10.1016/C2013-0-12584-6`.
.. [6] B. Phipson and G. K. Smyth. "Permutation P-values Should Never Be
       Zero: Calculating Exact P-values When Permutations Are Randomly
       Drawn." Statistical Applications in Genetics and Molecular Biology
       9.1 (2010).
.. [7] Ludbrook, J., &amp; Dudley, H. (1998). Why permutation tests are
       superior to t and F tests in biomedical research. The American
       Statistician, 52(2), 127-132.

Examples
--------
In [5]_, the influence of vitamin C on the tooth growth of guinea pigs
was investigated. In a control study, 60 subjects were divided into
small dose, medium dose, and large dose groups that received
daily doses of 0.5, 1.0 and 2.0 mg of vitamin C, respectively.
After 42 days, the tooth growth was measured.

The ``small_dose``, ``medium_dose``, and ``large_dose`` arrays below record
tooth growth measurements of the three groups in microns.

&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; small_dose = np.array([
...     4.2, 11.5, 7.3, 5.8, 6.4, 10, 11.2, 11.2, 5.2, 7,
...     15.2, 21.5, 17.6, 9.7, 14.5, 10, 8.2, 9.4, 16.5, 9.7
... ])
&gt;&gt;&gt; medium_dose = np.array([
...     16.5, 16.5, 15.2, 17.3, 22.5, 17.3, 13.6, 14.5, 18.8, 15.5,
...     19.7, 23.3, 23.6, 26.4, 20, 25.2, 25.8, 21.2, 14.5, 27.3
... ])
&gt;&gt;&gt; large_dose = np.array([
...     23.6, 18.5, 33.9, 25.5, 26.4, 32.5, 26.7, 21.5, 23.3, 29.5,
...     25.5, 26.4, 22.4, 24.5, 24.8, 30.9, 26.4, 27.3, 29.4, 23
... ])

The `fligner` statistic is sensitive to differences in variances
between the samples.

&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; res = stats.fligner(small_dose, medium_dose, large_dose)
&gt;&gt;&gt; res.statistic
1.3878943408857916

The value of the statistic tends to be high when there is a large
difference in variances.

We can test for inequality of variance among the groups by comparing the
observed value of the statistic against the null distribution: the
distribution of statistic values derived under the null hypothesis that
the population variances of the three groups are equal.

For this test, the null distribution follows the chi-square distribution
as shown below.

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; k = 3  # number of samples
&gt;&gt;&gt; dist = stats.chi2(df=k-1)
&gt;&gt;&gt; val = np.linspace(0, 8, 100)
&gt;&gt;&gt; pdf = dist.pdf(val)
&gt;&gt;&gt; fig, ax = plt.subplots(figsize=(8, 5))
&gt;&gt;&gt; def plot(ax):  # we'll re-use this
...     ax.plot(val, pdf, color='C0')
...     ax.set_title("Fligner Test Null Distribution")
...     ax.set_xlabel("statistic")
...     ax.set_ylabel("probability density")
...     ax.set_xlim(0, 8)
...     ax.set_ylim(0, 0.5)
&gt;&gt;&gt; plot(ax)
&gt;&gt;&gt; plt.show()

The comparison is quantified by the p-value: the proportion of values in
the null distribution greater than or equal to the observed value of the
statistic.

&gt;&gt;&gt; fig, ax = plt.subplots(figsize=(8, 5))
&gt;&gt;&gt; plot(ax)
&gt;&gt;&gt; pvalue = dist.sf(res.statistic)
&gt;&gt;&gt; annotation = (f'p-value={pvalue:.4f}\n(shaded area)')
&gt;&gt;&gt; props = dict(facecolor='black', width=1, headwidth=5, headlength=8)
&gt;&gt;&gt; _ = ax.annotate(annotation, (1.5, 0.22), (2.25, 0.3), arrowprops=props)
&gt;&gt;&gt; i = val &gt;= res.statistic
&gt;&gt;&gt; ax.fill_between(val[i], y1=0, y2=pdf[i], color='C0')
&gt;&gt;&gt; plt.show()

&gt;&gt;&gt; res.pvalue
0.49960016501182125

If the p-value is "small" - that is, if there is a low probability of
sampling data from distributions with identical variances that produces
such an extreme value of the statistic - this may be taken as evidence
against the null hypothesis in favor of the alternative: the variances of
the groups are not equal. Note that:

- The inverse is not true; that is, the test is not used to provide
  evidence for the null hypothesis.
- The threshold for values that will be considered "small" is a choice that
  should be made before the data is analyzed [6]_ with consideration of the
  risks of both false positives (incorrectly rejecting the null hypothesis)
  and false negatives (failure to reject a false null hypothesis).
- Small p-values are not evidence for a *large* effect; rather, they can
  only provide evidence for a "significant" effect, meaning that they are
  unlikely to have occurred under the null hypothesis.

Note that the chi-square distribution provides an asymptotic approximation
of the null distribution.
For small samples, it may be more appropriate to perform a
permutation test: Under the null hypothesis that all three samples were
drawn from the same population, each of the measurements is equally likely
to have been observed in any of the three samples. Therefore, we can form
a randomized null distribution by calculating the statistic under many
randomly-generated partitionings of the observations into the three
samples.

&gt;&gt;&gt; def statistic(*samples):
...     return stats.fligner(*samples).statistic
&gt;&gt;&gt; ref = stats.permutation_test(
...     (small_dose, medium_dose, large_dose), statistic,
...     permutation_type='independent', alternative='greater'
... )
&gt;&gt;&gt; fig, ax = plt.subplots(figsize=(8, 5))
&gt;&gt;&gt; plot(ax)
&gt;&gt;&gt; bins = np.linspace(0, 8, 25)
&gt;&gt;&gt; ax.hist(
...     ref.null_distribution, bins=bins, density=True, facecolor="C1"
... )
&gt;&gt;&gt; ax.legend(['aymptotic approximation\n(many observations)',
...            'randomized null distribution'])
&gt;&gt;&gt; plot(ax)
&gt;&gt;&gt; plt.show()

&gt;&gt;&gt; ref.pvalue  # randomized test p-value
0.4332  # may vary

Note that there is significant disagreement between the p-value calculated
here and the asymptotic approximation returned by `fligner` above.
The statistical inferences that can be drawn rigorously from a permutation
test are limited; nonetheless, they may be the preferred approach in many
circumstances [7]_.

Following is another generic example where the null hypothesis would be
rejected.

Test whether the lists `a`, `b` and `c` come from populations
with equal variances.

&gt;&gt;&gt; a = [8.88, 9.12, 9.04, 8.98, 9.00, 9.08, 9.01, 8.85, 9.06, 8.99]
&gt;&gt;&gt; b = [8.88, 8.95, 9.29, 9.44, 9.15, 9.58, 8.36, 9.18, 8.67, 9.05]
&gt;&gt;&gt; c = [8.95, 9.12, 8.95, 8.85, 9.03, 8.84, 9.07, 8.98, 8.86, 8.98]
&gt;&gt;&gt; stat, p = stats.fligner(a, b, c)
&gt;&gt;&gt; p
0.00450826080004775

The small p-value suggests that the populations do not have equal
variances.

This is not surprising, given that the sample variance of `b` is much
larger than that of `a` and `c`:

&gt;&gt;&gt; [np.var(x, ddof=1) for x in [a, b, c]]
[0.007054444444444413, 0.13073888888888888, 0.008890000000000002]
</pre> 
<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l03307">3307</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

</div>
</div>
<a id="a4240a80fd709860b5a63acf219991dcf" name="a4240a80fd709860b5a63acf219991dcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4240a80fd709860b5a63acf219991dcf">&#9670;&#160;</a></span>kstat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.kstat </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n</em></span><span class="paramdefsep"> = </span><span class="paramdefval">2</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the nth k-statistic (1&lt;=n&lt;=4 so far).

The nth k-statistic k_n is the unique symmetric unbiased estimator of the
nth cumulant kappa_n.

Parameters
----------
data : array_like
    Input array. Note that n-D input gets flattened.
n : int, {1, 2, 3, 4}, optional
    Default is equal to 2.

Returns
-------
kstat : float
    The nth k-statistic.

See Also
--------
kstatvar : Returns an unbiased estimator of the variance of the k-statistic
moment : Returns the n-th central moment about the mean for a sample.

Notes
-----
For a sample size n, the first few k-statistics are given by:

.. math::

    k_{1} = \mu
    k_{2} = \frac{n}{n-1} m_{2}
    k_{3} = \frac{ n^{2} } {(n-1) (n-2)} m_{3}
    k_{4} = \frac{ n^{2} [(n + 1)m_{4} - 3(n - 1) m^2_{2}]} {(n-1) (n-2) (n-3)}

where :math:`\mu` is the sample mean, :math:`m_2` is the sample
variance, and :math:`m_i` is the i-th sample central moment.

References
----------
http://mathworld.wolfram.com/k-Statistic.html

http://mathworld.wolfram.com/Cumulant.html

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; from numpy.random import default_rng
&gt;&gt;&gt; rng = default_rng()

As sample size increases, n-th moment and n-th k-statistic converge to the
same number (although they aren't identical). In the case of the normal
distribution, they converge to zero.

&gt;&gt;&gt; for n in [2, 3, 4, 5, 6, 7]:
...     x = rng.normal(size=10**n)
...     m, k = stats.moment(x, 3), stats.kstat(x, 3)
...     print("%.3g %.3g %.3g" % (m, k, m-k))
-0.631 -0.651 0.0194  # random
0.0282 0.0283 -8.49e-05
-0.0454 -0.0454 1.36e-05
7.53e-05 7.53e-05 -2.26e-09
0.00166 0.00166 -4.99e-09
-2.88e-06 -2.88e-06 8.63e-13
</pre> 
<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l00222">222</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../db/d84/__morestats_8py_source.html#l00321">kstatvar()</a>.</p>

</div>
</div>
<a id="ab8a9f133ef967d3f334ef8b7fc573983" name="ab8a9f133ef967d3f334ef8b7fc573983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8a9f133ef967d3f334ef8b7fc573983">&#9670;&#160;</a></span>kstatvar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.kstatvar </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n</em></span><span class="paramdefsep"> = </span><span class="paramdefval">2</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return an unbiased estimator of the variance of the k-statistic.

See `kstat` for more details of the k-statistic.

Parameters
----------
data : array_like
Input array. Note that n-D input gets flattened.
n : int, {1, 2}, optional
Default is equal to 2.

Returns
-------
kstatvar : float
The nth k-statistic variance.

See Also
--------
kstat : Returns the n-th k-statistic.
moment : Returns the n-th central moment about the mean for a sample.

Notes
-----
The variances of the first few k-statistics are given by:

.. math::

var(k_{1}) = \frac{\kappa^2}{n}
var(k_{2}) = \frac{\kappa^4}{n} + \frac{2\kappa^2_{2}}{n - 1}
var(k_{3}) = \frac{\kappa^6}{n} + \frac{9 \kappa_2 \kappa_4}{n - 1} +
     \frac{9 \kappa^2_{3}}{n - 1} +
     \frac{6 n \kappa^3_{2}}{(n-1) (n-2)}
var(k_{4}) = \frac{\kappa^8}{n} + \frac{16 \kappa_2 \kappa_6}{n - 1} +
     \frac{48 \kappa_{3} \kappa_5}{n - 1} +
     \frac{34 \kappa^2_{4}}{n-1} + \frac{72 n \kappa^2_{2} \kappa_4}{(n - 1) (n - 2)} +
     \frac{144 n \kappa_{2} \kappa^2_{3}}{(n - 1) (n - 2)} +
     \frac{24 (n + 1) n \kappa^4_{2}}{(n - 1) (n - 2) (n - 3)}
</pre> 
<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l00321">321</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

<p class="reference">References <a class="el" href="../../db/d84/__morestats_8py_source.html#l00222">kstat()</a>.</p>

</div>
</div>
<a id="aa23262638e4d8d639649530a5a7cf2d8" name="aa23262638e4d8d639649530a5a7cf2d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa23262638e4d8d639649530a5a7cf2d8">&#9670;&#160;</a></span>levene()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.levene </td>
          <td>(</td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em>samples</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>center</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'median'</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>proportiontocut</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.05</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Perform Levene test for equal variances.

The Levene test tests the null hypothesis that all input samples
are from populations with equal variances.  Levene's test is an
alternative to Bartlett's test `bartlett` in the case where
there are significant deviations from normality.

Parameters
----------
sample1, sample2, ... : array_like
The sample data, possibly with different lengths. Only one-dimensional
samples are accepted.
center : {'mean', 'median', 'trimmed'}, optional
Which function of the data to use in the test.  The default
is 'median'.
proportiontocut : float, optional
When `center` is 'trimmed', this gives the proportion of data points
to cut from each end. (See `scipy.stats.trim_mean`.)
Default is 0.05.

Returns
-------
statistic : float
The test statistic.
pvalue : float
The p-value for the test.

See Also
--------
fligner : A non-parametric test for the equality of k variances
bartlett : A parametric test for equality of k variances in normal samples

Notes
-----
Three variations of Levene's test are possible.  The possibilities
and their recommended usages are:

* 'median' : Recommended for skewed (non-normal) distributions&gt;
* 'mean' : Recommended for symmetric, moderate-tailed distributions.
* 'trimmed' : Recommended for heavy-tailed distributions.

The test version using the mean was proposed in the original article
of Levene ([2]_) while the median and trimmed mean have been studied by
Brown and Forsythe ([3]_), sometimes also referred to as Brown-Forsythe
test.

References
----------
.. [1] https://www.itl.nist.gov/div898/handbook/eda/section3/eda35a.htm
.. [2] Levene, H. (1960). In Contributions to Probability and Statistics:
Essays in Honor of Harold Hotelling, I. Olkin et al. eds.,
Stanford University Press, pp. 278-292.
.. [3] Brown, M. B. and Forsythe, A. B. (1974), Journal of the American
Statistical Association, 69, 364-367
.. [4] C.I. BLISS (1952), The Statistics of Bioassay: With Special
Reference to the Vitamins, pp 499-503,
:doi:`10.1016/C2013-0-12584-6`.
.. [5] B. Phipson and G. K. Smyth. "Permutation P-values Should Never Be
Zero: Calculating Exact P-values When Permutations Are Randomly
Drawn." Statistical Applications in Genetics and Molecular Biology
9.1 (2010).
.. [6] Ludbrook, J., &amp; Dudley, H. (1998). Why permutation tests are
superior to t and F tests in biomedical research. The American
Statistician, 52(2), 127-132.

Examples
--------
In [4]_, the influence of vitamin C on the tooth growth of guinea pigs
was investigated. In a control study, 60 subjects were divided into
small dose, medium dose, and large dose groups that received
daily doses of 0.5, 1.0 and 2.0 mg of vitamin C, respectively.
After 42 days, the tooth growth was measured.

The ``small_dose``, ``medium_dose``, and ``large_dose`` arrays below record
tooth growth measurements of the three groups in microns.

&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; small_dose = np.array([
...     4.2, 11.5, 7.3, 5.8, 6.4, 10, 11.2, 11.2, 5.2, 7,
...     15.2, 21.5, 17.6, 9.7, 14.5, 10, 8.2, 9.4, 16.5, 9.7
... ])
&gt;&gt;&gt; medium_dose = np.array([
...     16.5, 16.5, 15.2, 17.3, 22.5, 17.3, 13.6, 14.5, 18.8, 15.5,
...     19.7, 23.3, 23.6, 26.4, 20, 25.2, 25.8, 21.2, 14.5, 27.3
... ])
&gt;&gt;&gt; large_dose = np.array([
...     23.6, 18.5, 33.9, 25.5, 26.4, 32.5, 26.7, 21.5, 23.3, 29.5,
...     25.5, 26.4, 22.4, 24.5, 24.8, 30.9, 26.4, 27.3, 29.4, 23
... ])

The `levene` statistic is sensitive to differences in variances
between the samples.

&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; res = stats.levene(small_dose, medium_dose, large_dose)
&gt;&gt;&gt; res.statistic
0.6457341109631506

The value of the statistic tends to be high when there is a large
difference in variances.

We can test for inequality of variance among the groups by comparing the
observed value of the statistic against the null distribution: the
distribution of statistic values derived under the null hypothesis that
the population variances of the three groups are equal.

For this test, the null distribution follows the F distribution as shown
below.

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; k, n = 3, 60   # number of samples, total number of observations
&gt;&gt;&gt; dist = stats.f(dfn=k-1, dfd=n-k)
&gt;&gt;&gt; val = np.linspace(0, 5, 100)
&gt;&gt;&gt; pdf = dist.pdf(val)
&gt;&gt;&gt; fig, ax = plt.subplots(figsize=(8, 5))
&gt;&gt;&gt; def plot(ax):  # we'll re-use this
...     ax.plot(val, pdf, color='C0')
...     ax.set_title("Levene Test Null Distribution")
...     ax.set_xlabel("statistic")
...     ax.set_ylabel("probability density")
...     ax.set_xlim(0, 5)
...     ax.set_ylim(0, 1)
&gt;&gt;&gt; plot(ax)
&gt;&gt;&gt; plt.show()

The comparison is quantified by the p-value: the proportion of values in
the null distribution greater than or equal to the observed value of the
statistic.

&gt;&gt;&gt; fig, ax = plt.subplots(figsize=(8, 5))
&gt;&gt;&gt; plot(ax)
&gt;&gt;&gt; pvalue = dist.sf(res.statistic)
&gt;&gt;&gt; annotation = (f'p-value={pvalue:.3f}\n(shaded area)')
&gt;&gt;&gt; props = dict(facecolor='black', width=1, headwidth=5, headlength=8)
&gt;&gt;&gt; _ = ax.annotate(annotation, (1.5, 0.22), (2.25, 0.3), arrowprops=props)
&gt;&gt;&gt; i = val &gt;= res.statistic
&gt;&gt;&gt; ax.fill_between(val[i], y1=0, y2=pdf[i], color='C0')
&gt;&gt;&gt; plt.show()

&gt;&gt;&gt; res.pvalue
0.5280694573759905

If the p-value is "small" - that is, if there is a low probability of
sampling data from distributions with identical variances that produces
such an extreme value of the statistic - this may be taken as evidence
against the null hypothesis in favor of the alternative: the variances of
the groups are not equal. Note that:

- The inverse is not true; that is, the test is not used to provide
evidence for the null hypothesis.
- The threshold for values that will be considered "small" is a choice that
should be made before the data is analyzed [5]_ with consideration of the
risks of both false positives (incorrectly rejecting the null hypothesis)
and false negatives (failure to reject a false null hypothesis).
- Small p-values are not evidence for a *large* effect; rather, they can
only provide evidence for a "significant" effect, meaning that they are
unlikely to have occurred under the null hypothesis.

Note that the F distribution provides an asymptotic approximation of the
null distribution.
For small samples, it may be more appropriate to perform a permutation
test: Under the null hypothesis that all three samples were drawn from
the same population, each of the measurements is equally likely to have
been observed in any of the three samples. Therefore, we can form a
randomized null distribution by calculating the statistic under many
randomly-generated partitionings of the observations into the three
samples.

&gt;&gt;&gt; def statistic(*samples):
...     return stats.levene(*samples).statistic
&gt;&gt;&gt; ref = stats.permutation_test(
...     (small_dose, medium_dose, large_dose), statistic,
...     permutation_type='independent', alternative='greater'
... )
&gt;&gt;&gt; fig, ax = plt.subplots(figsize=(8, 5))
&gt;&gt;&gt; plot(ax)
&gt;&gt;&gt; bins = np.linspace(0, 5, 25)
&gt;&gt;&gt; ax.hist(
...     ref.null_distribution, bins=bins, density=True, facecolor="C1"
... )
&gt;&gt;&gt; ax.legend(['aymptotic approximation\n(many observations)',
...            'randomized null distribution'])
&gt;&gt;&gt; plot(ax)
&gt;&gt;&gt; plt.show()

&gt;&gt;&gt; ref.pvalue  # randomized test p-value
0.4559  # may vary

Note that there is significant disagreement between the p-value calculated
here and the asymptotic approximation returned by `levene` above.
The statistical inferences that can be drawn rigorously from a permutation
test are limited; nonetheless, they may be the preferred approach in many
circumstances [6]_.

Following is another generic example where the null hypothesis would be
rejected.

Test whether the lists `a`, `b` and `c` come from populations
with equal variances.

&gt;&gt;&gt; a = [8.88, 9.12, 9.04, 8.98, 9.00, 9.08, 9.01, 8.85, 9.06, 8.99]
&gt;&gt;&gt; b = [8.88, 8.95, 9.29, 9.44, 9.15, 9.58, 8.36, 9.18, 8.67, 9.05]
&gt;&gt;&gt; c = [8.95, 9.12, 8.95, 8.85, 9.03, 8.84, 9.07, 8.98, 8.86, 8.98]
&gt;&gt;&gt; stat, p = stats.levene(a, b, c)
&gt;&gt;&gt; p
0.002431505967249681

The small p-value suggests that the populations do not have equal
variances.

This is not surprising, given that the sample variance of `b` is much
larger than that of `a` and `c`:

&gt;&gt;&gt; [np.var(x, ddof=1) for x in [a, b, c]]
[0.007054444444444413, 0.13073888888888888, 0.008890000000000002]
</pre> 
<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l02913">2913</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

</div>
</div>
<a id="aa9d69aee9a069d7a4cec2d2cc5ab55a6" name="aa9d69aee9a069d7a4cec2d2cc5ab55a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9d69aee9a069d7a4cec2d2cc5ab55a6">&#9670;&#160;</a></span>median_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.median_test </td>
          <td>(</td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em>samples</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>ties</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'below'</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>correction</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d8/d0b/classTrue.html">True</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>lambda_</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>nan_policy</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'propagate'</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Perform a Mood's median test.

Test that two or more samples come from populations with the same median.

Let ``n = len(samples)`` be the number of samples.  The "grand median" of
all the data is computed, and a contingency table is formed by
classifying the values in each sample as being above or below the grand
median.  The contingency table, along with `correction` and `lambda_`,
are passed to `scipy.stats.chi2_contingency` to compute the test statistic
and p-value.

Parameters
----------
sample1, sample2, ... : array_like
    The set of samples.  There must be at least two samples.
    Each sample must be a one-dimensional sequence containing at least
    one value.  The samples are not required to have the same length.
ties : str, optional
    Determines how values equal to the grand median are classified in
    the contingency table.  The string must be one of::

        "below":
            Values equal to the grand median are counted as "below".
        "above":
            Values equal to the grand median are counted as "above".
        "ignore":
            Values equal to the grand median are not counted.

    The default is "below".
correction : bool, optional
    If True, *and* there are just two samples, apply Yates' correction
    for continuity when computing the test statistic associated with
    the contingency table.  Default is True.
lambda_ : float or str, optional
    By default, the statistic computed in this test is Pearson's
    chi-squared statistic.  `lambda_` allows a statistic from the
    Cressie-Read power divergence family to be used instead.  See
    `power_divergence` for details.
    Default is 1 (Pearson's chi-squared statistic).
nan_policy : {'propagate', 'raise', 'omit'}, optional
    Defines how to handle when input contains nan. 'propagate' returns nan,
    'raise' throws an error, 'omit' performs the calculations ignoring nan
    values. Default is 'propagate'.

Returns
-------
res : MedianTestResult
    An object containing attributes:

    statistic : float
        The test statistic.  The statistic that is returned is determined
        by `lambda_`.  The default is Pearson's chi-squared statistic.
    pvalue : float
        The p-value of the test.
    median : float
        The grand median.
    table : ndarray
        The contingency table.  The shape of the table is (2, n), where
        n is the number of samples.  The first row holds the counts of the
        values above the grand median, and the second row holds the counts
        of the values below the grand median.  The table allows further
        analysis with, for example, `scipy.stats.chi2_contingency`, or with
        `scipy.stats.fisher_exact` if there are two samples, without having
        to recompute the table.  If ``nan_policy`` is "propagate" and there
        are nans in the input, the return value for ``table`` is ``None``.

See Also
--------
kruskal : Compute the Kruskal-Wallis H-test for independent samples.
mannwhitneyu : Computes the Mann-Whitney rank test on samples x and y.

Notes
-----
.. versionadded:: 0.15.0

References
----------
.. [1] Mood, A. M., Introduction to the Theory of Statistics. McGraw-Hill
    (1950), pp. 394-399.
.. [2] Zar, J. H., Biostatistical Analysis, 5th ed. Prentice Hall (2010).
    See Sections 8.12 and 10.15.

Examples
--------
A biologist runs an experiment in which there are three groups of plants.
Group 1 has 16 plants, group 2 has 15 plants, and group 3 has 17 plants.
Each plant produces a number of seeds.  The seed counts for each group
are::

    Group 1: 10 14 14 18 20 22 24 25 31 31 32 39 43 43 48 49
    Group 2: 28 30 31 33 34 35 36 40 44 55 57 61 91 92 99
    Group 3:  0  3  9 22 23 25 25 33 34 34 40 45 46 48 62 67 84

The following code applies Mood's median test to these samples.

&gt;&gt;&gt; g1 = [10, 14, 14, 18, 20, 22, 24, 25, 31, 31, 32, 39, 43, 43, 48, 49]
&gt;&gt;&gt; g2 = [28, 30, 31, 33, 34, 35, 36, 40, 44, 55, 57, 61, 91, 92, 99]
&gt;&gt;&gt; g3 = [0, 3, 9, 22, 23, 25, 25, 33, 34, 34, 40, 45, 46, 48, 62, 67, 84]
&gt;&gt;&gt; from scipy.stats import median_test
&gt;&gt;&gt; res = median_test(g1, g2, g3)

The median is

&gt;&gt;&gt; res.median
34.0

and the contingency table is

&gt;&gt;&gt; res.table
array([[ 5, 10,  7],
       [11,  5, 10]])

`p` is too large to conclude that the medians are not the same:

&gt;&gt;&gt; res.pvalue
0.12609082774093244

The "G-test" can be performed by passing ``lambda_="log-likelihood"`` to
`median_test`.

&gt;&gt;&gt; res = median_test(g1, g2, g3, lambda_="log-likelihood")
&gt;&gt;&gt; res.pvalue
0.12224779737117837

The median occurs several times in the data, so we'll get a different
result if, for example, ``ties="above"`` is used:

&gt;&gt;&gt; res = median_test(g1, g2, g3, ties="above")
&gt;&gt;&gt; res.pvalue
0.063873276069553273

&gt;&gt;&gt; res.table
array([[ 5, 11,  9],
       [11,  4,  8]])

This example demonstrates that if the data set is not large and there
are values equal to the median, the p-value can be sensitive to the
choice of `ties`.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l04193">4193</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

</div>
</div>
<a id="aa2a8c126360ffed1a47ea5ef24d67463" name="aa2a8c126360ffed1a47ea5ef24d67463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2a8c126360ffed1a47ea5ef24d67463">&#9670;&#160;</a></span>mood()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.mood </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>axis</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>alternative</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;two-sided&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Perform Mood's test for equal scale parameters.

Mood's two-sample test for scale parameters is a non-parametric
test for the null hypothesis that two samples are drawn from the
same distribution with the same scale parameter.

Parameters
----------
x, y : array_like
    Arrays of sample data.
axis : int, optional
    The axis along which the samples are tested.  `x` and `y` can be of
    different length along `axis`.
    If `axis` is None, `x` and `y` are flattened and the test is done on
    all values in the flattened arrays.
alternative : {'two-sided', 'less', 'greater'}, optional
    Defines the alternative hypothesis. Default is 'two-sided'.
    The following options are available:

    * 'two-sided': the scales of the distributions underlying `x` and `y`
      are different.
    * 'less': the scale of the distribution underlying `x` is less than
      the scale of the distribution underlying `y`.
    * 'greater': the scale of the distribution underlying `x` is greater
      than the scale of the distribution underlying `y`.

    .. versionadded:: 1.7.0

Returns
-------
res : SignificanceResult
    An object containing attributes:

    statistic : scalar or ndarray
        The z-score for the hypothesis test.  For 1-D inputs a scalar is
        returned.
    pvalue : scalar ndarray
        The p-value for the hypothesis test.

See Also
--------
fligner : A non-parametric test for the equality of k variances
ansari : A non-parametric test for the equality of 2 variances
bartlett : A parametric test for equality of k variances in normal samples
levene : A parametric test for equality of k variances

Notes
-----
The data are assumed to be drawn from probability distributions ``f(x)``
and ``f(x/s) / s`` respectively, for some probability density function f.
The null hypothesis is that ``s == 1``.

For multi-dimensional arrays, if the inputs are of shapes
``(n0, n1, n2, n3)``  and ``(n0, m1, n2, n3)``, then if ``axis=1``, the
resulting z and p values will have shape ``(n0, n2, n3)``.  Note that
``n1`` and ``m1`` don't have to be equal, but the other dimensions do.

References
----------
[1] Mielke, Paul W. "Note on Some Squared Rank Tests with Existing Ties."
    Technometrics, vol. 9, no. 2, 1967, pp. 312-14. JSTOR,
    https://doi.org/10.2307/1266427. Accessed 18 May 2022.

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; x2 = rng.standard_normal((2, 45, 6, 7))
&gt;&gt;&gt; x1 = rng.standard_normal((2, 30, 6, 7))
&gt;&gt;&gt; res = stats.mood(x1, x2, axis=1)
&gt;&gt;&gt; res.pvalue.shape
(2, 6, 7)

Find the number of points where the difference in scale is not significant:

&gt;&gt;&gt; (res.pvalue &gt; 0.1).sum()
78

Perform the test with different scales:

&gt;&gt;&gt; x1 = rng.standard_normal((2, 30))
&gt;&gt;&gt; x2 = rng.standard_normal((2, 35)) * 10.0
&gt;&gt;&gt; stats.mood(x1, x2, axis=1)
SignificanceResult(statistic=array([-5.76174136, -6.12650783]),
                   pvalue=array([8.32505043e-09, 8.98287869e-10]))
</pre> 
<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l03657">3657</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

<p class="reference">References <a class="el" href="../../df/da7/__stats__py_8py_source.html#l01415">scipy.stats._stats_py._normtest_finish()</a>.</p>

</div>
</div>
<a id="aba1b41e7416dd9f4537909f6f4fb98f8" name="aba1b41e7416dd9f4537909f6f4fb98f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba1b41e7416dd9f4537909f6f4fb98f8">&#9670;&#160;</a></span>mvsdist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.mvsdist </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">'Frozen' distributions for mean, variance, and standard deviation of data.

Parameters
----------
data : array_like
    Input array. Converted to 1-D using ravel.
    Requires 2 or more data-points.

Returns
-------
mdist : "frozen" distribution object
    Distribution object representing the mean of the data.
vdist : "frozen" distribution object
    Distribution object representing the variance of the data.
sdist : "frozen" distribution object
    Distribution object representing the standard deviation of the data.

See Also
--------
bayes_mvs

Notes
-----
The return values from ``bayes_mvs(data)`` is equivalent to
``tuple((x.mean(), x.interval(0.90)) for x in mvsdist(data))``.

In other words, calling ``&lt;dist&gt;.mean()`` and ``&lt;dist&gt;.interval(0.90)``
on the three distribution objects returned from this function will give
the same results that are returned from `bayes_mvs`.

References
----------
T.E. Oliphant, "A Bayesian perspective on estimating mean, variance, and
standard-deviation from data", https://scholarsarchive.byu.edu/facpub/278,
2006.

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; data = [6, 9, 12, 7, 8, 8, 13]
&gt;&gt;&gt; mean, var, std = stats.mvsdist(data)

We now have frozen distribution objects "mean", "var" and "std" that we can
examine:

&gt;&gt;&gt; mean.mean()
9.0
&gt;&gt;&gt; mean.interval(0.95)
(6.6120585482655692, 11.387941451734431)
&gt;&gt;&gt; mean.std()
1.1952286093343936
</pre> 
<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l00144">144</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../db/d84/__morestats_8py_source.html#l00045">bayes_mvs()</a>.</p>

</div>
</div>
<a id="a3f28fe29e196c4bfe59e5619f859946f" name="a3f28fe29e196c4bfe59e5619f859946f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f28fe29e196c4bfe59e5619f859946f">&#9670;&#160;</a></span>ppcc_max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.ppcc_max </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>brack</em></span><span class="paramdefsep"> = </span><span class="paramdefval">(0.0,&#160;1.0)</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>dist</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'tukeylambda'</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate the shape parameter that maximizes the PPCC.

The probability plot correlation coefficient (PPCC) plot can be used
to determine the optimal shape parameter for a one-parameter family
of distributions. ``ppcc_max`` returns the shape parameter that would
maximize the probability plot correlation coefficient for the given
data to a one-parameter family of distributions.

Parameters
----------
x : array_like
    Input array.
brack : tuple, optional
    Triple (a,b,c) where (a&lt;b&lt;c). If bracket consists of two numbers (a, c)
    then they are assumed to be a starting interval for a downhill bracket
    search (see `scipy.optimize.brent`).
dist : str or stats.distributions instance, optional
    Distribution or distribution function name.  Objects that look enough
    like a stats.distributions instance (i.e. they have a ``ppf`` method)
    are also accepted.  The default is ``'tukeylambda'``.

Returns
-------
shape_value : float
    The shape parameter at which the probability plot correlation
    coefficient reaches its max value.

See Also
--------
ppcc_plot, probplot, boxcox

Notes
-----
The brack keyword serves as a starting point which is useful in corner
cases. One can use a plot to obtain a rough visual estimate of the location
for the maximum to start the search near it.

References
----------
.. [1] J.J. Filliben, "The Probability Plot Correlation Coefficient Test
       for Normality", Technometrics, Vol. 17, pp. 111-117, 1975.
.. [2] Engineering Statistics Handbook, NIST/SEMATEC,
       https://www.itl.nist.gov/div898/handbook/eda/section3/ppccplot.htm

Examples
--------
First we generate some random data from a Weibull distribution
with shape parameter 2.5:

&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; c = 2.5
&gt;&gt;&gt; x = stats.weibull_min.rvs(c, scale=4, size=2000, random_state=rng)

Generate the PPCC plot for this data with the Weibull distribution.

&gt;&gt;&gt; fig, ax = plt.subplots(figsize=(8, 6))
&gt;&gt;&gt; res = stats.ppcc_plot(x, c/2, 2*c, dist='weibull_min', plot=ax)

We calculate the value where the shape should reach its maximum and a
red line is drawn there. The line should coincide with the highest
point in the PPCC graph.

&gt;&gt;&gt; cmax = stats.ppcc_max(x, brack=(c/2, 2*c), dist='weibull_min')
&gt;&gt;&gt; ax.axvline(cmax, color='r')
&gt;&gt;&gt; plt.show()
</pre> 
<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l00648">648</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

<p class="reference">References <a class="el" href="../../db/d84/__morestats_8py_source.html#l00372">_calc_uniform_order_statistic_medians()</a>, and <a class="el" href="../../db/d84/__morestats_8py_source.html#l00435">_parse_dist_kw()</a>.</p>

</div>
</div>
<a id="ac92883d23651fe5aa26beaef7c55a5ce" name="ac92883d23651fe5aa26beaef7c55a5ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac92883d23651fe5aa26beaef7c55a5ce">&#9670;&#160;</a></span>ppcc_plot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.ppcc_plot </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>dist</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'tukeylambda'</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>plot</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>N</em></span><span class="paramdefsep"> = </span><span class="paramdefval">80</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate and optionally plot probability plot correlation coefficient.

The probability plot correlation coefficient (PPCC) plot can be used to
determine the optimal shape parameter for a one-parameter family of
distributions.  It cannot be used for distributions without shape
parameters
(like the normal distribution) or with multiple shape parameters.

By default a Tukey-Lambda distribution (`stats.tukeylambda`) is used. A
Tukey-Lambda PPCC plot interpolates from long-tailed to short-tailed
distributions via an approximately normal one, and is therefore
particularly useful in practice.

Parameters
----------
x : array_like
    Input array.
a, b : scalar
    Lower and upper bounds of the shape parameter to use.
dist : str or stats.distributions instance, optional
    Distribution or distribution function name.  Objects that look enough
    like a stats.distributions instance (i.e. they have a ``ppf`` method)
    are also accepted.  The default is ``'tukeylambda'``.
plot : object, optional
    If given, plots PPCC against the shape parameter.
    `plot` is an object that has to have methods "plot" and "text".
    The `matplotlib.pyplot` module or a Matplotlib Axes object can be used,
    or a custom object with the same methods.
    Default is None, which means that no plot is created.
N : int, optional
    Number of points on the horizontal axis (equally distributed from
    `a` to `b`).

Returns
-------
svals : ndarray
    The shape values for which `ppcc` was calculated.
ppcc : ndarray
    The calculated probability plot correlation coefficient values.

See Also
--------
ppcc_max, probplot, boxcox_normplot, tukeylambda

References
----------
J.J. Filliben, "The Probability Plot Correlation Coefficient Test for
Normality", Technometrics, Vol. 17, pp. 111-117, 1975.

Examples
--------
First we generate some random data from a Weibull distribution
with shape parameter 2.5, and plot the histogram of the data:

&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; c = 2.5
&gt;&gt;&gt; x = stats.weibull_min.rvs(c, scale=4, size=2000, random_state=rng)

Take a look at the histogram of the data.

&gt;&gt;&gt; fig1, ax = plt.subplots(figsize=(9, 4))
&gt;&gt;&gt; ax.hist(x, bins=50)
&gt;&gt;&gt; ax.set_title('Histogram of x')
&gt;&gt;&gt; plt.show()

Now we explore this data with a PPCC plot as well as the related
probability plot and Box-Cox normplot.  A red line is drawn where we
expect the PPCC value to be maximal (at the shape parameter ``c``
used above):

&gt;&gt;&gt; fig2 = plt.figure(figsize=(12, 4))
&gt;&gt;&gt; ax1 = fig2.add_subplot(1, 3, 1)
&gt;&gt;&gt; ax2 = fig2.add_subplot(1, 3, 2)
&gt;&gt;&gt; ax3 = fig2.add_subplot(1, 3, 3)
&gt;&gt;&gt; res = stats.probplot(x, plot=ax1)
&gt;&gt;&gt; res = stats.boxcox_normplot(x, -4, 4, plot=ax2)
&gt;&gt;&gt; res = stats.ppcc_plot(x, c/2, 2*c, dist='weibull_min', plot=ax3)
&gt;&gt;&gt; ax3.axvline(c, color='r')
&gt;&gt;&gt; plt.show()
</pre> 
<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l00736">736</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

<p class="reference">References <a class="el" href="../../db/d84/__morestats_8py_source.html#l00466">_add_axis_labels_title()</a>, and <a class="el" href="../../db/d84/__morestats_8py_source.html#l00485">probplot()</a>.</p>

</div>
</div>
<a id="ad0a762e91cdcf4bede4a0ace1d96b091" name="ad0a762e91cdcf4bede4a0ace1d96b091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0a762e91cdcf4bede4a0ace1d96b091">&#9670;&#160;</a></span>probplot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.probplot </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>sparams</em></span><span class="paramdefsep"> = </span><span class="paramdefval">()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>dist</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'norm'</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>fit</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d8/d0b/classTrue.html">True</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>plot</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>rvalue</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate quantiles for a probability plot, and optionally show the plot.

Generates a probability plot of sample data against the quantiles of a
specified theoretical distribution (the normal distribution by default).
`probplot` optionally calculates a best-fit line for the data and plots the
results using Matplotlib or a given plot function.

Parameters
----------
x : array_like
    Sample/response data from which `probplot` creates the plot.
sparams : tuple, optional
    Distribution-specific shape parameters (shape parameters plus location
    and scale).
dist : str or stats.distributions instance, optional
    Distribution or distribution function name. The default is 'norm' for a
    normal probability plot.  Objects that look enough like a
    stats.distributions instance (i.e. they have a ``ppf`` method) are also
    accepted.
fit : bool, optional
    Fit a least-squares regression (best-fit) line to the sample data if
    True (default).
plot : object, optional
    If given, plots the quantiles.
    If given and `fit` is True, also plots the least squares fit.
    `plot` is an object that has to have methods "plot" and "text".
    The `matplotlib.pyplot` module or a Matplotlib Axes object can be used,
    or a custom object with the same methods.
    Default is None, which means that no plot is created.
rvalue : bool, optional
    If `plot` is provided and `fit` is True, setting `rvalue` to True
    includes the coefficient of determination on the plot.
    Default is False.

Returns
-------
(osm, osr) : tuple of ndarrays
    Tuple of theoretical quantiles (osm, or order statistic medians) and
    ordered responses (osr).  `osr` is simply sorted input `x`.
    For details on how `osm` is calculated see the Notes section.
(slope, intercept, r) : tuple of floats, optional
    Tuple  containing the result of the least-squares fit, if that is
    performed by `probplot`. `r` is the square root of the coefficient of
    determination.  If ``fit=False`` and ``plot=None``, this tuple is not
    returned.

Notes
-----
Even if `plot` is given, the figure is not shown or saved by `probplot`;
``plt.show()`` or ``plt.savefig('figname.png')`` should be used after
calling `probplot`.

`probplot` generates a probability plot, which should not be confused with
a Q-Q or a P-P plot.  Statsmodels has more extensive functionality of this
type, see ``statsmodels.api.ProbPlot``.

The formula used for the theoretical quantiles (horizontal axis of the
probability plot) is Filliben's estimate::

    quantiles = dist.ppf(val), for

            0.5**(1/n),                  for i = n
      val = (i - 0.3175) / (n + 0.365),  for i = 2, ..., n-1
            1 - 0.5**(1/n),              for i = 1

where ``i`` indicates the i-th ordered value and ``n`` is the total number
of values.

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; nsample = 100
&gt;&gt;&gt; rng = np.random.default_rng()

A t distribution with small degrees of freedom:

&gt;&gt;&gt; ax1 = plt.subplot(221)
&gt;&gt;&gt; x = stats.t.rvs(3, size=nsample, random_state=rng)
&gt;&gt;&gt; res = stats.probplot(x, plot=plt)

A t distribution with larger degrees of freedom:

&gt;&gt;&gt; ax2 = plt.subplot(222)
&gt;&gt;&gt; x = stats.t.rvs(25, size=nsample, random_state=rng)
&gt;&gt;&gt; res = stats.probplot(x, plot=plt)

A mixture of two normal distributions with broadcasting:

&gt;&gt;&gt; ax3 = plt.subplot(223)
&gt;&gt;&gt; x = stats.norm.rvs(loc=[0,5], scale=[1,1.5],
...                    size=(nsample//2,2), random_state=rng).ravel()
&gt;&gt;&gt; res = stats.probplot(x, plot=plt)

A standard normal distribution:

&gt;&gt;&gt; ax4 = plt.subplot(224)
&gt;&gt;&gt; x = stats.norm.rvs(loc=0, scale=1, size=nsample, random_state=rng)
&gt;&gt;&gt; res = stats.probplot(x, plot=plt)

Produce a new figure with a loggamma distribution, using the ``dist`` and
``sparams`` keywords:

&gt;&gt;&gt; fig = plt.figure()
&gt;&gt;&gt; ax = fig.add_subplot(111)
&gt;&gt;&gt; x = stats.loggamma.rvs(c=2.5, size=500, random_state=rng)
&gt;&gt;&gt; res = stats.probplot(x, dist=stats.loggamma, sparams=(2.5,), plot=ax)
&gt;&gt;&gt; ax.set_title("Probplot for loggamma dist with shape parameter 2.5")

Show the results with Matplotlib:

&gt;&gt;&gt; plt.show()
</pre> 
<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l00485">485</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

<p class="reference">References <a class="el" href="../../db/d84/__morestats_8py_source.html#l00466">_add_axis_labels_title()</a>, <a class="el" href="../../db/d84/__morestats_8py_source.html#l00372">_calc_uniform_order_statistic_medians()</a>, and <a class="el" href="../../db/d84/__morestats_8py_source.html#l00435">_parse_dist_kw()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../db/d84/__morestats_8py_source.html#l01284">_normplot()</a>, and <a class="el" href="../../db/d84/__morestats_8py_source.html#l00736">ppcc_plot()</a>.</p>

</div>
</div>
<a id="ada353fe6934760152d3262990c5559c7" name="ada353fe6934760152d3262990c5559c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada353fe6934760152d3262990c5559c7">&#9670;&#160;</a></span>shapiro()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.shapiro </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Perform the Shapiro-Wilk test for normality.

The Shapiro-Wilk test tests the null hypothesis that the
data was drawn from a normal distribution.

Parameters
----------
x : array_like
    Array of sample data.

Returns
-------
statistic : float
    The test statistic.
p-value : float
    The p-value for the hypothesis test.

See Also
--------
anderson : The Anderson-Darling test for normality
kstest : The Kolmogorov-Smirnov test for goodness of fit.

Notes
-----
The algorithm used is described in [4]_ but censoring parameters as
described are not implemented. For N &gt; 5000 the W test statistic is
accurate, but the p-value may not be.

References
----------
.. [1] https://www.itl.nist.gov/div898/handbook/prc/section2/prc213.htm
.. [2] Shapiro, S. S. &amp; Wilk, M.B (1965). An analysis of variance test for
       normality (complete samples), Biometrika, Vol. 52, pp. 591-611.
.. [3] Razali, N. M. &amp; Wah, Y. B. (2011) Power comparisons of Shapiro-Wilk,
       Kolmogorov-Smirnov, Lilliefors and Anderson-Darling tests, Journal of
       Statistical Modeling and Analytics, Vol. 2, pp. 21-33.
.. [4] ALGORITHM AS R94 APPL. STATIST. (1995) VOL. 44, NO. 4.
.. [5] B. Phipson and G. K. Smyth. "Permutation P-values Should Never Be
       Zero: Calculating Exact P-values When Permutations Are Randomly
       Drawn." Statistical Applications in Genetics and Molecular Biology
       9.1 (2010).
.. [6] Panagiotakos, D. B. (2008). The value of p-value in biomedical
       research. The open cardiovascular medicine journal, 2, 97.

Examples
--------
Suppose we wish to infer from measurements whether the weights of adult
human males in a medical study are not normally distributed [2]_.
The weights (lbs) are recorded in the array ``x`` below.

&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; x = np.array([148, 154, 158, 160, 161, 162, 166, 170, 182, 195, 236])

The normality test of [1]_ and [2]_ begins by computing a statistic based
on the relationship between the observations and the expected order
statistics of a normal distribution.

&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; res = stats.shapiro(x)
&gt;&gt;&gt; res.statistic
0.7888147830963135

The value of this statistic tends to be high (close to 1) for samples drawn
from a normal distribution.

The test is performed by comparing the observed value of the statistic
against the null distribution: the distribution of statistic values formed
under the null hypothesis that the weights were drawn from a normal
distribution. For this normality test, the null distribution is not easy to
calculate exactly, so it is usually approximated by Monte Carlo methods,
that is, drawing many samples of the same size as ``x`` from a normal
distribution and computing the values of the statistic for each.

&gt;&gt;&gt; def statistic(x):
...     # Get only the `shapiro` statistic; ignore its p-value
...     return stats.shapiro(x).statistic
&gt;&gt;&gt; ref = stats.monte_carlo_test(x, stats.norm.rvs, statistic,
...                              alternative='less')
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; fig, ax = plt.subplots(figsize=(8, 5))
&gt;&gt;&gt; bins = np.linspace(0.65, 1, 50)
&gt;&gt;&gt; def plot(ax):  # we'll re-use this
...     ax.hist(ref.null_distribution, density=True, bins=bins)
...     ax.set_title("Shapiro-Wilk Test Null Distribution \n"
...                  "(Monte Carlo Approximation, 11 Observations)")
...     ax.set_xlabel("statistic")
...     ax.set_ylabel("probability density")
&gt;&gt;&gt; plot(ax)
&gt;&gt;&gt; plt.show()

The comparison is quantified by the p-value: the proportion of values in
the null distribution less than or equal to the observed value of the
statistic.

&gt;&gt;&gt; fig, ax = plt.subplots(figsize=(8, 5))
&gt;&gt;&gt; plot(ax)
&gt;&gt;&gt; annotation = (f'p-value={res.pvalue:.6f}\n(highlighted area)')
&gt;&gt;&gt; props = dict(facecolor='black', width=1, headwidth=5, headlength=8)
&gt;&gt;&gt; _ = ax.annotate(annotation, (0.75, 0.1), (0.68, 0.7), arrowprops=props)
&gt;&gt;&gt; i_extreme = np.where(bins &lt;= res.statistic)[0]
&gt;&gt;&gt; for i in i_extreme:
...     ax.patches[i].set_color('C1')
&gt;&gt;&gt; plt.xlim(0.65, 0.9)
&gt;&gt;&gt; plt.ylim(0, 4)
&gt;&gt;&gt; plt.show
&gt;&gt;&gt; res.pvalue
0.006703833118081093

If the p-value is "small" - that is, if there is a low probability of
sampling data from a normally distributed population that produces such an
extreme value of the statistic - this may be taken as evidence against
the null hypothesis in favor of the alternative: the weights were not
drawn from a normal distribution. Note that:

- The inverse is not true; that is, the test is not used to provide
  evidence *for* the null hypothesis.
- The threshold for values that will be considered "small" is a choice that
  should be made before the data is analyzed [5]_ with consideration of the
  risks of both false positives (incorrectly rejecting the null hypothesis)
  and false negatives (failure to reject a false null hypothesis).
</pre> 
<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l01742">1742</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

</div>
</div>
<a id="acf6be93729b9052a8ffa98d5a17f96f6" name="acf6be93729b9052a8ffa98d5a17f96f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf6be93729b9052a8ffa98d5a17f96f6">&#9670;&#160;</a></span>wilcoxon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.wilcoxon </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>zero_method</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;wilcox&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>correction</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>alternative</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;two-sided&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>method</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'auto'</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate the Wilcoxon signed-rank test.

The Wilcoxon signed-rank test tests the null hypothesis that two
related paired samples come from the same distribution. In particular,
it tests whether the distribution of the differences ``x - y`` is symmetric
about zero. It is a non-parametric version of the paired T-test.

Parameters
----------
x : array_like
    Either the first set of measurements (in which case ``y`` is the second
    set of measurements), or the differences between two sets of
    measurements (in which case ``y`` is not to be specified.)  Must be
    one-dimensional.
y : array_like, optional
    Either the second set of measurements (if ``x`` is the first set of
    measurements), or not specified (if ``x`` is the differences between
    two sets of measurements.)  Must be one-dimensional.

    .. warning::
        When `y` is provided, `wilcoxon` calculates the test statistic
        based on the ranks of the absolute values of ``d = x - y``.
        Roundoff error in the subtraction can result in elements of ``d``
        being assigned different ranks even when they would be tied with
        exact arithmetic. Rather than passing `x` and `y` separately,
        consider computing the difference ``x - y``, rounding as needed to
        ensure that only truly unique elements are numerically distinct,
        and passing the result as `x`, leaving `y` at the default (None).

zero_method : {"wilcox", "pratt", "zsplit"}, optional
    There are different conventions for handling pairs of observations
    with equal values ("zero-differences", or "zeros").

    * "wilcox": Discards all zero-differences (default); see [4]_.
    * "pratt": Includes zero-differences in the ranking process,
      but drops the ranks of the zeros (more conservative); see [3]_.
      In this case, the normal approximation is adjusted as in [5]_.
    * "zsplit": Includes zero-differences in the ranking process and
      splits the zero rank between positive and negative ones.

correction : bool, optional
    If True, apply continuity correction by adjusting the Wilcoxon rank
    statistic by 0.5 towards the mean value when computing the
    z-statistic if a normal approximation is used.  Default is False.
alternative : {"two-sided", "greater", "less"}, optional
    Defines the alternative hypothesis. Default is 'two-sided'.
    In the following, let ``d`` represent the difference between the paired
    samples: ``d = x - y`` if both ``x`` and ``y`` are provided, or
    ``d = x`` otherwise.

    * 'two-sided': the distribution underlying ``d`` is not symmetric
      about zero.
    * 'less': the distribution underlying ``d`` is stochastically less
      than a distribution symmetric about zero.
    * 'greater': the distribution underlying ``d`` is stochastically
      greater than a distribution symmetric about zero.

method : {"auto", "exact", "approx"}, optional
    Method to calculate the p-value, see Notes. Default is "auto".

Returns
-------
An object with the following attributes.

statistic : array_like
    If `alternative` is "two-sided", the sum of the ranks of the
    differences above or below zero, whichever is smaller.
    Otherwise the sum of the ranks of the differences above zero.
pvalue : array_like
    The p-value for the test depending on `alternative` and `method`.
zstatistic : array_like
    When ``method = 'approx'``, this is the normalized z-statistic::

        z = (T - mn - d) / se

    where ``T`` is `statistic` as defined above, ``mn`` is the mean of the
    distribution under the null hypothesis, ``d`` is a continuity
    correction, and ``se`` is the standard error.
    When ``method != 'approx'``, this attribute is not available.

See Also
--------
kruskal, mannwhitneyu

Notes
-----
In the following, let ``d`` represent the difference between the paired
samples: ``d = x - y`` if both ``x`` and ``y`` are provided, or ``d = x``
otherwise. Assume that all elements of ``d`` are independent and
identically distributed observations, and all are distinct and nonzero.

- When ``len(d)`` is sufficiently large, the null distribution of the
  normalized test statistic (`zstatistic` above) is approximately normal,
  and ``method = 'approx'`` can be used to compute the p-value.

- When ``len(d)`` is small, the normal approximation may not be accurate,
  and ``method='exact'`` is preferred (at the cost of additional
  execution time).

- The default, ``method='auto'``, selects between the two: when
  ``len(d) &lt;= 50``, the exact method is used; otherwise, the approximate
  method is used.

The presence of "ties" (i.e. not all elements of ``d`` are unique) and
"zeros" (i.e. elements of ``d`` are zero) changes the null distribution
of the test statistic, and ``method='exact'`` no longer calculates
the exact p-value. If ``method='approx'``, the z-statistic is adjusted
for more accurate comparison against the standard normal, but still,
for finite sample sizes, the standard normal is only an approximation of
the true null distribution of the z-statistic. There is no clear
consensus among references on which method most accurately approximates
the p-value for small samples in the presence of zeros and/or ties. In any
case, this is the behavior of `wilcoxon` when ``method='auto':
``method='exact'`` is used when ``len(d) &lt;= 50`` *and there are no zeros*;
otherwise, ``method='approx'`` is used.

References
----------
.. [1] https://en.wikipedia.org/wiki/Wilcoxon_signed-rank_test
.. [2] Conover, W.J., Practical Nonparametric Statistics, 1971.
.. [3] Pratt, J.W., Remarks on Zeros and Ties in the Wilcoxon Signed
   Rank Procedures, Journal of the American Statistical Association,
   Vol. 54, 1959, pp. 655-667. :doi:`10.1080/01621459.1959.10501526`
.. [4] Wilcoxon, F., Individual Comparisons by Ranking Methods,
   Biometrics Bulletin, Vol. 1, 1945, pp. 80-83. :doi:`10.2307/3001968`
.. [5] Cureton, E.E., The Normal Approximation to the Signed-Rank
   Sampling Distribution When Zero Differences are Present,
   Journal of the American Statistical Association, Vol. 62, 1967,
   pp. 1068-1069. :doi:`10.1080/01621459.1967.10500917`

Examples
--------
In [4]_, the differences in height between cross- and self-fertilized
corn plants is given as follows:

&gt;&gt;&gt; d = [6, 8, 14, 16, 23, 24, 28, 29, 41, -48, 49, 56, 60, -67, 75]

Cross-fertilized plants appear to be higher. To test the null
hypothesis that there is no height difference, we can apply the
two-sided test:

&gt;&gt;&gt; from scipy.stats import wilcoxon
&gt;&gt;&gt; res = wilcoxon(d)
&gt;&gt;&gt; res.statistic, res.pvalue
(24.0, 0.041259765625)

Hence, we would reject the null hypothesis at a confidence level of 5%,
concluding that there is a difference in height between the groups.
To confirm that the median of the differences can be assumed to be
positive, we use:

&gt;&gt;&gt; res = wilcoxon(d, alternative='greater')
&gt;&gt;&gt; res.statistic, res.pvalue
(96.0, 0.0206298828125)

This shows that the null hypothesis that the median is negative can be
rejected at a confidence level of 5% in favor of the alternative that
the median is greater than zero. The p-values above are exact. Using the
normal approximation gives very similar values:

&gt;&gt;&gt; res = wilcoxon(d, method='approx')
&gt;&gt;&gt; res.statistic, res.pvalue
(24.0, 0.04088813291185591)

Note that the statistic changed to 96 in the one-sided case (the sum
of ranks of positive differences) whereas it is 24 in the two-sided
case (the minimum of sum of ranks above and below zero).

In the example above, the differences in height between paired plants are
provided to `wilcoxon` directly. Alternatively, `wilcoxon` accepts two
samples of equal length, calculates the differences between paired
elements, then performs the test. Consider the samples ``x`` and ``y``:

&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; x = np.array([0.5, 0.825, 0.375, 0.5])
&gt;&gt;&gt; y = np.array([0.525, 0.775, 0.325, 0.55])
&gt;&gt;&gt; res = wilcoxon(x, y, alternative='greater')
&gt;&gt;&gt; res
WilcoxonResult(statistic=5.0, pvalue=0.5625)

Note that had we calculated the differences by hand, the test would have
produced different results:

&gt;&gt;&gt; d = [-0.025, 0.05, 0.05, -0.05]
&gt;&gt;&gt; ref = wilcoxon(d, alternative='greater')
&gt;&gt;&gt; ref
WilcoxonResult(statistic=6.0, pvalue=0.4375)

The substantial difference is due to roundoff error in the results of
``x-y``:

&gt;&gt;&gt; d - (x-y)
array([2.08166817e-17, 6.93889390e-17, 1.38777878e-17, 4.16333634e-17])

Even though we expected all the elements of ``(x-y)[1:]`` to have the same
magnitude ``0.05``, they have slightly different magnitudes in practice,
and therefore are assigned different ranks in the test. Before performing
the test, consider calculating ``d`` and adjusting it as necessary to
ensure that theoretically identically values are not numerically distinct.
For example:

&gt;&gt;&gt; d2 = np.around(x - y, decimals=3)
&gt;&gt;&gt; wilcoxon(d2, alternative='greater')
WilcoxonResult(statistic=6.0, pvalue=0.4375)
</pre> 
<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l03837">3837</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

<p class="reference">References <a class="el" href="../../de/d99/__hypotests_8py_source.html#l00600">scipy.stats._hypotests._get_wilcoxon_distr()</a>, and <a class="el" href="../../df/da7/__stats__py_8py_source.html#l10033">scipy.stats._stats_py.find_repeats()</a>.</p>

</div>
</div>
<a id="a5e6e371f0b3b6c73d4f678f59017343f" name="a5e6e371f0b3b6c73d4f678f59017343f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e6e371f0b3b6c73d4f678f59017343f">&#9670;&#160;</a></span>wilcoxon_outputs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.wilcoxon_outputs </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>kwds</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l03824">3824</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

</div>
</div>
<a id="a66cb6178c9c02363490ed746438f8857" name="a66cb6178c9c02363490ed746438f8857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66cb6178c9c02363490ed746438f8857">&#9670;&#160;</a></span>wilcoxon_result_object()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.wilcoxon_result_object </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>statistic</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>pvalue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>zstatistic</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l03817">3817</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

</div>
</div>
<a id="a6a2739e0b0f2ef66fdfd2131664be94b" name="a6a2739e0b0f2ef66fdfd2131664be94b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a2739e0b0f2ef66fdfd2131664be94b">&#9670;&#160;</a></span>wilcoxon_result_unpacker()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.wilcoxon_result_unpacker </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>res</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l03810">3810</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

</div>
</div>
<a id="a0b302a2d21bd578ba3ff828a99000b6d" name="a0b302a2d21bd578ba3ff828a99000b6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b302a2d21bd578ba3ff828a99000b6d">&#9670;&#160;</a></span>yeojohnson()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.yeojohnson </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>lmbda</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a dataset transformed by a Yeo-Johnson power transformation.

Parameters
----------
x : ndarray
    Input array.  Should be 1-dimensional.
lmbda : float, optional
    If ``lmbda`` is ``None``, find the lambda that maximizes the
    log-likelihood function and return it as the second output argument.
    Otherwise the transformation is done for the given value.

Returns
-------
yeojohnson: ndarray
    Yeo-Johnson power transformed array.
maxlog : float, optional
    If the `lmbda` parameter is None, the second returned argument is
    the lambda that maximizes the log-likelihood function.

See Also
--------
probplot, yeojohnson_normplot, yeojohnson_normmax, yeojohnson_llf, boxcox

Notes
-----
The Yeo-Johnson transform is given by::

    y = ((x + 1)**lmbda - 1) / lmbda,                for x &gt;= 0, lmbda != 0
        log(x + 1),                                  for x &gt;= 0, lmbda = 0
        -((-x + 1)**(2 - lmbda) - 1) / (2 - lmbda),  for x &lt; 0, lmbda != 2
        -log(-x + 1),                                for x &lt; 0, lmbda = 2

Unlike `boxcox`, `yeojohnson` does not require the input data to be
positive.

.. versionadded:: 1.2.0


References
----------
I. Yeo and R.A. Johnson, "A New Family of Power Transformations to
Improve Normality or Symmetry", Biometrika 87.4 (2000):


Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; import matplotlib.pyplot as plt

We generate some random variates from a non-normal distribution and make a
probability plot for it, to show it is non-normal in the tails:

&gt;&gt;&gt; fig = plt.figure()
&gt;&gt;&gt; ax1 = fig.add_subplot(211)
&gt;&gt;&gt; x = stats.loggamma.rvs(5, size=500) + 5
&gt;&gt;&gt; prob = stats.probplot(x, dist=stats.norm, plot=ax1)
&gt;&gt;&gt; ax1.set_xlabel('')
&gt;&gt;&gt; ax1.set_title('Probplot against normal distribution')

We now use `yeojohnson` to transform the data so it's closest to normal:

&gt;&gt;&gt; ax2 = fig.add_subplot(212)
&gt;&gt;&gt; xt, lmbda = stats.yeojohnson(x)
&gt;&gt;&gt; prob = stats.probplot(xt, dist=stats.norm, plot=ax2)
&gt;&gt;&gt; ax2.set_title('Probplot after Yeo-Johnson transformation')

&gt;&gt;&gt; plt.show()
</pre> 
<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l01394">1394</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

<p class="reference">References <a class="el" href="../../db/d84/__morestats_8py_source.html#l01485">_yeojohnson_transform()</a>, and <a class="el" href="../../db/d84/__morestats_8py_source.html#l01610">yeojohnson_normmax()</a>.</p>

</div>
</div>
<a id="ae07ef1cbf1d88998be1d88789ac21135" name="ae07ef1cbf1d88998be1d88789ac21135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae07ef1cbf1d88998be1d88789ac21135">&#9670;&#160;</a></span>yeojohnson_llf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.yeojohnson_llf </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>lmb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The yeojohnson log-likelihood function.

Parameters
----------
lmb : scalar
    Parameter for Yeo-Johnson transformation. See `yeojohnson` for
    details.
data : array_like
    Data to calculate Yeo-Johnson log-likelihood for. If `data` is
    multi-dimensional, the log-likelihood is calculated along the first
    axis.

Returns
-------
llf : float
    Yeo-Johnson log-likelihood of `data` given `lmb`.

See Also
--------
yeojohnson, probplot, yeojohnson_normplot, yeojohnson_normmax

Notes
-----
The Yeo-Johnson log-likelihood function is defined here as

.. math::

    llf = -N/2 \log(\hat{\sigma}^2) + (\lambda - 1)
          \sum_i \text{ sign }(x_i)\log(|x_i| + 1)

where :math:`\hat{\sigma}^2` is estimated variance of the Yeo-Johnson
transformed input data ``x``.

.. versionadded:: 1.2.0

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; from mpl_toolkits.axes_grid1.inset_locator import inset_axes

Generate some random variates and calculate Yeo-Johnson log-likelihood
values for them for a range of ``lmbda`` values:

&gt;&gt;&gt; x = stats.loggamma.rvs(5, loc=10, size=1000)
&gt;&gt;&gt; lmbdas = np.linspace(-2, 10)
&gt;&gt;&gt; llf = np.zeros(lmbdas.shape, dtype=float)
&gt;&gt;&gt; for ii, lmbda in enumerate(lmbdas):
...     llf[ii] = stats.yeojohnson_llf(lmbda, x)

Also find the optimal lmbda value with `yeojohnson`:

&gt;&gt;&gt; x_most_normal, lmbda_optimal = stats.yeojohnson(x)

Plot the log-likelihood as function of lmbda.  Add the optimal lmbda as a
horizontal line to check that that's really the optimum:

&gt;&gt;&gt; fig = plt.figure()
&gt;&gt;&gt; ax = fig.add_subplot(111)
&gt;&gt;&gt; ax.plot(lmbdas, llf, 'b.-')
&gt;&gt;&gt; ax.axhline(stats.yeojohnson_llf(lmbda_optimal, x), color='r')
&gt;&gt;&gt; ax.set_xlabel('lmbda parameter')
&gt;&gt;&gt; ax.set_ylabel('Yeo-Johnson log-likelihood')

Now add some probability plots to show that where the log-likelihood is
maximized the data transformed with `yeojohnson` looks closest to normal:

&gt;&gt;&gt; locs = [3, 10, 4]  # 'lower left', 'center', 'lower right'
&gt;&gt;&gt; for lmbda, loc in zip([-1, lmbda_optimal, 9], locs):
...     xt = stats.yeojohnson(x, lmbda=lmbda)
...     (osm, osr), (slope, intercept, r_sq) = stats.probplot(xt)
...     ax_inset = inset_axes(ax, width="20%", height="20%", loc=loc)
...     ax_inset.plot(osm, osr, 'c.', osm, slope*osm + intercept, 'k-')
...     ax_inset.set_xticklabels([])
...     ax_inset.set_yticklabels([])
...     ax_inset.set_title(r'$\lambda=%1.2f$' % lmbda)

&gt;&gt;&gt; plt.show()
</pre> 
<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l01507">1507</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

<p class="reference">References <a class="el" href="../../db/d84/__morestats_8py_source.html#l01485">_yeojohnson_transform()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../db/d84/__morestats_8py_source.html#l01610">yeojohnson_normmax()</a>.</p>

</div>
</div>
<a id="a7e11fd74ac89acf7920558617d8aa708" name="a7e11fd74ac89acf7920558617d8aa708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e11fd74ac89acf7920558617d8aa708">&#9670;&#160;</a></span>yeojohnson_normmax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.yeojohnson_normmax </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>brack</em></span><span class="paramdefsep"> = </span><span class="paramdefval">(-2,&#160;2)</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute optimal Yeo-Johnson transform parameter.

Compute optimal Yeo-Johnson transform parameter for input data, using
maximum likelihood estimation.

Parameters
----------
x : array_like
    Input array.
brack : 2-tuple, optional
    The starting interval for a downhill bracket search with
    `optimize.brent`. Note that this is in most cases not critical; the
    final result is allowed to be outside this bracket.

Returns
-------
maxlog : float
    The optimal transform parameter found.

See Also
--------
yeojohnson, yeojohnson_llf, yeojohnson_normplot

Notes
-----
.. versionadded:: 1.2.0

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; import matplotlib.pyplot as plt

Generate some data and determine optimal ``lmbda``

&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; x = stats.loggamma.rvs(5, size=30, random_state=rng) + 5
&gt;&gt;&gt; lmax = stats.yeojohnson_normmax(x)

&gt;&gt;&gt; fig = plt.figure()
&gt;&gt;&gt; ax = fig.add_subplot(111)
&gt;&gt;&gt; prob = stats.yeojohnson_normplot(x, -10, 10, plot=ax)
&gt;&gt;&gt; ax.axvline(lmax, color='r')

&gt;&gt;&gt; plt.show()
</pre> 
<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l01610">1610</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

<p class="reference">References <a class="el" href="../../db/d84/__morestats_8py_source.html#l01507">yeojohnson_llf()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../db/d84/__morestats_8py_source.html#l01394">yeojohnson()</a>.</p>

</div>
</div>
<a id="ac40ff897f481883c947ea2fe777cb0f1" name="ac40ff897f481883c947ea2fe777cb0f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac40ff897f481883c947ea2fe777cb0f1">&#9670;&#160;</a></span>yeojohnson_normplot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.yeojohnson_normplot </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>la</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>lb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>plot</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>N</em></span><span class="paramdefsep"> = </span><span class="paramdefval">80</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute parameters for a Yeo-Johnson normality plot, optionally show it.

A Yeo-Johnson normality plot shows graphically what the best
transformation parameter is to use in `yeojohnson` to obtain a
distribution that is close to normal.

Parameters
----------
x : array_like
    Input array.
la, lb : scalar
    The lower and upper bounds for the ``lmbda`` values to pass to
    `yeojohnson` for Yeo-Johnson transformations. These are also the
    limits of the horizontal axis of the plot if that is generated.
plot : object, optional
    If given, plots the quantiles and least squares fit.
    `plot` is an object that has to have methods "plot" and "text".
    The `matplotlib.pyplot` module or a Matplotlib Axes object can be used,
    or a custom object with the same methods.
    Default is None, which means that no plot is created.
N : int, optional
    Number of points on the horizontal axis (equally distributed from
    `la` to `lb`).

Returns
-------
lmbdas : ndarray
    The ``lmbda`` values for which a Yeo-Johnson transform was done.
ppcc : ndarray
    Probability Plot Correlelation Coefficient, as obtained from `probplot`
    when fitting the Box-Cox transformed input `x` against a normal
    distribution.

See Also
--------
probplot, yeojohnson, yeojohnson_normmax, yeojohnson_llf, ppcc_max

Notes
-----
Even if `plot` is given, the figure is not shown or saved by
`boxcox_normplot`; ``plt.show()`` or ``plt.savefig('figname.png')``
should be used after calling `probplot`.

.. versionadded:: 1.2.0

Examples
--------
&gt;&gt;&gt; from scipy import stats
&gt;&gt;&gt; import matplotlib.pyplot as plt

Generate some non-normally distributed data, and create a Yeo-Johnson plot:

&gt;&gt;&gt; x = stats.loggamma.rvs(5, size=500) + 5
&gt;&gt;&gt; fig = plt.figure()
&gt;&gt;&gt; ax = fig.add_subplot(111)
&gt;&gt;&gt; prob = stats.yeojohnson_normplot(x, -20, 20, plot=ax)

Determine and plot the optimal ``lmbda`` to transform ``x`` and plot it in
the same plot:

&gt;&gt;&gt; _, maxlog = stats.yeojohnson(x)
&gt;&gt;&gt; ax.axvline(maxlog, color='r')

&gt;&gt;&gt; plt.show()
</pre> 
<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l01669">1669</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

<p class="reference">References <a class="el" href="../../db/d84/__morestats_8py_source.html#l01284">_normplot()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="abf0f4fd772467873380775de27d522b8" name="abf0f4fd772467873380775de27d522b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf0f4fd772467873380775de27d522b8">&#9670;&#160;</a></span>__all__</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">list scipy.stats._morestats.__all__</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  [<span class="stringliteral">&#39;mvsdist&#39;</span>,</div>
<div class="line"><span class="lineno">    2</span>           <span class="stringliteral">&#39;bayes_mvs&#39;</span>, <span class="stringliteral">&#39;kstat&#39;</span>, <span class="stringliteral">&#39;kstatvar&#39;</span>, <span class="stringliteral">&#39;probplot&#39;</span>, <span class="stringliteral">&#39;ppcc_max&#39;</span>, <span class="stringliteral">&#39;ppcc_plot&#39;</span>,</div>
<div class="line"><span class="lineno">    3</span>           <span class="stringliteral">&#39;boxcox_llf&#39;</span>, <span class="stringliteral">&#39;boxcox&#39;</span>, <span class="stringliteral">&#39;boxcox_normmax&#39;</span>, <span class="stringliteral">&#39;boxcox_normplot&#39;</span>,</div>
<div class="line"><span class="lineno">    4</span>           <span class="stringliteral">&#39;shapiro&#39;</span>, <span class="stringliteral">&#39;anderson&#39;</span>, <span class="stringliteral">&#39;ansari&#39;</span>, <span class="stringliteral">&#39;bartlett&#39;</span>, <span class="stringliteral">&#39;levene&#39;</span>, <span class="stringliteral">&#39;binom_test&#39;</span>,</div>
<div class="line"><span class="lineno">    5</span>           <span class="stringliteral">&#39;fligner&#39;</span>, <span class="stringliteral">&#39;mood&#39;</span>, <span class="stringliteral">&#39;wilcoxon&#39;</span>, <span class="stringliteral">&#39;median_test&#39;</span>,</div>
<div class="line"><span class="lineno">    6</span>           <span class="stringliteral">&#39;circmean&#39;</span>, <span class="stringliteral">&#39;circvar&#39;</span>, <span class="stringliteral">&#39;circstd&#39;</span>, <span class="stringliteral">&#39;anderson_ksamp&#39;</span>,</div>
<div class="line"><span class="lineno">    7</span>           <span class="stringliteral">&#39;yeojohnson_llf&#39;</span>, <span class="stringliteral">&#39;yeojohnson&#39;</span>, <span class="stringliteral">&#39;yeojohnson_normmax&#39;</span>,</div>
<div class="line"><span class="lineno">    8</span>           <span class="stringliteral">&#39;yeojohnson_normplot&#39;</span>, <span class="stringliteral">&#39;directional_stats&#39;</span>,</div>
<div class="line"><span class="lineno">    9</span>           <span class="stringliteral">&#39;false_discovery_control&#39;</span></div>
<div class="line"><span class="lineno">   10</span>           ]</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l00028">28</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

</div>
</div>
<a id="a07abc5dc6f5050cd6d367147d07ceab8" name="a07abc5dc6f5050cd6d367147d07ceab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07abc5dc6f5050cd6d367147d07ceab8">&#9670;&#160;</a></span>_abw_state</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats._abw_state = <a class="el" href="../../db/d8c/classscipy_1_1stats_1_1__morestats_1_1__ABW.html">_ABW</a>()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l02508">2508</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

</div>
</div>
<a id="a8549d509c0d1eeba1b065cbdf4639966" name="a8549d509c0d1eeba1b065cbdf4639966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8549d509c0d1eeba1b065cbdf4639966">&#9670;&#160;</a></span>_Avals_expon</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats._Avals_expon = array([0.922, 1.078, 1.341, 1.606, 1.957])</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l01895">1895</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

</div>
</div>
<a id="a4a7e585a2cdac83e1d7baba82b355ecd" name="a4a7e585a2cdac83e1d7baba82b355ecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a7e585a2cdac83e1d7baba82b355ecd">&#9670;&#160;</a></span>_Avals_gumbel</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats._Avals_gumbel = array([0.474, 0.637, 0.757, 0.877, 1.038])</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l01898">1898</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

</div>
</div>
<a id="aa81d3b78fe67a51c6bea0ef06599d68b" name="aa81d3b78fe67a51c6bea0ef06599d68b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa81d3b78fe67a51c6bea0ef06599d68b">&#9670;&#160;</a></span>_Avals_logistic</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats._Avals_logistic = array([0.426, 0.563, 0.660, 0.769, 0.906, 1.010])</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l01902">1902</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

</div>
</div>
<a id="a7cd2ed9760a5b98dbc3fd333fc804528" name="a7cd2ed9760a5b98dbc3fd333fc804528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cd2ed9760a5b98dbc3fd333fc804528">&#9670;&#160;</a></span>_Avals_norm</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats._Avals_norm = array([0.576, 0.656, 0.787, 0.918, 1.092])</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l01894">1894</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

</div>
</div>
<a id="a10992db1e056da85f3087e90be78b5d3" name="a10992db1e056da85f3087e90be78b5d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10992db1e056da85f3087e90be78b5d3">&#9670;&#160;</a></span>_Avals_weibull</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats._Avals_weibull</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  [[0.292, 0.395, 0.467, 0.522, 0.617, 0.711, 0.836, 0.931],</div>
<div class="line"><span class="lineno">    2</span>                  [0.295, 0.399, 0.471, 0.527, 0.623, 0.719, 0.845, 0.941],</div>
<div class="line"><span class="lineno">    3</span>                  [0.298, 0.403, 0.476, 0.534, 0.631, 0.728, 0.856, 0.954],</div>
<div class="line"><span class="lineno">    4</span>                  [0.301, 0.408, 0.483, 0.541, 0.640, 0.738, 0.869, 0.969],</div>
<div class="line"><span class="lineno">    5</span>                  [0.305, 0.414, 0.490, 0.549, 0.650, 0.751, 0.885, 0.986],</div>
<div class="line"><span class="lineno">    6</span>                  [0.309, 0.421, 0.498, 0.559, 0.662, 0.765, 0.902, 1.007],</div>
<div class="line"><span class="lineno">    7</span>                  [0.314, 0.429, 0.508, 0.570, 0.676, 0.782, 0.923, 1.030],</div>
<div class="line"><span class="lineno">    8</span>                  [0.320, 0.438, 0.519, 0.583, 0.692, 0.802, 0.947, 1.057],</div>
<div class="line"><span class="lineno">    9</span>                  [0.327, 0.448, 0.532, 0.598, 0.711, 0.824, 0.974, 1.089],</div>
<div class="line"><span class="lineno">   10</span>                  [0.334, 0.469, 0.547, 0.615, 0.732, 0.850, 1.006, 1.125],</div>
<div class="line"><span class="lineno">   11</span>                  [0.342, 0.472, 0.563, 0.636, 0.757, 0.879, 1.043, 1.167]]</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l01907">1907</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

</div>
</div>
<a id="a5395ce168ae4cbc09a446fc54f69f47a" name="a5395ce168ae4cbc09a446fc54f69f47a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5395ce168ae4cbc09a446fc54f69f47a">&#9670;&#160;</a></span>_cvals_weibull</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats._cvals_weibull = np.linspace(0, 0.5, 11)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l01919">1919</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

</div>
</div>
<a id="ace023ed646db4e070b167dd34d0c1112" name="ace023ed646db4e070b167dd34d0c1112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace023ed646db4e070b167dd34d0c1112">&#9670;&#160;</a></span>_get_As_weibull</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats._get_As_weibull</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  interpolate.interp1d(_cvals_weibull, _Avals_weibull.T,</div>
<div class="line"><span class="lineno">    2</span>                                       kind=<span class="stringliteral">&#39;linear&#39;</span>, bounds_error=<span class="keyword">False</span>,</div>
<div class="line"><span class="lineno">    3</span>                                       fill_value=_Avals_weibull[-1])</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l01920">1920</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

</div>
</div>
<a id="a0d0d6fdc5a2cc8ffd86eb87a38bfa5ff" name="a0d0d6fdc5a2cc8ffd86eb87a38bfa5ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d0d6fdc5a2cc8ffd86eb87a38bfa5ff">&#9670;&#160;</a></span>Anderson_ksampResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.Anderson_ksampResult</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  _make_tuple_bunch(</div>
<div class="line"><span class="lineno">    2</span>    <span class="stringliteral">&#39;Anderson_ksampResult&#39;</span>,</div>
<div class="line"><span class="lineno">    3</span>    [<span class="stringliteral">&#39;statistic&#39;</span>, <span class="stringliteral">&#39;critical_values&#39;</span>, <span class="stringliteral">&#39;pvalue&#39;</span>], []</div>
<div class="line"><span class="lineno">    4</span>)</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l02279">2279</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

</div>
</div>
<a id="a4c2b948cf1b0b7f3e3a89f732d46a158" name="a4c2b948cf1b0b7f3e3a89f732d46a158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c2b948cf1b0b7f3e3a89f732d46a158">&#9670;&#160;</a></span>AndersonResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.AndersonResult</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  _make_tuple_bunch(<span class="stringliteral">&#39;AndersonResult&#39;</span>,</div>
<div class="line"><span class="lineno">    2</span>                                   [<span class="stringliteral">&#39;statistic&#39;</span>, <span class="stringliteral">&#39;critical_values&#39;</span>,</div>
<div class="line"><span class="lineno">    3</span>                                    <span class="stringliteral">&#39;significance_level&#39;</span>], [<span class="stringliteral">&#39;fit_result&#39;</span>])</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l01990">1990</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

</div>
</div>
<a id="ac2ca11a242ed6b7363bbcd987cb99719" name="ac2ca11a242ed6b7363bbcd987cb99719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2ca11a242ed6b7363bbcd987cb99719">&#9670;&#160;</a></span>AnsariResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.AnsariResult = <a class="el" href="../../d7/d51/classnamedtuple.html">namedtuple</a>('AnsariResult', ('statistic', 'pvalue'))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l02450">2450</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

</div>
</div>
<a id="a554d0b4564651ac511f77b4db7cedcbc" name="a554d0b4564651ac511f77b4db7cedcbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a554d0b4564651ac511f77b4db7cedcbc">&#9670;&#160;</a></span>BartlettResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.BartlettResult = <a class="el" href="../../d7/d51/classnamedtuple.html">namedtuple</a>('BartlettResult', ('statistic', 'pvalue'))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l02671">2671</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

</div>
</div>
<a id="a5984334ae4ec091c625db36e4df5a0fc" name="a5984334ae4ec091c625db36e4df5a0fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5984334ae4ec091c625db36e4df5a0fc">&#9670;&#160;</a></span>FlignerResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.FlignerResult = <a class="el" href="../../d7/d51/classnamedtuple.html">namedtuple</a>('FlignerResult', ('statistic', 'pvalue'))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l03304">3304</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

</div>
</div>
<a id="a3aa85627e72f7e9cfaa3289858b4070b" name="a3aa85627e72f7e9cfaa3289858b4070b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aa85627e72f7e9cfaa3289858b4070b">&#9670;&#160;</a></span>LeveneResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.LeveneResult = <a class="el" href="../../d7/d51/classnamedtuple.html">namedtuple</a>('LeveneResult', ('statistic', 'pvalue'))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l02910">2910</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

</div>
</div>
<a id="a4c7e806ff86e4c65ae6c3bb01070277d" name="a4c7e806ff86e4c65ae6c3bb01070277d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c7e806ff86e4c65ae6c3bb01070277d">&#9670;&#160;</a></span>Mean</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.Mean = <a class="el" href="../../d7/d51/classnamedtuple.html">namedtuple</a>('Mean', ('statistic', '<a class="el" href="../../db/de6/classminmax.html">minmax</a>'))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l00040">40</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

</div>
</div>
<a id="a6759d232a7b56059c1560724f99919cb" name="a6759d232a7b56059c1560724f99919cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6759d232a7b56059c1560724f99919cb">&#9670;&#160;</a></span>MedianTestResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.MedianTestResult</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  _make_tuple_bunch(</div>
<div class="line"><span class="lineno">    2</span>    <span class="stringliteral">&#39;MedianTestResult&#39;</span>,</div>
<div class="line"><span class="lineno">    3</span>    [<span class="stringliteral">&#39;statistic&#39;</span>, <span class="stringliteral">&#39;pvalue&#39;</span>, <span class="stringliteral">&#39;median&#39;</span>, <span class="stringliteral">&#39;table&#39;</span>], []</div>
<div class="line"><span class="lineno">    4</span>)</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l04187">4187</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

</div>
</div>
<a id="aee599c9ef5b9c5cb6169a4073e4f652d" name="aee599c9ef5b9c5cb6169a4073e4f652d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee599c9ef5b9c5cb6169a4073e4f652d">&#9670;&#160;</a></span>ShapiroResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.ShapiroResult = <a class="el" href="../../d7/d51/classnamedtuple.html">namedtuple</a>('ShapiroResult', ('statistic', 'pvalue'))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l01739">1739</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

</div>
</div>
<a id="ae5e0efb5926c36511cd250ae4ad4f517" name="ae5e0efb5926c36511cd250ae4ad4f517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5e0efb5926c36511cd250ae4ad4f517">&#9670;&#160;</a></span>Std_dev</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.Std_dev = <a class="el" href="../../d7/d51/classnamedtuple.html">namedtuple</a>('Std_dev', ('statistic', '<a class="el" href="../../db/de6/classminmax.html">minmax</a>'))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l00042">42</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

</div>
</div>
<a id="abab3ea6ff622d79893687564827860de" name="abab3ea6ff622d79893687564827860de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abab3ea6ff622d79893687564827860de">&#9670;&#160;</a></span>Variance</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.Variance = <a class="el" href="../../d7/d51/classnamedtuple.html">namedtuple</a>('Variance', ('statistic', '<a class="el" href="../../db/de6/classminmax.html">minmax</a>'))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l00041">41</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

</div>
</div>
<a id="a55dc3765613b9ba274d8c8020459cf47" name="a55dc3765613b9ba274d8c8020459cf47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55dc3765613b9ba274d8c8020459cf47">&#9670;&#160;</a></span>WilcoxonResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.stats._morestats.WilcoxonResult = _make_tuple_bunch('WilcoxonResult', ['statistic', 'pvalue'])</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../db/d84/__morestats_8py_source.html#l03807">3807</a> of file <a class="el" href="../../db/d84/__morestats_8py_source.html">_morestats.py</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../db/d0f/namespacescipy.html">scipy</a></li><li class="navelem"><a class="el" href="../../d0/df6/namespacescipy_1_1stats.html">stats</a></li><li class="navelem"><a class="el" href="../../d6/d08/namespacescipy_1_1stats_1_1__morestats.html">_morestats</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
