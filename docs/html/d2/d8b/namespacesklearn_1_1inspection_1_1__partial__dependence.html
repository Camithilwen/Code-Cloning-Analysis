<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Code Cloning Analysis: sklearn.inspection._partial_dependence Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Code Cloning Analysis
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d2/d8b/namespacesklearn_1_1inspection_1_1__partial__dependence.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">sklearn.inspection._partial_dependence Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0b534d4f30b7dd8df8fd2dfb3550b45c" id="r_a0b534d4f30b7dd8df8fd2dfb3550b45c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b534d4f30b7dd8df8fd2dfb3550b45c">_grid_from_X</a> (X, percentiles, is_categorical, grid_resolution, custom_values)</td></tr>
<tr class="separator:a0b534d4f30b7dd8df8fd2dfb3550b45c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2efd20fe885379a42a2deb7c4aec67be" id="r_a2efd20fe885379a42a2deb7c4aec67be"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2efd20fe885379a42a2deb7c4aec67be">_partial_dependence_recursion</a> (est, grid, features)</td></tr>
<tr class="separator:a2efd20fe885379a42a2deb7c4aec67be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdeaff408e05b819e07c334d2b3e2235" id="r_afdeaff408e05b819e07c334d2b3e2235"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afdeaff408e05b819e07c334d2b3e2235">_partial_dependence_brute</a> (est, grid, features, X, response_method, sample_weight=None)</td></tr>
<tr class="separator:afdeaff408e05b819e07c334d2b3e2235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ee78bd4dbd71afaf47b4721f77af94" id="r_af2ee78bd4dbd71afaf47b4721f77af94"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2ee78bd4dbd71afaf47b4721f77af94">partial_dependence</a> (estimator, X, features, *, sample_weight=None, categorical_features=None, feature_names=None, response_method=&quot;auto&quot;, percentiles=(0.05, 0.95), grid_resolution=100, custom_values=None, method=&quot;auto&quot;, kind=&quot;average&quot;)</td></tr>
<tr class="separator:af2ee78bd4dbd71afaf47b4721f77af94"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a745f6c1e530ab6f32ba8aa1279892d71" id="r_a745f6c1e530ab6f32ba8aa1279892d71"><td class="memItemLeft" align="right" valign="top">list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a745f6c1e530ab6f32ba8aa1279892d71">__all__</a></td></tr>
<tr class="separator:a745f6c1e530ab6f32ba8aa1279892d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Partial dependence plots for regression and classification models.</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a0b534d4f30b7dd8df8fd2dfb3550b45c" name="a0b534d4f30b7dd8df8fd2dfb3550b45c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b534d4f30b7dd8df8fd2dfb3550b45c">&#9670;&#160;</a></span>_grid_from_X()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.inspection._partial_dependence._grid_from_X </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>percentiles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>is_categorical</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>grid_resolution</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>custom_values</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Generate a grid of points based on the percentiles of X.

The grid is a cartesian product between the columns of ``values``. The
ith column of ``values`` consists in ``grid_resolution`` equally-spaced
points between the percentiles of the jth column of X.

If ``grid_resolution`` is bigger than the number of unique values in the
j-th column of X or if the feature is a categorical feature (by inspecting
`is_categorical`) , then those unique values will be used instead.

Parameters
----------
X : array-like of shape (n_samples, n_target_features)
    The data.

percentiles : tuple of float
    The percentiles which are used to construct the extreme values of
    the grid. Must be in [0, 1].

is_categorical : list of bool
    For each feature, tells whether it is categorical or not. If a feature
    is categorical, then the values used will be the unique ones
    (i.e. categories) instead of the percentiles.

grid_resolution : int
    The number of equally spaced points to be placed on the grid for each
    feature.

custom_values: dict
    Mapping from column index of X to an array-like of values where
    the partial dependence should be calculated for that feature

Returns
-------
grid : ndarray of shape (n_points, n_target_features)
    A value for each feature at each point in the grid. ``n_points`` is
    always ``&lt;= grid_resolution ** X.shape[1]``.

values : list of 1d ndarrays
    The values with which the grid has been created. The size of each
    array ``values[j]`` is either ``grid_resolution``, the number of
    unique values in ``X[:, j]``, if j is not in ``custom_range``.
    If j is in ``custom_range``, then it is the length of ``custom_range[j]``.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d4/d14/__partial__dependence_8py_source.html#l00040">40</a> of file <a class="el" href="../../d4/d14/__partial__dependence_8py_source.html">_partial_dependence.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d4/d14/__partial__dependence_8py_source.html#l00381">partial_dependence()</a>.</p>

</div>
</div>
<a id="afdeaff408e05b819e07c334d2b3e2235" name="afdeaff408e05b819e07c334d2b3e2235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdeaff408e05b819e07c334d2b3e2235">&#9670;&#160;</a></span>_partial_dependence_brute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.inspection._partial_dependence._partial_dependence_brute </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>est</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>features</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>response_method</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>sample_weight</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Calculate partial dependence via the brute force method.

The brute method explicitly averages the predictions of an estimator over a
grid of feature values.

For each `grid` value, all the samples from `X` have their variables of
interest replaced by that specific `grid` value. The predictions are then made
and averaged across the samples.

This method is slower than the `'recursion'`
(:func:`~sklearn.inspection._partial_dependence._partial_dependence_recursion`)
version for estimators with this second option. However, with the `'brute'`
force method, the average will be done with the given `X` and not the `X`
used during training, as it is done in the `'recursion'` version. Therefore
the average can always accept `sample_weight` (even when the estimator was
fitted without).

Parameters
----------
est : BaseEstimator
    A fitted estimator object implementing :term:`predict`,
    :term:`predict_proba`, or :term:`decision_function`.
    Multioutput-multiclass classifiers are not supported.

grid : array-like of shape (n_points, n_target_features)
    The grid of feature values for which the partial dependence is calculated.
    Note that `n_points` is the number of points in the grid and `n_target_features`
    is the number of features you are doing partial dependence at.

features : array-like of {int, str}
    The feature (e.g. `[0]`) or pair of interacting features
    (e.g. `[(0, 1)]`) for which the partial dependency should be computed.

X : array-like of shape (n_samples, n_features)
    `X` is used to generate values for the complement features. That is, for
    each value in `grid`, the method will average the prediction of each
    sample from `X` having that grid value for `features`.

response_method : {'auto', 'predict_proba', 'decision_function'}, \
        default='auto'
    Specifies whether to use :term:`predict_proba` or
    :term:`decision_function` as the target response. For regressors
    this parameter is ignored and the response is always the output of
    :term:`predict`. By default, :term:`predict_proba` is tried first
    and we revert to :term:`decision_function` if it doesn't exist.

sample_weight : array-like of shape (n_samples,), default=None
    Sample weights are used to calculate weighted means when averaging the
    model output. If `None`, then samples are equally weighted. Note that
    `sample_weight` does not change the individual predictions.

Returns
-------
averaged_predictions : array-like of shape (n_targets, n_points)
    The averaged predictions for the given `grid` of features values.
    Note that `n_targets` is the number of targets (e.g. 1 for binary
    classification, `n_tasks` for multi-output regression, and `n_classes` for
    multiclass classification) and `n_points` is the number of points in the `grid`.

predictions : array-like
    The predictions for the given `grid` of features values over the samples
    from `X`. For non-multioutput regression and binary classification the
    shape is `(n_instances, n_points)` and for multi-output regression and
    multiclass classification the shape is `(n_targets, n_instances, n_points)`,
    where `n_targets` is the number of targets (`n_tasks` for multi-output
    regression, and `n_classes` for multiclass classification), `n_instances`
    is the number of instances in `X`, and `n_points` is the number of points
    in the `grid`.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d4/d14/__partial__dependence_8py_source.html#l00218">218</a> of file <a class="el" href="../../d4/d14/__partial__dependence_8py_source.html">_partial_dependence.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d4/d14/__partial__dependence_8py_source.html#l00381">partial_dependence()</a>.</p>

</div>
</div>
<a id="a2efd20fe885379a42a2deb7c4aec67be" name="a2efd20fe885379a42a2deb7c4aec67be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2efd20fe885379a42a2deb7c4aec67be">&#9670;&#160;</a></span>_partial_dependence_recursion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.inspection._partial_dependence._partial_dependence_recursion </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>est</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>features</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Calculate partial dependence via the recursion method.

The recursion method is in particular enabled for tree-based estimators.

For each `grid` value, a weighted tree traversal is performed: if a split node
involves an input feature of interest, the corresponding left or right branch
is followed; otherwise both branches are followed, each branch being weighted
by the fraction of training samples that entered that branch. Finally, the
partial dependence is given by a weighted average of all the visited leaves
values.

This method is more efficient in terms of speed than the `'brute'` method
(:func:`~sklearn.inspection._partial_dependence._partial_dependence_brute`).
However, here, the partial dependence computation is done explicitly with the
`X` used during training of `est`.

Parameters
----------
est : BaseEstimator
    A fitted estimator object implementing :term:`predict` or
    :term:`decision_function`. Multioutput-multiclass classifiers are not
    supported. Note that `'recursion'` is only supported for some tree-based
    estimators (namely
    :class:`~sklearn.ensemble.GradientBoostingClassifier`,
    :class:`~sklearn.ensemble.GradientBoostingRegressor`,
    :class:`~sklearn.ensemble.HistGradientBoostingClassifier`,
    :class:`~sklearn.ensemble.HistGradientBoostingRegressor`,
    :class:`~sklearn.tree.DecisionTreeRegressor`,
    :class:`~sklearn.ensemble.RandomForestRegressor`,
    ).

grid : array-like of shape (n_points, n_target_features)
    The grid of feature values for which the partial dependence is calculated.
    Note that `n_points` is the number of points in the grid and `n_target_features`
    is the number of features you are doing partial dependence at.

features : array-like of {int, str}
    The feature (e.g. `[0]`) or pair of interacting features
    (e.g. `[(0, 1)]`) for which the partial dependency should be computed.

Returns
-------
averaged_predictions : array-like of shape (n_targets, n_points)
    The averaged predictions for the given `grid` of features values.
    Note that `n_targets` is the number of targets (e.g. 1 for binary
    classification, `n_tasks` for multi-output regression, and `n_classes` for
    multiclass classification) and `n_points` is the number of points in the `grid`.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d4/d14/__partial__dependence_8py_source.html#l00160">160</a> of file <a class="el" href="../../d4/d14/__partial__dependence_8py_source.html">_partial_dependence.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d4/d14/__partial__dependence_8py_source.html#l00381">partial_dependence()</a>.</p>

</div>
</div>
<a id="af2ee78bd4dbd71afaf47b4721f77af94" name="af2ee78bd4dbd71afaf47b4721f77af94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2ee78bd4dbd71afaf47b4721f77af94">&#9670;&#160;</a></span>partial_dependence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.inspection._partial_dependence.partial_dependence </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>estimator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>features</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>sample_weight</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>categorical_features</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>feature_names</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>response_method</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;auto&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>percentiles</em></span><span class="paramdefsep"> = </span><span class="paramdefval">(0.05,&#160;0.95)</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>grid_resolution</em></span><span class="paramdefsep"> = </span><span class="paramdefval">100</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>custom_values</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>method</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;auto&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>kind</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;average&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Partial dependence of ``features``.

Partial dependence of a feature (or a set of features) corresponds to
the average response of an estimator for each possible value of the
feature.

Read more in
:ref:`sphx_glr_auto_examples_inspection_plot_partial_dependence.py`
and the :ref:`User Guide &lt;partial_dependence&gt;`.

.. warning::

    For :class:`~sklearn.ensemble.GradientBoostingClassifier` and
    :class:`~sklearn.ensemble.GradientBoostingRegressor`, the
    `'recursion'` method (used by default) will not account for the `init`
    predictor of the boosting process. In practice, this will produce
    the same values as `'brute'` up to a constant offset in the target
    response, provided that `init` is a constant estimator (which is the
    default). However, if `init` is not a constant estimator, the
    partial dependence values are incorrect for `'recursion'` because the
    offset will be sample-dependent. It is preferable to use the `'brute'`
    method. Note that this only applies to
    :class:`~sklearn.ensemble.GradientBoostingClassifier` and
    :class:`~sklearn.ensemble.GradientBoostingRegressor`, not to
    :class:`~sklearn.ensemble.HistGradientBoostingClassifier` and
    :class:`~sklearn.ensemble.HistGradientBoostingRegressor`.

Parameters
----------
estimator : BaseEstimator
    A fitted estimator object implementing :term:`predict`,
    :term:`predict_proba`, or :term:`decision_function`.
    Multioutput-multiclass classifiers are not supported.

X : {array-like, sparse matrix or dataframe} of shape (n_samples, n_features)
    ``X`` is used to generate a grid of values for the target
    ``features`` (where the partial dependence will be evaluated), and
    also to generate values for the complement features when the
    `method` is 'brute'.

features : array-like of {int, str, bool} or int or str
    The feature (e.g. `[0]`) or pair of interacting features
    (e.g. `[(0, 1)]`) for which the partial dependency should be computed.

sample_weight : array-like of shape (n_samples,), default=None
    Sample weights are used to calculate weighted means when averaging the
    model output. If `None`, then samples are equally weighted. If
    `sample_weight` is not `None`, then `method` will be set to `'brute'`.
    Note that `sample_weight` is ignored for `kind='individual'`.

    .. versionadded:: 1.3

categorical_features : array-like of shape (n_features,) or shape \
        (n_categorical_features,), dtype={bool, int, str}, default=None
    Indicates the categorical features.

    - `None`: no feature will be considered categorical;
    - boolean array-like: boolean mask of shape `(n_features,)`
        indicating which features are categorical. Thus, this array has
        the same shape has `X.shape[1]`;
    - integer or string array-like: integer indices or strings
        indicating categorical features.

    .. versionadded:: 1.2

feature_names : array-like of shape (n_features,), dtype=str, default=None
    Name of each feature; `feature_names[i]` holds the name of the feature
    with index `i`.
    By default, the name of the feature corresponds to their numerical
    index for NumPy array and their column name for pandas dataframe.

    .. versionadded:: 1.2

response_method : {'auto', 'predict_proba', 'decision_function'}, \
        default='auto'
    Specifies whether to use :term:`predict_proba` or
    :term:`decision_function` as the target response. For regressors
    this parameter is ignored and the response is always the output of
    :term:`predict`. By default, :term:`predict_proba` is tried first
    and we revert to :term:`decision_function` if it doesn't exist. If
    ``method`` is 'recursion', the response is always the output of
    :term:`decision_function`.

percentiles : tuple of float, default=(0.05, 0.95)
    The lower and upper percentile used to create the extreme values
    for the grid. Must be in [0, 1].
    This parameter is overridden by `custom_values` if that parameter is set.

grid_resolution : int, default=100
    The number of equally spaced points on the grid, for each target
    feature.
    This parameter is overridden by `custom_values` if that parameter is set.

custom_values : dict
    A dictionary mapping the index of an element of `features` to an array
    of values where the partial dependence should be calculated
    for that feature. Setting a range of values for a feature overrides
    `grid_resolution` and `percentiles`.

    See :ref:`how to use partial_dependence
    &lt;plt_partial_dependence_custom_values&gt;` for an example of how this parameter can
    be used.

    .. versionadded:: 1.7

method : {'auto', 'recursion', 'brute'}, default='auto'
    The method used to calculate the averaged predictions:

    - `'recursion'` is only supported for some tree-based estimators
      (namely
      :class:`~sklearn.ensemble.GradientBoostingClassifier`,
      :class:`~sklearn.ensemble.GradientBoostingRegressor`,
      :class:`~sklearn.ensemble.HistGradientBoostingClassifier`,
      :class:`~sklearn.ensemble.HistGradientBoostingRegressor`,
      :class:`~sklearn.tree.DecisionTreeRegressor`,
      :class:`~sklearn.ensemble.RandomForestRegressor`,
      ) when `kind='average'`.
      This is more efficient in terms of speed.
      With this method, the target response of a
      classifier is always the decision function, not the predicted
      probabilities. Since the `'recursion'` method implicitly computes
      the average of the Individual Conditional Expectation (ICE) by
      design, it is not compatible with ICE and thus `kind` must be
      `'average'`.

    - `'brute'` is supported for any estimator, but is more
      computationally intensive.

    - `'auto'`: the `'recursion'` is used for estimators that support it,
      and `'brute'` is used otherwise. If `sample_weight` is not `None`,
      then `'brute'` is used regardless of the estimator.

    Please see :ref:`this note &lt;pdp_method_differences&gt;` for
    differences between the `'brute'` and `'recursion'` method.

kind : {'average', 'individual', 'both'}, default='average'
    Whether to return the partial dependence averaged across all the
    samples in the dataset or one value per sample or both.
    See Returns below.

    Note that the fast `method='recursion'` option is only available for
    `kind='average'` and `sample_weights=None`. Computing individual
    dependencies and doing weighted averages requires using the slower
    `method='brute'`.

    .. versionadded:: 0.24

Returns
-------
predictions : :class:`~sklearn.utils.Bunch`
    Dictionary-like object, with the following attributes.

    individual : ndarray of shape (n_outputs, n_instances, \
            len(values[0]), len(values[1]), ...)
        The predictions for all the points in the grid for all
        samples in X. This is also known as Individual
        Conditional Expectation (ICE).
        Only available when `kind='individual'` or `kind='both'`.

    average : ndarray of shape (n_outputs, len(values[0]), \
            len(values[1]), ...)
        The predictions for all the points in the grid, averaged
        over all samples in X (or over the training data if
        `method` is 'recursion').
        Only available when `kind='average'` or `kind='both'`.

    grid_values : seq of 1d ndarrays
        The values with which the grid has been created. The generated
        grid is a cartesian product of the arrays in `grid_values` where
        `len(grid_values) == len(features)`. The size of each array
        `grid_values[j]` is either `grid_resolution`, or the number of
        unique values in `X[:, j]`, whichever is smaller.

        .. versionadded:: 1.3

    `n_outputs` corresponds to the number of classes in a multi-class
    setting, or to the number of tasks for multi-output regression.
    For classical regression and binary classification `n_outputs==1`.
    `n_values_feature_j` corresponds to the size `grid_values[j]`.

See Also
--------
PartialDependenceDisplay.from_estimator : Plot Partial Dependence.
PartialDependenceDisplay : Partial Dependence visualization.

Examples
--------
&gt;&gt;&gt; X = [[0, 0, 2], [1, 0, 0]]
&gt;&gt;&gt; y = [0, 1]
&gt;&gt;&gt; from sklearn.ensemble import GradientBoostingClassifier
&gt;&gt;&gt; gb = GradientBoostingClassifier(random_state=0).fit(X, y)
&gt;&gt;&gt; partial_dependence(gb, features=[0], X=X, percentiles=(0, 1),
...                    grid_resolution=2) # doctest: +SKIP
(array([[-4.52,  4.52]]), [array([ 0.,  1.])])
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d4/d14/__partial__dependence_8py_source.html#l00367">367</a> of file <a class="el" href="../../d4/d14/__partial__dependence_8py_source.html">_partial_dependence.py</a>.</p>

<p class="reference">References <a class="el" href="../../d4/d14/__partial__dependence_8py_source.html#l00040">_grid_from_X()</a>, <a class="el" href="../../d4/d14/__partial__dependence_8py_source.html#l00220">_partial_dependence_brute()</a>, and <a class="el" href="../../d4/d14/__partial__dependence_8py_source.html#l00160">_partial_dependence_recursion()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a745f6c1e530ab6f32ba8aa1279892d71" name="a745f6c1e530ab6f32ba8aa1279892d71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a745f6c1e530ab6f32ba8aa1279892d71">&#9670;&#160;</a></span>__all__</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">list sklearn.inspection._partial_dependence.__all__</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  [</div>
<div class="line"><span class="lineno">    2</span>    <span class="stringliteral">&quot;partial_dependence&quot;</span>,</div>
<div class="line"><span class="lineno">    3</span>]</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="../../d4/d14/__partial__dependence_8py_source.html#l00035">35</a> of file <a class="el" href="../../d4/d14/__partial__dependence_8py_source.html">_partial_dependence.py</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d6/d1d/namespacesklearn.html">sklearn</a></li><li class="navelem"><a class="el" href="../../d3/da6/namespacesklearn_1_1inspection.html">inspection</a></li><li class="navelem"><a class="el" href="../../d2/d8b/namespacesklearn_1_1inspection_1_1__partial__dependence.html">_partial_dependence</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
