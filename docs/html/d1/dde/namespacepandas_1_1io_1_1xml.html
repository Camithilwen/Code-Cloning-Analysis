<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Code Cloning Analysis: pandas.io.xml Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Code Cloning Analysis
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d1/dde/namespacepandas_1_1io_1_1xml.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">pandas.io.xml Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/ddc/classpandas_1_1io_1_1xml_1_1__EtreeFrameParser.html">_EtreeFrameParser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d28/classpandas_1_1io_1_1xml_1_1__LxmlFrameParser.html">_LxmlFrameParser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/de5/classpandas_1_1io_1_1xml_1_1__XMLFrameParser.html">_XMLFrameParser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a67c794bfdfaf92783b14e5c5ea33c321" id="r_a67c794bfdfaf92783b14e5c5ea33c321"><td class="memItemLeft" align="right" valign="top">str|bytes|<a class="el" href="../../d4/d8e/classpandas_1_1__typing_1_1ReadBuffer.html">ReadBuffer</a>[bytes]|<a class="el" href="../../d4/d8e/classpandas_1_1__typing_1_1ReadBuffer.html">ReadBuffer</a>[str]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67c794bfdfaf92783b14e5c5ea33c321">get_data_from_filepath</a> (FilePath|bytes|<a class="el" href="../../d4/d8e/classpandas_1_1__typing_1_1ReadBuffer.html">ReadBuffer</a>[bytes]|<a class="el" href="../../d4/d8e/classpandas_1_1__typing_1_1ReadBuffer.html">ReadBuffer</a>[str] filepath_or_buffer, str|None encoding, CompressionOptions compression, StorageOptions storage_options)</td></tr>
<tr class="separator:a67c794bfdfaf92783b14e5c5ea33c321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e00c5ae2a77150415d7efd48b1d84c" id="r_af3e00c5ae2a77150415d7efd48b1d84c"><td class="memItemLeft" align="right" valign="top">io.StringIO|io.BytesIO&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3e00c5ae2a77150415d7efd48b1d84c">preprocess_data</a> (data)</td></tr>
<tr class="separator:af3e00c5ae2a77150415d7efd48b1d84c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaeb915a6b24afce31e3c0bcd7d1f698" id="r_acaeb915a6b24afce31e3c0bcd7d1f698"><td class="memItemLeft" align="right" valign="top">DataFrame&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acaeb915a6b24afce31e3c0bcd7d1f698">_data_to_frame</a> (data, **kwargs)</td></tr>
<tr class="separator:acaeb915a6b24afce31e3c0bcd7d1f698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a756e1182724cbdcdf66c0fc96fdd5398" id="r_a756e1182724cbdcdf66c0fc96fdd5398"><td class="memItemLeft" align="right" valign="top">DataFrame&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a756e1182724cbdcdf66c0fc96fdd5398">_parse</a> (FilePath|<a class="el" href="../../d4/d8e/classpandas_1_1__typing_1_1ReadBuffer.html">ReadBuffer</a>[bytes]|<a class="el" href="../../d4/d8e/classpandas_1_1__typing_1_1ReadBuffer.html">ReadBuffer</a>[str] path_or_buffer, str xpath, dict[str, str]|None namespaces, bool elems_only, bool attrs_only, Sequence[str]|None names, DtypeArg|None dtype, ConvertersArg|None converters, ParseDatesArg|None parse_dates, str|None encoding, XMLParsers parser, FilePath|<a class="el" href="../../d4/d8e/classpandas_1_1__typing_1_1ReadBuffer.html">ReadBuffer</a>[bytes]|<a class="el" href="../../d4/d8e/classpandas_1_1__typing_1_1ReadBuffer.html">ReadBuffer</a>[str]|None stylesheet, dict[str, list[str]]|None iterparse, CompressionOptions compression, StorageOptions storage_options, DtypeBackend|lib.NoDefault dtype_backend=lib.no_default, **kwargs)</td></tr>
<tr class="separator:a756e1182724cbdcdf66c0fc96fdd5398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3ec489e78912b8149c74b35da3fd1e7" id="r_ae3ec489e78912b8149c74b35da3fd1e7"><td class="memItemLeft" align="right" valign="top">DataFrame&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3ec489e78912b8149c74b35da3fd1e7">read_xml</a> (FilePath|<a class="el" href="../../d4/d8e/classpandas_1_1__typing_1_1ReadBuffer.html">ReadBuffer</a>[bytes]|<a class="el" href="../../d4/d8e/classpandas_1_1__typing_1_1ReadBuffer.html">ReadBuffer</a>[str] path_or_buffer, *, str xpath=&quot;./*&quot;, dict[str, str]|None namespaces=None, bool elems_only=False, bool attrs_only=False, Sequence[str]|None names=None, DtypeArg|None dtype=None, ConvertersArg|None converters=None, ParseDatesArg|None parse_dates=None, str|None encoding=&quot;utf-8&quot;, XMLParsers parser=&quot;lxml&quot;, FilePath|<a class="el" href="../../d4/d8e/classpandas_1_1__typing_1_1ReadBuffer.html">ReadBuffer</a>[bytes]|<a class="el" href="../../d4/d8e/classpandas_1_1__typing_1_1ReadBuffer.html">ReadBuffer</a>[str]|None stylesheet=None, dict[str, list[str]]|None iterparse=None, CompressionOptions compression=&quot;infer&quot;, StorageOptions|None storage_options=None, DtypeBackend|lib.NoDefault dtype_backend=lib.no_default)</td></tr>
<tr class="separator:ae3ec489e78912b8149c74b35da3fd1e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">:mod:``pandas.io.xml`` is a module for reading XML.
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="acaeb915a6b24afce31e3c0bcd7d1f698" name="acaeb915a6b24afce31e3c0bcd7d1f698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaeb915a6b24afce31e3c0bcd7d1f698">&#9670;&#160;</a></span>_data_to_frame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> DataFrame pandas.io.xml._data_to_frame </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**</td>          <td class="paramname"><span class="paramname"><em>kwargs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Convert parsed data to Data Frame.

This method will bind xml dictionary data of keys and values
into named columns of Data Frame using the built-in TextParser
class that build Data Frame and infers specific dtypes.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d1/df3/xml_8py_source.html#l00734">734</a> of file <a class="el" href="../../d1/df3/xml_8py_source.html">xml.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d1/df3/xml_8py_source.html#l00775">_parse()</a>.</p>

</div>
</div>
<a id="a756e1182724cbdcdf66c0fc96fdd5398" name="a756e1182724cbdcdf66c0fc96fdd5398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a756e1182724cbdcdf66c0fc96fdd5398">&#9670;&#160;</a></span>_parse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> DataFrame pandas.io.xml._parse </td>
          <td>(</td>
          <td class="paramtype">FilePath | <a class="el" href="../../d4/d8e/classpandas_1_1__typing_1_1ReadBuffer.html">ReadBuffer</a>[bytes] | <a class="el" href="../../d4/d8e/classpandas_1_1__typing_1_1ReadBuffer.html">ReadBuffer</a>[str]</td>          <td class="paramname"><span class="paramname"><em>path_or_buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>xpath</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, str] | None</td>          <td class="paramname"><span class="paramname"><em>namespaces</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>elems_only</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>attrs_only</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sequence[str] | None</td>          <td class="paramname"><span class="paramname"><em>names</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DtypeArg | None</td>          <td class="paramname"><span class="paramname"><em>dtype</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConvertersArg | None</td>          <td class="paramname"><span class="paramname"><em>converters</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParseDatesArg | None</td>          <td class="paramname"><span class="paramname"><em>parse_dates</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None</td>          <td class="paramname"><span class="paramname"><em>encoding</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XMLParsers</td>          <td class="paramname"><span class="paramname"><em>parser</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FilePath | <a class="el" href="../../d4/d8e/classpandas_1_1__typing_1_1ReadBuffer.html">ReadBuffer</a>[bytes] | <a class="el" href="../../d4/d8e/classpandas_1_1__typing_1_1ReadBuffer.html">ReadBuffer</a>[str] | None</td>          <td class="paramname"><span class="paramname"><em>stylesheet</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, list[str]] | None</td>          <td class="paramname"><span class="paramname"><em>iterparse</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompressionOptions</td>          <td class="paramname"><span class="paramname"><em>compression</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StorageOptions</td>          <td class="paramname"><span class="paramname"><em>storage_options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DtypeBackend | lib.NoDefault </td>          <td class="paramname"><span class="paramname"><em>dtype_backend</em></span><span class="paramdefsep"> = </span><span class="paramdefval">lib.no_default</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**</td>          <td class="paramname"><span class="paramname"><em>kwargs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Call internal parsers.

This method will conditionally call internal parsers:
LxmlFrameParser and/or EtreeParser.

Raises
------
ImportError
    * If lxml is not installed if selected as parser.

ValueError
    * If parser is not lxml or etree.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d1/df3/xml_8py_source.html#l00757">757</a> of file <a class="el" href="../../d1/df3/xml_8py_source.html">xml.py</a>.</p>

<p class="reference">References <a class="el" href="../../d1/df3/xml_8py_source.html#l00734">_data_to_frame()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d1/df3/xml_8py_source.html#l00887">read_xml()</a>.</p>

</div>
</div>
<a id="a67c794bfdfaf92783b14e5c5ea33c321" name="a67c794bfdfaf92783b14e5c5ea33c321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67c794bfdfaf92783b14e5c5ea33c321">&#9670;&#160;</a></span>get_data_from_filepath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> str | bytes | <a class="el" href="../../d4/d8e/classpandas_1_1__typing_1_1ReadBuffer.html">ReadBuffer</a>[bytes] | <a class="el" href="../../d4/d8e/classpandas_1_1__typing_1_1ReadBuffer.html">ReadBuffer</a>[str] pandas.io.xml.get_data_from_filepath </td>
          <td>(</td>
          <td class="paramtype">FilePath | bytes | <a class="el" href="../../d4/d8e/classpandas_1_1__typing_1_1ReadBuffer.html">ReadBuffer</a>[bytes] | <a class="el" href="../../d4/d8e/classpandas_1_1__typing_1_1ReadBuffer.html">ReadBuffer</a>[str]</td>          <td class="paramname"><span class="paramname"><em>filepath_or_buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None</td>          <td class="paramname"><span class="paramname"><em>encoding</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompressionOptions</td>          <td class="paramname"><span class="paramname"><em>compression</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StorageOptions</td>          <td class="paramname"><span class="paramname"><em>storage_options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Extract raw XML data.

The method accepts three input types:
    1. filepath (string-like)
    2. file-like object (e.g. open file object, StringIO)
    3. XML string or bytes

This method turns (1) into (2) to simplify the rest of the processing.
It returns input types (2) and (3) unchanged.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d1/df3/xml_8py_source.html#l00671">671</a> of file <a class="el" href="../../d1/df3/xml_8py_source.html">xml.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d1/df3/xml_8py_source.html#l00518">pandas.io.xml._EtreeFrameParser._parse_doc()</a>, and <a class="el" href="../../d1/df3/xml_8py_source.html#l00624">pandas.io.xml._LxmlFrameParser._parse_doc()</a>.</p>

</div>
</div>
<a id="af3e00c5ae2a77150415d7efd48b1d84c" name="af3e00c5ae2a77150415d7efd48b1d84c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3e00c5ae2a77150415d7efd48b1d84c">&#9670;&#160;</a></span>preprocess_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> io.StringIO | io.BytesIO pandas.io.xml.preprocess_data </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert extracted raw data.

This method will return underlying data of extracted XML content.
The data either has a `read` attribute (e.g. a file object or a
StringIO/BytesIO) or is a string or bytes that is an XML document.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d1/df3/xml_8py_source.html#l00716">716</a> of file <a class="el" href="../../d1/df3/xml_8py_source.html">xml.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d1/df3/xml_8py_source.html#l00518">pandas.io.xml._EtreeFrameParser._parse_doc()</a>, and <a class="el" href="../../d1/df3/xml_8py_source.html#l00624">pandas.io.xml._LxmlFrameParser._parse_doc()</a>.</p>

</div>
</div>
<a id="ae3ec489e78912b8149c74b35da3fd1e7" name="ae3ec489e78912b8149c74b35da3fd1e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3ec489e78912b8149c74b35da3fd1e7">&#9670;&#160;</a></span>read_xml()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> DataFrame pandas.io.xml.read_xml </td>
          <td>(</td>
          <td class="paramtype">FilePath | <a class="el" href="../../d4/d8e/classpandas_1_1__typing_1_1ReadBuffer.html">ReadBuffer</a>[bytes] | <a class="el" href="../../d4/d8e/classpandas_1_1__typing_1_1ReadBuffer.html">ReadBuffer</a>[str]</td>          <td class="paramname"><span class="paramname"><em>path_or_buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str </td>          <td class="paramname"><span class="paramname"><em>xpath</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;./*&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, str] | None </td>          <td class="paramname"><span class="paramname"><em>namespaces</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>          <td class="paramname"><span class="paramname"><em>elems_only</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>          <td class="paramname"><span class="paramname"><em>attrs_only</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sequence[str] | None </td>          <td class="paramname"><span class="paramname"><em>names</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DtypeArg | None </td>          <td class="paramname"><span class="paramname"><em>dtype</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConvertersArg | None </td>          <td class="paramname"><span class="paramname"><em>converters</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParseDatesArg | None </td>          <td class="paramname"><span class="paramname"><em>parse_dates</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None </td>          <td class="paramname"><span class="paramname"><em>encoding</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;utf-8&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XMLParsers </td>          <td class="paramname"><span class="paramname"><em>parser</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;lxml&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FilePath | <a class="el" href="../../d4/d8e/classpandas_1_1__typing_1_1ReadBuffer.html">ReadBuffer</a>[bytes] | <a class="el" href="../../d4/d8e/classpandas_1_1__typing_1_1ReadBuffer.html">ReadBuffer</a>[str] | None </td>          <td class="paramname"><span class="paramname"><em>stylesheet</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[str, list[str]] | None </td>          <td class="paramname"><span class="paramname"><em>iterparse</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompressionOptions </td>          <td class="paramname"><span class="paramname"><em>compression</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;infer&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StorageOptions | None </td>          <td class="paramname"><span class="paramname"><em>storage_options</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DtypeBackend | lib.NoDefault </td>          <td class="paramname"><span class="paramname"><em>dtype_backend</em></span><span class="paramdefsep"> = </span><span class="paramdefval">lib.no_default</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Read XML document into a :class:`~pandas.DataFrame` object.

.. versionadded:: 1.3.0

Parameters
----------
path_or_buffer : str, path object, or file-like object
    String, path object (implementing ``os.PathLike[str]``), or file-like
    object implementing a ``read()`` function. The string can be any valid XML
    string or a path. The string can further be a URL. Valid URL schemes
    include http, ftp, s3, and file.

    .. deprecated:: 2.1.0
        Passing xml literal strings is deprecated.
        Wrap literal xml input in ``io.StringIO`` or ``io.BytesIO`` instead.

xpath : str, optional, default './\*'
    The ``XPath`` to parse required set of nodes for migration to
    :class:`~pandas.DataFrame`.``XPath`` should return a collection of elements
    and not a single element. Note: The ``etree`` parser supports limited ``XPath``
    expressions. For more complex ``XPath``, use ``lxml`` which requires
    installation.

namespaces : dict, optional
    The namespaces defined in XML document as dicts with key being
    namespace prefix and value the URI. There is no need to include all
    namespaces in XML, only the ones used in ``xpath`` expression.
    Note: if XML document uses default namespace denoted as
    `xmlns='&lt;URI&gt;'` without a prefix, you must assign any temporary
    namespace prefix such as 'doc' to the URI in order to parse
    underlying nodes and/or attributes. For example, ::

        namespaces = {{"doc": "https://example.com"}}

elems_only : bool, optional, default False
    Parse only the child elements at the specified ``xpath``. By default,
    all child elements and non-empty text nodes are returned.

attrs_only :  bool, optional, default False
    Parse only the attributes at the specified ``xpath``.
    By default, all attributes are returned.

names :  list-like, optional
    Column names for DataFrame of parsed XML data. Use this parameter to
    rename original element names and distinguish same named elements and
    attributes.

dtype : Type name or dict of column -&gt; type, optional
    Data type for data or columns. E.g. {{'a': np.float64, 'b': np.int32,
    'c': 'Int64'}}
    Use `str` or `object` together with suitable `na_values` settings
    to preserve and not interpret dtype.
    If converters are specified, they will be applied INSTEAD
    of dtype conversion.

    .. versionadded:: 1.5.0

converters : dict, optional
    Dict of functions for converting values in certain columns. Keys can either
    be integers or column labels.

    .. versionadded:: 1.5.0

parse_dates : bool or list of int or names or list of lists or dict, default False
    Identifiers to parse index or columns to datetime. The behavior is as follows:

    * boolean. If True -&gt; try parsing the index.
    * list of int or names. e.g. If [1, 2, 3] -&gt; try parsing columns 1, 2, 3
      each as a separate date column.
    * list of lists. e.g.  If [[1, 3]] -&gt; combine columns 1 and 3 and parse as
      a single date column.
    * dict, e.g. {{'foo' : [1, 3]}} -&gt; parse columns 1, 3 as date and call
      result 'foo'

    .. versionadded:: 1.5.0

encoding : str, optional, default 'utf-8'
    Encoding of XML document.

parser : {{'lxml','etree'}}, default 'lxml'
    Parser module to use for retrieval of data. Only 'lxml' and
    'etree' are supported. With 'lxml' more complex ``XPath`` searches
    and ability to use XSLT stylesheet are supported.

stylesheet : str, path object or file-like object
    A URL, file-like object, or a raw string containing an XSLT script.
    This stylesheet should flatten complex, deeply nested XML documents
    for easier parsing. To use this feature you must have ``lxml`` module
    installed and specify 'lxml' as ``parser``. The ``xpath`` must
    reference nodes of transformed XML document generated after XSLT
    transformation and not the original XML document. Only XSLT 1.0
    scripts and not later versions is currently supported.

iterparse : dict, optional
    The nodes or attributes to retrieve in iterparsing of XML document
    as a dict with key being the name of repeating element and value being
    list of elements or attribute names that are descendants of the repeated
    element. Note: If this option is used, it will replace ``xpath`` parsing
    and unlike ``xpath``, descendants do not need to relate to each other but can
    exist any where in document under the repeating element. This memory-
    efficient method should be used for very large XML files (500MB, 1GB, or 5GB+).
    For example, ::

        iterparse = {{"row_element": ["child_elem", "attr", "grandchild_elem"]}}

    .. versionadded:: 1.5.0

{decompression_options}

    .. versionchanged:: 1.4.0 Zstandard support.

{storage_options}

dtype_backend : {{'numpy_nullable', 'pyarrow'}}, default 'numpy_nullable'
    Back-end data type applied to the resultant :class:`DataFrame`
    (still experimental). Behaviour is as follows:

    * ``"numpy_nullable"``: returns nullable-dtype-backed :class:`DataFrame`
      (default).
    * ``"pyarrow"``: returns pyarrow-backed nullable :class:`ArrowDtype`
      DataFrame.

    .. versionadded:: 2.0

Returns
-------
df
    A DataFrame.

See Also
--------
read_json : Convert a JSON string to pandas object.
read_html : Read HTML tables into a list of DataFrame objects.

Notes
-----
This method is best designed to import shallow XML documents in
following format which is the ideal fit for the two-dimensions of a
``DataFrame`` (row by column). ::

        &lt;root&gt;
            &lt;row&gt;
              &lt;column1&gt;data&lt;/column1&gt;
              &lt;column2&gt;data&lt;/column2&gt;
              &lt;column3&gt;data&lt;/column3&gt;
              ...
           &lt;/row&gt;
           &lt;row&gt;
              ...
           &lt;/row&gt;
           ...
        &lt;/root&gt;

As a file format, XML documents can be designed any way including
layout of elements and attributes as long as it conforms to W3C
specifications. Therefore, this method is a convenience handler for
a specific flatter design and not all possible XML structures.

However, for more complex XML documents, ``stylesheet`` allows you to
temporarily redesign original document with XSLT (a special purpose
language) for a flatter version for migration to a DataFrame.

This function will *always* return a single :class:`DataFrame` or raise
exceptions due to issues with XML document, ``xpath``, or other
parameters.

See the :ref:`read_xml documentation in the IO section of the docs
&lt;io.read_xml&gt;` for more information in using this method to parse XML
files to DataFrames.

Examples
--------
&gt;&gt;&gt; from io import StringIO
&gt;&gt;&gt; xml = '''&lt;?xml version='1.0' encoding='utf-8'?&gt;
... &lt;data xmlns="http://example.com"&gt;
...  &lt;row&gt;
...    &lt;shape&gt;square&lt;/shape&gt;
...    &lt;degrees&gt;360&lt;/degrees&gt;
...    &lt;sides&gt;4.0&lt;/sides&gt;
...  &lt;/row&gt;
...  &lt;row&gt;
...    &lt;shape&gt;circle&lt;/shape&gt;
...    &lt;degrees&gt;360&lt;/degrees&gt;
...    &lt;sides/&gt;
...  &lt;/row&gt;
...  &lt;row&gt;
...    &lt;shape&gt;triangle&lt;/shape&gt;
...    &lt;degrees&gt;180&lt;/degrees&gt;
...    &lt;sides&gt;3.0&lt;/sides&gt;
...  &lt;/row&gt;
... &lt;/data&gt;'''

&gt;&gt;&gt; df = pd.read_xml(StringIO(xml))
&gt;&gt;&gt; df
      shape  degrees  sides
0    square      360    4.0
1    circle      360    NaN
2  triangle      180    3.0

&gt;&gt;&gt; xml = '''&lt;?xml version='1.0' encoding='utf-8'?&gt;
... &lt;data&gt;
...   &lt;row shape="square" degrees="360" sides="4.0"/&gt;
...   &lt;row shape="circle" degrees="360"/&gt;
...   &lt;row shape="triangle" degrees="180" sides="3.0"/&gt;
... &lt;/data&gt;'''

&gt;&gt;&gt; df = pd.read_xml(StringIO(xml), xpath=".//row")
&gt;&gt;&gt; df
      shape  degrees  sides
0    square      360    4.0
1    circle      360    NaN
2  triangle      180    3.0

&gt;&gt;&gt; xml = '''&lt;?xml version='1.0' encoding='utf-8'?&gt;
... &lt;doc:data xmlns:doc="https://example.com"&gt;
...   &lt;doc:row&gt;
...     &lt;doc:shape&gt;square&lt;/doc:shape&gt;
...     &lt;doc:degrees&gt;360&lt;/doc:degrees&gt;
...     &lt;doc:sides&gt;4.0&lt;/doc:sides&gt;
...   &lt;/doc:row&gt;
...   &lt;doc:row&gt;
...     &lt;doc:shape&gt;circle&lt;/doc:shape&gt;
...     &lt;doc:degrees&gt;360&lt;/doc:degrees&gt;
...     &lt;doc:sides/&gt;
...   &lt;/doc:row&gt;
...   &lt;doc:row&gt;
...     &lt;doc:shape&gt;triangle&lt;/doc:shape&gt;
...     &lt;doc:degrees&gt;180&lt;/doc:degrees&gt;
...     &lt;doc:sides&gt;3.0&lt;/doc:sides&gt;
...   &lt;/doc:row&gt;
... &lt;/doc:data&gt;'''

&gt;&gt;&gt; df = pd.read_xml(StringIO(xml),
...                  xpath="//doc:row",
...                  namespaces={{"doc": "https://example.com"}})
&gt;&gt;&gt; df
      shape  degrees  sides
0    square      360    4.0
1    circle      360    NaN
2  triangle      180    3.0

&gt;&gt;&gt; xml_data = '''
...         &lt;data&gt;
...            &lt;row&gt;
...               &lt;index&gt;0&lt;/index&gt;
...               &lt;a&gt;1&lt;/a&gt;
...               &lt;b&gt;2.5&lt;/b&gt;
...               &lt;c&gt;True&lt;/c&gt;
...               &lt;d&gt;a&lt;/d&gt;
...               &lt;e&gt;2019-12-31 00:00:00&lt;/e&gt;
...            &lt;/row&gt;
...            &lt;row&gt;
...               &lt;index&gt;1&lt;/index&gt;
...               &lt;b&gt;4.5&lt;/b&gt;
...               &lt;c&gt;False&lt;/c&gt;
...               &lt;d&gt;b&lt;/d&gt;
...               &lt;e&gt;2019-12-31 00:00:00&lt;/e&gt;
...            &lt;/row&gt;
...         &lt;/data&gt;
...         '''

&gt;&gt;&gt; df = pd.read_xml(StringIO(xml_data),
...                  dtype_backend="numpy_nullable",
...                  parse_dates=["e"])
&gt;&gt;&gt; df
   index     a    b      c  d          e
0      0     1  2.5   True  a 2019-12-31
1      1  &lt;NA&gt;  4.5  False  b 2019-12-31
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d1/df3/xml_8py_source.html#l00868">868</a> of file <a class="el" href="../../d1/df3/xml_8py_source.html">xml.py</a>.</p>

<p class="reference">References <a class="el" href="../../d1/df3/xml_8py_source.html#l00775">_parse()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d1/d53/namespacepandas.html">pandas</a></li><li class="navelem"><a class="el" href="../../d7/d0d/namespacepandas_1_1io.html">io</a></li><li class="navelem"><a class="el" href="../../d1/dde/namespacepandas_1_1io_1_1xml.html">xml</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
