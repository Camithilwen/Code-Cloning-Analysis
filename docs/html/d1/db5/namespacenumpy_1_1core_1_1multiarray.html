<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Code Cloning Analysis: numpy.core.multiarray Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Code Cloning Analysis
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d1/db5/namespacenumpy_1_1core_1_1multiarray.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">numpy.core.multiarray Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ada1001d8f93718a2060ebb0bfb320566" id="r_ada1001d8f93718a2060ebb0bfb320566"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada1001d8f93718a2060ebb0bfb320566">empty_like</a> (prototype, dtype=None, order=None, subok=None, <a class="el" href="../../d5/da5/namespacenumpy_1_1core_1_1fromnumeric.html#aa22b69964320c5aabb55d909c8780c9f">shape</a>=None)</td></tr>
<tr class="separator:ada1001d8f93718a2060ebb0bfb320566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f40643185f6245cd630fcf3cb6c589" id="r_a43f40643185f6245cd630fcf3cb6c589"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43f40643185f6245cd630fcf3cb6c589">concatenate</a> (arrays, axis=None, out=None, *, dtype=None, casting=None)</td></tr>
<tr class="separator:a43f40643185f6245cd630fcf3cb6c589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b170dbdd3f2d833f9eb7c289cb9308b" id="r_a2b170dbdd3f2d833f9eb7c289cb9308b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b170dbdd3f2d833f9eb7c289cb9308b">inner</a> (a, b)</td></tr>
<tr class="separator:a2b170dbdd3f2d833f9eb7c289cb9308b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafec298d2664515002736e4905e6719b" id="r_aafec298d2664515002736e4905e6719b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aafec298d2664515002736e4905e6719b">where</a> (condition, x=None, y=None)</td></tr>
<tr class="separator:aafec298d2664515002736e4905e6719b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8ad7def2a66f3fe06f715cb4023972" id="r_ace8ad7def2a66f3fe06f715cb4023972"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace8ad7def2a66f3fe06f715cb4023972">lexsort</a> (keys, axis=None)</td></tr>
<tr class="separator:ace8ad7def2a66f3fe06f715cb4023972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeab9136a883992c277491a86e13efb61" id="r_aeab9136a883992c277491a86e13efb61"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeab9136a883992c277491a86e13efb61">can_cast</a> (from_, to, casting=None)</td></tr>
<tr class="separator:aeab9136a883992c277491a86e13efb61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33554df6963ba407087d085e3d3e92cc" id="r_a33554df6963ba407087d085e3d3e92cc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33554df6963ba407087d085e3d3e92cc">min_scalar_type</a> (a)</td></tr>
<tr class="separator:a33554df6963ba407087d085e3d3e92cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a631dd443594fa259a859838d2f68c7ec" id="r_a631dd443594fa259a859838d2f68c7ec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a631dd443594fa259a859838d2f68c7ec">result_type</a> (*arrays_and_dtypes)</td></tr>
<tr class="separator:a631dd443594fa259a859838d2f68c7ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d9a5c7d84575fc3b30df46912ecba76" id="r_a6d9a5c7d84575fc3b30df46912ecba76"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d9a5c7d84575fc3b30df46912ecba76">dot</a> (a, b, out=None)</td></tr>
<tr class="separator:a6d9a5c7d84575fc3b30df46912ecba76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb4f2892682f3716f61b5eaf5a35b4a" id="r_addb4f2892682f3716f61b5eaf5a35b4a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#addb4f2892682f3716f61b5eaf5a35b4a">vdot</a> (a, b)</td></tr>
<tr class="separator:addb4f2892682f3716f61b5eaf5a35b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e60db196719f0acc24d2dfa28953805" id="r_a9e60db196719f0acc24d2dfa28953805"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e60db196719f0acc24d2dfa28953805">bincount</a> (x, weights=None, minlength=None)</td></tr>
<tr class="separator:a9e60db196719f0acc24d2dfa28953805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8504d23fefcc338cbd7617d1b6a78ad8" id="r_a8504d23fefcc338cbd7617d1b6a78ad8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8504d23fefcc338cbd7617d1b6a78ad8">ravel_multi_index</a> (multi_index, dims, mode=None, order=None)</td></tr>
<tr class="separator:a8504d23fefcc338cbd7617d1b6a78ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05fb5a81e759751a4846cfdb2a7c0661" id="r_a05fb5a81e759751a4846cfdb2a7c0661"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05fb5a81e759751a4846cfdb2a7c0661">unravel_index</a> (<a class="el" href="../../d9/d41/namespacenumpy_1_1core_1_1numeric.html#a9b57e299af9537cd1030c654e4be8abb">indices</a>, <a class="el" href="../../d5/da5/namespacenumpy_1_1core_1_1fromnumeric.html#aa22b69964320c5aabb55d909c8780c9f">shape</a>=None, order=None)</td></tr>
<tr class="separator:a05fb5a81e759751a4846cfdb2a7c0661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a976075176cee5304cdbb9636e761a1" id="r_a5a976075176cee5304cdbb9636e761a1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a976075176cee5304cdbb9636e761a1">copyto</a> (dst, src, casting=None, <a class="el" href="#aafec298d2664515002736e4905e6719b">where</a>=None)</td></tr>
<tr class="separator:a5a976075176cee5304cdbb9636e761a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b8a9c5fd8b434b5700a26280140116" id="r_ae9b8a9c5fd8b434b5700a26280140116"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9b8a9c5fd8b434b5700a26280140116">putmask</a> (a, mask, values)</td></tr>
<tr class="separator:ae9b8a9c5fd8b434b5700a26280140116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a2455f865e0ab4d6e086efac2163fa" id="r_a91a2455f865e0ab4d6e086efac2163fa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91a2455f865e0ab4d6e086efac2163fa">packbits</a> (a, axis=None, bitorder='big')</td></tr>
<tr class="separator:a91a2455f865e0ab4d6e086efac2163fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab260a98a2750798027f651b626b8403f" id="r_ab260a98a2750798027f651b626b8403f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab260a98a2750798027f651b626b8403f">unpackbits</a> (a, axis=None, count=None, bitorder='big')</td></tr>
<tr class="separator:ab260a98a2750798027f651b626b8403f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2f8c4e2c932442df0c92eedce29aac" id="r_a0c2f8c4e2c932442df0c92eedce29aac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c2f8c4e2c932442df0c92eedce29aac">shares_memory</a> (a, b, max_work=None)</td></tr>
<tr class="separator:a0c2f8c4e2c932442df0c92eedce29aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ad592278d3cb45614f93e90a1acffc" id="r_a53ad592278d3cb45614f93e90a1acffc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53ad592278d3cb45614f93e90a1acffc">may_share_memory</a> (a, b, max_work=None)</td></tr>
<tr class="separator:a53ad592278d3cb45614f93e90a1acffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15d744404a5ecb28d9cbb89b9762cc53" id="r_a15d744404a5ecb28d9cbb89b9762cc53"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15d744404a5ecb28d9cbb89b9762cc53">is_busday</a> (dates, weekmask=None, holidays=None, busdaycal=None, out=None)</td></tr>
<tr class="separator:a15d744404a5ecb28d9cbb89b9762cc53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ee5aadc9c5f54a2125e7fb03f0ef9d" id="r_a99ee5aadc9c5f54a2125e7fb03f0ef9d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a99ee5aadc9c5f54a2125e7fb03f0ef9d">busday_offset</a> (dates, offsets, <a class="el" href="../../d9/d41/namespacenumpy_1_1core_1_1numeric.html#ac1b2b647e32899d2e32fff33a0ed90ef">roll</a>=None, weekmask=None, holidays=None, busdaycal=None, out=None)</td></tr>
<tr class="separator:a99ee5aadc9c5f54a2125e7fb03f0ef9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af46f6e97509f4906c4cb96d68d853567" id="r_af46f6e97509f4906c4cb96d68d853567"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af46f6e97509f4906c4cb96d68d853567">busday_count</a> (begindates, enddates, weekmask=None, holidays=None, busdaycal=None, out=None)</td></tr>
<tr class="separator:af46f6e97509f4906c4cb96d68d853567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affcfe796e24491e022f5c5ea93e9007c" id="r_affcfe796e24491e022f5c5ea93e9007c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#affcfe796e24491e022f5c5ea93e9007c">datetime_as_string</a> (arr, unit=None, timezone=None, casting=None)</td></tr>
<tr class="separator:affcfe796e24491e022f5c5ea93e9007c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ad54995e21c5da2de148ea2e3c9e8469f" id="r_ad54995e21c5da2de148ea2e3c9e8469f"><td class="memItemLeft" align="right" valign="top">list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad54995e21c5da2de148ea2e3c9e8469f">__all__</a></td></tr>
<tr class="separator:ad54995e21c5da2de148ea2e3c9e8469f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad88a4b24c1217f78f7ff42f3869dfe93" id="r_ad88a4b24c1217f78f7ff42f3869dfe93"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad88a4b24c1217f78f7ff42f3869dfe93">__module__</a></td></tr>
<tr class="separator:ad88a4b24c1217f78f7ff42f3869dfe93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f0985446cd1812ab7345b24aaf37a2b" id="r_a8f0985446cd1812ab7345b24aaf37a2b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f0985446cd1812ab7345b24aaf37a2b">array_function_from_c_func_and_dispatcher</a></td></tr>
<tr class="separator:a8f0985446cd1812ab7345b24aaf37a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Create the numpy.core.multiarray namespace for backward compatibility. In v1.16
the multiarray and umath c-extension modules were merged into a single
_multiarray_umath extension module. So we replicate the old namespace
by importing from the extension module.
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a9e60db196719f0acc24d2dfa28953805" name="a9e60db196719f0acc24d2dfa28953805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e60db196719f0acc24d2dfa28953805">&#9670;&#160;</a></span>bincount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.multiarray.bincount </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>weights</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>minlength</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">bincount(x, /, weights=None, minlength=0)

Count number of occurrences of each value in array of non-negative ints.

The number of bins (of size 1) is one larger than the largest value in
`x`. If `minlength` is specified, there will be at least this number
of bins in the output array (though it will be longer if necessary,
depending on the contents of `x`).
Each bin gives the number of occurrences of its index value in `x`.
If `weights` is specified the input array is weighted by it, i.e. if a
value ``n`` is found at position ``i``, ``out[n] += weight[i]`` instead
of ``out[n] += 1``.

Parameters
----------
x : array_like, 1 dimension, nonnegative ints
    Input array.
weights : array_like, optional
    Weights, array of the same shape as `x`.
minlength : int, optional
    A minimum number of bins for the output array.

    .. versionadded:: 1.6.0

Returns
-------
out : ndarray of ints
    The result of binning the input array.
    The length of `out` is equal to ``np.amax(x)+1``.

Raises
------
ValueError
    If the input is not 1-dimensional, or contains elements with negative
    values, or if `minlength` is negative.
TypeError
    If the type of the input is float or complex.

See Also
--------
histogram, digitize, unique

Examples
--------
&gt;&gt;&gt; np.bincount(np.arange(5))
array([1, 1, 1, 1, 1])
&gt;&gt;&gt; np.bincount(np.array([0, 1, 1, 3, 2, 1, 7]))
array([1, 3, 1, 1, 0, 0, 0, 1])

&gt;&gt;&gt; x = np.array([0, 1, 1, 3, 2, 1, 7, 23])
&gt;&gt;&gt; np.bincount(x).size == np.amax(x)+1
True

The input array needs to be of integer dtype, otherwise a
TypeError is raised:

&gt;&gt;&gt; np.bincount(np.arange(5, dtype=float))
Traceback (most recent call last):
  ...
TypeError: Cannot cast array data from dtype('float64') to dtype('int64')
according to the rule 'safe'

A possible use of ``bincount`` is to perform sums over
variable-size chunks of an array, using the ``weights`` keyword.

&gt;&gt;&gt; w = np.array([0.3, 0.5, 0.2, 0.7, 1., -0.6]) # weights
&gt;&gt;&gt; x = np.array([0, 1, 1, 2, 2, 2])
&gt;&gt;&gt; np.bincount(x,  weights=w)
array([ 0.3,  0.7,  1.1])
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d0/d1a/core_2multiarray_8py_source.html#l00893">893</a> of file <a class="el" href="../../d0/d1a/core_2multiarray_8py_source.html">multiarray.py</a>.</p>

</div>
</div>
<a id="af46f6e97509f4906c4cb96d68d853567" name="af46f6e97509f4906c4cb96d68d853567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af46f6e97509f4906c4cb96d68d853567">&#9670;&#160;</a></span>busday_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.multiarray.busday_count </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>begindates</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>enddates</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>weekmask</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>holidays</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>busdaycal</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>out</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">busday_count(begindates, enddates, weekmask='1111100', holidays=[], busdaycal=None, out=None)

Counts the number of valid days between `begindates` and
`enddates`, not including the day of `enddates`.

If ``enddates`` specifies a date value that is earlier than the
corresponding ``begindates`` date value, the count will be negative.

.. versionadded:: 1.7.0

Parameters
----------
begindates : array_like of datetime64[D]
    The array of the first dates for counting.
enddates : array_like of datetime64[D]
    The array of the end dates for counting, which are excluded
    from the count themselves.
weekmask : str or array_like of bool, optional
    A seven-element array indicating which of Monday through Sunday are
    valid days. May be specified as a length-seven list or array, like
    [1,1,1,1,1,0,0]; a length-seven string, like '1111100'; or a string
    like "Mon Tue Wed Thu Fri", made up of 3-character abbreviations for
    weekdays, optionally separated by white space. Valid abbreviations
    are: Mon Tue Wed Thu Fri Sat Sun
holidays : array_like of datetime64[D], optional
    An array of dates to consider as invalid dates.  They may be
    specified in any order, and NaT (not-a-time) dates are ignored.
    This list is saved in a normalized form that is suited for
    fast calculations of valid days.
busdaycal : busdaycalendar, optional
    A `busdaycalendar` object which specifies the valid days. If this
    parameter is provided, neither weekmask nor holidays may be
    provided.
out : array of int, optional
    If provided, this array is filled with the result.

Returns
-------
out : array of int
    An array with a shape from broadcasting ``begindates`` and ``enddates``
    together, containing the number of valid days between
    the begin and end dates.

See Also
--------
busdaycalendar : An object that specifies a custom set of valid days.
is_busday : Returns a boolean array indicating valid days.
busday_offset : Applies an offset counted in valid days.

Examples
--------
&gt;&gt;&gt; # Number of weekdays in January 2011
... np.busday_count('2011-01', '2011-02')
21
&gt;&gt;&gt; # Number of weekdays in 2011
&gt;&gt;&gt; np.busday_count('2011', '2012')
260
&gt;&gt;&gt; # Number of Saturdays in 2011
... np.busday_count('2011', '2012', weekmask='Sat')
53
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d0/d1a/core_2multiarray_8py_source.html#l01583">1583</a> of file <a class="el" href="../../d0/d1a/core_2multiarray_8py_source.html">multiarray.py</a>.</p>

</div>
</div>
<a id="a99ee5aadc9c5f54a2125e7fb03f0ef9d" name="a99ee5aadc9c5f54a2125e7fb03f0ef9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99ee5aadc9c5f54a2125e7fb03f0ef9d">&#9670;&#160;</a></span>busday_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.multiarray.busday_offset </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>dates</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>offsets</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>roll</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>weekmask</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>holidays</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>busdaycal</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>out</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">busday_offset(dates, offsets, roll='raise', weekmask='1111100', holidays=None, busdaycal=None, out=None)

First adjusts the date to fall on a valid day according to
the ``roll`` rule, then applies offsets to the given dates
counted in valid days.

.. versionadded:: 1.7.0

Parameters
----------
dates : array_like of datetime64[D]
    The array of dates to process.
offsets : array_like of int
    The array of offsets, which is broadcast with ``dates``.
roll : {'raise', 'nat', 'forward', 'following', 'backward', 'preceding', 'modifiedfollowing', 'modifiedpreceding'}, optional
    How to treat dates that do not fall on a valid day. The default
    is 'raise'.

      * 'raise' means to raise an exception for an invalid day.
      * 'nat' means to return a NaT (not-a-time) for an invalid day.
      * 'forward' and 'following' mean to take the first valid day
        later in time.
      * 'backward' and 'preceding' mean to take the first valid day
        earlier in time.
      * 'modifiedfollowing' means to take the first valid day
        later in time unless it is across a Month boundary, in which
        case to take the first valid day earlier in time.
      * 'modifiedpreceding' means to take the first valid day
        earlier in time unless it is across a Month boundary, in which
        case to take the first valid day later in time.
weekmask : str or array_like of bool, optional
    A seven-element array indicating which of Monday through Sunday are
    valid days. May be specified as a length-seven list or array, like
    [1,1,1,1,1,0,0]; a length-seven string, like '1111100'; or a string
    like "Mon Tue Wed Thu Fri", made up of 3-character abbreviations for
    weekdays, optionally separated by white space. Valid abbreviations
    are: Mon Tue Wed Thu Fri Sat Sun
holidays : array_like of datetime64[D], optional
    An array of dates to consider as invalid dates.  They may be
    specified in any order, and NaT (not-a-time) dates are ignored.
    This list is saved in a normalized form that is suited for
    fast calculations of valid days.
busdaycal : busdaycalendar, optional
    A `busdaycalendar` object which specifies the valid days. If this
    parameter is provided, neither weekmask nor holidays may be
    provided.
out : array of datetime64[D], optional
    If provided, this array is filled with the result.

Returns
-------
out : array of datetime64[D]
    An array with a shape from broadcasting ``dates`` and ``offsets``
    together, containing the dates with offsets applied.

See Also
--------
busdaycalendar : An object that specifies a custom set of valid days.
is_busday : Returns a boolean array indicating valid days.
busday_count : Counts how many valid days are in a half-open date range.

Examples
--------
&gt;&gt;&gt; # First business day in October 2011 (not accounting for holidays)
... np.busday_offset('2011-10', 0, roll='forward')
numpy.datetime64('2011-10-03')
&gt;&gt;&gt; # Last business day in February 2012 (not accounting for holidays)
... np.busday_offset('2012-03', -1, roll='forward')
numpy.datetime64('2012-02-29')
&gt;&gt;&gt; # Third Wednesday in January 2011
... np.busday_offset('2011-01', 2, roll='forward', weekmask='Wed')
numpy.datetime64('2011-01-19')
&gt;&gt;&gt; # 2012 Mother's Day in Canada and the U.S.
... np.busday_offset('2012-05', 1, roll='forward', weekmask='Sun')
numpy.datetime64('2012-05-13')

&gt;&gt;&gt; # First business day on or after a date
... np.busday_offset('2011-03-20', 0, roll='forward')
numpy.datetime64('2011-03-21')
&gt;&gt;&gt; np.busday_offset('2011-03-22', 0, roll='forward')
numpy.datetime64('2011-03-22')
&gt;&gt;&gt; # First business day after a date
... np.busday_offset('2011-03-20', 1, roll='backward')
numpy.datetime64('2011-03-21')
&gt;&gt;&gt; np.busday_offset('2011-03-22', 1, roll='backward')
numpy.datetime64('2011-03-23')
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d0/d1a/core_2multiarray_8py_source.html#l01489">1489</a> of file <a class="el" href="../../d0/d1a/core_2multiarray_8py_source.html">multiarray.py</a>.</p>

</div>
</div>
<a id="aeab9136a883992c277491a86e13efb61" name="aeab9136a883992c277491a86e13efb61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeab9136a883992c277491a86e13efb61">&#9670;&#160;</a></span>can_cast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.multiarray.can_cast </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>from_</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>to</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>casting</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">can_cast(from_, to, casting='safe')

Returns True if cast between data types can occur according to the
casting rule.  If from is a scalar or array scalar, also returns
True if the scalar value can be cast without overflow or truncation
to an integer.

Parameters
----------
from_ : dtype, dtype specifier, scalar, or array
    Data type, scalar, or array to cast from.
to : dtype or dtype specifier
    Data type to cast to.
casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional
    Controls what kind of data casting may occur.

      * 'no' means the data types should not be cast at all.
      * 'equiv' means only byte-order changes are allowed.
      * 'safe' means only casts which can preserve values are allowed.
      * 'same_kind' means only safe casts or casts within a kind,
        like float64 to float32, are allowed.
      * 'unsafe' means any data conversions may be done.

Returns
-------
out : bool
    True if cast can occur according to the casting rule.

Notes
-----
.. versionchanged:: 1.17.0
   Casting between a simple data type and a structured one is possible only
   for "unsafe" casting.  Casting to multiple fields is allowed, but
   casting from multiple fields is not.

.. versionchanged:: 1.9.0
   Casting from numeric to string types in 'safe' casting mode requires
   that the string dtype length is long enough to store the maximum
   integer/float value converted.

See also
--------
dtype, result_type

Examples
--------
Basic examples

&gt;&gt;&gt; np.can_cast(np.int32, np.int64)
True
&gt;&gt;&gt; np.can_cast(np.float64, complex)
True
&gt;&gt;&gt; np.can_cast(complex, float)
False

&gt;&gt;&gt; np.can_cast('i8', 'f8')
True
&gt;&gt;&gt; np.can_cast('i8', 'f4')
False
&gt;&gt;&gt; np.can_cast('i4', 'S4')
False

Casting scalars

&gt;&gt;&gt; np.can_cast(100, 'i1')
True
&gt;&gt;&gt; np.can_cast(150, 'i1')
False
&gt;&gt;&gt; np.can_cast(150, 'u1')
True

&gt;&gt;&gt; np.can_cast(3.5e100, np.float32)
False
&gt;&gt;&gt; np.can_cast(1000.0, np.float32)
True

Array scalar checks the value, array does not

&gt;&gt;&gt; np.can_cast(np.array(1000.0), np.float32)
True
&gt;&gt;&gt; np.can_cast(np.array([1000.0]), np.float32)
False

Using the casting rules

&gt;&gt;&gt; np.can_cast('i8', 'i8', 'no')
True
&gt;&gt;&gt; np.can_cast('&lt;i8', '&gt;i8', 'no')
False

&gt;&gt;&gt; np.can_cast('&lt;i8', '&gt;i8', 'equiv')
True
&gt;&gt;&gt; np.can_cast('&lt;i4', '&gt;i8', 'equiv')
False

&gt;&gt;&gt; np.can_cast('&lt;i4', '&gt;i8', 'safe')
True
&gt;&gt;&gt; np.can_cast('&lt;i8', '&gt;i4', 'safe')
False

&gt;&gt;&gt; np.can_cast('&lt;i8', '&gt;i4', 'same_kind')
True
&gt;&gt;&gt; np.can_cast('&lt;i8', '&gt;u4', 'same_kind')
False

&gt;&gt;&gt; np.can_cast('&lt;i8', '&gt;u4', 'unsafe')
True
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d0/d1a/core_2multiarray_8py_source.html#l00504">504</a> of file <a class="el" href="../../d0/d1a/core_2multiarray_8py_source.html">multiarray.py</a>.</p>

</div>
</div>
<a id="a43f40643185f6245cd630fcf3cb6c589" name="a43f40643185f6245cd630fcf3cb6c589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43f40643185f6245cd630fcf3cb6c589">&#9670;&#160;</a></span>concatenate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.multiarray.concatenate </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>arrays</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>axis</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>out</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>dtype</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>casting</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">concatenate((a1, a2, ...), axis=0, out=None, dtype=None, casting="same_kind")

Join a sequence of arrays along an existing axis.

Parameters
----------
a1, a2, ... : sequence of array_like
    The arrays must have the same shape, except in the dimension
    corresponding to `axis` (the first, by default).
axis : int, optional
    The axis along which the arrays will be joined.  If axis is None,
    arrays are flattened before use.  Default is 0.
out : ndarray, optional
    If provided, the destination to place the result. The shape must be
    correct, matching that of what concatenate would have returned if no
    out argument were specified.
dtype : str or dtype
    If provided, the destination array will have this dtype. Cannot be
    provided together with `out`.

    .. versionadded:: 1.20.0

casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional
    Controls what kind of data casting may occur. Defaults to 'same_kind'.

    .. versionadded:: 1.20.0

Returns
-------
res : ndarray
    The concatenated array.

See Also
--------
ma.concatenate : Concatenate function that preserves input masks.
array_split : Split an array into multiple sub-arrays of equal or
              near-equal size.
split : Split array into a list of multiple sub-arrays of equal size.
hsplit : Split array into multiple sub-arrays horizontally (column wise).
vsplit : Split array into multiple sub-arrays vertically (row wise).
dsplit : Split array into multiple sub-arrays along the 3rd axis (depth).
stack : Stack a sequence of arrays along a new axis.
block : Assemble arrays from blocks.
hstack : Stack arrays in sequence horizontally (column wise).
vstack : Stack arrays in sequence vertically (row wise).
dstack : Stack arrays in sequence depth wise (along third dimension).
column_stack : Stack 1-D arrays as columns into a 2-D array.

Notes
-----
When one or more of the arrays to be concatenated is a MaskedArray,
this function will return a MaskedArray object instead of an ndarray,
but the input masks are *not* preserved. In cases where a MaskedArray
is expected as input, use the ma.concatenate function from the masked
array module instead.

Examples
--------
&gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])
&gt;&gt;&gt; b = np.array([[5, 6]])
&gt;&gt;&gt; np.concatenate((a, b), axis=0)
array([[1, 2],
       [3, 4],
       [5, 6]])
&gt;&gt;&gt; np.concatenate((a, b.T), axis=1)
array([[1, 2, 5],
       [3, 4, 6]])
&gt;&gt;&gt; np.concatenate((a, b), axis=None)
array([1, 2, 3, 4, 5, 6])

This function will not preserve masking of MaskedArray inputs.

&gt;&gt;&gt; a = np.ma.arange(3)
&gt;&gt;&gt; a[1] = np.ma.masked
&gt;&gt;&gt; b = np.arange(2, 5)
&gt;&gt;&gt; a
masked_array(data=[0, --, 2],
             mask=[False,  True, False],
       fill_value=999999)
&gt;&gt;&gt; b
array([2, 3, 4])
&gt;&gt;&gt; np.concatenate([a, b])
masked_array(data=[0, 1, 2, 2, 3, 4],
             mask=False,
       fill_value=999999)
&gt;&gt;&gt; np.ma.concatenate([a, b])
masked_array(data=[0, --, 2, 2, 3, 4],
             mask=[False,  True, False, False, False, False],
       fill_value=999999)
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d0/d1a/core_2multiarray_8py_source.html#l00154">154</a> of file <a class="el" href="../../d0/d1a/core_2multiarray_8py_source.html">multiarray.py</a>.</p>

</div>
</div>
<a id="a5a976075176cee5304cdbb9636e761a1" name="a5a976075176cee5304cdbb9636e761a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a976075176cee5304cdbb9636e761a1">&#9670;&#160;</a></span>copyto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.multiarray.copyto </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>dst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>casting</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>where</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">copyto(dst, src, casting='same_kind', where=True)

Copies values from one array to another, broadcasting as necessary.

Raises a TypeError if the `casting` rule is violated, and if
`where` is provided, it selects which elements to copy.

.. versionadded:: 1.7.0

Parameters
----------
dst : ndarray
    The array into which values are copied.
src : array_like
    The array from which values are copied.
casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional
    Controls what kind of data casting may occur when copying.

      * 'no' means the data types should not be cast at all.
      * 'equiv' means only byte-order changes are allowed.
      * 'safe' means only casts which can preserve values are allowed.
      * 'same_kind' means only safe casts or casts within a kind,
        like float64 to float32, are allowed.
      * 'unsafe' means any data conversions may be done.
where : array_like of bool, optional
    A boolean array which is broadcasted to match the dimensions
    of `dst`, and selects elements to copy from `src` to `dst`
    wherever it contains the value True.

Examples
--------
&gt;&gt;&gt; A = np.array([4, 5, 6])
&gt;&gt;&gt; B = [1, 2, 3]
&gt;&gt;&gt; np.copyto(A, B)
&gt;&gt;&gt; A
array([1, 2, 3])

&gt;&gt;&gt; A = np.array([[1, 2, 3], [4, 5, 6]])
&gt;&gt;&gt; B = [[4, 5, 6], [7, 8, 9]]
&gt;&gt;&gt; np.copyto(A, B)
&gt;&gt;&gt; A
array([[4, 5, 6],
       [7, 8, 9]])
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d0/d1a/core_2multiarray_8py_source.html#l01081">1081</a> of file <a class="el" href="../../d0/d1a/core_2multiarray_8py_source.html">multiarray.py</a>.</p>

</div>
</div>
<a id="affcfe796e24491e022f5c5ea93e9007c" name="affcfe796e24491e022f5c5ea93e9007c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affcfe796e24491e022f5c5ea93e9007c">&#9670;&#160;</a></span>datetime_as_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.multiarray.datetime_as_string </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>arr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>unit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>timezone</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>casting</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">datetime_as_string(arr, unit=None, timezone='naive', casting='same_kind')

Convert an array of datetimes into an array of strings.

Parameters
----------
arr : array_like of datetime64
    The array of UTC timestamps to format.
unit : str
    One of None, 'auto', or a :ref:`datetime unit &lt;arrays.dtypes.dateunits&gt;`.
timezone : {'naive', 'UTC', 'local'} or tzinfo
    Timezone information to use when displaying the datetime. If 'UTC', end
    with a Z to indicate UTC time. If 'local', convert to the local timezone
    first, and suffix with a +-#### timezone offset. If a tzinfo object,
    then do as with 'local', but use the specified timezone.
casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}
    Casting to allow when changing between datetime units.

Returns
-------
str_arr : ndarray
    An array of strings the same shape as `arr`.

Examples
--------
&gt;&gt;&gt; import pytz
&gt;&gt;&gt; d = np.arange('2002-10-27T04:30', 4*60, 60, dtype='M8[m]')
&gt;&gt;&gt; d
array(['2002-10-27T04:30', '2002-10-27T05:30', '2002-10-27T06:30',
       '2002-10-27T07:30'], dtype='datetime64[m]')

Setting the timezone to UTC shows the same information, but with a Z suffix

&gt;&gt;&gt; np.datetime_as_string(d, timezone='UTC')
array(['2002-10-27T04:30Z', '2002-10-27T05:30Z', '2002-10-27T06:30Z',
       '2002-10-27T07:30Z'], dtype='&lt;U35')

Note that we picked datetimes that cross a DST boundary. Passing in a
``pytz`` timezone object will print the appropriate offset

&gt;&gt;&gt; np.datetime_as_string(d, timezone=pytz.timezone('US/Eastern'))
array(['2002-10-27T00:30-0400', '2002-10-27T01:30-0400',
       '2002-10-27T01:30-0500', '2002-10-27T02:30-0500'], dtype='&lt;U39')

Passing in a unit will change the precision

&gt;&gt;&gt; np.datetime_as_string(d, unit='h')
array(['2002-10-27T04', '2002-10-27T05', '2002-10-27T06', '2002-10-27T07'],
      dtype='&lt;U32')
&gt;&gt;&gt; np.datetime_as_string(d, unit='s')
array(['2002-10-27T04:30:00', '2002-10-27T05:30:00', '2002-10-27T06:30:00',
       '2002-10-27T07:30:00'], dtype='&lt;U38')

'casting' can be used to specify whether precision can be changed

&gt;&gt;&gt; np.datetime_as_string(d, unit='h', casting='safe')
Traceback (most recent call last):
    ...
TypeError: Cannot create a datetime string as units 'h' from a NumPy
datetime with units 'm' according to the rule 'safe'
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d0/d1a/core_2multiarray_8py_source.html#l01652">1652</a> of file <a class="el" href="../../d0/d1a/core_2multiarray_8py_source.html">multiarray.py</a>.</p>

</div>
</div>
<a id="a6d9a5c7d84575fc3b30df46912ecba76" name="a6d9a5c7d84575fc3b30df46912ecba76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d9a5c7d84575fc3b30df46912ecba76">&#9670;&#160;</a></span>dot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.multiarray.dot </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>out</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">dot(a, b, out=None)

Dot product of two arrays. Specifically,

- If both `a` and `b` are 1-D arrays, it is inner product of vectors
  (without complex conjugation).

- If both `a` and `b` are 2-D arrays, it is matrix multiplication,
  but using :func:`matmul` or ``a @ b`` is preferred.

- If either `a` or `b` is 0-D (scalar), it is equivalent to
  :func:`multiply` and using ``numpy.multiply(a, b)`` or ``a * b`` is
  preferred.

- If `a` is an N-D array and `b` is a 1-D array, it is a sum product over
  the last axis of `a` and `b`.

- If `a` is an N-D array and `b` is an M-D array (where ``M&gt;=2``), it is a
  sum product over the last axis of `a` and the second-to-last axis of
  `b`::

    dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])

It uses an optimized BLAS library when possible (see `numpy.linalg`).

Parameters
----------
a : array_like
    First argument.
b : array_like
    Second argument.
out : ndarray, optional
    Output argument. This must have the exact kind that would be returned
    if it was not used. In particular, it must have the right type, must be
    C-contiguous, and its dtype must be the dtype that would be returned
    for `dot(a,b)`. This is a performance feature. Therefore, if these
    conditions are not met, an exception is raised, instead of attempting
    to be flexible.

Returns
-------
output : ndarray
    Returns the dot product of `a` and `b`.  If `a` and `b` are both
    scalars or both 1-D arrays then a scalar is returned; otherwise
    an array is returned.
    If `out` is given, then it is returned.

Raises
------
ValueError
    If the last dimension of `a` is not the same size as
    the second-to-last dimension of `b`.

See Also
--------
vdot : Complex-conjugating dot product.
tensordot : Sum products over arbitrary axes.
einsum : Einstein summation convention.
matmul : '@' operator as method with out parameter.
linalg.multi_dot : Chained dot product.

Examples
--------
&gt;&gt;&gt; np.dot(3, 4)
12

Neither argument is complex-conjugated:

&gt;&gt;&gt; np.dot([2j, 3j], [2j, 3j])
(-13+0j)

For 2-D arrays it is the matrix product:

&gt;&gt;&gt; a = [[1, 0], [0, 1]]
&gt;&gt;&gt; b = [[4, 1], [2, 2]]
&gt;&gt;&gt; np.dot(a, b)
array([[4, 1],
       [2, 2]])

&gt;&gt;&gt; a = np.arange(3*4*5*6).reshape((3,4,5,6))
&gt;&gt;&gt; b = np.arange(3*4*5*6)[::-1].reshape((5,4,6,3))
&gt;&gt;&gt; np.dot(a, b)[2,3,2,1,2,2]
499128
&gt;&gt;&gt; sum(a[2,3,2,:] * b[1,2,:,2])
499128
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d0/d1a/core_2multiarray_8py_source.html#l00742">742</a> of file <a class="el" href="../../d0/d1a/core_2multiarray_8py_source.html">multiarray.py</a>.</p>

</div>
</div>
<a id="ada1001d8f93718a2060ebb0bfb320566" name="ada1001d8f93718a2060ebb0bfb320566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada1001d8f93718a2060ebb0bfb320566">&#9670;&#160;</a></span>empty_like()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.multiarray.empty_like </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>prototype</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>dtype</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>order</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>subok</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>shape</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">empty_like(prototype, dtype=None, order='K', subok=True, shape=None)

Return a new array with the same shape and type as a given array.

Parameters
----------
prototype : array_like
    The shape and data-type of `prototype` define these same attributes
    of the returned array.
dtype : data-type, optional
    Overrides the data type of the result.

    .. versionadded:: 1.6.0
order : {'C', 'F', 'A', or 'K'}, optional
    Overrides the memory layout of the result. 'C' means C-order,
    'F' means F-order, 'A' means 'F' if `prototype` is Fortran
    contiguous, 'C' otherwise. 'K' means match the layout of `prototype`
    as closely as possible.

    .. versionadded:: 1.6.0
subok : bool, optional.
    If True, then the newly created array will use the sub-class
    type of `prototype`, otherwise it will be a base-class array. Defaults
    to True.
shape : int or sequence of ints, optional.
    Overrides the shape of the result. If order='K' and the number of
    dimensions is unchanged, will try to keep order, otherwise,
    order='C' is implied.

    .. versionadded:: 1.17.0

Returns
-------
out : ndarray
    Array of uninitialized (arbitrary) data with the same
    shape and type as `prototype`.

See Also
--------
ones_like : Return an array of ones with shape and type of input.
zeros_like : Return an array of zeros with shape and type of input.
full_like : Return a new array with shape of input filled with value.
empty : Return a new uninitialized array.

Notes
-----
This function does *not* initialize the returned array; to do that use
`zeros_like` or `ones_like` instead.  It may be marginally faster than
the functions that do set the array values.

Examples
--------
&gt;&gt;&gt; a = ([1,2,3], [4,5,6])                         # a is array-like
&gt;&gt;&gt; np.empty_like(a)
array([[-1073741821, -1073741821,           3],    # uninitialized
       [          0,           0, -1073741821]])
&gt;&gt;&gt; a = np.array([[1., 2., 3.],[4.,5.,6.]])
&gt;&gt;&gt; np.empty_like(a)
array([[ -2.00000715e+000,   1.48219694e-323,  -2.00000572e+000], # uninitialized
       [  4.38791518e-305,  -2.00000715e+000,   4.17269252e-309]])
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d0/d1a/core_2multiarray_8py_source.html#l00086">86</a> of file <a class="el" href="../../d0/d1a/core_2multiarray_8py_source.html">multiarray.py</a>.</p>

</div>
</div>
<a id="a2b170dbdd3f2d833f9eb7c289cb9308b" name="a2b170dbdd3f2d833f9eb7c289cb9308b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b170dbdd3f2d833f9eb7c289cb9308b">&#9670;&#160;</a></span>inner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.multiarray.inner </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">inner(a, b, /)

Inner product of two arrays.

Ordinary inner product of vectors for 1-D arrays (without complex
conjugation), in higher dimensions a sum product over the last axes.

Parameters
----------
a, b : array_like
    If `a` and `b` are nonscalar, their last dimensions must match.

Returns
-------
out : ndarray
    If `a` and `b` are both
    scalars or both 1-D arrays then a scalar is returned; otherwise
    an array is returned.
    ``out.shape = (*a.shape[:-1], *b.shape[:-1])``

Raises
------
ValueError
    If both `a` and `b` are nonscalar and their last dimensions have
    different sizes.

See Also
--------
tensordot : Sum products over arbitrary axes.
dot : Generalised matrix product, using second last dimension of `b`.
einsum : Einstein summation convention.

Notes
-----
For vectors (1-D arrays) it computes the ordinary inner-product::

    np.inner(a, b) = sum(a[:]*b[:])

More generally, if ``ndim(a) = r &gt; 0`` and ``ndim(b) = s &gt; 0``::

    np.inner(a, b) = np.tensordot(a, b, axes=(-1,-1))

or explicitly::

    np.inner(a, b)[i0,...,ir-2,j0,...,js-2]
         = sum(a[i0,...,ir-2,:]*b[j0,...,js-2,:])

In addition `a` or `b` may be scalars, in which case::

   np.inner(a,b) = a*b

Examples
--------
Ordinary inner product for vectors:

&gt;&gt;&gt; a = np.array([1,2,3])
&gt;&gt;&gt; b = np.array([0,1,0])
&gt;&gt;&gt; np.inner(a, b)
2

Some multidimensional examples:

&gt;&gt;&gt; a = np.arange(24).reshape((2,3,4))
&gt;&gt;&gt; b = np.arange(4)
&gt;&gt;&gt; c = np.inner(a, b)
&gt;&gt;&gt; c.shape
(2, 3)
&gt;&gt;&gt; c
array([[ 14,  38,  62],
       [ 86, 110, 134]])

&gt;&gt;&gt; a = np.arange(2).reshape((1,1,2))
&gt;&gt;&gt; b = np.arange(6).reshape((3,2))
&gt;&gt;&gt; c = np.inner(a, b)
&gt;&gt;&gt; c.shape
(1, 1, 3)
&gt;&gt;&gt; c
array([[[1, 3, 5]]])

An example where `b` is a scalar:

&gt;&gt;&gt; np.inner(np.eye(2), 7)
array([[7., 0.],
       [0., 7.]])
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d0/d1a/core_2multiarray_8py_source.html#l00255">255</a> of file <a class="el" href="../../d0/d1a/core_2multiarray_8py_source.html">multiarray.py</a>.</p>

</div>
</div>
<a id="a15d744404a5ecb28d9cbb89b9762cc53" name="a15d744404a5ecb28d9cbb89b9762cc53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15d744404a5ecb28d9cbb89b9762cc53">&#9670;&#160;</a></span>is_busday()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.multiarray.is_busday </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>dates</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>weekmask</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>holidays</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>busdaycal</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>out</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">is_busday(dates, weekmask='1111100', holidays=None, busdaycal=None, out=None)

Calculates which of the given dates are valid days, and which are not.

.. versionadded:: 1.7.0

Parameters
----------
dates : array_like of datetime64[D]
    The array of dates to process.
weekmask : str or array_like of bool, optional
    A seven-element array indicating which of Monday through Sunday are
    valid days. May be specified as a length-seven list or array, like
    [1,1,1,1,1,0,0]; a length-seven string, like '1111100'; or a string
    like "Mon Tue Wed Thu Fri", made up of 3-character abbreviations for
    weekdays, optionally separated by white space. Valid abbreviations
    are: Mon Tue Wed Thu Fri Sat Sun
holidays : array_like of datetime64[D], optional
    An array of dates to consider as invalid dates.  They may be
    specified in any order, and NaT (not-a-time) dates are ignored.
    This list is saved in a normalized form that is suited for
    fast calculations of valid days.
busdaycal : busdaycalendar, optional
    A `busdaycalendar` object which specifies the valid days. If this
    parameter is provided, neither weekmask nor holidays may be
    provided.
out : array of bool, optional
    If provided, this array is filled with the result.

Returns
-------
out : array of bool
    An array with the same shape as ``dates``, containing True for
    each valid day, and False for each invalid day.

See Also
--------
busdaycalendar : An object that specifies a custom set of valid days.
busday_offset : Applies an offset counted in valid days.
busday_count : Counts how many valid days are in a half-open date range.

Examples
--------
&gt;&gt;&gt; # The weekdays are Friday, Saturday, and Monday
... np.is_busday(['2011-07-01', '2011-07-02', '2011-07-18'],
...                 holidays=['2011-07-01', '2011-07-04', '2011-07-17'])
array([False, False,  True])
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d0/d1a/core_2multiarray_8py_source.html#l01435">1435</a> of file <a class="el" href="../../d0/d1a/core_2multiarray_8py_source.html">multiarray.py</a>.</p>

</div>
</div>
<a id="ace8ad7def2a66f3fe06f715cb4023972" name="ace8ad7def2a66f3fe06f715cb4023972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace8ad7def2a66f3fe06f715cb4023972">&#9670;&#160;</a></span>lexsort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.multiarray.lexsort </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>keys</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>axis</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">lexsort(keys, axis=-1)

Perform an indirect stable sort using a sequence of keys.

Given multiple sorting keys, which can be interpreted as columns in a
spreadsheet, lexsort returns an array of integer indices that describes
the sort order by multiple columns. The last key in the sequence is used
for the primary sort order, the second-to-last key for the secondary sort
order, and so on. The keys argument must be a sequence of objects that
can be converted to arrays of the same shape. If a 2D array is provided
for the keys argument, its rows are interpreted as the sorting keys and
sorting is according to the last row, second last row etc.

Parameters
----------
keys : (k, N) array or tuple containing k (N,)-shaped sequences
    The `k` different "columns" to be sorted.  The last column (or row if
    `keys` is a 2D array) is the primary sort key.
axis : int, optional
    Axis to be indirectly sorted.  By default, sort over the last axis.

Returns
-------
indices : (N,) ndarray of ints
    Array of indices that sort the keys along the specified axis.

See Also
--------
argsort : Indirect sort.
ndarray.sort : In-place sort.
sort : Return a sorted copy of an array.

Examples
--------
Sort names: first by surname, then by name.

&gt;&gt;&gt; surnames =    ('Hertz',    'Galilei', 'Hertz')
&gt;&gt;&gt; first_names = ('Heinrich', 'Galileo', 'Gustav')
&gt;&gt;&gt; ind = np.lexsort((first_names, surnames))
&gt;&gt;&gt; ind
array([1, 2, 0])

&gt;&gt;&gt; [surnames[i] + ", " + first_names[i] for i in ind]
['Galilei, Galileo', 'Hertz, Gustav', 'Hertz, Heinrich']

Sort two columns of numbers:

&gt;&gt;&gt; a = [1,5,1,4,3,4,4] # First column
&gt;&gt;&gt; b = [9,4,0,4,0,2,1] # Second column
&gt;&gt;&gt; ind = np.lexsort((b,a)) # Sort by a, then by b
&gt;&gt;&gt; ind
array([2, 0, 4, 6, 5, 3, 1])

&gt;&gt;&gt; [(a[i],b[i]) for i in ind]
[(1, 0), (1, 9), (3, 0), (4, 1), (4, 2), (4, 4), (5, 4)]

Note that sorting is first according to the elements of ``a``.
Secondary sorting is according to the elements of ``b``.

A normal ``argsort`` would have yielded:

&gt;&gt;&gt; [(a[i],b[i]) for i in np.argsort(a)]
[(1, 9), (1, 0), (3, 0), (4, 4), (4, 2), (4, 1), (5, 4)]

Structured arrays are sorted lexically by ``argsort``:

&gt;&gt;&gt; x = np.array([(1,9), (5,4), (1,0), (4,4), (3,0), (4,2), (4,1)],
...              dtype=np.dtype([('x', int), ('y', int)]))

&gt;&gt;&gt; np.argsort(x) # or np.argsort(x, order=('x', 'y'))
array([2, 0, 4, 6, 5, 3, 1])
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d0/d1a/core_2multiarray_8py_source.html#l00422">422</a> of file <a class="el" href="../../d0/d1a/core_2multiarray_8py_source.html">multiarray.py</a>.</p>

</div>
</div>
<a id="a53ad592278d3cb45614f93e90a1acffc" name="a53ad592278d3cb45614f93e90a1acffc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53ad592278d3cb45614f93e90a1acffc">&#9670;&#160;</a></span>may_share_memory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.multiarray.may_share_memory </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>max_work</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">may_share_memory(a, b, /, max_work=None)

Determine if two arrays might share memory

A return of True does not necessarily mean that the two arrays
share any element.  It just means that they *might*.

Only the memory bounds of a and b are checked by default.

Parameters
----------
a, b : ndarray
    Input arrays
max_work : int, optional
    Effort to spend on solving the overlap problem.  See
    `shares_memory` for details.  Default for ``may_share_memory``
    is to do a bounds check.

Returns
-------
out : bool

See Also
--------
shares_memory

Examples
--------
&gt;&gt;&gt; np.may_share_memory(np.array([1,2]), np.array([5,8,9]))
False
&gt;&gt;&gt; x = np.zeros([3, 4])
&gt;&gt;&gt; np.may_share_memory(x[:,0], x[:,1])
True
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d0/d1a/core_2multiarray_8py_source.html#l01394">1394</a> of file <a class="el" href="../../d0/d1a/core_2multiarray_8py_source.html">multiarray.py</a>.</p>

</div>
</div>
<a id="a33554df6963ba407087d085e3d3e92cc" name="a33554df6963ba407087d085e3d3e92cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33554df6963ba407087d085e3d3e92cc">&#9670;&#160;</a></span>min_scalar_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.multiarray.min_scalar_type </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">min_scalar_type(a, /)

For scalar ``a``, returns the data type with the smallest size
and smallest scalar kind which can hold its value.  For non-scalar
array ``a``, returns the vector's dtype unmodified.

Floating point values are not demoted to integers,
and complex values are not demoted to floats.

Parameters
----------
a : scalar or array_like
    The value whose minimal data type is to be found.

Returns
-------
out : dtype
    The minimal data type.

Notes
-----
.. versionadded:: 1.6.0

See Also
--------
result_type, promote_types, dtype, can_cast

Examples
--------
&gt;&gt;&gt; np.min_scalar_type(10)
dtype('uint8')

&gt;&gt;&gt; np.min_scalar_type(-260)
dtype('int16')

&gt;&gt;&gt; np.min_scalar_type(3.1)
dtype('float16')

&gt;&gt;&gt; np.min_scalar_type(1e50)
dtype('float64')

&gt;&gt;&gt; np.min_scalar_type(np.arange(4,dtype='f8'))
dtype('float64')
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d0/d1a/core_2multiarray_8py_source.html#l00619">619</a> of file <a class="el" href="../../d0/d1a/core_2multiarray_8py_source.html">multiarray.py</a>.</p>

</div>
</div>
<a id="a91a2455f865e0ab4d6e086efac2163fa" name="a91a2455f865e0ab4d6e086efac2163fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91a2455f865e0ab4d6e086efac2163fa">&#9670;&#160;</a></span>packbits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.multiarray.packbits </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>axis</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>bitorder</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'big'</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">packbits(a, /, axis=None, bitorder='big')

Packs the elements of a binary-valued array into bits in a uint8 array.

The result is padded to full bytes by inserting zero bits at the end.

Parameters
----------
a : array_like
    An array of integers or booleans whose elements should be packed to
    bits.
axis : int, optional
    The dimension over which bit-packing is done.
    ``None`` implies packing the flattened array.
bitorder : {'big', 'little'}, optional
    The order of the input bits. 'big' will mimic bin(val),
    ``[0, 0, 0, 0, 0, 0, 1, 1] =&gt; 3 = 0b00000011``, 'little' will
    reverse the order so ``[1, 1, 0, 0, 0, 0, 0, 0] =&gt; 3``.
    Defaults to 'big'.

    .. versionadded:: 1.17.0

Returns
-------
packed : ndarray
    Array of type uint8 whose elements represent bits corresponding to the
    logical (0 or nonzero) value of the input elements. The shape of
    `packed` has the same number of dimensions as the input (unless `axis`
    is None, in which case the output is 1-D).

See Also
--------
unpackbits: Unpacks elements of a uint8 array into a binary-valued output
            array.

Examples
--------
&gt;&gt;&gt; a = np.array([[[1,0,1],
...                [0,1,0]],
...               [[1,1,0],
...                [0,0,1]]])
&gt;&gt;&gt; b = np.packbits(a, axis=-1)
&gt;&gt;&gt; b
array([[[160],
        [ 64]],
       [[192],
        [ 32]]], dtype=uint8)

Note that in binary 160 = 1010 0000, 64 = 0100 0000, 192 = 1100 0000,
and 32 = 0010 0000.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d0/d1a/core_2multiarray_8py_source.html#l01177">1177</a> of file <a class="el" href="../../d0/d1a/core_2multiarray_8py_source.html">multiarray.py</a>.</p>

</div>
</div>
<a id="ae9b8a9c5fd8b434b5700a26280140116" name="ae9b8a9c5fd8b434b5700a26280140116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9b8a9c5fd8b434b5700a26280140116">&#9670;&#160;</a></span>putmask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.multiarray.putmask </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>values</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">putmask(a, mask, values)

Changes elements of an array based on conditional and input values.

Sets ``a.flat[n] = values[n]`` for each n where ``mask.flat[n]==True``.

If `values` is not the same size as `a` and `mask` then it will repeat.
This gives behavior different from ``a[mask] = values``.

Parameters
----------
a : ndarray
    Target array.
mask : array_like
    Boolean mask array. It has to be the same shape as `a`.
values : array_like
    Values to put into `a` where `mask` is True. If `values` is smaller
    than `a` it will be repeated.

See Also
--------
place, put, take, copyto

Examples
--------
&gt;&gt;&gt; x = np.arange(6).reshape(2, 3)
&gt;&gt;&gt; np.putmask(x, x&gt;2, x**2)
&gt;&gt;&gt; x
array([[ 0,  1,  2],
       [ 9, 16, 25]])

If `values` is smaller than `a` it is repeated:

&gt;&gt;&gt; x = np.arange(5)
&gt;&gt;&gt; np.putmask(x, x&gt;1, [-33, -44])
&gt;&gt;&gt; x
array([  0,   1, -33, -44, -33])
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d0/d1a/core_2multiarray_8py_source.html#l01132">1132</a> of file <a class="el" href="../../d0/d1a/core_2multiarray_8py_source.html">multiarray.py</a>.</p>

</div>
</div>
<a id="a8504d23fefcc338cbd7617d1b6a78ad8" name="a8504d23fefcc338cbd7617d1b6a78ad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8504d23fefcc338cbd7617d1b6a78ad8">&#9670;&#160;</a></span>ravel_multi_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.multiarray.ravel_multi_index </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>multi_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>dims</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>mode</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>order</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">ravel_multi_index(multi_index, dims, mode='raise', order='C')

Converts a tuple of index arrays into an array of flat
indices, applying boundary modes to the multi-index.

Parameters
----------
multi_index : tuple of array_like
    A tuple of integer arrays, one array for each dimension.
dims : tuple of ints
    The shape of array into which the indices from ``multi_index`` apply.
mode : {'raise', 'wrap', 'clip'}, optional
    Specifies how out-of-bounds indices are handled.  Can specify
    either one mode or a tuple of modes, one mode per index.

    * 'raise' -- raise an error (default)
    * 'wrap' -- wrap around
    * 'clip' -- clip to the range

    In 'clip' mode, a negative index which would normally
    wrap will clip to 0 instead.
order : {'C', 'F'}, optional
    Determines whether the multi-index should be viewed as
    indexing in row-major (C-style) or column-major
    (Fortran-style) order.

Returns
-------
raveled_indices : ndarray
    An array of indices into the flattened version of an array
    of dimensions ``dims``.

See Also
--------
unravel_index

Notes
-----
.. versionadded:: 1.6.0

Examples
--------
&gt;&gt;&gt; arr = np.array([[3,6,6],[4,5,1]])
&gt;&gt;&gt; np.ravel_multi_index(arr, (7,6))
array([22, 41, 37])
&gt;&gt;&gt; np.ravel_multi_index(arr, (7,6), order='F')
array([31, 41, 13])
&gt;&gt;&gt; np.ravel_multi_index(arr, (4,6), mode='clip')
array([22, 23, 19])
&gt;&gt;&gt; np.ravel_multi_index(arr, (4,4), mode=('clip','wrap'))
array([12, 13, 13])

&gt;&gt;&gt; np.ravel_multi_index((3,1,4,1), (6,7,8,9))
1621
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d0/d1a/core_2multiarray_8py_source.html#l00970">970</a> of file <a class="el" href="../../d0/d1a/core_2multiarray_8py_source.html">multiarray.py</a>.</p>

</div>
</div>
<a id="a631dd443594fa259a859838d2f68c7ec" name="a631dd443594fa259a859838d2f68c7ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a631dd443594fa259a859838d2f68c7ec">&#9670;&#160;</a></span>result_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.multiarray.result_type </td>
          <td>(</td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em>arrays_and_dtypes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">result_type(*arrays_and_dtypes)

Returns the type that results from applying the NumPy
type promotion rules to the arguments.

Type promotion in NumPy works similarly to the rules in languages
like C++, with some slight differences.  When both scalars and
arrays are used, the array's type takes precedence and the actual value
of the scalar is taken into account.

For example, calculating 3*a, where a is an array of 32-bit floats,
intuitively should result in a 32-bit float output.  If the 3 is a
32-bit integer, the NumPy rules indicate it can't convert losslessly
into a 32-bit float, so a 64-bit float should be the result type.
By examining the value of the constant, '3', we see that it fits in
an 8-bit integer, which can be cast losslessly into the 32-bit float.

Parameters
----------
arrays_and_dtypes : list of arrays and dtypes
    The operands of some operation whose result type is needed.

Returns
-------
out : dtype
    The result type.

See also
--------
dtype, promote_types, min_scalar_type, can_cast

Notes
-----
.. versionadded:: 1.6.0

The specific algorithm used is as follows.

Categories are determined by first checking which of boolean,
integer (int/uint), or floating point (float/complex) the maximum
kind of all the arrays and the scalars are.

If there are only scalars or the maximum category of the scalars
is higher than the maximum category of the arrays,
the data types are combined with :func:`promote_types`
to produce the return value.

Otherwise, `min_scalar_type` is called on each scalar, and
the resulting data types are all combined with :func:`promote_types`
to produce the return value.

The set of int values is not a subset of the uint values for types
with the same number of bits, something not reflected in
:func:`min_scalar_type`, but handled as a special case in `result_type`.

Examples
--------
&gt;&gt;&gt; np.result_type(3, np.arange(7, dtype='i1'))
dtype('int8')

&gt;&gt;&gt; np.result_type('i4', 'c8')
dtype('complex128')

&gt;&gt;&gt; np.result_type(3.0, -2)
dtype('float64')
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d0/d1a/core_2multiarray_8py_source.html#l00670">670</a> of file <a class="el" href="../../d0/d1a/core_2multiarray_8py_source.html">multiarray.py</a>.</p>

</div>
</div>
<a id="a0c2f8c4e2c932442df0c92eedce29aac" name="a0c2f8c4e2c932442df0c92eedce29aac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c2f8c4e2c932442df0c92eedce29aac">&#9670;&#160;</a></span>shares_memory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.multiarray.shares_memory </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>max_work</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">shares_memory(a, b, /, max_work=None)

Determine if two arrays share memory.

.. warning::

   This function can be exponentially slow for some inputs, unless
   `max_work` is set to a finite number or ``MAY_SHARE_BOUNDS``.
   If in doubt, use `numpy.may_share_memory` instead.

Parameters
----------
a, b : ndarray
    Input arrays
max_work : int, optional
    Effort to spend on solving the overlap problem (maximum number
    of candidate solutions to consider). The following special
    values are recognized:

    max_work=MAY_SHARE_EXACT  (default)
        The problem is solved exactly. In this case, the function returns
        True only if there is an element shared between the arrays. Finding
        the exact solution may take extremely long in some cases.
    max_work=MAY_SHARE_BOUNDS
        Only the memory bounds of a and b are checked.

Raises
------
numpy.exceptions.TooHardError
    Exceeded max_work.

Returns
-------
out : bool

See Also
--------
may_share_memory

Examples
--------
&gt;&gt;&gt; x = np.array([1, 2, 3, 4])
&gt;&gt;&gt; np.shares_memory(x, np.array([5, 6, 7]))
False
&gt;&gt;&gt; np.shares_memory(x[::2], x)
True
&gt;&gt;&gt; np.shares_memory(x[::2], x[1::2])
False

Checking whether two arrays share memory is NP-complete, and
runtime may increase exponentially in the number of
dimensions. Hence, `max_work` should generally be set to a finite
number, as it is possible to construct examples that take
extremely long to run:

&gt;&gt;&gt; from numpy.lib.stride_tricks import as_strided
&gt;&gt;&gt; x = np.zeros([192163377], dtype=np.int8)
&gt;&gt;&gt; x1 = as_strided(x, strides=(36674, 61119, 85569), shape=(1049, 1049, 1049))
&gt;&gt;&gt; x2 = as_strided(x[64023025:], strides=(12223, 12224, 1), shape=(1049, 1049, 1))
&gt;&gt;&gt; np.shares_memory(x1, x2, max_work=1000)
Traceback (most recent call last):
...
numpy.exceptions.TooHardError: Exceeded max_work

Running ``np.shares_memory(x1, x2)`` without `max_work` set takes
around 1 minute for this case. It is possible to find problems
that take still significantly longer.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d0/d1a/core_2multiarray_8py_source.html#l01319">1319</a> of file <a class="el" href="../../d0/d1a/core_2multiarray_8py_source.html">multiarray.py</a>.</p>

</div>
</div>
<a id="ab260a98a2750798027f651b626b8403f" name="ab260a98a2750798027f651b626b8403f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab260a98a2750798027f651b626b8403f">&#9670;&#160;</a></span>unpackbits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.multiarray.unpackbits </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>axis</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>count</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>bitorder</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'big'</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">unpackbits(a, /, axis=None, count=None, bitorder='big')

Unpacks elements of a uint8 array into a binary-valued output array.

Each element of `a` represents a bit-field that should be unpacked
into a binary-valued output array. The shape of the output array is
either 1-D (if `axis` is ``None``) or the same shape as the input
array with unpacking done along the axis specified.

Parameters
----------
a : ndarray, uint8 type
   Input array.
axis : int, optional
    The dimension over which bit-unpacking is done.
    ``None`` implies unpacking the flattened array.
count : int or None, optional
    The number of elements to unpack along `axis`, provided as a way
    of undoing the effect of packing a size that is not a multiple
    of eight. A non-negative number means to only unpack `count`
    bits. A negative number means to trim off that many bits from
    the end. ``None`` means to unpack the entire array (the
    default). Counts larger than the available number of bits will
    add zero padding to the output. Negative counts must not
    exceed the available number of bits.

    .. versionadded:: 1.17.0

bitorder : {'big', 'little'}, optional
    The order of the returned bits. 'big' will mimic bin(val),
    ``3 = 0b00000011 =&gt; [0, 0, 0, 0, 0, 0, 1, 1]``, 'little' will reverse
    the order to ``[1, 1, 0, 0, 0, 0, 0, 0]``.
    Defaults to 'big'.

    .. versionadded:: 1.17.0

Returns
-------
unpacked : ndarray, uint8 type
   The elements are binary-valued (0 or 1).

See Also
--------
packbits : Packs the elements of a binary-valued array into bits in
           a uint8 array.

Examples
--------
&gt;&gt;&gt; a = np.array([[2], [7], [23]], dtype=np.uint8)
&gt;&gt;&gt; a
array([[ 2],
       [ 7],
       [23]], dtype=uint8)
&gt;&gt;&gt; b = np.unpackbits(a, axis=1)
&gt;&gt;&gt; b
array([[0, 0, 0, 0, 0, 0, 1, 0],
       [0, 0, 0, 0, 0, 1, 1, 1],
       [0, 0, 0, 1, 0, 1, 1, 1]], dtype=uint8)
&gt;&gt;&gt; c = np.unpackbits(a, axis=1, count=-3)
&gt;&gt;&gt; c
array([[0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0],
       [0, 0, 0, 1, 0]], dtype=uint8)

&gt;&gt;&gt; p = np.packbits(b, axis=0)
&gt;&gt;&gt; np.unpackbits(p, axis=0)
array([[0, 0, 0, 0, 0, 0, 1, 0],
       [0, 0, 0, 0, 0, 1, 1, 1],
       [0, 0, 0, 1, 0, 1, 1, 1],
       [0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)
&gt;&gt;&gt; np.array_equal(b, np.unpackbits(p, axis=0, count=b.shape[0]))
True
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d0/d1a/core_2multiarray_8py_source.html#l01235">1235</a> of file <a class="el" href="../../d0/d1a/core_2multiarray_8py_source.html">multiarray.py</a>.</p>

</div>
</div>
<a id="a05fb5a81e759751a4846cfdb2a7c0661" name="a05fb5a81e759751a4846cfdb2a7c0661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05fb5a81e759751a4846cfdb2a7c0661">&#9670;&#160;</a></span>unravel_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.multiarray.unravel_index </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>indices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>shape</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>order</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">unravel_index(indices, shape, order='C')

Converts a flat index or array of flat indices into a tuple
of coordinate arrays.

Parameters
----------
indices : array_like
    An integer array whose elements are indices into the flattened
    version of an array of dimensions ``shape``. Before version 1.6.0,
    this function accepted just one index value.
shape : tuple of ints
    The shape of the array to use for unraveling ``indices``.

    .. versionchanged:: 1.16.0
        Renamed from ``dims`` to ``shape``.

order : {'C', 'F'}, optional
    Determines whether the indices should be viewed as indexing in
    row-major (C-style) or column-major (Fortran-style) order.

    .. versionadded:: 1.6.0

Returns
-------
unraveled_coords : tuple of ndarray
    Each array in the tuple has the same shape as the ``indices``
    array.

See Also
--------
ravel_multi_index

Examples
--------
&gt;&gt;&gt; np.unravel_index([22, 41, 37], (7,6))
(array([3, 6, 6]), array([4, 5, 1]))
&gt;&gt;&gt; np.unravel_index([31, 41, 13], (7,6), order='F')
(array([3, 6, 6]), array([4, 5, 1]))

&gt;&gt;&gt; np.unravel_index(1621, (6,7,8,9))
(3, 1, 4, 1)
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d0/d1a/core_2multiarray_8py_source.html#l01031">1031</a> of file <a class="el" href="../../d0/d1a/core_2multiarray_8py_source.html">multiarray.py</a>.</p>

</div>
</div>
<a id="addb4f2892682f3716f61b5eaf5a35b4a" name="addb4f2892682f3716f61b5eaf5a35b4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addb4f2892682f3716f61b5eaf5a35b4a">&#9670;&#160;</a></span>vdot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.multiarray.vdot </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">vdot(a, b, /)

Return the dot product of two vectors.

The vdot(`a`, `b`) function handles complex numbers differently than
dot(`a`, `b`).  If the first argument is complex the complex conjugate
of the first argument is used for the calculation of the dot product.

Note that `vdot` handles multidimensional arrays differently than `dot`:
it does *not* perform a matrix product, but flattens input arguments
to 1-D vectors first. Consequently, it should only be used for vectors.

Parameters
----------
a : array_like
    If `a` is complex the complex conjugate is taken before calculation
    of the dot product.
b : array_like
    Second argument to the dot product.

Returns
-------
output : ndarray
    Dot product of `a` and `b`.  Can be an int, float, or
    complex depending on the types of `a` and `b`.

See Also
--------
dot : Return the dot product without using the complex conjugate of the
      first argument.

Examples
--------
&gt;&gt;&gt; a = np.array([1+2j,3+4j])
&gt;&gt;&gt; b = np.array([5+6j,7+8j])
&gt;&gt;&gt; np.vdot(a, b)
(70-8j)
&gt;&gt;&gt; np.vdot(b, a)
(70+8j)

Note that higher-dimensional arrays are flattened!

&gt;&gt;&gt; a = np.array([[1, 4], [5, 6]])
&gt;&gt;&gt; b = np.array([[4, 1], [2, 2]])
&gt;&gt;&gt; np.vdot(a, b)
30
&gt;&gt;&gt; np.vdot(b, a)
30
&gt;&gt;&gt; 1*4 + 4*1 + 5*2 + 6*2
30
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d0/d1a/core_2multiarray_8py_source.html#l00835">835</a> of file <a class="el" href="../../d0/d1a/core_2multiarray_8py_source.html">multiarray.py</a>.</p>

</div>
</div>
<a id="aafec298d2664515002736e4905e6719b" name="aafec298d2664515002736e4905e6719b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafec298d2664515002736e4905e6719b">&#9670;&#160;</a></span>where()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.multiarray.where </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>condition</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>x</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">where(condition, [x, y], /)

Return elements chosen from `x` or `y` depending on `condition`.

.. note::
    When only `condition` is provided, this function is a shorthand for
    ``np.asarray(condition).nonzero()``. Using `nonzero` directly should be
    preferred, as it behaves correctly for subclasses. The rest of this
    documentation covers only the case where all three arguments are
    provided.

Parameters
----------
condition : array_like, bool
    Where True, yield `x`, otherwise yield `y`.
x, y : array_like
    Values from which to choose. `x`, `y` and `condition` need to be
    broadcastable to some shape.

Returns
-------
out : ndarray
    An array with elements from `x` where `condition` is True, and elements
    from `y` elsewhere.

See Also
--------
choose
nonzero : The function that is called when x and y are omitted

Notes
-----
If all the arrays are 1-D, `where` is equivalent to::

    [xv if c else yv
     for c, xv, yv in zip(condition, x, y)]

Examples
--------
&gt;&gt;&gt; a = np.arange(10)
&gt;&gt;&gt; a
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
&gt;&gt;&gt; np.where(a &lt; 5, a, 10*a)
array([ 0,  1,  2,  3,  4, 50, 60, 70, 80, 90])

This can be used on multidimensional arrays too:

&gt;&gt;&gt; np.where([[True, False], [True, True]],
...          [[1, 2], [3, 4]],
...          [[9, 8], [7, 6]])
array([[1, 8],
       [3, 4]])

The shapes of x, y, and the condition are broadcast together:

&gt;&gt;&gt; x, y = np.ogrid[:3, :4]
&gt;&gt;&gt; np.where(x &lt; y, x, 10 + y)  # both x and 10+y are broadcast
array([[10,  0,  0,  0],
       [10, 11,  1,  1],
       [10, 11, 12,  2]])

&gt;&gt;&gt; a = np.array([[0, 1, 2],
...               [0, 2, 4],
...               [0, 3, 6]])
&gt;&gt;&gt; np.where(a &lt; 4, a, -1)  # -1 is broadcast
array([[ 0,  1,  2],
       [ 0,  2, -1],
       [ 0,  3, -1]])
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d0/d1a/core_2multiarray_8py_source.html#l00347">347</a> of file <a class="el" href="../../d0/d1a/core_2multiarray_8py_source.html">multiarray.py</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ad54995e21c5da2de148ea2e3c9e8469f" name="ad54995e21c5da2de148ea2e3c9e8469f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad54995e21c5da2de148ea2e3c9e8469f">&#9670;&#160;</a></span>__all__</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">list numpy.core.multiarray.__all__</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  [</div>
<div class="line"><span class="lineno">    2</span>    <span class="stringliteral">&#39;_ARRAY_API&#39;</span>, <span class="stringliteral">&#39;ALLOW_THREADS&#39;</span>, <span class="stringliteral">&#39;BUFSIZE&#39;</span>, <span class="stringliteral">&#39;CLIP&#39;</span>, <span class="stringliteral">&#39;DATETIMEUNITS&#39;</span>,</div>
<div class="line"><span class="lineno">    3</span>    <span class="stringliteral">&#39;ITEM_HASOBJECT&#39;</span>, <span class="stringliteral">&#39;ITEM_IS_POINTER&#39;</span>, <span class="stringliteral">&#39;LIST_PICKLE&#39;</span>, <span class="stringliteral">&#39;MAXDIMS&#39;</span>,</div>
<div class="line"><span class="lineno">    4</span>    <span class="stringliteral">&#39;MAY_SHARE_BOUNDS&#39;</span>, <span class="stringliteral">&#39;MAY_SHARE_EXACT&#39;</span>, <span class="stringliteral">&#39;NEEDS_INIT&#39;</span>, <span class="stringliteral">&#39;NEEDS_PYAPI&#39;</span>,</div>
<div class="line"><span class="lineno">    5</span>    <span class="stringliteral">&#39;RAISE&#39;</span>, <span class="stringliteral">&#39;USE_GETITEM&#39;</span>, <span class="stringliteral">&#39;USE_SETITEM&#39;</span>, <span class="stringliteral">&#39;WRAP&#39;</span>,</div>
<div class="line"><span class="lineno">    6</span>    <span class="stringliteral">&#39;_flagdict&#39;</span>, <span class="stringliteral">&#39;from_dlpack&#39;</span>, <span class="stringliteral">&#39;_place&#39;</span>, <span class="stringliteral">&#39;_reconstruct&#39;</span>, <span class="stringliteral">&#39;_vec_string&#39;</span>,</div>
<div class="line"><span class="lineno">    7</span>    <span class="stringliteral">&#39;_monotonicity&#39;</span>, <span class="stringliteral">&#39;add_docstring&#39;</span>, <span class="stringliteral">&#39;arange&#39;</span>, <span class="stringliteral">&#39;array&#39;</span>, <span class="stringliteral">&#39;asarray&#39;</span>,</div>
<div class="line"><span class="lineno">    8</span>    <span class="stringliteral">&#39;asanyarray&#39;</span>, <span class="stringliteral">&#39;ascontiguousarray&#39;</span>, <span class="stringliteral">&#39;asfortranarray&#39;</span>, <span class="stringliteral">&#39;bincount&#39;</span>,</div>
<div class="line"><span class="lineno">    9</span>    <span class="stringliteral">&#39;broadcast&#39;</span>, <span class="stringliteral">&#39;busday_count&#39;</span>, <span class="stringliteral">&#39;busday_offset&#39;</span>, <span class="stringliteral">&#39;busdaycalendar&#39;</span>, <span class="stringliteral">&#39;can_cast&#39;</span>,</div>
<div class="line"><span class="lineno">   10</span>    <span class="stringliteral">&#39;compare_chararrays&#39;</span>, <span class="stringliteral">&#39;concatenate&#39;</span>, <span class="stringliteral">&#39;copyto&#39;</span>, <span class="stringliteral">&#39;correlate&#39;</span>, <span class="stringliteral">&#39;correlate2&#39;</span>,</div>
<div class="line"><span class="lineno">   11</span>    <span class="stringliteral">&#39;count_nonzero&#39;</span>, <span class="stringliteral">&#39;c_einsum&#39;</span>, <span class="stringliteral">&#39;datetime_as_string&#39;</span>, <span class="stringliteral">&#39;datetime_data&#39;</span>,</div>
<div class="line"><span class="lineno">   12</span>    <span class="stringliteral">&#39;dot&#39;</span>, <span class="stringliteral">&#39;dragon4_positional&#39;</span>, <span class="stringliteral">&#39;dragon4_scientific&#39;</span>, <span class="stringliteral">&#39;dtype&#39;</span>,</div>
<div class="line"><span class="lineno">   13</span>    <span class="stringliteral">&#39;empty&#39;</span>, <span class="stringliteral">&#39;empty_like&#39;</span>, <span class="stringliteral">&#39;error&#39;</span>, <span class="stringliteral">&#39;flagsobj&#39;</span>, <span class="stringliteral">&#39;flatiter&#39;</span>, <span class="stringliteral">&#39;format_longfloat&#39;</span>,</div>
<div class="line"><span class="lineno">   14</span>    <span class="stringliteral">&#39;frombuffer&#39;</span>, <span class="stringliteral">&#39;fromfile&#39;</span>, <span class="stringliteral">&#39;fromiter&#39;</span>, <span class="stringliteral">&#39;fromstring&#39;</span>,</div>
<div class="line"><span class="lineno">   15</span>    <span class="stringliteral">&#39;get_handler_name&#39;</span>, <span class="stringliteral">&#39;get_handler_version&#39;</span>, <span class="stringliteral">&#39;inner&#39;</span>, <span class="stringliteral">&#39;interp&#39;</span>,</div>
<div class="line"><span class="lineno">   16</span>    <span class="stringliteral">&#39;interp_complex&#39;</span>, <span class="stringliteral">&#39;is_busday&#39;</span>, <span class="stringliteral">&#39;lexsort&#39;</span>, <span class="stringliteral">&#39;matmul&#39;</span>, <span class="stringliteral">&#39;may_share_memory&#39;</span>,</div>
<div class="line"><span class="lineno">   17</span>    <span class="stringliteral">&#39;min_scalar_type&#39;</span>, <span class="stringliteral">&#39;ndarray&#39;</span>, <span class="stringliteral">&#39;nditer&#39;</span>, <span class="stringliteral">&#39;nested_iters&#39;</span>,</div>
<div class="line"><span class="lineno">   18</span>    <span class="stringliteral">&#39;normalize_axis_index&#39;</span>, <span class="stringliteral">&#39;packbits&#39;</span>, <span class="stringliteral">&#39;promote_types&#39;</span>, <span class="stringliteral">&#39;putmask&#39;</span>,</div>
<div class="line"><span class="lineno">   19</span>    <span class="stringliteral">&#39;ravel_multi_index&#39;</span>, <span class="stringliteral">&#39;result_type&#39;</span>, <span class="stringliteral">&#39;scalar&#39;</span>, <span class="stringliteral">&#39;set_datetimeparse_function&#39;</span>,</div>
<div class="line"><span class="lineno">   20</span>    <span class="stringliteral">&#39;set_legacy_print_mode&#39;</span>, <span class="stringliteral">&#39;set_numeric_ops&#39;</span>, <span class="stringliteral">&#39;set_string_function&#39;</span>,</div>
<div class="line"><span class="lineno">   21</span>    <span class="stringliteral">&#39;set_typeDict&#39;</span>, <span class="stringliteral">&#39;shares_memory&#39;</span>, <span class="stringliteral">&#39;tracemalloc_domain&#39;</span>, <span class="stringliteral">&#39;typeinfo&#39;</span>,</div>
<div class="line"><span class="lineno">   22</span>    <span class="stringliteral">&#39;unpackbits&#39;</span>, <span class="stringliteral">&#39;unravel_index&#39;</span>, <span class="stringliteral">&#39;vdot&#39;</span>, <span class="stringliteral">&#39;where&#39;</span>, <span class="stringliteral">&#39;zeros&#39;</span>,</div>
<div class="line"><span class="lineno">   23</span>    <span class="stringliteral">&#39;_get_promotion_state&#39;</span>, <span class="stringliteral">&#39;_set_promotion_state&#39;</span>, <span class="stringliteral">&#39;_using_numpy2_behavior&#39;</span>]</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="../../d0/d1a/core_2multiarray_8py_source.html#l00023">23</a> of file <a class="el" href="../../d0/d1a/core_2multiarray_8py_source.html">multiarray.py</a>.</p>

</div>
</div>
<a id="ad88a4b24c1217f78f7ff42f3869dfe93" name="ad88a4b24c1217f78f7ff42f3869dfe93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad88a4b24c1217f78f7ff42f3869dfe93">&#9670;&#160;</a></span>__module__</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.multiarray.__module__</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d0/d1a/core_2multiarray_8py_source.html#l00048">48</a> of file <a class="el" href="../../d0/d1a/core_2multiarray_8py_source.html">multiarray.py</a>.</p>

</div>
</div>
<a id="a8f0985446cd1812ab7345b24aaf37a2b" name="a8f0985446cd1812ab7345b24aaf37a2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f0985446cd1812ab7345b24aaf37a2b">&#9670;&#160;</a></span>array_function_from_c_func_and_dispatcher</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.multiarray.array_function_from_c_func_and_dispatcher</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  functools.partial(</div>
<div class="line"><span class="lineno">    2</span>    overrides.array_function_from_dispatcher,</div>
<div class="line"><span class="lineno">    3</span>    module=<span class="stringliteral">&#39;numpy&#39;</span>, docs_from_dispatcher=<span class="keyword">True</span>, verify=<span class="keyword">False</span>)</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="../../d0/d1a/core_2multiarray_8py_source.html#l00080">80</a> of file <a class="el" href="../../d0/d1a/core_2multiarray_8py_source.html">multiarray.py</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d2/ddb/namespacenumpy.html">numpy</a></li><li class="navelem"><a class="el" href="../../dd/d5a/namespacenumpy_1_1core.html">core</a></li><li class="navelem"><a class="el" href="../../d1/db5/namespacenumpy_1_1core_1_1multiarray.html">multiarray</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
