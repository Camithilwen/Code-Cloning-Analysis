<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Code Cloning Analysis: scipy.sparse.linalg._eigen._svds_doc Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Code Cloning Analysis
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d0/def/namespacescipy_1_1sparse_1_1linalg_1_1__eigen_1_1__svds__doc.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">scipy.sparse.linalg._eigen._svds_doc Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a08bb01e5bda890658b9d91ce5a64dfc0" id="r_a08bb01e5bda890658b9d91ce5a64dfc0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08bb01e5bda890658b9d91ce5a64dfc0">_svds_arpack_doc</a> (A, k=6, ncv=None, tol=0, which='LM', v0=None, maxiter=None, return_singular_vectors=<a class="el" href="../../d8/d0b/classTrue.html">True</a>, solver='arpack', random_state=None)</td></tr>
<tr class="separator:a08bb01e5bda890658b9d91ce5a64dfc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade264da5631b707ef32aad90ad59697e" id="r_ade264da5631b707ef32aad90ad59697e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade264da5631b707ef32aad90ad59697e">_svds_lobpcg_doc</a> (A, k=6, ncv=None, tol=0, which='LM', v0=None, maxiter=None, return_singular_vectors=<a class="el" href="../../d8/d0b/classTrue.html">True</a>, solver='lobpcg', random_state=None)</td></tr>
<tr class="separator:ade264da5631b707ef32aad90ad59697e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb400a283489b22664b33162b04c4c0" id="r_afdb400a283489b22664b33162b04c4c0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afdb400a283489b22664b33162b04c4c0">_svds_propack_doc</a> (A, k=6, ncv=None, tol=0, which='LM', v0=None, maxiter=None, return_singular_vectors=<a class="el" href="../../d8/d0b/classTrue.html">True</a>, solver='propack', random_state=None)</td></tr>
<tr class="separator:afdb400a283489b22664b33162b04c4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a08bb01e5bda890658b9d91ce5a64dfc0" name="a08bb01e5bda890658b9d91ce5a64dfc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08bb01e5bda890658b9d91ce5a64dfc0">&#9670;&#160;</a></span>_svds_arpack_doc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.sparse.linalg._eigen._svds_doc._svds_arpack_doc </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>k</em></span><span class="paramdefsep"> = </span><span class="paramdefval">6</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>ncv</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>tol</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>which</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'LM'</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>v0</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>maxiter</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>return_singular_vectors</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d8/d0b/classTrue.html">True</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>solver</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'arpack'</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>random_state</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Partial singular value decomposition of a sparse matrix using ARPACK.

Compute the largest or smallest `k` singular values and corresponding
singular vectors of a sparse matrix `A`. The order in which the singular
values are returned is not guaranteed.

In the descriptions below, let ``M, N = A.shape``.

Parameters
----------
A : sparse matrix or LinearOperator
    Matrix to decompose.
k : int, optional
    Number of singular values and singular vectors to compute.
    Must satisfy ``1 &lt;= k &lt;= min(M, N) - 1``.
    Default is 6.
ncv : int, optional
    The number of Lanczos vectors generated.
    The default is ``min(n, max(2*k + 1, 20))``.
    If specified, must satistify ``k + 1 &lt; ncv &lt; min(M, N)``; ``ncv &gt; 2*k``
    is recommended.
tol : float, optional
    Tolerance for singular values. Zero (default) means machine precision.
which : {'LM', 'SM'}
    Which `k` singular values to find: either the largest magnitude ('LM')
    or smallest magnitude ('SM') singular values.
v0 : ndarray, optional
    The starting vector for iteration:
    an (approximate) left singular vector if ``N &gt; M`` and a right singular
    vector otherwise. Must be of length ``min(M, N)``.
    Default: random
maxiter : int, optional
    Maximum number of Arnoldi update iterations allowed;
    default is ``min(M, N) * 10``.
return_singular_vectors : {True, False, "u", "vh"}
    Singular values are always computed and returned; this parameter
    controls the computation and return of singular vectors.

    - ``True``: return singular vectors.
    - ``False``: do not return singular vectors.
    - ``"u"``: if ``M &lt;= N``, compute only the left singular vectors and
      return ``None`` for the right singular vectors. Otherwise, compute
      all singular vectors.
    - ``"vh"``: if ``M &gt; N``, compute only the right singular vectors and
      return ``None`` for the left singular vectors. Otherwise, compute
      all singular vectors.

solver :  {'arpack', 'propack', 'lobpcg'}, optional
        This is the solver-specific documentation for ``solver='arpack'``.
        :ref:`'lobpcg' &lt;sparse.linalg.svds-lobpcg&gt;` and
        :ref:`'propack' &lt;sparse.linalg.svds-propack&gt;`
        are also supported.
random_state : {None, int, `numpy.random.Generator`,
                `numpy.random.RandomState`}, optional

    Pseudorandom number generator state used to generate resamples.

    If `random_state` is ``None`` (or `np.random`), the
    `numpy.random.RandomState` singleton is used.
    If `random_state` is an int, a new ``RandomState`` instance is used,
    seeded with `random_state`.
    If `random_state` is already a ``Generator`` or ``RandomState``
    instance then that instance is used.
options : dict, optional
    A dictionary of solver-specific options. No solver-specific options
    are currently supported; this parameter is reserved for future use.

Returns
-------
u : ndarray, shape=(M, k)
    Unitary matrix having left singular vectors as columns.
s : ndarray, shape=(k,)
    The singular values.
vh : ndarray, shape=(k, N)
    Unitary matrix having right singular vectors as rows.

Notes
-----
This is a naive implementation using ARPACK as an eigensolver
on ``A.conj().T @ A`` or ``A @ A.conj().T``, depending on which one is more
efficient.

Examples
--------
Construct a matrix ``A`` from singular values and vectors.

&gt;&gt;&gt; from scipy.stats import ortho_group
&gt;&gt;&gt; from scipy.sparse import csc_matrix, diags
&gt;&gt;&gt; from scipy.sparse.linalg import svds
&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; orthogonal = csc_matrix(ortho_group.rvs(10, random_state=rng))
&gt;&gt;&gt; s = [0.0001, 0.001, 3, 4, 5]  # singular values
&gt;&gt;&gt; u = orthogonal[:, :5]         # left singular vectors
&gt;&gt;&gt; vT = orthogonal[:, 5:].T      # right singular vectors
&gt;&gt;&gt; A = u @ diags(s) @ vT

With only three singular values/vectors, the SVD approximates the original
matrix.

&gt;&gt;&gt; u2, s2, vT2 = svds(A, k=3, solver='arpack')
&gt;&gt;&gt; A2 = u2 @ np.diag(s2) @ vT2
&gt;&gt;&gt; np.allclose(A2, A.toarray(), atol=1e-3)
True

With all five singular values/vectors, we can reproduce the original
matrix.

&gt;&gt;&gt; u3, s3, vT3 = svds(A, k=5, solver='arpack')
&gt;&gt;&gt; A3 = u3 @ np.diag(s3) @ vT3
&gt;&gt;&gt; np.allclose(A3, A.toarray())
True

The singular values match the expected singular values, and the singular
vectors are as expected up to a difference in sign.

&gt;&gt;&gt; (np.allclose(s3, s) and
...  np.allclose(np.abs(u3), np.abs(u.toarray())) and
...  np.allclose(np.abs(vT3), np.abs(vT.toarray())))
True

The singular vectors are also orthogonal.

&gt;&gt;&gt; (np.allclose(u3.T @ u3, np.eye(5)) and
...  np.allclose(vT3 @ vT3.T, np.eye(5)))
True
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d6/d1d/__svds__doc_8py_source.html#l00001">1</a> of file <a class="el" href="../../d6/d1d/__svds__doc_8py_source.html">_svds_doc.py</a>.</p>

</div>
</div>
<a id="ade264da5631b707ef32aad90ad59697e" name="ade264da5631b707ef32aad90ad59697e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade264da5631b707ef32aad90ad59697e">&#9670;&#160;</a></span>_svds_lobpcg_doc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.sparse.linalg._eigen._svds_doc._svds_lobpcg_doc </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>k</em></span><span class="paramdefsep"> = </span><span class="paramdefval">6</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>ncv</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>tol</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>which</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'LM'</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>v0</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>maxiter</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>return_singular_vectors</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d8/d0b/classTrue.html">True</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>solver</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'lobpcg'</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>random_state</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Partial singular value decomposition of a sparse matrix using LOBPCG.

Compute the largest or smallest `k` singular values and corresponding
singular vectors of a sparse matrix `A`. The order in which the singular
values are returned is not guaranteed.

In the descriptions below, let ``M, N = A.shape``.

Parameters
----------
A : sparse matrix or LinearOperator
    Matrix to decompose.
k : int, default: 6
    Number of singular values and singular vectors to compute.
    Must satisfy ``1 &lt;= k &lt;= min(M, N) - 1``.
ncv : int, optional
    Ignored.
tol : float, optional
    Tolerance for singular values. Zero (default) means machine precision.
which : {'LM', 'SM'}
    Which `k` singular values to find: either the largest magnitude ('LM')
    or smallest magnitude ('SM') singular values.
v0 : ndarray, optional
    If `k` is 1, the starting vector for iteration:
    an (approximate) left singular vector if ``N &gt; M`` and a right singular
    vector otherwise. Must be of length ``min(M, N)``.
    Ignored otherwise.
    Default: random
maxiter : int, default: 20
    Maximum number of iterations.
return_singular_vectors : {True, False, "u", "vh"}
    Singular values are always computed and returned; this parameter
    controls the computation and return of singular vectors.

    - ``True``: return singular vectors.
    - ``False``: do not return singular vectors.
    - ``"u"``: if ``M &lt;= N``, compute only the left singular vectors and
      return ``None`` for the right singular vectors. Otherwise, compute
      all singular vectors.
    - ``"vh"``: if ``M &gt; N``, compute only the right singular vectors and
      return ``None`` for the left singular vectors. Otherwise, compute
      all singular vectors.

solver :  {'arpack', 'propack', 'lobpcg'}, optional
        This is the solver-specific documentation for ``solver='lobpcg'``.
        :ref:`'arpack' &lt;sparse.linalg.svds-arpack&gt;` and
        :ref:`'propack' &lt;sparse.linalg.svds-propack&gt;`
        are also supported.
random_state : {None, int, `numpy.random.Generator`,
                `numpy.random.RandomState`}, optional

    Pseudorandom number generator state used to generate resamples.

    If `random_state` is ``None`` (or `np.random`), the
    `numpy.random.RandomState` singleton is used.
    If `random_state` is an int, a new ``RandomState`` instance is used,
    seeded with `random_state`.
    If `random_state` is already a ``Generator`` or ``RandomState``
    instance then that instance is used.
options : dict, optional
    A dictionary of solver-specific options. No solver-specific options
    are currently supported; this parameter is reserved for future use.

Returns
-------
u : ndarray, shape=(M, k)
    Unitary matrix having left singular vectors as columns.
s : ndarray, shape=(k,)
    The singular values.
vh : ndarray, shape=(k, N)
    Unitary matrix having right singular vectors as rows.

Notes
-----
This is a naive implementation using LOBPCG as an eigensolver
on ``A.conj().T @ A`` or ``A @ A.conj().T``, depending on which one is more
efficient.

Examples
--------
Construct a matrix ``A`` from singular values and vectors.

&gt;&gt;&gt; from scipy.stats import ortho_group
&gt;&gt;&gt; from scipy.sparse import csc_matrix, diags
&gt;&gt;&gt; from scipy.sparse.linalg import svds
&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; orthogonal = csc_matrix(ortho_group.rvs(10, random_state=rng))
&gt;&gt;&gt; s = [0.0001, 0.001, 3, 4, 5]  # singular values
&gt;&gt;&gt; u = orthogonal[:, :5]         # left singular vectors
&gt;&gt;&gt; vT = orthogonal[:, 5:].T      # right singular vectors
&gt;&gt;&gt; A = u @ diags(s) @ vT

With only three singular values/vectors, the SVD approximates the original
matrix.

&gt;&gt;&gt; u2, s2, vT2 = svds(A, k=3, solver='lobpcg')
&gt;&gt;&gt; A2 = u2 @ np.diag(s2) @ vT2
&gt;&gt;&gt; np.allclose(A2, A.toarray(), atol=1e-3)
True

With all five singular values/vectors, we can reproduce the original
matrix.

&gt;&gt;&gt; u3, s3, vT3 = svds(A, k=5, solver='lobpcg')
&gt;&gt;&gt; A3 = u3 @ np.diag(s3) @ vT3
&gt;&gt;&gt; np.allclose(A3, A.toarray())
True

The singular values match the expected singular values, and the singular
vectors are as expected up to a difference in sign.

&gt;&gt;&gt; (np.allclose(s3, s) and
...  np.allclose(np.abs(u3), np.abs(u.todense())) and
...  np.allclose(np.abs(vT3), np.abs(vT.todense())))
True

The singular vectors are also orthogonal.

&gt;&gt;&gt; (np.allclose(u3.T @ u3, np.eye(5)) and
...  np.allclose(vT3 @ vT3.T, np.eye(5)))
True
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d6/d1d/__svds__doc_8py_source.html#l00134">134</a> of file <a class="el" href="../../d6/d1d/__svds__doc_8py_source.html">_svds_doc.py</a>.</p>

</div>
</div>
<a id="afdb400a283489b22664b33162b04c4c0" name="afdb400a283489b22664b33162b04c4c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdb400a283489b22664b33162b04c4c0">&#9670;&#160;</a></span>_svds_propack_doc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.sparse.linalg._eigen._svds_doc._svds_propack_doc </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>k</em></span><span class="paramdefsep"> = </span><span class="paramdefval">6</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>ncv</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>tol</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>which</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'LM'</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>v0</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>maxiter</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>return_singular_vectors</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d8/d0b/classTrue.html">True</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>solver</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'propack'</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>random_state</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Partial singular value decomposition of a sparse matrix using PROPACK.

Compute the largest or smallest `k` singular values and corresponding
singular vectors of a sparse matrix `A`. The order in which the singular
values are returned is not guaranteed.

In the descriptions below, let ``M, N = A.shape``.

Parameters
----------
A : sparse matrix or LinearOperator
    Matrix to decompose. If `A` is a ``LinearOperator``
    object, it must define both ``matvec`` and ``rmatvec`` methods.
k : int, default: 6
    Number of singular values and singular vectors to compute.
    Must satisfy ``1 &lt;= k &lt;= min(M, N)``.
ncv : int, optional
    Ignored.
tol : float, optional
    The desired relative accuracy for computed singular values.
    Zero (default) means machine precision.
which : {'LM', 'SM'}
    Which `k` singular values to find: either the largest magnitude ('LM')
    or smallest magnitude ('SM') singular values. Note that choosing
    ``which='SM'`` will force the ``irl`` option to be set ``True``.
v0 : ndarray, optional
    Starting vector for iterations: must be of length ``A.shape[0]``.
    If not specified, PROPACK will generate a starting vector.
maxiter : int, optional
    Maximum number of iterations / maximal dimension of the Krylov
    subspace. Default is ``10 * k``.
return_singular_vectors : {True, False, "u", "vh"}
    Singular values are always computed and returned; this parameter
    controls the computation and return of singular vectors.

    - ``True``: return singular vectors.
    - ``False``: do not return singular vectors.
    - ``"u"``: compute only the left singular vectors; return ``None`` for
      the right singular vectors.
    - ``"vh"``: compute only the right singular vectors; return ``None``
      for the left singular vectors.

solver :  {'arpack', 'propack', 'lobpcg'}, optional
        This is the solver-specific documentation for ``solver='propack'``.
        :ref:`'arpack' &lt;sparse.linalg.svds-arpack&gt;` and
        :ref:`'lobpcg' &lt;sparse.linalg.svds-lobpcg&gt;`
        are also supported.
random_state : {None, int, `numpy.random.Generator`,
                `numpy.random.RandomState`}, optional

    Pseudorandom number generator state used to generate resamples.

    If `random_state` is ``None`` (or `np.random`), the
    `numpy.random.RandomState` singleton is used.
    If `random_state` is an int, a new ``RandomState`` instance is used,
    seeded with `random_state`.
    If `random_state` is already a ``Generator`` or ``RandomState``
    instance then that instance is used.
options : dict, optional
    A dictionary of solver-specific options. No solver-specific options
    are currently supported; this parameter is reserved for future use.

Returns
-------
u : ndarray, shape=(M, k)
    Unitary matrix having left singular vectors as columns.
s : ndarray, shape=(k,)
    The singular values.
vh : ndarray, shape=(k, N)
    Unitary matrix having right singular vectors as rows.

Notes
-----
This is an interface to the Fortran library PROPACK [1]_.
The current default is to run with IRL mode disabled unless seeking the
smallest singular values/vectors (``which='SM'``).

References
----------

.. [1] Larsen, Rasmus Munk. "PROPACK-Software for large and sparse SVD
   calculations." Available online. URL
   http://sun.stanford.edu/~rmunk/PROPACK (2004): 2008-2009.

Examples
--------
Construct a matrix ``A`` from singular values and vectors.

&gt;&gt;&gt; from scipy.stats import ortho_group
&gt;&gt;&gt; from scipy.sparse import csc_matrix, diags
&gt;&gt;&gt; from scipy.sparse.linalg import svds
&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; orthogonal = csc_matrix(ortho_group.rvs(10, random_state=rng))
&gt;&gt;&gt; s = [0.0001, 0.001, 3, 4, 5]  # singular values
&gt;&gt;&gt; u = orthogonal[:, :5]         # left singular vectors
&gt;&gt;&gt; vT = orthogonal[:, 5:].T      # right singular vectors
&gt;&gt;&gt; A = u @ diags(s) @ vT

With only three singular values/vectors, the SVD approximates the original
matrix.

&gt;&gt;&gt; u2, s2, vT2 = svds(A, k=3, solver='propack')
&gt;&gt;&gt; A2 = u2 @ np.diag(s2) @ vT2
&gt;&gt;&gt; np.allclose(A2, A.todense(), atol=1e-3)
True

With all five singular values/vectors, we can reproduce the original
matrix.

&gt;&gt;&gt; u3, s3, vT3 = svds(A, k=5, solver='propack')
&gt;&gt;&gt; A3 = u3 @ np.diag(s3) @ vT3
&gt;&gt;&gt; np.allclose(A3, A.todense())
True

The singular values match the expected singular values, and the singular
vectors are as expected up to a difference in sign.

&gt;&gt;&gt; (np.allclose(s3, s) and
...  np.allclose(np.abs(u3), np.abs(u.toarray())) and
...  np.allclose(np.abs(vT3), np.abs(vT.toarray())))
True

The singular vectors are also orthogonal.

&gt;&gt;&gt; (np.allclose(u3.T @ u3, np.eye(5)) and
...  np.allclose(vT3 @ vT3.T, np.eye(5)))
True
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d6/d1d/__svds__doc_8py_source.html#l00264">264</a> of file <a class="el" href="../../d6/d1d/__svds__doc_8py_source.html">_svds_doc.py</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../db/d0f/namespacescipy.html">scipy</a></li><li class="navelem"><a class="el" href="../../dd/d6f/namespacescipy_1_1sparse.html">sparse</a></li><li class="navelem"><a class="el" href="../../d9/d41/namespacescipy_1_1sparse_1_1linalg.html">linalg</a></li><li class="navelem"><a class="el" href="../../d1/d70/namespacescipy_1_1sparse_1_1linalg_1_1__eigen.html">_eigen</a></li><li class="navelem"><a class="el" href="../../d0/def/namespacescipy_1_1sparse_1_1linalg_1_1__eigen_1_1__svds__doc.html">_svds_doc</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
