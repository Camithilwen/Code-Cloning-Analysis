<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Code Cloning Analysis: pandas.core.sorting Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Code Cloning Analysis
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d0/daf/namespacepandas_1_1core_1_1sorting.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">pandas.core.sorting Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5d59af530c66d30bee514adae3065f97" id="r_a5d59af530c66d30bee514adae3065f97"><td class="memItemLeft" align="right" valign="top">npt.NDArray[np.intp]|None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d59af530c66d30bee514adae3065f97">get_indexer_indexer</a> (<a class="el" href="../../d9/d4b/classpandas_1_1core_1_1indexes_1_1base_1_1Index.html">Index</a> target, Level|list[Level]|None level, list[bool]|bool ascending, SortKind kind, NaPosition na_position, bool sort_remaining, IndexKeyFunc key)</td></tr>
<tr class="separator:a5d59af530c66d30bee514adae3065f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbcaea4c69033b757e68fb6f8ed6105c" id="r_adbcaea4c69033b757e68fb6f8ed6105c"><td class="memItemLeft" align="right" valign="top">npt.NDArray[np.int64]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adbcaea4c69033b757e68fb6f8ed6105c">get_group_index</a> (labels, Shape shape, bool sort, bool xnull)</td></tr>
<tr class="separator:adbcaea4c69033b757e68fb6f8ed6105c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958d45b3afb39502d01b014cccbb7401" id="r_a958d45b3afb39502d01b014cccbb7401"><td class="memItemLeft" align="right" valign="top">tuple[npt.NDArray[np.intp], npt.NDArray[np.int64]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a958d45b3afb39502d01b014cccbb7401">get_compressed_ids</a> (labels, Shape sizes)</td></tr>
<tr class="separator:a958d45b3afb39502d01b014cccbb7401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae8cf75c93f330b36b0d473c588b747" id="r_a6ae8cf75c93f330b36b0d473c588b747"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ae8cf75c93f330b36b0d473c588b747">is_int64_overflow_possible</a> (Shape shape)</td></tr>
<tr class="separator:a6ae8cf75c93f330b36b0d473c588b747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea88f88f2c88a1a2966dd2406e7f06ab" id="r_aea88f88f2c88a1a2966dd2406e7f06ab"><td class="memItemLeft" align="right" valign="top">list[npt.NDArray[np.intp]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea88f88f2c88a1a2966dd2406e7f06ab">_decons_group_index</a> (npt.NDArray[np.intp] comp_labels, Shape shape)</td></tr>
<tr class="separator:aea88f88f2c88a1a2966dd2406e7f06ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae47f9cd7d5058c4fcd4f6f5830bb1b84" id="r_ae47f9cd7d5058c4fcd4f6f5830bb1b84"><td class="memItemLeft" align="right" valign="top">list[npt.NDArray[np.intp]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae47f9cd7d5058c4fcd4f6f5830bb1b84">decons_obs_group_ids</a> (npt.NDArray[np.intp] comp_ids, npt.NDArray[np.intp] obs_ids, Shape shape, Sequence[npt.NDArray[np.signedinteger]] labels, bool xnull)</td></tr>
<tr class="separator:ae47f9cd7d5058c4fcd4f6f5830bb1b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a984c5ea1947ec578cdaff655702df5a3" id="r_a984c5ea1947ec578cdaff655702df5a3"><td class="memItemLeft" align="right" valign="top">npt.NDArray[np.intp]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a984c5ea1947ec578cdaff655702df5a3">lexsort_indexer</a> (Sequence[ArrayLike|<a class="el" href="../../d9/d4b/classpandas_1_1core_1_1indexes_1_1base_1_1Index.html">Index</a>|Series] keys, orders=None, str na_position=&quot;last&quot;, Callable|None key=None, bool codes_given=False)</td></tr>
<tr class="separator:a984c5ea1947ec578cdaff655702df5a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add1268682e9720be5e4682def9a832ed" id="r_add1268682e9720be5e4682def9a832ed"><td class="memItemLeft" align="right" valign="top">npt.NDArray[np.intp]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add1268682e9720be5e4682def9a832ed">nargsort</a> (ArrayLike|<a class="el" href="../../d9/d4b/classpandas_1_1core_1_1indexes_1_1base_1_1Index.html">Index</a>|Series items, SortKind kind=&quot;quicksort&quot;, bool ascending=<a class="el" href="../../d8/d0b/classTrue.html">True</a>, str na_position=&quot;last&quot;, Callable|None key=None, npt.NDArray[np.bool_]|None mask=None)</td></tr>
<tr class="separator:add1268682e9720be5e4682def9a832ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc3cdcbfcd60d2253e7e843f254a8d6b" id="r_acc3cdcbfcd60d2253e7e843f254a8d6b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc3cdcbfcd60d2253e7e843f254a8d6b">nargminmax</a> (<a class="el" href="../../d4/dd3/classpandas_1_1core_1_1arrays_1_1base_1_1ExtensionArray.html">ExtensionArray</a> values, str method, AxisInt axis=0)</td></tr>
<tr class="separator:acc3cdcbfcd60d2253e7e843f254a8d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e3a92a42103c4b3e5ff927d4c908b6" id="r_a98e3a92a42103c4b3e5ff927d4c908b6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98e3a92a42103c4b3e5ff927d4c908b6">_nanargminmax</a> (np.ndarray values, npt.NDArray[np.bool_] mask, func)</td></tr>
<tr class="separator:a98e3a92a42103c4b3e5ff927d4c908b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40672fba282049a52ada719678ec5baf" id="r_a40672fba282049a52ada719678ec5baf"><td class="memItemLeft" align="right" valign="top">MultiIndex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40672fba282049a52ada719678ec5baf">_ensure_key_mapped_multiindex</a> (MultiIndex index, Callable key, level=None)</td></tr>
<tr class="separator:a40672fba282049a52ada719678ec5baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a987539d31d22237fc43c6ee443d2120f" id="r_a987539d31d22237fc43c6ee443d2120f"><td class="memItemLeft" align="right" valign="top">ArrayLike|<a class="el" href="../../d9/d4b/classpandas_1_1core_1_1indexes_1_1base_1_1Index.html">Index</a>|Series&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a987539d31d22237fc43c6ee443d2120f">ensure_key_mapped</a> (ArrayLike|<a class="el" href="../../d9/d4b/classpandas_1_1core_1_1indexes_1_1base_1_1Index.html">Index</a>|Series values, Callable|None key, levels=None)</td></tr>
<tr class="separator:a987539d31d22237fc43c6ee443d2120f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb4b09b6dcedc57a6e7d13733b54e395" id="r_aeb4b09b6dcedc57a6e7d13733b54e395"><td class="memItemLeft" align="right" valign="top">list[tuple]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb4b09b6dcedc57a6e7d13733b54e395">get_flattened_list</a> (npt.NDArray[np.intp] comp_ids, int ngroups, Iterable[<a class="el" href="../../d9/d4b/classpandas_1_1core_1_1indexes_1_1base_1_1Index.html">Index</a>] levels, Iterable[np.ndarray] labels)</td></tr>
<tr class="separator:aeb4b09b6dcedc57a6e7d13733b54e395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f9b61304768d12c21ff05d08e6f739" id="r_ac2f9b61304768d12c21ff05d08e6f739"><td class="memItemLeft" align="right" valign="top">dict[Hashable, npt.NDArray[np.intp]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2f9b61304768d12c21ff05d08e6f739">get_indexer_dict</a> (list[np.ndarray] label_list, list[<a class="el" href="../../d9/d4b/classpandas_1_1core_1_1indexes_1_1base_1_1Index.html">Index</a>] keys)</td></tr>
<tr class="separator:ac2f9b61304768d12c21ff05d08e6f739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a508c4e5b564f2354194bf7a44b6df8e7" id="r_a508c4e5b564f2354194bf7a44b6df8e7"><td class="memItemLeft" align="right" valign="top">npt.NDArray[np.intp]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a508c4e5b564f2354194bf7a44b6df8e7">get_group_index_sorter</a> (npt.NDArray[np.intp] group_index, int|None ngroups=None)</td></tr>
<tr class="separator:a508c4e5b564f2354194bf7a44b6df8e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4671f23853e5550b2dce6fcaaa13e00b" id="r_a4671f23853e5550b2dce6fcaaa13e00b"><td class="memItemLeft" align="right" valign="top">tuple[npt.NDArray[np.int64], npt.NDArray[np.int64]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4671f23853e5550b2dce6fcaaa13e00b">compress_group_index</a> (npt.NDArray[np.int64] group_index, bool sort=<a class="el" href="../../d8/d0b/classTrue.html">True</a>)</td></tr>
<tr class="separator:a4671f23853e5550b2dce6fcaaa13e00b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fed5723f0a2dffd444d6b22afe32692" id="r_a6fed5723f0a2dffd444d6b22afe32692"><td class="memItemLeft" align="right" valign="top">tuple[npt.NDArray[np.int64], npt.NDArray[np.intp]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6fed5723f0a2dffd444d6b22afe32692">_reorder_by_uniques</a> (npt.NDArray[np.int64] uniques, npt.NDArray[np.intp] labels)</td></tr>
<tr class="separator:a6fed5723f0a2dffd444d6b22afe32692"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment"> miscellaneous sorting / groupby utilities </pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="aea88f88f2c88a1a2966dd2406e7f06ab" name="aea88f88f2c88a1a2966dd2406e7f06ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea88f88f2c88a1a2966dd2406e7f06ab">&#9670;&#160;</a></span>_decons_group_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> list[npt.NDArray[np.intp]] pandas.core.sorting._decons_group_index </td>
          <td>(</td>
          <td class="paramtype">npt.NDArray[np.intp]</td>          <td class="paramname"><span class="paramname"><em>comp_labels</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Shape
</td>          <td class="paramname"><span class="paramname"><em>shape</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d5/d9a/sorting_8py_source.html#l00246">246</a> of file <a class="el" href="../../d5/d9a/sorting_8py_source.html">sorting.py</a>.</p>

</div>
</div>
<a id="a40672fba282049a52ada719678ec5baf" name="a40672fba282049a52ada719678ec5baf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40672fba282049a52ada719678ec5baf">&#9670;&#160;</a></span>_ensure_key_mapped_multiindex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> MultiIndex pandas.core.sorting._ensure_key_mapped_multiindex </td>
          <td>(</td>
          <td class="paramtype">MultiIndex</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>level</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Returns a new MultiIndex in which key has been applied
to all levels specified in level (or all levels if level
is None). Used for key sorting for MultiIndex.

Parameters
----------
index : MultiIndex
    Index to which to apply the key function on the
    specified levels.
key : Callable
    Function that takes an Index and returns an Index of
    the same shape. This key is applied to each level
    separately. The name of the level can be used to
    distinguish different levels for application.
level : list-like, int or str, default None
    Level or list of levels to apply the key function to.
    If None, key function is applied to all levels. Other
    levels are left unchanged.

Returns
-------
labels : MultiIndex
    Resulting MultiIndex with modified levels.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d5/d9a/sorting_8py_source.html#l00497">497</a> of file <a class="el" href="../../d5/d9a/sorting_8py_source.html">sorting.py</a>.</p>

<p class="reference">References <a class="el" href="../../d5/d9a/sorting_8py_source.html#l00548">ensure_key_mapped()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d5/d9a/sorting_8py_source.html#l00548">ensure_key_mapped()</a>.</p>

</div>
</div>
<a id="a98e3a92a42103c4b3e5ff927d4c908b6" name="a98e3a92a42103c4b3e5ff927d4c908b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98e3a92a42103c4b3e5ff927d4c908b6">&#9670;&#160;</a></span>_nanargminmax()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> int pandas.core.sorting._nanargminmax </td>
          <td>(</td>
          <td class="paramtype">np.ndarray</td>          <td class="paramname"><span class="paramname"><em>values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">npt.NDArray[np.bool_]</td>          <td class="paramname"><span class="paramname"><em>mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">See nanargminmax.__doc__.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d5/d9a/sorting_8py_source.html#l00486">486</a> of file <a class="el" href="../../d5/d9a/sorting_8py_source.html">sorting.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d5/d9a/sorting_8py_source.html#l00453">nargminmax()</a>.</p>

</div>
</div>
<a id="a6fed5723f0a2dffd444d6b22afe32692" name="a6fed5723f0a2dffd444d6b22afe32692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fed5723f0a2dffd444d6b22afe32692">&#9670;&#160;</a></span>_reorder_by_uniques()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[npt.NDArray[np.int64], npt.NDArray[np.intp]] pandas.core.sorting._reorder_by_uniques </td>
          <td>(</td>
          <td class="paramtype">npt.NDArray[np.int64]</td>          <td class="paramname"><span class="paramname"><em>uniques</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">npt.NDArray[np.intp]
</td>          <td class="paramname"><span class="paramname"><em>labels</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Parameters
----------
uniques : np.ndarray[np.int64]
labels : np.ndarray[np.intp]

Returns
-------
np.ndarray[np.int64]
np.ndarray[np.intp]
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d5/d9a/sorting_8py_source.html#l00718">718</a> of file <a class="el" href="../../d5/d9a/sorting_8py_source.html">sorting.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d5/d9a/sorting_8py_source.html#l00689">compress_group_index()</a>.</p>

</div>
</div>
<a id="a4671f23853e5550b2dce6fcaaa13e00b" name="a4671f23853e5550b2dce6fcaaa13e00b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4671f23853e5550b2dce6fcaaa13e00b">&#9670;&#160;</a></span>compress_group_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[npt.NDArray[np.int64], npt.NDArray[np.int64]] pandas.core.sorting.compress_group_index </td>
          <td>(</td>
          <td class="paramtype">npt.NDArray[np.int64]</td>          <td class="paramname"><span class="paramname"><em>group_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>          <td class="paramname"><span class="paramname"><em>sort</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d8/d0b/classTrue.html">True</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Group_index is offsets into cartesian product of all possible labels. This
space can be huge, so this function compresses it, by computing offsets
(comp_ids) into the list of unique labels (obs_group_ids).
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d5/d9a/sorting_8py_source.html#l00687">687</a> of file <a class="el" href="../../d5/d9a/sorting_8py_source.html">sorting.py</a>.</p>

<p class="reference">References <a class="el" href="../../d5/d9a/sorting_8py_source.html#l00720">_reorder_by_uniques()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d5/d9a/sorting_8py_source.html#l00216">get_compressed_ids()</a>, and <a class="el" href="../../d5/d9a/sorting_8py_source.html#l00124">get_group_index()</a>.</p>

</div>
</div>
<a id="ae47f9cd7d5058c4fcd4f6f5830bb1b84" name="ae47f9cd7d5058c4fcd4f6f5830bb1b84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae47f9cd7d5058c4fcd4f6f5830bb1b84">&#9670;&#160;</a></span>decons_obs_group_ids()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> list[npt.NDArray[np.intp]] pandas.core.sorting.decons_obs_group_ids </td>
          <td>(</td>
          <td class="paramtype">npt.NDArray[np.intp]</td>          <td class="paramname"><span class="paramname"><em>comp_ids</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">npt.NDArray[np.intp]</td>          <td class="paramname"><span class="paramname"><em>obs_ids</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Shape</td>          <td class="paramname"><span class="paramname"><em>shape</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sequence[npt.NDArray[np.signedinteger]]</td>          <td class="paramname"><span class="paramname"><em>labels</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>xnull</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Reconstruct labels from observed group ids.

Parameters
----------
comp_ids : np.ndarray[np.intp]
obs_ids: np.ndarray[np.intp]
shape : tuple[int]
labels : Sequence[np.ndarray[np.signedinteger]]
xnull : bool
    If nulls are excluded; i.e. -1 labels are passed through.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d5/d9a/sorting_8py_source.html#l00268">268</a> of file <a class="el" href="../../d5/d9a/sorting_8py_source.html">sorting.py</a>.</p>

</div>
</div>
<a id="a987539d31d22237fc43c6ee443d2120f" name="a987539d31d22237fc43c6ee443d2120f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a987539d31d22237fc43c6ee443d2120f">&#9670;&#160;</a></span>ensure_key_mapped()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> ArrayLike | <a class="el" href="../../d9/d4b/classpandas_1_1core_1_1indexes_1_1base_1_1Index.html">Index</a> | Series pandas.core.sorting.ensure_key_mapped </td>
          <td>(</td>
          <td class="paramtype">ArrayLike | <a class="el" href="../../d9/d4b/classpandas_1_1core_1_1indexes_1_1base_1_1Index.html">Index</a> | Series</td>          <td class="paramname"><span class="paramname"><em>values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable | None</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>levels</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Applies a callable key function to the values function and checks
that the resulting value has the same shape. Can be called on Index
subclasses, Series, DataFrames, or ndarrays.

Parameters
----------
values : Series, DataFrame, Index subclass, or ndarray
key : Optional[Callable], key to be called on the values array
levels : Optional[List], if values is a MultiIndex, list of levels to
apply the key to.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d5/d9a/sorting_8py_source.html#l00546">546</a> of file <a class="el" href="../../d5/d9a/sorting_8py_source.html">sorting.py</a>.</p>

<p class="reference">References <a class="el" href="../../d5/d9a/sorting_8py_source.html#l00499">_ensure_key_mapped_multiindex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d5/d9a/sorting_8py_source.html#l00499">_ensure_key_mapped_multiindex()</a>, <a class="el" href="../../d5/d9a/sorting_8py_source.html#l00067">get_indexer_indexer()</a>, <a class="el" href="../../d5/d9a/sorting_8py_source.html#l00307">lexsort_indexer()</a>, and <a class="el" href="../../d5/d9a/sorting_8py_source.html#l00376">nargsort()</a>.</p>

</div>
</div>
<a id="a958d45b3afb39502d01b014cccbb7401" name="a958d45b3afb39502d01b014cccbb7401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a958d45b3afb39502d01b014cccbb7401">&#9670;&#160;</a></span>get_compressed_ids()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[npt.NDArray[np.intp], npt.NDArray[np.int64]] pandas.core.sorting.get_compressed_ids </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>labels</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Shape
</td>          <td class="paramname"><span class="paramname"><em>sizes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Group_index is offsets into cartesian product of all possible labels. This
space can be huge, so this function compresses it, by computing offsets
(comp_ids) into the list of unique labels (obs_group_ids).

Parameters
----------
labels : list of label arrays
sizes : tuple[int] of size of the levels

Returns
-------
np.ndarray[np.intp]
    comp_ids
np.ndarray[np.int64]
    obs_group_ids
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d5/d9a/sorting_8py_source.html#l00214">214</a> of file <a class="el" href="../../d5/d9a/sorting_8py_source.html">sorting.py</a>.</p>

<p class="reference">References <a class="el" href="../../d5/d9a/sorting_8py_source.html#l00689">compress_group_index()</a>, and <a class="el" href="../../d5/d9a/sorting_8py_source.html#l00124">get_group_index()</a>.</p>

</div>
</div>
<a id="aeb4b09b6dcedc57a6e7d13733b54e395" name="aeb4b09b6dcedc57a6e7d13733b54e395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb4b09b6dcedc57a6e7d13733b54e395">&#9670;&#160;</a></span>get_flattened_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> list[tuple] pandas.core.sorting.get_flattened_list </td>
          <td>(</td>
          <td class="paramtype">npt.NDArray[np.intp]</td>          <td class="paramname"><span class="paramname"><em>comp_ids</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ngroups</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable[<a class="el" href="../../d9/d4b/classpandas_1_1core_1_1indexes_1_1base_1_1Index.html">Index</a>]</td>          <td class="paramname"><span class="paramname"><em>levels</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable[np.ndarray]</td>          <td class="paramname"><span class="paramname"><em>labels</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Map compressed group id -&gt; key tuple.</pre> 
<p class="definition">Definition at line <a class="el" href="../../d5/d9a/sorting_8py_source.html#l00594">594</a> of file <a class="el" href="../../d5/d9a/sorting_8py_source.html">sorting.py</a>.</p>

</div>
</div>
<a id="adbcaea4c69033b757e68fb6f8ed6105c" name="adbcaea4c69033b757e68fb6f8ed6105c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbcaea4c69033b757e68fb6f8ed6105c">&#9670;&#160;</a></span>get_group_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> npt.NDArray[np.int64] pandas.core.sorting.get_group_index </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>labels</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Shape</td>          <td class="paramname"><span class="paramname"><em>shape</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>sort</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool
</td>          <td class="paramname"><span class="paramname"><em>xnull</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">For the particular label_list, gets the offsets into the hypothetical list
representing the totally ordered cartesian product of all possible label
combinations, *as long as* this space fits within int64 bounds;
otherwise, though group indices identify unique combinations of
labels, they cannot be deconstructed.
- If `sort`, rank of returned ids preserve lexical ranks of labels.
  i.e. returned id's can be used to do lexical sort on labels;
- If `xnull` nulls (-1 labels) are passed through.

Parameters
----------
labels : sequence of arrays
    Integers identifying levels at each location
shape : tuple[int, ...]
    Number of unique levels at each location
sort : bool
    If the ranks of returned ids should match lexical ranks of labels
xnull : bool
    If true nulls are excluded. i.e. -1 values in the labels are
    passed through.

Returns
-------
An array of type int64 where two elements are equal if their corresponding
labels are equal at all location.

Notes
-----
The length of `labels` and `shape` must be identical.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d5/d9a/sorting_8py_source.html#l00122">122</a> of file <a class="el" href="../../d5/d9a/sorting_8py_source.html">sorting.py</a>.</p>

<p class="reference">References <a class="el" href="../../d5/d9a/sorting_8py_source.html#l00689">compress_group_index()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d5/d9a/sorting_8py_source.html#l00216">get_compressed_ids()</a>, and <a class="el" href="../../d5/d9a/sorting_8py_source.html#l00613">get_indexer_dict()</a>.</p>

</div>
</div>
<a id="a508c4e5b564f2354194bf7a44b6df8e7" name="a508c4e5b564f2354194bf7a44b6df8e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a508c4e5b564f2354194bf7a44b6df8e7">&#9670;&#160;</a></span>get_group_index_sorter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> npt.NDArray[np.intp] pandas.core.sorting.get_group_index_sorter </td>
          <td>(</td>
          <td class="paramtype">npt.NDArray[np.intp]</td>          <td class="paramname"><span class="paramname"><em>group_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None </td>          <td class="paramname"><span class="paramname"><em>ngroups</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">algos.groupsort_indexer implements `counting sort` and it is at least
O(ngroups), where
    ngroups = prod(shape)
    shape = map(len, keys)
that is, linear in the number of combinations (cartesian product) of unique
values of groupby keys. This can be huge when doing multi-key groupby.
np.argsort(kind='mergesort') is O(count x log(count)) where count is the
length of the data-frame;
Both algorithms are `stable` sort and that is necessary for correctness of
groupby operations. e.g. consider:
    df.groupby(key)[col].transform('first')

Parameters
----------
group_index : np.ndarray[np.intp]
    signed integer dtype
ngroups : int or None, default None

Returns
-------
np.ndarray[np.intp]
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d5/d9a/sorting_8py_source.html#l00644">644</a> of file <a class="el" href="../../d5/d9a/sorting_8py_source.html">sorting.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d5/d9a/sorting_8py_source.html#l00613">get_indexer_dict()</a>.</p>

</div>
</div>
<a id="ac2f9b61304768d12c21ff05d08e6f739" name="ac2f9b61304768d12c21ff05d08e6f739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2f9b61304768d12c21ff05d08e6f739">&#9670;&#160;</a></span>get_indexer_dict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> dict[Hashable, npt.NDArray[np.intp]] pandas.core.sorting.get_indexer_dict </td>
          <td>(</td>
          <td class="paramtype">list[np.ndarray]</td>          <td class="paramname"><span class="paramname"><em>label_list</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list[<a class="el" href="../../d9/d4b/classpandas_1_1core_1_1indexes_1_1base_1_1Index.html">Index</a>]
</td>          <td class="paramname"><span class="paramname"><em>keys</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns
-------
dict:
    Labels mapped to indexers.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d5/d9a/sorting_8py_source.html#l00611">611</a> of file <a class="el" href="../../d5/d9a/sorting_8py_source.html">sorting.py</a>.</p>

<p class="reference">References <a class="el" href="../../d5/d9a/sorting_8py_source.html#l00124">get_group_index()</a>, and <a class="el" href="../../d5/d9a/sorting_8py_source.html#l00646">get_group_index_sorter()</a>.</p>

</div>
</div>
<a id="a5d59af530c66d30bee514adae3065f97" name="a5d59af530c66d30bee514adae3065f97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d59af530c66d30bee514adae3065f97">&#9670;&#160;</a></span>get_indexer_indexer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> npt.NDArray[np.intp] | None pandas.core.sorting.get_indexer_indexer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d4b/classpandas_1_1core_1_1indexes_1_1base_1_1Index.html">Index</a></td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Level | list[Level] | None</td>          <td class="paramname"><span class="paramname"><em>level</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list[bool] | bool</td>          <td class="paramname"><span class="paramname"><em>ascending</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SortKind</td>          <td class="paramname"><span class="paramname"><em>kind</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NaPosition</td>          <td class="paramname"><span class="paramname"><em>na_position</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>sort_remaining</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexKeyFunc</td>          <td class="paramname"><span class="paramname"><em>key</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Helper method that return the indexer according to input parameters for
the sort_index method of DataFrame and Series.

Parameters
----------
target : Index
level : int or level name or list of ints or list of level names
ascending : bool or list of bools, default True
kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}
na_position : {'first', 'last'}
sort_remaining : bool
key : callable, optional

Returns
-------
Optional[ndarray[intp]]
    The indexer for the new index.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d5/d9a/sorting_8py_source.html#l00059">59</a> of file <a class="el" href="../../d5/d9a/sorting_8py_source.html">sorting.py</a>.</p>

<p class="reference">References <a class="el" href="../../d5/d9a/sorting_8py_source.html#l00548">ensure_key_mapped()</a>, <a class="el" href="../../d5/d9a/sorting_8py_source.html#l00307">lexsort_indexer()</a>, and <a class="el" href="../../d5/d9a/sorting_8py_source.html#l00376">nargsort()</a>.</p>

</div>
</div>
<a id="a6ae8cf75c93f330b36b0d473c588b747" name="a6ae8cf75c93f330b36b0d473c588b747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ae8cf75c93f330b36b0d473c588b747">&#9670;&#160;</a></span>is_int64_overflow_possible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.core.sorting.is_int64_overflow_possible </td>
          <td>(</td>
          <td class="paramtype">Shape</td>          <td class="paramname"><span class="paramname"><em>shape</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d5/d9a/sorting_8py_source.html#l00238">238</a> of file <a class="el" href="../../d5/d9a/sorting_8py_source.html">sorting.py</a>.</p>

</div>
</div>
<a id="a984c5ea1947ec578cdaff655702df5a3" name="a984c5ea1947ec578cdaff655702df5a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a984c5ea1947ec578cdaff655702df5a3">&#9670;&#160;</a></span>lexsort_indexer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> npt.NDArray[np.intp] pandas.core.sorting.lexsort_indexer </td>
          <td>(</td>
          <td class="paramtype">Sequence[ArrayLike | <a class="el" href="../../d9/d4b/classpandas_1_1core_1_1indexes_1_1base_1_1Index.html">Index</a> | Series]</td>          <td class="paramname"><span class="paramname"><em>keys</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>orders</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str </td>          <td class="paramname"><span class="paramname"><em>na_position</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;last&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable | None </td>          <td class="paramname"><span class="paramname"><em>key</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>          <td class="paramname"><span class="paramname"><em>codes_given</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Performs lexical sorting on a set of keys

Parameters
----------
keys : Sequence[ArrayLike | Index | Series]
    Sequence of arrays to be sorted by the indexer
    Sequence[Series] is only if key is not None.
orders : bool or list of booleans, optional
    Determines the sorting order for each element in keys. If a list,
    it must be the same length as keys. This determines whether the
    corresponding element in keys should be sorted in ascending
    (True) or descending (False) order. if bool, applied to all
    elements as above. if None, defaults to True.
na_position : {'first', 'last'}, default 'last'
    Determines placement of NA elements in the sorted list ("last" or "first")
key : Callable, optional
    Callable key function applied to every element in keys before sorting
codes_given: bool, False
    Avoid categorical materialization if codes are already provided.

Returns
-------
np.ndarray[np.intp]
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d5/d9a/sorting_8py_source.html#l00301">301</a> of file <a class="el" href="../../d5/d9a/sorting_8py_source.html">sorting.py</a>.</p>

<p class="reference">References <a class="el" href="../../d5/d9a/sorting_8py_source.html#l00548">ensure_key_mapped()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d5/d9a/sorting_8py_source.html#l00067">get_indexer_indexer()</a>.</p>

</div>
</div>
<a id="acc3cdcbfcd60d2253e7e843f254a8d6b" name="acc3cdcbfcd60d2253e7e843f254a8d6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc3cdcbfcd60d2253e7e843f254a8d6b">&#9670;&#160;</a></span>nargminmax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.sorting.nargminmax </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/dd3/classpandas_1_1core_1_1arrays_1_1base_1_1ExtensionArray.html">ExtensionArray</a></td>          <td class="paramname"><span class="paramname"><em>values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>method</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AxisInt </td>          <td class="paramname"><span class="paramname"><em>axis</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Implementation of np.argmin/argmax but for ExtensionArray and which
handles missing values.

Parameters
----------
values : ExtensionArray
method : {"argmax", "argmin"}
axis : int, default 0

Returns
-------
int
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d5/d9a/sorting_8py_source.html#l00453">453</a> of file <a class="el" href="../../d5/d9a/sorting_8py_source.html">sorting.py</a>.</p>

<p class="reference">References <a class="el" href="../../d5/d9a/sorting_8py_source.html#l00486">_nanargminmax()</a>.</p>

</div>
</div>
<a id="add1268682e9720be5e4682def9a832ed" name="add1268682e9720be5e4682def9a832ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add1268682e9720be5e4682def9a832ed">&#9670;&#160;</a></span>nargsort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> npt.NDArray[np.intp] pandas.core.sorting.nargsort </td>
          <td>(</td>
          <td class="paramtype">ArrayLike | <a class="el" href="../../d9/d4b/classpandas_1_1core_1_1indexes_1_1base_1_1Index.html">Index</a> | Series</td>          <td class="paramname"><span class="paramname"><em>items</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SortKind </td>          <td class="paramname"><span class="paramname"><em>kind</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;quicksort&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>          <td class="paramname"><span class="paramname"><em>ascending</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d8/d0b/classTrue.html">True</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str </td>          <td class="paramname"><span class="paramname"><em>na_position</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;last&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable | None </td>          <td class="paramname"><span class="paramname"><em>key</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">npt.NDArray[np.bool_] | None </td>          <td class="paramname"><span class="paramname"><em>mask</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Intended to be a drop-in replacement for np.argsort which handles NaNs.

Adds ascending, na_position, and key parameters.

(GH #6399, #5231, #27237)

Parameters
----------
items : np.ndarray, ExtensionArray, Index, or Series
kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, default 'quicksort'
ascending : bool, default True
na_position : {'first', 'last'}, default 'last'
key : Optional[Callable], default None
mask : Optional[np.ndarray[bool]], default None
    Passed when called by ExtensionArray.argsort.

Returns
-------
np.ndarray[np.intp]
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d5/d9a/sorting_8py_source.html#l00369">369</a> of file <a class="el" href="../../d5/d9a/sorting_8py_source.html">sorting.py</a>.</p>

<p class="reference">References <a class="el" href="../../d5/d9a/sorting_8py_source.html#l00548">ensure_key_mapped()</a>, and <a class="el" href="../../d5/d9a/sorting_8py_source.html#l00376">nargsort()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d5/d9a/sorting_8py_source.html#l00067">get_indexer_indexer()</a>, and <a class="el" href="../../d5/d9a/sorting_8py_source.html#l00376">nargsort()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d1/d53/namespacepandas.html">pandas</a></li><li class="navelem"><a class="el" href="../../d7/dfb/namespacepandas_1_1core.html">core</a></li><li class="navelem"><a class="el" href="../../d0/daf/namespacepandas_1_1core_1_1sorting.html">sorting</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
