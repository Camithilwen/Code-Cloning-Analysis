<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Code Cloning Analysis: sklearn.metrics.cluster._supervised Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Code Cloning Analysis
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d5/d66/namespacesklearn_1_1metrics_1_1cluster_1_1__supervised.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">sklearn.metrics.cluster._supervised Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad9ede3a9f83c02952cadece7910465b6" id="r_ad9ede3a9f83c02952cadece7910465b6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9ede3a9f83c02952cadece7910465b6">check_clusterings</a> (labels_true, labels_pred)</td></tr>
<tr class="separator:ad9ede3a9f83c02952cadece7910465b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67b19ae497dbdcd1efa9e35f55dbbfc7" id="r_a67b19ae497dbdcd1efa9e35f55dbbfc7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67b19ae497dbdcd1efa9e35f55dbbfc7">_generalized_average</a> (U, <a class="el" href="../../d7/d59/classV.html">V</a>, average_method)</td></tr>
<tr class="separator:a67b19ae497dbdcd1efa9e35f55dbbfc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a513ab980b3884723e418e4cbd45d7dc1" id="r_a513ab980b3884723e418e4cbd45d7dc1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a513ab980b3884723e418e4cbd45d7dc1">contingency_matrix</a> (labels_true, labels_pred, *, eps=None, sparse=False, dtype=np.int64)</td></tr>
<tr class="separator:a513ab980b3884723e418e4cbd45d7dc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e10db8525d943e132641d887df35d1" id="r_a91e10db8525d943e132641d887df35d1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91e10db8525d943e132641d887df35d1">pair_confusion_matrix</a> (labels_true, labels_pred)</td></tr>
<tr class="separator:a91e10db8525d943e132641d887df35d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a730947c8e7e9b0e67c8b8e2370accf67" id="r_a730947c8e7e9b0e67c8b8e2370accf67"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a730947c8e7e9b0e67c8b8e2370accf67">rand_score</a> (labels_true, labels_pred)</td></tr>
<tr class="separator:a730947c8e7e9b0e67c8b8e2370accf67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34402b0738a8cbc3a89c2a13fe75daba" id="r_a34402b0738a8cbc3a89c2a13fe75daba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34402b0738a8cbc3a89c2a13fe75daba">adjusted_rand_score</a> (labels_true, labels_pred)</td></tr>
<tr class="separator:a34402b0738a8cbc3a89c2a13fe75daba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa45224bfac0b7cba5c38959188f56ec9" id="r_aa45224bfac0b7cba5c38959188f56ec9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa45224bfac0b7cba5c38959188f56ec9">homogeneity_completeness_v_measure</a> (labels_true, labels_pred, *, beta=1.0)</td></tr>
<tr class="separator:aa45224bfac0b7cba5c38959188f56ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f3b0a25f6e1f4f1088a64ae1600bef" id="r_a90f3b0a25f6e1f4f1088a64ae1600bef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90f3b0a25f6e1f4f1088a64ae1600bef">homogeneity_score</a> (labels_true, labels_pred)</td></tr>
<tr class="separator:a90f3b0a25f6e1f4f1088a64ae1600bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3545c1577bdb7d983eaabd92ec7a1a00" id="r_a3545c1577bdb7d983eaabd92ec7a1a00"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3545c1577bdb7d983eaabd92ec7a1a00">completeness_score</a> (labels_true, labels_pred)</td></tr>
<tr class="separator:a3545c1577bdb7d983eaabd92ec7a1a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9383c7869c1a7bc200249412830f358" id="r_ad9383c7869c1a7bc200249412830f358"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9383c7869c1a7bc200249412830f358">v_measure_score</a> (labels_true, labels_pred, *, beta=1.0)</td></tr>
<tr class="separator:ad9383c7869c1a7bc200249412830f358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48c789f3bc2570f591c6886f1adcc7e2" id="r_a48c789f3bc2570f591c6886f1adcc7e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48c789f3bc2570f591c6886f1adcc7e2">mutual_info_score</a> (labels_true, labels_pred, *, contingency=None)</td></tr>
<tr class="separator:a48c789f3bc2570f591c6886f1adcc7e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af62bd3283daf3948bb80346547f32a6d" id="r_af62bd3283daf3948bb80346547f32a6d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af62bd3283daf3948bb80346547f32a6d">adjusted_mutual_info_score</a> (labels_true, labels_pred, *, average_method=&quot;arithmetic&quot;)</td></tr>
<tr class="separator:af62bd3283daf3948bb80346547f32a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e4766b5411a29bc6a4202df9dad15c8" id="r_a8e4766b5411a29bc6a4202df9dad15c8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e4766b5411a29bc6a4202df9dad15c8">normalized_mutual_info_score</a> (labels_true, labels_pred, *, average_method=&quot;arithmetic&quot;)</td></tr>
<tr class="separator:a8e4766b5411a29bc6a4202df9dad15c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af19a9aaa9be6eb933fbe78c9d8772647" id="r_af19a9aaa9be6eb933fbe78c9d8772647"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af19a9aaa9be6eb933fbe78c9d8772647">fowlkes_mallows_score</a> (labels_true, labels_pred, *, sparse=&quot;deprecated&quot;)</td></tr>
<tr class="separator:af19a9aaa9be6eb933fbe78c9d8772647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69009aa559a2656c733bd33fe144b21" id="r_af69009aa559a2656c733bd33fe144b21"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af69009aa559a2656c733bd33fe144b21">entropy</a> (labels)</td></tr>
<tr class="separator:af69009aa559a2656c733bd33fe144b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Utilities to evaluate the clustering performance of models.

Functions named as *_score return a scalar value to maximize: the higher the
better.
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a67b19ae497dbdcd1efa9e35f55dbbfc7" name="a67b19ae497dbdcd1efa9e35f55dbbfc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67b19ae497dbdcd1efa9e35f55dbbfc7">&#9670;&#160;</a></span>_generalized_average()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.cluster._supervised._generalized_average </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>U</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>V</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>average_method</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Return a particular mean of two numbers.</pre> 
<p class="definition">Definition at line <a class="el" href="../../db/dbe/__supervised_8py_source.html#l00070">70</a> of file <a class="el" href="../../db/dbe/__supervised_8py_source.html">_supervised.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../db/dbe/__supervised_8py_source.html#l00937">adjusted_mutual_info_score()</a>, and <a class="el" href="../../db/dbe/__supervised_8py_source.html#l01075">normalized_mutual_info_score()</a>.</p>

</div>
</div>
<a id="af62bd3283daf3948bb80346547f32a6d" name="af62bd3283daf3948bb80346547f32a6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af62bd3283daf3948bb80346547f32a6d">&#9670;&#160;</a></span>adjusted_mutual_info_score()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.cluster._supervised.adjusted_mutual_info_score </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>labels_true</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>labels_pred</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>average_method</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;arithmetic&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Adjusted Mutual Information between two clusterings.

Adjusted Mutual Information (AMI) is an adjustment of the Mutual
Information (MI) score to account for chance. It accounts for the fact that
the MI is generally higher for two clusterings with a larger number of
clusters, regardless of whether there is actually more information shared.
For two clusterings :math:`U` and :math:`V`, the AMI is given as::

    AMI(U, V) = [MI(U, V) - E(MI(U, V))] / [avg(H(U), H(V)) - E(MI(U, V))]

This metric is independent of the absolute values of the labels:
a permutation of the class or cluster label values won't change the
score value in any way.

This metric is furthermore symmetric: switching :math:`U` (``label_true``)
with :math:`V` (``labels_pred``) will return the same score value. This can
be useful to measure the agreement of two independent label assignments
strategies on the same dataset when the real ground truth is not known.

Be mindful that this function is an order of magnitude slower than other
metrics, such as the Adjusted Rand Index.

Read more in the :ref:`User Guide &lt;mutual_info_score&gt;`.

Parameters
----------
labels_true : int array-like of shape (n_samples,)
    A clustering of the data into disjoint subsets, called :math:`U` in
    the above formula.

labels_pred : int array-like of shape (n_samples,)
    A clustering of the data into disjoint subsets, called :math:`V` in
    the above formula.

average_method : {'min', 'geometric', 'arithmetic', 'max'}, default='arithmetic'
    How to compute the normalizer in the denominator.

    .. versionadded:: 0.20

    .. versionchanged:: 0.22
       The default value of ``average_method`` changed from 'max' to
       'arithmetic'.

Returns
-------
ami: float (upperlimited by 1.0)
   The AMI returns a value of 1 when the two partitions are identical
   (ie perfectly matched). Random partitions (independent labellings) have
   an expected AMI around 0 on average hence can be negative. The value is
   in adjusted nats (based on the natural logarithm).

See Also
--------
adjusted_rand_score : Adjusted Rand Index.
mutual_info_score : Mutual Information (not adjusted for chance).

References
----------
.. [1] `Vinh, Epps, and Bailey, (2010). Information Theoretic Measures for
   Clusterings Comparison: Variants, Properties, Normalization and
   Correction for Chance, JMLR
   &lt;http://jmlr.csail.mit.edu/papers/volume11/vinh10a/vinh10a.pdf&gt;`_

.. [2] `Wikipedia entry for the Adjusted Mutual Information
   &lt;https://en.wikipedia.org/wiki/Adjusted_Mutual_Information&gt;`_

Examples
--------

Perfect labelings are both homogeneous and complete, hence have
score 1.0::

  &gt;&gt;&gt; from sklearn.metrics.cluster import adjusted_mutual_info_score
  &gt;&gt;&gt; adjusted_mutual_info_score([0, 0, 1, 1], [0, 0, 1, 1])
  1.0
  &gt;&gt;&gt; adjusted_mutual_info_score([0, 0, 1, 1], [1, 1, 0, 0])
  1.0

If classes members are completely split across different clusters,
the assignment is totally in-complete, hence the AMI is null::

  &gt;&gt;&gt; adjusted_mutual_info_score([0, 0, 0, 0], [0, 1, 2, 3])
  0.0
</pre> 
<p class="definition">Definition at line <a class="el" href="../../db/dbe/__supervised_8py_source.html#l00935">935</a> of file <a class="el" href="../../db/dbe/__supervised_8py_source.html">_supervised.py</a>.</p>

<p class="reference">References <a class="el" href="../../db/dbe/__supervised_8py_source.html#l00070">_generalized_average()</a>, <a class="el" href="../../db/dbe/__supervised_8py_source.html#l00024">check_clusterings()</a>, <a class="el" href="../../db/dbe/__supervised_8py_source.html#l00098">contingency_matrix()</a>, <a class="el" href="../../db/dbe/__supervised_8py_source.html#l01281">entropy()</a>, and <a class="el" href="../../db/dbe/__supervised_8py_source.html#l00819">mutual_info_score()</a>.</p>

</div>
</div>
<a id="a34402b0738a8cbc3a89c2a13fe75daba" name="a34402b0738a8cbc3a89c2a13fe75daba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34402b0738a8cbc3a89c2a13fe75daba">&#9670;&#160;</a></span>adjusted_rand_score()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.cluster._supervised.adjusted_rand_score </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>labels_true</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>labels_pred</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Rand index adjusted for chance.

The Rand Index computes a similarity measure between two clusterings
by considering all pairs of samples and counting pairs that are
assigned in the same or different clusters in the predicted and
true clusterings.

The raw RI score is then "adjusted for chance" into the ARI score
using the following scheme::

    ARI = (RI - Expected_RI) / (max(RI) - Expected_RI)

The adjusted Rand index is thus ensured to have a value close to
0.0 for random labeling independently of the number of clusters and
samples and exactly 1.0 when the clusterings are identical (up to
a permutation). The adjusted Rand index is bounded below by -0.5 for
especially discordant clusterings.

ARI is a symmetric measure::

    adjusted_rand_score(a, b) == adjusted_rand_score(b, a)

Read more in the :ref:`User Guide &lt;adjusted_rand_score&gt;`.

Parameters
----------
labels_true : array-like of shape (n_samples,), dtype=int
    Ground truth class labels to be used as a reference.

labels_pred : array-like of shape (n_samples,), dtype=int
    Cluster labels to evaluate.

Returns
-------
ARI : float
   Similarity score between -0.5 and 1.0. Random labelings have an ARI
   close to 0.0. 1.0 stands for perfect match.

See Also
--------
adjusted_mutual_info_score : Adjusted Mutual Information.

References
----------
.. [Hubert1985] L. Hubert and P. Arabie, Comparing Partitions,
  Journal of Classification 1985
  https://link.springer.com/article/10.1007%2FBF01908075

.. [Steinley2004] D. Steinley, Properties of the Hubert-Arabie
  adjusted Rand index, Psychological Methods 2004

.. [wk] https://en.wikipedia.org/wiki/Rand_index#Adjusted_Rand_index

.. [Chacon] :doi:`Minimum adjusted Rand index for two clusterings of a given size,
  2022, J. E. Chac√≥n and A. I. Rastrojo &lt;10.1007/s11634-022-00491-w&gt;`

Examples
--------
Perfectly matching labelings have a score of 1 even

  &gt;&gt;&gt; from sklearn.metrics.cluster import adjusted_rand_score
  &gt;&gt;&gt; adjusted_rand_score([0, 0, 1, 1], [0, 0, 1, 1])
  1.0
  &gt;&gt;&gt; adjusted_rand_score([0, 0, 1, 1], [1, 1, 0, 0])
  1.0

Labelings that assign all classes members to the same clusters
are complete but may not always be pure, hence penalized::

  &gt;&gt;&gt; adjusted_rand_score([0, 0, 1, 2], [0, 0, 1, 1])
  0.57

ARI is symmetric, so labelings that have pure clusters with members
coming from the same classes but unnecessary splits are penalized::

  &gt;&gt;&gt; adjusted_rand_score([0, 0, 1, 1], [0, 0, 1, 2])
  0.57

If classes members are completely split across different clusters, the
assignment is totally incomplete, hence the ARI is very low::

  &gt;&gt;&gt; adjusted_rand_score([0, 0, 0, 0], [0, 1, 2, 3])
  0.0

ARI may take a negative value for especially discordant labelings that
are a worse choice than the expected value of random labels::

  &gt;&gt;&gt; adjusted_rand_score([0, 0, 1, 1], [0, 1, 0, 1])
  -0.5

See :ref:`sphx_glr_auto_examples_cluster_plot_adjusted_for_chance_measures.py`
for a more detailed example.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../db/dbe/__supervised_8py_source.html#l00349">349</a> of file <a class="el" href="../../db/dbe/__supervised_8py_source.html">_supervised.py</a>.</p>

<p class="reference">References <a class="el" href="../../db/dbe/__supervised_8py_source.html#l00184">pair_confusion_matrix()</a>.</p>

</div>
</div>
<a id="ad9ede3a9f83c02952cadece7910465b6" name="ad9ede3a9f83c02952cadece7910465b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9ede3a9f83c02952cadece7910465b6">&#9670;&#160;</a></span>check_clusterings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.cluster._supervised.check_clusterings </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>labels_true</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>labels_pred</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Check that the labels arrays are 1D and of same dimension.

Parameters
----------
labels_true : array-like of shape (n_samples,)
    The true labels.

labels_pred : array-like of shape (n_samples,)
    The predicted labels.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../db/dbe/__supervised_8py_source.html#l00024">24</a> of file <a class="el" href="../../db/dbe/__supervised_8py_source.html">_supervised.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../db/dbe/__supervised_8py_source.html#l00937">adjusted_mutual_info_score()</a>, <a class="el" href="../../db/dbe/__supervised_8py_source.html#l01185">fowlkes_mallows_score()</a>, <a class="el" href="../../db/dbe/__supervised_8py_source.html#l00462">homogeneity_completeness_v_measure()</a>, <a class="el" href="../../db/dbe/__supervised_8py_source.html#l00819">mutual_info_score()</a>, <a class="el" href="../../db/dbe/__supervised_8py_source.html#l01075">normalized_mutual_info_score()</a>, and <a class="el" href="../../db/dbe/__supervised_8py_source.html#l00184">pair_confusion_matrix()</a>.</p>

</div>
</div>
<a id="a3545c1577bdb7d983eaabd92ec7a1a00" name="a3545c1577bdb7d983eaabd92ec7a1a00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3545c1577bdb7d983eaabd92ec7a1a00">&#9670;&#160;</a></span>completeness_score()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.cluster._supervised.completeness_score </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>labels_true</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>labels_pred</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute completeness metric of a cluster labeling given a ground truth.

A clustering result satisfies completeness if all the data points
that are members of a given class are elements of the same cluster.

This metric is independent of the absolute values of the labels:
a permutation of the class or cluster label values won't change the
score value in any way.

This metric is not symmetric: switching ``label_true`` with ``label_pred``
will return the :func:`homogeneity_score` which will be different in
general.

Read more in the :ref:`User Guide &lt;homogeneity_completeness&gt;`.

Parameters
----------
labels_true : array-like of shape (n_samples,)
    Ground truth class labels to be used as a reference.

labels_pred : array-like of shape (n_samples,)
    Cluster labels to evaluate.

Returns
-------
completeness : float
   Score between 0.0 and 1.0. 1.0 stands for perfectly complete labeling.

See Also
--------
homogeneity_score : Homogeneity metric of cluster labeling.
v_measure_score : V-Measure (NMI with arithmetic mean option).

References
----------

.. [1] `Andrew Rosenberg and Julia Hirschberg, 2007. V-Measure: A
   conditional entropy-based external cluster evaluation measure
   &lt;https://aclweb.org/anthology/D/D07/D07-1043.pdf&gt;`_

Examples
--------

Perfect labelings are complete::

  &gt;&gt;&gt; from sklearn.metrics.cluster import completeness_score
  &gt;&gt;&gt; completeness_score([0, 0, 1, 1], [1, 1, 0, 0])
  1.0

Non-perfect labelings that assign all classes members to the same clusters
are still complete::

  &gt;&gt;&gt; print(completeness_score([0, 0, 1, 1], [0, 0, 0, 0]))
  1.0
  &gt;&gt;&gt; print(completeness_score([0, 1, 2, 3], [0, 0, 1, 1]))
  0.999

If classes members are split across different clusters, the
assignment cannot be complete::

  &gt;&gt;&gt; print(completeness_score([0, 0, 1, 1], [0, 1, 0, 1]))
  0.0
  &gt;&gt;&gt; print(completeness_score([0, 0, 0, 0], [0, 1, 2, 3]))
  0.0
</pre> 
<p class="definition">Definition at line <a class="el" href="../../db/dbe/__supervised_8py_source.html#l00638">638</a> of file <a class="el" href="../../db/dbe/__supervised_8py_source.html">_supervised.py</a>.</p>

<p class="reference">References <a class="el" href="../../db/dbe/__supervised_8py_source.html#l00462">homogeneity_completeness_v_measure()</a>.</p>

</div>
</div>
<a id="a513ab980b3884723e418e4cbd45d7dc1" name="a513ab980b3884723e418e4cbd45d7dc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a513ab980b3884723e418e4cbd45d7dc1">&#9670;&#160;</a></span>contingency_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.cluster._supervised.contingency_matrix </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>labels_true</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>labels_pred</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>eps</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>sparse</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>dtype</em></span><span class="paramdefsep"> = </span><span class="paramdefval">np.int64</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Build a contingency matrix describing the relationship between labels.

Read more in the :ref:`User Guide &lt;contingency_matrix&gt;`.

Parameters
----------
labels_true : array-like of shape (n_samples,)
    Ground truth class labels to be used as a reference.

labels_pred : array-like of shape (n_samples,)
    Cluster labels to evaluate.

eps : float, default=None
    If a float, that value is added to all values in the contingency
    matrix. This helps to stop NaN propagation.
    If ``None``, nothing is adjusted.

sparse : bool, default=False
    If `True`, return a sparse CSR contingency matrix. If `eps` is not
    `None` and `sparse` is `True` will raise ValueError.

    .. versionadded:: 0.18

dtype : numeric type, default=np.int64
    Output dtype. Ignored if `eps` is not `None`.

    .. versionadded:: 0.24

Returns
-------
contingency : {array-like, sparse}, shape=[n_classes_true, n_classes_pred]
    Matrix :math:`C` such that :math:`C_{i, j}` is the number of samples in
    true class :math:`i` and in predicted class :math:`j`. If
    ``eps is None``, the dtype of this array will be integer unless set
    otherwise with the ``dtype`` argument. If ``eps`` is given, the dtype
    will be float.
    Will be a ``sklearn.sparse.csr_matrix`` if ``sparse=True``.

Examples
--------
&gt;&gt;&gt; from sklearn.metrics.cluster import contingency_matrix
&gt;&gt;&gt; labels_true = [0, 0, 1, 1, 2, 2]
&gt;&gt;&gt; labels_pred = [1, 0, 2, 1, 0, 2]
&gt;&gt;&gt; contingency_matrix(labels_true, labels_pred)
array([[1, 1, 0],
       [0, 1, 1],
       [1, 0, 1]])
</pre> 
<p class="definition">Definition at line <a class="el" href="../../db/dbe/__supervised_8py_source.html#l00096">96</a> of file <a class="el" href="../../db/dbe/__supervised_8py_source.html">_supervised.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../db/dbe/__supervised_8py_source.html#l00937">adjusted_mutual_info_score()</a>, <a class="el" href="../../db/dbe/__supervised_8py_source.html#l01185">fowlkes_mallows_score()</a>, <a class="el" href="../../db/dbe/__supervised_8py_source.html#l00462">homogeneity_completeness_v_measure()</a>, <a class="el" href="../../db/dbe/__supervised_8py_source.html#l00819">mutual_info_score()</a>, <a class="el" href="../../db/dbe/__supervised_8py_source.html#l01075">normalized_mutual_info_score()</a>, and <a class="el" href="../../db/dbe/__supervised_8py_source.html#l00184">pair_confusion_matrix()</a>.</p>

</div>
</div>
<a id="af69009aa559a2656c733bd33fe144b21" name="af69009aa559a2656c733bd33fe144b21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af69009aa559a2656c733bd33fe144b21">&#9670;&#160;</a></span>entropy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.cluster._supervised.entropy </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>labels</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate the entropy for a labeling.

Parameters
----------
labels : array-like of shape (n_samples,), dtype=int
    The labels.

Returns
-------
entropy : float
   The entropy for a labeling.

Notes
-----
The logarithm used is the natural logarithm (base-e).
</pre> 
<p class="definition">Definition at line <a class="el" href="../../db/dbe/__supervised_8py_source.html#l01281">1281</a> of file <a class="el" href="../../db/dbe/__supervised_8py_source.html">_supervised.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../db/dbe/__supervised_8py_source.html#l00937">adjusted_mutual_info_score()</a>, <a class="el" href="../../db/dbe/__supervised_8py_source.html#l00462">homogeneity_completeness_v_measure()</a>, and <a class="el" href="../../db/dbe/__supervised_8py_source.html#l01075">normalized_mutual_info_score()</a>.</p>

</div>
</div>
<a id="af19a9aaa9be6eb933fbe78c9d8772647" name="af19a9aaa9be6eb933fbe78c9d8772647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af19a9aaa9be6eb933fbe78c9d8772647">&#9670;&#160;</a></span>fowlkes_mallows_score()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.cluster._supervised.fowlkes_mallows_score </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>labels_true</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>labels_pred</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>sparse</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;deprecated&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Measure the similarity of two clusterings of a set of points.

.. versionadded:: 0.18

The Fowlkes-Mallows index (FMI) is defined as the geometric mean of
the precision and recall::

    FMI = TP / sqrt((TP + FP) * (TP + FN))

Where ``TP`` is the number of **True Positive** (i.e. the number of pairs of
points that belong to the same cluster in both ``labels_true`` and
``labels_pred``), ``FP`` is the number of **False Positive** (i.e. the
number of pairs of points that belong to the same cluster in
``labels_pred`` but not in ``labels_true``) and ``FN`` is the number of
**False Negative** (i.e. the number of pairs of points that belong to the
same cluster in ``labels_true`` but not in ``labels_pred``).

The score ranges from 0 to 1. A high value indicates a good similarity
between two clusters.

Read more in the :ref:`User Guide &lt;fowlkes_mallows_scores&gt;`.

Parameters
----------
labels_true : array-like of shape (n_samples,), dtype=int
    A clustering of the data into disjoint subsets.

labels_pred : array-like of shape (n_samples,), dtype=int
    A clustering of the data into disjoint subsets.

sparse : bool, default=False
    Compute contingency matrix internally with sparse matrix.

    .. deprecated:: 1.7
        The ``sparse`` parameter is deprecated and will be removed in 1.9. It has
        no effect.

Returns
-------
score : float
   The resulting Fowlkes-Mallows score.

References
----------
.. [1] `E. B. Fowkles and C. L. Mallows, 1983. "A method for comparing two
   hierarchical clusterings". Journal of the American Statistical
   Association
   &lt;https://www.tandfonline.com/doi/abs/10.1080/01621459.1983.10478008&gt;`_

.. [2] `Wikipedia entry for the Fowlkes-Mallows Index
       &lt;https://en.wikipedia.org/wiki/Fowlkes-Mallows_index&gt;`_

Examples
--------

Perfect labelings are both homogeneous and complete, hence have
score 1.0::

  &gt;&gt;&gt; from sklearn.metrics.cluster import fowlkes_mallows_score
  &gt;&gt;&gt; fowlkes_mallows_score([0, 0, 1, 1], [0, 0, 1, 1])
  1.0
  &gt;&gt;&gt; fowlkes_mallows_score([0, 0, 1, 1], [1, 1, 0, 0])
  1.0

If classes members are completely split across different clusters,
the assignment is totally random, hence the FMI is null::

  &gt;&gt;&gt; fowlkes_mallows_score([0, 0, 0, 0], [0, 1, 2, 3])
  0.0
</pre> 
<p class="definition">Definition at line <a class="el" href="../../db/dbe/__supervised_8py_source.html#l01185">1185</a> of file <a class="el" href="../../db/dbe/__supervised_8py_source.html">_supervised.py</a>.</p>

<p class="reference">References <a class="el" href="../../db/dbe/__supervised_8py_source.html#l00024">check_clusterings()</a>, and <a class="el" href="../../db/dbe/__supervised_8py_source.html#l00098">contingency_matrix()</a>.</p>

</div>
</div>
<a id="aa45224bfac0b7cba5c38959188f56ec9" name="aa45224bfac0b7cba5c38959188f56ec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa45224bfac0b7cba5c38959188f56ec9">&#9670;&#160;</a></span>homogeneity_completeness_v_measure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.cluster._supervised.homogeneity_completeness_v_measure </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>labels_true</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>labels_pred</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>beta</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the homogeneity and completeness and V-Measure scores at once.

Those metrics are based on normalized conditional entropy measures of
the clustering labeling to evaluate given the knowledge of a Ground
Truth class labels of the same samples.

A clustering result satisfies homogeneity if all of its clusters
contain only data points which are members of a single class.

A clustering result satisfies completeness if all the data points
that are members of a given class are elements of the same cluster.

Both scores have positive values between 0.0 and 1.0, larger values
being desirable.

Those 3 metrics are independent of the absolute values of the labels:
a permutation of the class or cluster label values won't change the
score values in any way.

V-Measure is furthermore symmetric: swapping ``labels_true`` and
``label_pred`` will give the same score. This does not hold for
homogeneity and completeness. V-Measure is identical to
:func:`normalized_mutual_info_score` with the arithmetic averaging
method.

Read more in the :ref:`User Guide &lt;homogeneity_completeness&gt;`.

Parameters
----------
labels_true : array-like of shape (n_samples,)
    Ground truth class labels to be used as a reference.

labels_pred : array-like of shape (n_samples,)
    Cluster labels to evaluate.

beta : float, default=1.0
    Ratio of weight attributed to ``homogeneity`` vs ``completeness``.
    If ``beta`` is greater than 1, ``completeness`` is weighted more
    strongly in the calculation. If ``beta`` is less than 1,
    ``homogeneity`` is weighted more strongly.

Returns
-------
homogeneity : float
    Score between 0.0 and 1.0. 1.0 stands for perfectly homogeneous labeling.

completeness : float
    Score between 0.0 and 1.0. 1.0 stands for perfectly complete labeling.

v_measure : float
    Harmonic mean of the first two.

See Also
--------
homogeneity_score : Homogeneity metric of cluster labeling.
completeness_score : Completeness metric of cluster labeling.
v_measure_score : V-Measure (NMI with arithmetic mean option).

Examples
--------
&gt;&gt;&gt; from sklearn.metrics import homogeneity_completeness_v_measure
&gt;&gt;&gt; y_true, y_pred = [0, 0, 1, 1, 2, 2], [0, 0, 1, 2, 2, 2]
&gt;&gt;&gt; homogeneity_completeness_v_measure(y_true, y_pred)
(0.71, 0.771, 0.74)
</pre> 
<p class="definition">Definition at line <a class="el" href="../../db/dbe/__supervised_8py_source.html#l00462">462</a> of file <a class="el" href="../../db/dbe/__supervised_8py_source.html">_supervised.py</a>.</p>

<p class="reference">References <a class="el" href="../../db/dbe/__supervised_8py_source.html#l00024">check_clusterings()</a>, <a class="el" href="../../db/dbe/__supervised_8py_source.html#l00098">contingency_matrix()</a>, <a class="el" href="../../db/dbe/__supervised_8py_source.html#l01281">entropy()</a>, and <a class="el" href="../../db/dbe/__supervised_8py_source.html#l00819">mutual_info_score()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../db/dbe/__supervised_8py_source.html#l00638">completeness_score()</a>, <a class="el" href="../../db/dbe/__supervised_8py_source.html#l00562">homogeneity_score()</a>, and <a class="el" href="../../db/dbe/__supervised_8py_source.html#l00715">v_measure_score()</a>.</p>

</div>
</div>
<a id="a90f3b0a25f6e1f4f1088a64ae1600bef" name="a90f3b0a25f6e1f4f1088a64ae1600bef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90f3b0a25f6e1f4f1088a64ae1600bef">&#9670;&#160;</a></span>homogeneity_score()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.cluster._supervised.homogeneity_score </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>labels_true</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>labels_pred</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Homogeneity metric of a cluster labeling given a ground truth.

A clustering result satisfies homogeneity if all of its clusters
contain only data points which are members of a single class.

This metric is independent of the absolute values of the labels:
a permutation of the class or cluster label values won't change the
score value in any way.

This metric is not symmetric: switching ``label_true`` with ``label_pred``
will return the :func:`completeness_score` which will be different in
general.

Read more in the :ref:`User Guide &lt;homogeneity_completeness&gt;`.

Parameters
----------
labels_true : array-like of shape (n_samples,)
    Ground truth class labels to be used as a reference.

labels_pred : array-like of shape (n_samples,)
    Cluster labels to evaluate.

Returns
-------
homogeneity : float
   Score between 0.0 and 1.0. 1.0 stands for perfectly homogeneous labeling.

See Also
--------
completeness_score : Completeness metric of cluster labeling.
v_measure_score : V-Measure (NMI with arithmetic mean option).

References
----------

.. [1] `Andrew Rosenberg and Julia Hirschberg, 2007. V-Measure: A
   conditional entropy-based external cluster evaluation measure
   &lt;https://aclweb.org/anthology/D/D07/D07-1043.pdf&gt;`_

Examples
--------

Perfect labelings are homogeneous::

  &gt;&gt;&gt; from sklearn.metrics.cluster import homogeneity_score
  &gt;&gt;&gt; homogeneity_score([0, 0, 1, 1], [1, 1, 0, 0])
  1.0

Non-perfect labelings that further split classes into more clusters can be
perfectly homogeneous::

  &gt;&gt;&gt; print("%.6f" % homogeneity_score([0, 0, 1, 1], [0, 0, 1, 2]))
  1.000000
  &gt;&gt;&gt; print("%.6f" % homogeneity_score([0, 0, 1, 1], [0, 1, 2, 3]))
  1.000000

Clusters that include samples from different classes do not make for an
homogeneous labeling::

  &gt;&gt;&gt; print("%.6f" % homogeneity_score([0, 0, 1, 1], [0, 1, 0, 1]))
  0.0...
  &gt;&gt;&gt; print("%.6f" % homogeneity_score([0, 0, 1, 1], [0, 0, 0, 0]))
  0.0...
</pre> 
<p class="definition">Definition at line <a class="el" href="../../db/dbe/__supervised_8py_source.html#l00562">562</a> of file <a class="el" href="../../db/dbe/__supervised_8py_source.html">_supervised.py</a>.</p>

<p class="reference">References <a class="el" href="../../db/dbe/__supervised_8py_source.html#l00462">homogeneity_completeness_v_measure()</a>.</p>

</div>
</div>
<a id="a48c789f3bc2570f591c6886f1adcc7e2" name="a48c789f3bc2570f591c6886f1adcc7e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48c789f3bc2570f591c6886f1adcc7e2">&#9670;&#160;</a></span>mutual_info_score()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.cluster._supervised.mutual_info_score </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>labels_true</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>labels_pred</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>contingency</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Mutual Information between two clusterings.

The Mutual Information is a measure of the similarity between two labels
of the same data. Where :math:`|U_i|` is the number of the samples
in cluster :math:`U_i` and :math:`|V_j|` is the number of the
samples in cluster :math:`V_j`, the Mutual Information
between clusterings :math:`U` and :math:`V` is given as:

.. math::

    MI(U,V)=\\sum_{i=1}^{|U|} \\sum_{j=1}^{|V|} \\frac{|U_i\\cap V_j|}{N}
    \\log\\frac{N|U_i \\cap V_j|}{|U_i||V_j|}

This metric is independent of the absolute values of the labels:
a permutation of the class or cluster label values won't change the
score value in any way.

This metric is furthermore symmetric: switching :math:`U` (i.e
``label_true``) with :math:`V` (i.e. ``label_pred``) will return the
same score value. This can be useful to measure the agreement of two
independent label assignments strategies on the same dataset when the
real ground truth is not known.

Read more in the :ref:`User Guide &lt;mutual_info_score&gt;`.

Parameters
----------
labels_true : array-like of shape (n_samples,), dtype=integral
    A clustering of the data into disjoint subsets, called :math:`U` in
    the above formula.

labels_pred : array-like of shape (n_samples,), dtype=integral
    A clustering of the data into disjoint subsets, called :math:`V` in
    the above formula.

contingency : {array-like, sparse matrix} of shape \
        (n_classes_true, n_classes_pred), default=None
    A contingency matrix given by the
    :func:`~sklearn.metrics.cluster.contingency_matrix` function. If value
    is ``None``, it will be computed, otherwise the given value is used,
    with ``labels_true`` and ``labels_pred`` ignored.

Returns
-------
mi : float
   Mutual information, a non-negative value, measured in nats using the
   natural logarithm.

See Also
--------
adjusted_mutual_info_score : Adjusted against chance Mutual Information.
normalized_mutual_info_score : Normalized Mutual Information.

Notes
-----
The logarithm used is the natural logarithm (base-e).

Examples
--------
&gt;&gt;&gt; from sklearn.metrics import mutual_info_score
&gt;&gt;&gt; labels_true = [0, 1, 1, 0, 1, 0]
&gt;&gt;&gt; labels_pred = [0, 1, 0, 0, 1, 1]
&gt;&gt;&gt; mutual_info_score(labels_true, labels_pred)
0.0566
</pre> 
<p class="definition">Definition at line <a class="el" href="../../db/dbe/__supervised_8py_source.html#l00819">819</a> of file <a class="el" href="../../db/dbe/__supervised_8py_source.html">_supervised.py</a>.</p>

<p class="reference">References <a class="el" href="../../db/dbe/__supervised_8py_source.html#l00024">check_clusterings()</a>, and <a class="el" href="../../db/dbe/__supervised_8py_source.html#l00098">contingency_matrix()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../db/dbe/__supervised_8py_source.html#l00937">adjusted_mutual_info_score()</a>, <a class="el" href="../../db/dbe/__supervised_8py_source.html#l00462">homogeneity_completeness_v_measure()</a>, and <a class="el" href="../../db/dbe/__supervised_8py_source.html#l01075">normalized_mutual_info_score()</a>.</p>

</div>
</div>
<a id="a8e4766b5411a29bc6a4202df9dad15c8" name="a8e4766b5411a29bc6a4202df9dad15c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e4766b5411a29bc6a4202df9dad15c8">&#9670;&#160;</a></span>normalized_mutual_info_score()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.cluster._supervised.normalized_mutual_info_score </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>labels_true</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>labels_pred</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>average_method</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;arithmetic&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Normalized Mutual Information between two clusterings.

Normalized Mutual Information (NMI) is a normalization of the Mutual
Information (MI) score to scale the results between 0 (no mutual
information) and 1 (perfect correlation). In this function, mutual
information is normalized by some generalized mean of ``H(labels_true)``
and ``H(labels_pred))``, defined by the `average_method`.

This measure is not adjusted for chance. Therefore
:func:`adjusted_mutual_info_score` might be preferred.

This metric is independent of the absolute values of the labels:
a permutation of the class or cluster label values won't change the
score value in any way.

This metric is furthermore symmetric: switching ``label_true`` with
``label_pred`` will return the same score value. This can be useful to
measure the agreement of two independent label assignments strategies
on the same dataset when the real ground truth is not known.

Read more in the :ref:`User Guide &lt;mutual_info_score&gt;`.

Parameters
----------
labels_true : int array-like of shape (n_samples,)
    A clustering of the data into disjoint subsets.

labels_pred : int array-like of shape (n_samples,)
    A clustering of the data into disjoint subsets.

average_method : {'min', 'geometric', 'arithmetic', 'max'}, default='arithmetic'
    How to compute the normalizer in the denominator.

    .. versionadded:: 0.20

    .. versionchanged:: 0.22
       The default value of ``average_method`` changed from 'geometric' to
       'arithmetic'.

Returns
-------
nmi : float
   Score between 0.0 and 1.0 in normalized nats (based on the natural
   logarithm). 1.0 stands for perfectly complete labeling.

See Also
--------
v_measure_score : V-Measure (NMI with arithmetic mean option).
adjusted_rand_score : Adjusted Rand Index.
adjusted_mutual_info_score : Adjusted Mutual Information (adjusted
    against chance).

Examples
--------

Perfect labelings are both homogeneous and complete, hence have
score 1.0::

  &gt;&gt;&gt; from sklearn.metrics.cluster import normalized_mutual_info_score
  &gt;&gt;&gt; normalized_mutual_info_score([0, 0, 1, 1], [0, 0, 1, 1])
  1.0
  &gt;&gt;&gt; normalized_mutual_info_score([0, 0, 1, 1], [1, 1, 0, 0])
  1.0

If classes members are completely split across different clusters,
the assignment is totally in-complete, hence the NMI is null::

  &gt;&gt;&gt; normalized_mutual_info_score([0, 0, 0, 0], [0, 1, 2, 3])
  0.0
</pre> 
<p class="definition">Definition at line <a class="el" href="../../db/dbe/__supervised_8py_source.html#l01073">1073</a> of file <a class="el" href="../../db/dbe/__supervised_8py_source.html">_supervised.py</a>.</p>

<p class="reference">References <a class="el" href="../../db/dbe/__supervised_8py_source.html#l00070">_generalized_average()</a>, <a class="el" href="../../db/dbe/__supervised_8py_source.html#l00024">check_clusterings()</a>, <a class="el" href="../../db/dbe/__supervised_8py_source.html#l00098">contingency_matrix()</a>, <a class="el" href="../../db/dbe/__supervised_8py_source.html#l01281">entropy()</a>, and <a class="el" href="../../db/dbe/__supervised_8py_source.html#l00819">mutual_info_score()</a>.</p>

</div>
</div>
<a id="a91e10db8525d943e132641d887df35d1" name="a91e10db8525d943e132641d887df35d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91e10db8525d943e132641d887df35d1">&#9670;&#160;</a></span>pair_confusion_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.cluster._supervised.pair_confusion_matrix </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>labels_true</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>labels_pred</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Pair confusion matrix arising from two clusterings.

The pair confusion matrix :math:`C` computes a 2 by 2 similarity matrix
between two clusterings by considering all pairs of samples and counting
pairs that are assigned into the same or into different clusters under
the true and predicted clusterings [1]_.

Considering a pair of samples that is clustered together a positive pair,
then as in binary classification the count of true negatives is
:math:`C_{00}`, false negatives is :math:`C_{10}`, true positives is
:math:`C_{11}` and false positives is :math:`C_{01}`.

Read more in the :ref:`User Guide &lt;pair_confusion_matrix&gt;`.

Parameters
----------
labels_true : array-like of shape (n_samples,), dtype=integral
    Ground truth class labels to be used as a reference.

labels_pred : array-like of shape (n_samples,), dtype=integral
    Cluster labels to evaluate.

Returns
-------
C : ndarray of shape (2, 2), dtype=np.int64
    The contingency matrix.

See Also
--------
sklearn.metrics.rand_score : Rand Score.
sklearn.metrics.adjusted_rand_score : Adjusted Rand Score.
sklearn.metrics.adjusted_mutual_info_score : Adjusted Mutual Information.

References
----------
.. [1] :doi:`Hubert, L., Arabie, P. "Comparing partitions."
       Journal of Classification 2, 193‚Äì218 (1985).
       &lt;10.1007/BF01908075&gt;`

Examples
--------
Perfectly matching labelings have all non-zero entries on the
diagonal regardless of actual label values:

  &gt;&gt;&gt; from sklearn.metrics.cluster import pair_confusion_matrix
  &gt;&gt;&gt; pair_confusion_matrix([0, 0, 1, 1], [1, 1, 0, 0])
  array([[8, 0],
         [0, 4]]...

Labelings that assign all classes members to the same clusters
are complete but may be not always pure, hence penalized, and
have some off-diagonal non-zero entries:

  &gt;&gt;&gt; pair_confusion_matrix([0, 0, 1, 2], [0, 0, 1, 1])
  array([[8, 2],
         [0, 2]]...

Note that the matrix is not symmetric.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../db/dbe/__supervised_8py_source.html#l00184">184</a> of file <a class="el" href="../../db/dbe/__supervised_8py_source.html">_supervised.py</a>.</p>

<p class="reference">References <a class="el" href="../../db/dbe/__supervised_8py_source.html#l00024">check_clusterings()</a>, and <a class="el" href="../../db/dbe/__supervised_8py_source.html#l00098">contingency_matrix()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../db/dbe/__supervised_8py_source.html#l00349">adjusted_rand_score()</a>, and <a class="el" href="../../db/dbe/__supervised_8py_source.html#l00269">rand_score()</a>.</p>

</div>
</div>
<a id="a730947c8e7e9b0e67c8b8e2370accf67" name="a730947c8e7e9b0e67c8b8e2370accf67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a730947c8e7e9b0e67c8b8e2370accf67">&#9670;&#160;</a></span>rand_score()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.cluster._supervised.rand_score </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>labels_true</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>labels_pred</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Rand index.

The Rand Index computes a similarity measure between two clusterings
by considering all pairs of samples and counting pairs that are
assigned in the same or different clusters in the predicted and
true clusterings [1]_ [2]_.

The raw RI score [3]_ is:

.. code-block:: text

    RI = (number of agreeing pairs) / (number of pairs)

Read more in the :ref:`User Guide &lt;rand_score&gt;`.

Parameters
----------
labels_true : array-like of shape (n_samples,), dtype=integral
    Ground truth class labels to be used as a reference.

labels_pred : array-like of shape (n_samples,), dtype=integral
    Cluster labels to evaluate.

Returns
-------
RI : float
   Similarity score between 0.0 and 1.0, inclusive, 1.0 stands for
   perfect match.

See Also
--------
adjusted_rand_score: Adjusted Rand Score.
adjusted_mutual_info_score: Adjusted Mutual Information.

References
----------
.. [1] :doi:`Hubert, L., Arabie, P. "Comparing partitions."
   Journal of Classification 2, 193‚Äì218 (1985).
   &lt;10.1007/BF01908075&gt;`.

.. [2] `Wikipedia: Simple Matching Coefficient
    &lt;https://en.wikipedia.org/wiki/Simple_matching_coefficient&gt;`_

.. [3] `Wikipedia: Rand Index &lt;https://en.wikipedia.org/wiki/Rand_index&gt;`_

Examples
--------
Perfectly matching labelings have a score of 1 even

  &gt;&gt;&gt; from sklearn.metrics.cluster import rand_score
  &gt;&gt;&gt; rand_score([0, 0, 1, 1], [1, 1, 0, 0])
  1.0

Labelings that assign all classes members to the same clusters
are complete but may not always be pure, hence penalized:

  &gt;&gt;&gt; rand_score([0, 0, 1, 2], [0, 0, 1, 1])
  0.83
</pre> 
<p class="definition">Definition at line <a class="el" href="../../db/dbe/__supervised_8py_source.html#l00269">269</a> of file <a class="el" href="../../db/dbe/__supervised_8py_source.html">_supervised.py</a>.</p>

<p class="reference">References <a class="el" href="../../db/dbe/__supervised_8py_source.html#l00184">pair_confusion_matrix()</a>.</p>

</div>
</div>
<a id="ad9383c7869c1a7bc200249412830f358" name="ad9383c7869c1a7bc200249412830f358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9383c7869c1a7bc200249412830f358">&#9670;&#160;</a></span>v_measure_score()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics.cluster._supervised.v_measure_score </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>labels_true</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>labels_pred</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>beta</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">V-measure cluster labeling given a ground truth.

This score is identical to :func:`normalized_mutual_info_score` with
the ``'arithmetic'`` option for averaging.

The V-measure is the harmonic mean between homogeneity and completeness::

    v = (1 + beta) * homogeneity * completeness
         / (beta * homogeneity + completeness)

This metric is independent of the absolute values of the labels:
a permutation of the class or cluster label values won't change the
score value in any way.

This metric is furthermore symmetric: switching ``label_true`` with
``label_pred`` will return the same score value. This can be useful to
measure the agreement of two independent label assignments strategies
on the same dataset when the real ground truth is not known.

Read more in the :ref:`User Guide &lt;homogeneity_completeness&gt;`.

Parameters
----------
labels_true : array-like of shape (n_samples,)
    Ground truth class labels to be used as a reference.

labels_pred : array-like of shape (n_samples,)
    Cluster labels to evaluate.

beta : float, default=1.0
    Ratio of weight attributed to ``homogeneity`` vs ``completeness``.
    If ``beta`` is greater than 1, ``completeness`` is weighted more
    strongly in the calculation. If ``beta`` is less than 1,
    ``homogeneity`` is weighted more strongly.

Returns
-------
v_measure : float
   Score between 0.0 and 1.0. 1.0 stands for perfectly complete labeling.

See Also
--------
homogeneity_score : Homogeneity metric of cluster labeling.
completeness_score : Completeness metric of cluster labeling.
normalized_mutual_info_score : Normalized Mutual Information.

References
----------

.. [1] `Andrew Rosenberg and Julia Hirschberg, 2007. V-Measure: A
   conditional entropy-based external cluster evaluation measure
   &lt;https://aclweb.org/anthology/D/D07/D07-1043.pdf&gt;`_

Examples
--------
Perfect labelings are both homogeneous and complete, hence have score 1.0::

  &gt;&gt;&gt; from sklearn.metrics.cluster import v_measure_score
  &gt;&gt;&gt; v_measure_score([0, 0, 1, 1], [0, 0, 1, 1])
  1.0
  &gt;&gt;&gt; v_measure_score([0, 0, 1, 1], [1, 1, 0, 0])
  1.0

Labelings that assign all classes members to the same clusters
are complete but not homogeneous, hence penalized::

  &gt;&gt;&gt; print("%.6f" % v_measure_score([0, 0, 1, 2], [0, 0, 1, 1]))
  0.8
  &gt;&gt;&gt; print("%.6f" % v_measure_score([0, 1, 2, 3], [0, 0, 1, 1]))
  0.67

Labelings that have pure clusters with members coming from the same
classes are homogeneous but un-necessary splits harm completeness
and thus penalize V-measure as well::

  &gt;&gt;&gt; print("%.6f" % v_measure_score([0, 0, 1, 1], [0, 0, 1, 2]))
  0.8
  &gt;&gt;&gt; print("%.6f" % v_measure_score([0, 0, 1, 1], [0, 1, 2, 3]))
  0.67

If classes members are completely split across different clusters,
the assignment is totally incomplete, hence the V-Measure is null::

  &gt;&gt;&gt; print("%.6f" % v_measure_score([0, 0, 0, 0], [0, 1, 2, 3]))
  0.0

Clusters that include samples from totally different classes totally
destroy the homogeneity of the labeling, hence::

  &gt;&gt;&gt; print("%.6f" % v_measure_score([0, 0, 1, 1], [0, 0, 0, 0]))
  0.0
</pre> 
<p class="definition">Definition at line <a class="el" href="../../db/dbe/__supervised_8py_source.html#l00715">715</a> of file <a class="el" href="../../db/dbe/__supervised_8py_source.html">_supervised.py</a>.</p>

<p class="reference">References <a class="el" href="../../db/dbe/__supervised_8py_source.html#l00462">homogeneity_completeness_v_measure()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d6/d1d/namespacesklearn.html">sklearn</a></li><li class="navelem"><a class="el" href="../../d0/d06/namespacesklearn_1_1metrics.html">metrics</a></li><li class="navelem"><a class="el" href="../../dc/da2/namespacesklearn_1_1metrics_1_1cluster.html">cluster</a></li><li class="navelem"><a class="el" href="../../d5/d66/namespacesklearn_1_1metrics_1_1cluster_1_1__supervised.html">_supervised</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
