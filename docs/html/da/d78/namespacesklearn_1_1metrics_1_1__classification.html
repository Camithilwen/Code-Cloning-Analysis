<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Code Cloning Analysis: sklearn.metrics._classification Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Code Cloning Analysis
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('da/d78/namespacesklearn_1_1metrics_1_1__classification.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">sklearn.metrics._classification Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a346ed1eea7dc119562be2c93704eb299" id="r_a346ed1eea7dc119562be2c93704eb299"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a346ed1eea7dc119562be2c93704eb299">_check_zero_division</a> (zero_division)</td></tr>
<tr class="separator:a346ed1eea7dc119562be2c93704eb299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab052693e5a75a63b200115e2c3949926" id="r_ab052693e5a75a63b200115e2c3949926"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab052693e5a75a63b200115e2c3949926">_check_targets</a> (y_true, y_pred)</td></tr>
<tr class="separator:ab052693e5a75a63b200115e2c3949926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8a783c3bb698a466cf5f0f2b4d39b2" id="r_a9e8a783c3bb698a466cf5f0f2b4d39b2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e8a783c3bb698a466cf5f0f2b4d39b2">_validate_multiclass_probabilistic_prediction</a> (y_true, y_prob, sample_weight, labels)</td></tr>
<tr class="separator:a9e8a783c3bb698a466cf5f0f2b4d39b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14760381108ce762d9681e2878d4da3b" id="r_a14760381108ce762d9681e2878d4da3b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14760381108ce762d9681e2878d4da3b">accuracy_score</a> (y_true, y_pred, *, normalize=<a class="el" href="../../d8/d0b/classTrue.html">True</a>, sample_weight=None)</td></tr>
<tr class="separator:a14760381108ce762d9681e2878d4da3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bdecf060bbdd6ebe26f442d9d3f1382" id="r_a9bdecf060bbdd6ebe26f442d9d3f1382"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9bdecf060bbdd6ebe26f442d9d3f1382">confusion_matrix</a> (y_true, y_pred, *, labels=None, sample_weight=None, normalize=None)</td></tr>
<tr class="separator:a9bdecf060bbdd6ebe26f442d9d3f1382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a441d970c6097ed3b4af7dbb919e53813" id="r_a441d970c6097ed3b4af7dbb919e53813"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a441d970c6097ed3b4af7dbb919e53813">multilabel_confusion_matrix</a> (y_true, y_pred, *, sample_weight=None, labels=None, samplewise=False)</td></tr>
<tr class="separator:a441d970c6097ed3b4af7dbb919e53813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7430b47501eea60d89bf4abec2eef197" id="r_a7430b47501eea60d89bf4abec2eef197"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7430b47501eea60d89bf4abec2eef197">cohen_kappa_score</a> (y1, y2, *, labels=None, weights=None, sample_weight=None)</td></tr>
<tr class="separator:a7430b47501eea60d89bf4abec2eef197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba21abda11d69893f8ae3727cb64472f" id="r_aba21abda11d69893f8ae3727cb64472f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba21abda11d69893f8ae3727cb64472f">jaccard_score</a> (y_true, y_pred, *, labels=None, pos_label=1, average=&quot;binary&quot;, sample_weight=None, zero_division=&quot;warn&quot;)</td></tr>
<tr class="separator:aba21abda11d69893f8ae3727cb64472f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68e73cd770f722164235c466adbf5a0c" id="r_a68e73cd770f722164235c466adbf5a0c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68e73cd770f722164235c466adbf5a0c">matthews_corrcoef</a> (y_true, y_pred, *, sample_weight=None)</td></tr>
<tr class="separator:a68e73cd770f722164235c466adbf5a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf01048251d2b41d3fb5ee881300fc73" id="r_adf01048251d2b41d3fb5ee881300fc73"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf01048251d2b41d3fb5ee881300fc73">zero_one_loss</a> (y_true, y_pred, *, normalize=<a class="el" href="../../d8/d0b/classTrue.html">True</a>, sample_weight=None)</td></tr>
<tr class="separator:adf01048251d2b41d3fb5ee881300fc73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d31c24f718a99decc9441f1e82a7329" id="r_a5d31c24f718a99decc9441f1e82a7329"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d31c24f718a99decc9441f1e82a7329">f1_score</a> (y_true, y_pred, *, labels=None, pos_label=1, average=&quot;binary&quot;, sample_weight=None, zero_division=&quot;warn&quot;)</td></tr>
<tr class="separator:a5d31c24f718a99decc9441f1e82a7329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada551803819b8de72f08d36b10c2775b" id="r_ada551803819b8de72f08d36b10c2775b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada551803819b8de72f08d36b10c2775b">fbeta_score</a> (y_true, y_pred, *, beta, labels=None, pos_label=1, average=&quot;binary&quot;, sample_weight=None, zero_division=&quot;warn&quot;)</td></tr>
<tr class="separator:ada551803819b8de72f08d36b10c2775b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aebe969f1ab1fec83528c39979d699a" id="r_a0aebe969f1ab1fec83528c39979d699a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0aebe969f1ab1fec83528c39979d699a">_prf_divide</a> (numerator, denominator, metric, modifier, average, warn_for, zero_division=&quot;warn&quot;)</td></tr>
<tr class="separator:a0aebe969f1ab1fec83528c39979d699a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b2a6e4f3795b2fbc6aaa89025757de0" id="r_a0b2a6e4f3795b2fbc6aaa89025757de0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b2a6e4f3795b2fbc6aaa89025757de0">_warn_prf</a> (average, modifier, msg_start, result_size)</td></tr>
<tr class="separator:a0b2a6e4f3795b2fbc6aaa89025757de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c8f32774ecf6aeebfa0b0b44cd33ec3" id="r_a3c8f32774ecf6aeebfa0b0b44cd33ec3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c8f32774ecf6aeebfa0b0b44cd33ec3">_check_set_wise_labels</a> (y_true, y_pred, average, labels, pos_label)</td></tr>
<tr class="separator:a3c8f32774ecf6aeebfa0b0b44cd33ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15142b0e8df592903125d73338098b62" id="r_a15142b0e8df592903125d73338098b62"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15142b0e8df592903125d73338098b62">precision_recall_fscore_support</a> (y_true, y_pred, *, beta=1.0, labels=None, pos_label=1, average=None, warn_for=(&quot;precision&quot;, &quot;recall&quot;, &quot;f-score&quot;), sample_weight=None, zero_division=&quot;warn&quot;)</td></tr>
<tr class="separator:a15142b0e8df592903125d73338098b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b445b22ee35994b69bb8f2b0c3fcea" id="r_a09b445b22ee35994b69bb8f2b0c3fcea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09b445b22ee35994b69bb8f2b0c3fcea">class_likelihood_ratios</a> (y_true, y_pred, *, labels=None, sample_weight=None, raise_warning=&quot;deprecated&quot;, replace_undefined_by=np.nan)</td></tr>
<tr class="separator:a09b445b22ee35994b69bb8f2b0c3fcea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7da5219ebca6807f6a19706be6f05ba" id="r_aa7da5219ebca6807f6a19706be6f05ba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7da5219ebca6807f6a19706be6f05ba">precision_score</a> (y_true, y_pred, *, labels=None, pos_label=1, average=&quot;binary&quot;, sample_weight=None, zero_division=&quot;warn&quot;)</td></tr>
<tr class="separator:aa7da5219ebca6807f6a19706be6f05ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5557c71c9e924d3e1d9e3679d1e0e710" id="r_a5557c71c9e924d3e1d9e3679d1e0e710"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5557c71c9e924d3e1d9e3679d1e0e710">recall_score</a> (y_true, y_pred, *, labels=None, pos_label=1, average=&quot;binary&quot;, sample_weight=None, zero_division=&quot;warn&quot;)</td></tr>
<tr class="separator:a5557c71c9e924d3e1d9e3679d1e0e710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78df17d784f34f119fa6ccfe6ce72d2b" id="r_a78df17d784f34f119fa6ccfe6ce72d2b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78df17d784f34f119fa6ccfe6ce72d2b">balanced_accuracy_score</a> (y_true, y_pred, *, sample_weight=None, adjusted=False)</td></tr>
<tr class="separator:a78df17d784f34f119fa6ccfe6ce72d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3d62594d97dfc77db45e359f91ba6b7" id="r_aa3d62594d97dfc77db45e359f91ba6b7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3d62594d97dfc77db45e359f91ba6b7">classification_report</a> (y_true, y_pred, *, labels=None, target_names=None, sample_weight=None, digits=2, output_dict=False, zero_division=&quot;warn&quot;)</td></tr>
<tr class="separator:aa3d62594d97dfc77db45e359f91ba6b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1726217c03db123e1bbc0ae220edabe4" id="r_a1726217c03db123e1bbc0ae220edabe4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1726217c03db123e1bbc0ae220edabe4">hamming_loss</a> (y_true, y_pred, *, sample_weight=None)</td></tr>
<tr class="separator:a1726217c03db123e1bbc0ae220edabe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f7198fff7b380c1a136c9d69c883ef" id="r_a04f7198fff7b380c1a136c9d69c883ef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04f7198fff7b380c1a136c9d69c883ef">log_loss</a> (y_true, y_pred, *, normalize=<a class="el" href="../../d8/d0b/classTrue.html">True</a>, sample_weight=None, labels=None)</td></tr>
<tr class="separator:a04f7198fff7b380c1a136c9d69c883ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b103f5754e2cfae479b2d92e59f53fd" id="r_a8b103f5754e2cfae479b2d92e59f53fd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b103f5754e2cfae479b2d92e59f53fd">hinge_loss</a> (y_true, pred_decision, *, labels=None, sample_weight=None)</td></tr>
<tr class="separator:a8b103f5754e2cfae479b2d92e59f53fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31b149c6b885fafbe21f5de6871f4070" id="r_a31b149c6b885fafbe21f5de6871f4070"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31b149c6b885fafbe21f5de6871f4070">_validate_binary_probabilistic_prediction</a> (y_true, y_prob, sample_weight, pos_label)</td></tr>
<tr class="separator:a31b149c6b885fafbe21f5de6871f4070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a223bfbbb1d1efa0ad89868253dee9c7e" id="r_a223bfbbb1d1efa0ad89868253dee9c7e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a223bfbbb1d1efa0ad89868253dee9c7e">brier_score_loss</a> (y_true, y_proba, *, sample_weight=None, pos_label=None, labels=None, scale_by_half=&quot;auto&quot;)</td></tr>
<tr class="separator:a223bfbbb1d1efa0ad89868253dee9c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457f569cc9a5bb6f2172dde936d3be7f" id="r_a457f569cc9a5bb6f2172dde936d3be7f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a457f569cc9a5bb6f2172dde936d3be7f">d2_log_loss_score</a> (y_true, y_pred, *, sample_weight=None, labels=None)</td></tr>
<tr class="separator:a457f569cc9a5bb6f2172dde936d3be7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Metrics to assess performance on classification task given class prediction.

Functions named as ``*_score`` return a scalar value to maximize: the higher
the better.

Function named as ``*_error`` or ``*_loss`` return a scalar value to minimize:
the lower the better.
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a3c8f32774ecf6aeebfa0b0b44cd33ec3" name="a3c8f32774ecf6aeebfa0b0b44cd33ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c8f32774ecf6aeebfa0b0b44cd33ec3">&#9670;&#160;</a></span>_check_set_wise_labels()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics._classification._check_set_wise_labels </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y_true</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y_pred</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>average</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>labels</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>pos_label</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Validation associated with set-wise metrics.

Returns identified labels.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l01752">1752</a> of file <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html">_classification.py</a>.</p>

<p class="reference">References <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l00069">_check_targets()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l00928">jaccard_score()</a>, and <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l01826">precision_recall_fscore_support()</a>.</p>

</div>
</div>
<a id="ab052693e5a75a63b200115e2c3949926" name="ab052693e5a75a63b200115e2c3949926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab052693e5a75a63b200115e2c3949926">&#9670;&#160;</a></span>_check_targets()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics._classification._check_targets </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y_true</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y_pred</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Check that y_true and y_pred belong to the same classification task.

This converts multiclass or binary types to a common shape, and raises a
ValueError for a mix of multilabel and multiclass targets, a mix of
multilabel formats, for the presence of continuous-valued or multioutput
targets, or for targets of different lengths.

Column vectors are squeezed to 1d, while multilabel formats are returned
as CSR sparse label indicators.

Parameters
----------
y_true : array-like

y_pred : array-like

Returns
-------
type_true : one of {'multilabel-indicator', 'multiclass', 'binary'}
    The type of the true target data, as output by
    ``utils.multiclass.type_of_target``.

y_true : array or indicator matrix

y_pred : array or indicator matrix
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l00069">69</a> of file <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html">_classification.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l01752">_check_set_wise_labels()</a>, <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l00296">accuracy_score()</a>, <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l02095">class_likelihood_ratios()</a>, <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l02839">classification_report()</a>, <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l00383">confusion_matrix()</a>, <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l03061">hamming_loss()</a>, <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l01110">matthews_corrcoef()</a>, and <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l00558">multilabel_confusion_matrix()</a>.</p>

</div>
</div>
<a id="a346ed1eea7dc119562be2c93704eb299" name="a346ed1eea7dc119562be2c93704eb299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a346ed1eea7dc119562be2c93704eb299">&#9670;&#160;</a></span>_check_zero_division()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics._classification._check_zero_division </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>zero_division</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l00060">60</a> of file <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html">_classification.py</a>.</p>

</div>
</div>
<a id="a0aebe969f1ab1fec83528c39979d699a" name="a0aebe969f1ab1fec83528c39979d699a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aebe969f1ab1fec83528c39979d699a">&#9670;&#160;</a></span>_prf_divide()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics._classification._prf_divide </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>numerator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>denominator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>metric</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>modifier</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>average</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>warn_for</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>zero_division</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;warn&quot;</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Performs division and handles divide-by-zero.

On zero-division, sets the corresponding result elements equal to
0, 1 or np.nan (according to ``zero_division``). Plus, if
``zero_division != "warn"`` raises a warning.

The metric, modifier and average arguments are used only for determining
an appropriate warning.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l01697">1697</a> of file <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html">_classification.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l00928">jaccard_score()</a>, and <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l01826">precision_recall_fscore_support()</a>.</p>

</div>
</div>
<a id="a31b149c6b885fafbe21f5de6871f4070" name="a31b149c6b885fafbe21f5de6871f4070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31b149c6b885fafbe21f5de6871f4070">&#9670;&#160;</a></span>_validate_binary_probabilistic_prediction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics._classification._validate_binary_probabilistic_prediction </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y_true</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y_prob</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>sample_weight</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>pos_label</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Convert y_true and y_prob in binary classification to shape (n_samples, 2)

Parameters
----------
y_true : array-like of shape (n_samples,)
    True labels.

y_prob : array-like of shape (n_samples,)
    Probabilities of the positive class.

sample_weight : array-like of shape (n_samples,), default=None
    Sample weights.

pos_label : int, float, bool or str, default=None
    Label of the positive class. If None, `pos_label` will be inferred
    in the following manner:

    * if `y_true` in {-1, 1} or {0, 1}, `pos_label` defaults to 1;
    * else if `y_true` contains string, an error will be raised and
      `pos_label` should be explicitly specified;
    * otherwise, `pos_label` defaults to the greater label,
      i.e. `np.unique(y_true)[-1]`.

Returns
-------
transformed_labels : array of shape (n_samples, 2)

y_prob : array of shape (n_samples, 2)
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l03405">3405</a> of file <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html">_classification.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l03495">brier_score_loss()</a>.</p>

</div>
</div>
<a id="a9e8a783c3bb698a466cf5f0f2b4d39b2" name="a9e8a783c3bb698a466cf5f0f2b4d39b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e8a783c3bb698a466cf5f0f2b4d39b2">&#9670;&#160;</a></span>_validate_multiclass_probabilistic_prediction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics._classification._validate_multiclass_probabilistic_prediction </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y_true</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y_prob</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>sample_weight</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>labels</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Convert y_true and y_prob to shape (n_samples, n_classes)

1. Verify that y_true, y_prob, and sample_weights have the same first dim
2. Ensure 2 or more classes in y_true i.e. valid classification task. The
classes are provided by the labels argument, or inferred using y_true.
When inferring y_true is assumed binary if it has shape (n_samples, ).
3. Validate y_true, and y_prob have the same number of classes. Convert to
shape (n_samples, n_classes)

Parameters
----------
y_true : array-like or label indicator matrix
Ground truth (correct) labels for n_samples samples.

y_prob : array-like of float, shape=(n_samples, n_classes) or (n_samples,)
Predicted probabilities, as returned by a classifier's
predict_proba method. If `y_prob.shape = (n_samples,)`
the probabilities provided are assumed to be that of the
positive class. The labels in `y_prob` are assumed to be
ordered lexicographically, as done by
:class:`preprocessing.LabelBinarizer`.

sample_weight : array-like of shape (n_samples,), default=None
Sample weights.

labels : array-like, default=None
If not provided, labels will be inferred from y_true. If `labels`
is `None` and `y_prob` has shape `(n_samples,)` the labels are
assumed to be binary and are inferred from `y_true`.

Returns
-------
transformed_labels : array of shape (n_samples, n_classes)

y_prob : array of shape (n_samples, n_classes)
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l00154">154</a> of file <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html">_classification.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l03495">brier_score_loss()</a>, and <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l03172">log_loss()</a>.</p>

</div>
</div>
<a id="a0b2a6e4f3795b2fbc6aaa89025757de0" name="a0b2a6e4f3795b2fbc6aaa89025757de0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b2a6e4f3795b2fbc6aaa89025757de0">&#9670;&#160;</a></span>_warn_prf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics._classification._warn_prf </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>average</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>modifier</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>msg_start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>result_size</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l01736">1736</a> of file <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html">_classification.py</a>.</p>

</div>
</div>
<a id="a14760381108ce762d9681e2878d4da3b" name="a14760381108ce762d9681e2878d4da3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14760381108ce762d9681e2878d4da3b">&#9670;&#160;</a></span>accuracy_score()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics._classification.accuracy_score </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y_true</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y_pred</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>normalize</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d8/d0b/classTrue.html">True</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>sample_weight</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Accuracy classification score.

In multilabel classification, this function computes subset accuracy:
the set of labels predicted for a sample must *exactly* match the
corresponding set of labels in y_true.

Read more in the :ref:`User Guide &lt;accuracy_score&gt;`.

Parameters
----------
y_true : 1d array-like, or label indicator array / sparse matrix
    Ground truth (correct) labels.

y_pred : 1d array-like, or label indicator array / sparse matrix
    Predicted labels, as returned by a classifier.

normalize : bool, default=True
    If ``False``, return the number of correctly classified samples.
    Otherwise, return the fraction of correctly classified samples.

sample_weight : array-like of shape (n_samples,), default=None
    Sample weights.

Returns
-------
score : float or int
    If ``normalize == True``, return the fraction of correctly
    classified samples (float), else returns the number of correctly
    classified samples (int).

    The best performance is 1 with ``normalize == True`` and the number
    of samples with ``normalize == False``.

See Also
--------
balanced_accuracy_score : Compute the balanced accuracy to deal with
    imbalanced datasets.
jaccard_score : Compute the Jaccard similarity coefficient score.
hamming_loss : Compute the average Hamming loss or Hamming distance between
    two sets of samples.
zero_one_loss : Compute the Zero-one classification loss. By default, the
    function will return the percentage of imperfectly predicted subsets.

Examples
--------
&gt;&gt;&gt; from sklearn.metrics import accuracy_score
&gt;&gt;&gt; y_pred = [0, 2, 1, 3]
&gt;&gt;&gt; y_true = [0, 1, 2, 3]
&gt;&gt;&gt; accuracy_score(y_true, y_pred)
0.5
&gt;&gt;&gt; accuracy_score(y_true, y_pred, normalize=False)
2.0

In the multilabel case with binary label indicators:

&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; accuracy_score(np.array([[0, 1], [1, 1]]), np.ones((2, 2)))
0.5
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l00296">296</a> of file <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html">_classification.py</a>.</p>

<p class="reference">References <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l00069">_check_targets()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l01209">zero_one_loss()</a>.</p>

</div>
</div>
<a id="a78df17d784f34f119fa6ccfe6ce72d2b" name="a78df17d784f34f119fa6ccfe6ce72d2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78df17d784f34f119fa6ccfe6ce72d2b">&#9670;&#160;</a></span>balanced_accuracy_score()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics._classification.balanced_accuracy_score </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y_true</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y_pred</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>sample_weight</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>adjusted</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the balanced accuracy.

The balanced accuracy in binary and multiclass classification problems to
deal with imbalanced datasets. It is defined as the average of recall
obtained on each class.

The best value is 1 and the worst value is 0 when ``adjusted=False``.

Read more in the :ref:`User Guide &lt;balanced_accuracy_score&gt;`.

.. versionadded:: 0.20

Parameters
----------
y_true : array-like of shape (n_samples,)
    Ground truth (correct) target values.

y_pred : array-like of shape (n_samples,)
    Estimated targets as returned by a classifier.

sample_weight : array-like of shape (n_samples,), default=None
    Sample weights.

adjusted : bool, default=False
    When true, the result is adjusted for chance, so that random
    performance would score 0, while keeping perfect performance at a score
    of 1.

Returns
-------
balanced_accuracy : float
    Balanced accuracy score.

See Also
--------
average_precision_score : Compute average precision (AP) from prediction
    scores.
precision_score : Compute the precision score.
recall_score : Compute the recall score.
roc_auc_score : Compute Area Under the Receiver Operating Characteristic
    Curve (ROC AUC) from prediction scores.

Notes
-----
Some literature promotes alternative definitions of balanced accuracy. Our
definition is equivalent to :func:`accuracy_score` with class-balanced
sample weights, and shares desirable properties with the binary case.
See the :ref:`User Guide &lt;balanced_accuracy_score&gt;`.

References
----------
.. [1] Brodersen, K.H.; Ong, C.S.; Stephan, K.E.; Buhmann, J.M. (2010).
       The balanced accuracy and its posterior distribution.
       Proceedings of the 20th International Conference on Pattern
       Recognition, 3121-24.
.. [2] John. D. Kelleher, Brian Mac Namee, Aoife D'Arcy, (2015).
       `Fundamentals of Machine Learning for Predictive Data Analytics:
       Algorithms, Worked Examples, and Case Studies
       &lt;https://mitpress.mit.edu/books/fundamentals-machine-learning-predictive-data-analytics&gt;`_.

Examples
--------
&gt;&gt;&gt; from sklearn.metrics import balanced_accuracy_score
&gt;&gt;&gt; y_true = [0, 1, 0, 0, 1, 0]
&gt;&gt;&gt; y_pred = [0, 1, 0, 0, 0, 1]
&gt;&gt;&gt; balanced_accuracy_score(y_true, y_pred)
0.625
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l02728">2728</a> of file <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html">_classification.py</a>.</p>

</div>
</div>
<a id="a223bfbbb1d1efa0ad89868253dee9c7e" name="a223bfbbb1d1efa0ad89868253dee9c7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a223bfbbb1d1efa0ad89868253dee9c7e">&#9670;&#160;</a></span>brier_score_loss()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics._classification.brier_score_loss </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y_true</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y_proba</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>sample_weight</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>pos_label</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>labels</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>scale_by_half</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;auto&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the Brier score loss.

The smaller the Brier score loss, the better, hence the naming with "loss".
The Brier score measures the mean squared difference between the predicted
probability and the actual outcome. The Brier score is a strictly proper scoring
rule.

Read more in the :ref:`User Guide &lt;brier_score_loss&gt;`.

Parameters
----------
y_true : array-like of shape (n_samples,)
    True targets.

y_proba : array-like of shape (n_samples,) or (n_samples, n_classes)
    Predicted probabilities. If `y_proba.shape = (n_samples,)`
    the probabilities provided are assumed to be that of the
    positive class. If `y_proba.shape = (n_samples, n_classes)`
    the columns in `y_proba` are assumed to correspond to the
    labels in alphabetical order, as done by
    :class:`~sklearn.preprocessing.LabelBinarizer`.

sample_weight : array-like of shape (n_samples,), default=None
    Sample weights.

pos_label : int, float, bool or str, default=None
    Label of the positive class when `y_proba.shape = (n_samples,)`.
    If not provided, `pos_label` will be inferred in the
    following manner:

    * if `y_true` in {-1, 1} or {0, 1}, `pos_label` defaults to 1;
    * else if `y_true` contains string, an error will be raised and
      `pos_label` should be explicitly specified;
    * otherwise, `pos_label` defaults to the greater label,
      i.e. `np.unique(y_true)[-1]`.

labels : array-like of shape (n_classes,), default=None
    Class labels when `y_proba.shape = (n_samples, n_classes)`.
    If not provided, labels will be inferred from `y_true`.

    .. versionadded:: 1.7

scale_by_half : bool or "auto", default="auto"
    When True, scale the Brier score by 1/2 to lie in the [0, 1] range instead
    of the [0, 2] range. The default "auto" option implements the rescaling to
    [0, 1] only for binary classification (as customary) but keeps the
    original [0, 2] range for multiclass classification.

    .. versionadded:: 1.7

Returns
-------
score : float
    Brier score loss.

Notes
-----

For :math:`N` observations labeled from :math:`C` possible classes, the Brier
score is defined as:

.. math::
    \frac{1}{N}\sum_{i=1}^{N}\sum_{c=1}^{C}(y_{ic} - \hat{p}_{ic})^{2}

where :math:`y_{ic}` is 1 if observation `i` belongs to class `c`,
otherwise 0 and :math:`\hat{p}_{ic}` is the predicted probability for
observation `i` to belong to class `c`.
The Brier score then ranges between :math:`[0, 2]`.

In binary classification tasks the Brier score is usually divided by
two and then ranges between :math:`[0, 1]`. It can be alternatively
written as:

.. math::
    \frac{1}{N}\sum_{i=1}^{N}(y_{i} - \hat{p}_{i})^{2}

where :math:`y_{i}` is the binary target and :math:`\hat{p}_{i}`
is the predicted probability of the positive class.

References
----------
.. [1] `Wikipedia entry for the Brier score
        &lt;https://en.wikipedia.org/wiki/Brier_score&gt;`_.

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from sklearn.metrics import brier_score_loss
&gt;&gt;&gt; y_true = np.array([0, 1, 1, 0])
&gt;&gt;&gt; y_true_categorical = np.array(["spam", "ham", "ham", "spam"])
&gt;&gt;&gt; y_prob = np.array([0.1, 0.9, 0.8, 0.3])
&gt;&gt;&gt; brier_score_loss(y_true, y_prob)
0.0375
&gt;&gt;&gt; brier_score_loss(y_true, 1-y_prob, pos_label=0)
0.0375
&gt;&gt;&gt; brier_score_loss(y_true_categorical, y_prob, pos_label="ham")
0.0375
&gt;&gt;&gt; brier_score_loss(y_true, np.array(y_prob) &gt; 0.5)
0.0
&gt;&gt;&gt; brier_score_loss(y_true, y_prob, scale_by_half=False)
0.075
&gt;&gt;&gt; brier_score_loss(
...    ["eggs", "ham", "spam"],
...    [[0.8, 0.1, 0.1], [0.2, 0.7, 0.1], [0.2, 0.2, 0.6]],
...    labels=["eggs", "ham", "spam"]
... )
0.146
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l03487">3487</a> of file <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html">_classification.py</a>.</p>

<p class="reference">References <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l03405">_validate_binary_probabilistic_prediction()</a>, and <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l00156">_validate_multiclass_probabilistic_prediction()</a>.</p>

</div>
</div>
<a id="a09b445b22ee35994b69bb8f2b0c3fcea" name="a09b445b22ee35994b69bb8f2b0c3fcea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09b445b22ee35994b69bb8f2b0c3fcea">&#9670;&#160;</a></span>class_likelihood_ratios()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics._classification.class_likelihood_ratios </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y_true</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y_pred</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>labels</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>sample_weight</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>raise_warning</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;deprecated&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>replace_undefined_by</em></span><span class="paramdefsep"> = </span><span class="paramdefval">np.nan</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute binary classification positive and negative likelihood ratios.

The positive likelihood ratio is `LR+ = sensitivity / (1 - specificity)`
where the sensitivity or recall is the ratio `tp / (tp + fn)` and the
specificity is `tn / (tn + fp)`. The negative likelihood ratio is `LR- = (1
- sensitivity) / specificity`. Here `tp` is the number of true positives,
`fp` the number of false positives, `tn` is the number of true negatives and
`fn` the number of false negatives. Both class likelihood ratios can be used
to obtain post-test probabilities given a pre-test probability.

`LR+` ranges from 1.0 to infinity. A `LR+` of 1.0 indicates that the probability
of predicting the positive class is the same for samples belonging to either
class; therefore, the test is useless. The greater `LR+` is, the more a
positive prediction is likely to be a true positive when compared with the
pre-test probability. A value of `LR+` lower than 1.0 is invalid as it would
indicate that the odds of a sample being a true positive decrease with
respect to the pre-test odds.

`LR-` ranges from 0.0 to 1.0. The closer it is to 0.0, the lower the probability
of a given sample to be a false negative. A `LR-` of 1.0 means the test is
useless because the odds of having the condition did not change after the
test. A value of `LR-` greater than 1.0 invalidates the classifier as it
indicates an increase in the odds of a sample belonging to the positive
class after being classified as negative. This is the case when the
classifier systematically predicts the opposite of the true label.

A typical application in medicine is to identify the positive/negative class
to the presence/absence of a disease, respectively; the classifier being a
diagnostic test; the pre-test probability of an individual having the
disease can be the prevalence of such disease (proportion of a particular
population found to be affected by a medical condition); and the post-test
probabilities would be the probability that the condition is truly present
given a positive test result.

Read more in the :ref:`User Guide &lt;class_likelihood_ratios&gt;`.

Parameters
----------
y_true : 1d array-like, or label indicator array / sparse matrix
    Ground truth (correct) target values.

y_pred : 1d array-like, or label indicator array / sparse matrix
    Estimated targets as returned by a classifier.

labels : array-like, default=None
    List of labels to index the matrix. This may be used to select the
    positive and negative classes with the ordering `labels=[negative_class,
    positive_class]`. If `None` is given, those that appear at least once in
    `y_true` or `y_pred` are used in sorted order.

sample_weight : array-like of shape (n_samples,), default=None
    Sample weights.

raise_warning : bool, default=True
    Whether or not a case-specific warning message is raised when there is division
    by zero.

    .. deprecated:: 1.7
        `raise_warning` was deprecated in version 1.7 and will be removed in 1.9,
        when an :class:`~sklearn.exceptions.UndefinedMetricWarning` will always
        raise in case of a division by zero.

replace_undefined_by : np.nan, 1.0, or dict, default=np.nan
    Sets the return values for LR+ and LR- when there is a division by zero. Can
    take the following values:

    - `np.nan` to return `np.nan` for both `LR+` and `LR-`
    - `1.0` to return the worst possible scores: `{"LR+": 1.0, "LR-": 1.0}`
    - a dict in the format `{"LR+": value_1, "LR-": value_2}` where the values can
      be non-negative floats, `np.inf` or `np.nan` in the range of the
      likelihood ratios. For example, `{"LR+": 1.0, "LR-": 1.0}` can be used for
      returning the worst scores, indicating a useless model, and `{"LR+": np.inf,
      "LR-": 0.0}` can be used for returning the best scores, indicating a useful
      model.

    If a division by zero occurs, only the affected metric is replaced with the set
    value; the other metric is calculated as usual.

    .. versionadded:: 1.7

Returns
-------
(positive_likelihood_ratio, negative_likelihood_ratio) : tuple
    A tuple of two floats, the first containing the positive likelihood ratio (LR+)
    and the second the negative likelihood ratio (LR-).

Warns
-----
Raises :class:`~sklearn.exceptions.UndefinedMetricWarning` when `y_true` and
`y_pred` lead to the following conditions:

    - The number of false positives is 0 and `raise_warning` is set to `True`
      (default): positive likelihood ratio is undefined.
    - The number of true negatives is 0 and `raise_warning` is set to `True`
      (default): negative likelihood ratio is undefined.
    - The sum of true positives and false negatives is 0 (no samples of the positive
      class are present in `y_true`): both likelihood ratios are undefined.

    For the first two cases, an undefined metric can be defined by setting the
    `replace_undefined_by` param.

References
----------
.. [1] `Wikipedia entry for the Likelihood ratios in diagnostic testing
       &lt;https://en.wikipedia.org/wiki/Likelihood_ratios_in_diagnostic_testing&gt;`_.

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from sklearn.metrics import class_likelihood_ratios
&gt;&gt;&gt; class_likelihood_ratios([0, 1, 0, 1, 0], [1, 1, 0, 0, 0])
(1.5, 0.75)
&gt;&gt;&gt; y_true = np.array(["non-cat", "cat", "non-cat", "cat", "non-cat"])
&gt;&gt;&gt; y_pred = np.array(["cat", "cat", "non-cat", "non-cat", "non-cat"])
&gt;&gt;&gt; class_likelihood_ratios(y_true, y_pred)
(1.33, 0.66)
&gt;&gt;&gt; y_true = np.array(["non-zebra", "zebra", "non-zebra", "zebra", "non-zebra"])
&gt;&gt;&gt; y_pred = np.array(["zebra", "zebra", "non-zebra", "non-zebra", "non-zebra"])
&gt;&gt;&gt; class_likelihood_ratios(y_true, y_pred)
(1.5, 0.75)

To avoid ambiguities, use the notation `labels=[negative_class,
positive_class]`

&gt;&gt;&gt; y_true = np.array(["non-cat", "cat", "non-cat", "cat", "non-cat"])
&gt;&gt;&gt; y_pred = np.array(["cat", "cat", "non-cat", "non-cat", "non-cat"])
&gt;&gt;&gt; class_likelihood_ratios(y_true, y_pred, labels=["non-cat", "cat"])
(1.5, 0.75)
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l02087">2087</a> of file <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html">_classification.py</a>.</p>

<p class="reference">References <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l00069">_check_targets()</a>.</p>

</div>
</div>
<a id="aa3d62594d97dfc77db45e359f91ba6b7" name="aa3d62594d97dfc77db45e359f91ba6b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3d62594d97dfc77db45e359f91ba6b7">&#9670;&#160;</a></span>classification_report()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics._classification.classification_report </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y_true</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y_pred</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>labels</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>target_names</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>sample_weight</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>digits</em></span><span class="paramdefsep"> = </span><span class="paramdefval">2</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>output_dict</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>zero_division</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;warn&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Build a text report showing the main classification metrics.

Read more in the :ref:`User Guide &lt;classification_report&gt;`.

Parameters
----------
y_true : 1d array-like, or label indicator array / sparse matrix
    Ground truth (correct) target values.

y_pred : 1d array-like, or label indicator array / sparse matrix
    Estimated targets as returned by a classifier.

labels : array-like of shape (n_labels,), default=None
    Optional list of label indices to include in the report.

target_names : array-like of shape (n_labels,), default=None
    Optional display names matching the labels (same order).

sample_weight : array-like of shape (n_samples,), default=None
    Sample weights.

digits : int, default=2
    Number of digits for formatting output floating point values.
    When ``output_dict`` is ``True``, this will be ignored and the
    returned values will not be rounded.

output_dict : bool, default=False
    If True, return output as dict.

    .. versionadded:: 0.20

zero_division : {"warn", 0.0, 1.0, np.nan}, default="warn"
    Sets the value to return when there is a zero division. If set to
    "warn", this acts as 0, but warnings are also raised.

    .. versionadded:: 1.3
       `np.nan` option was added.

Returns
-------
report : str or dict
    Text summary of the precision, recall, F1 score for each class.
    Dictionary returned if output_dict is True. Dictionary has the
    following structure::

        {'label 1': {'precision':0.5,
                     'recall':1.0,
                     'f1-score':0.67,
                     'support':1},
         'label 2': { ... },
          ...
        }

    The reported averages include macro average (averaging the unweighted
    mean per label), weighted average (averaging the support-weighted mean
    per label), and sample average (only for multilabel classification).
    Micro average (averaging the total true positives, false negatives and
    false positives) is only shown for multi-label or multi-class
    with a subset of classes, because it corresponds to accuracy
    otherwise and would be the same for all metrics.
    See also :func:`precision_recall_fscore_support` for more details
    on averages.

    Note that in binary classification, recall of the positive class
    is also known as "sensitivity"; recall of the negative class is
    "specificity".

See Also
--------
precision_recall_fscore_support: Compute precision, recall, F-measure and
    support for each class.
confusion_matrix: Compute confusion matrix to evaluate the accuracy of a
    classification.
multilabel_confusion_matrix: Compute a confusion matrix for each class or sample.

Examples
--------
&gt;&gt;&gt; from sklearn.metrics import classification_report
&gt;&gt;&gt; y_true = [0, 1, 2, 2, 2]
&gt;&gt;&gt; y_pred = [0, 0, 2, 2, 1]
&gt;&gt;&gt; target_names = ['class 0', 'class 1', 'class 2']
&gt;&gt;&gt; print(classification_report(y_true, y_pred, target_names=target_names))
              precision    recall  f1-score   support
&lt;BLANKLINE&gt;
     class 0       0.50      1.00      0.67         1
     class 1       0.00      0.00      0.00         1
     class 2       1.00      0.67      0.80         3
&lt;BLANKLINE&gt;
    accuracy                           0.60         5
   macro avg       0.50      0.56      0.49         5
weighted avg       0.70      0.60      0.61         5
&lt;BLANKLINE&gt;
&gt;&gt;&gt; y_pred = [1, 1, 0]
&gt;&gt;&gt; y_true = [1, 1, 1]
&gt;&gt;&gt; print(classification_report(y_true, y_pred, labels=[1, 2, 3]))
              precision    recall  f1-score   support
&lt;BLANKLINE&gt;
           1       1.00      0.67      0.80         3
           2       0.00      0.00      0.00         0
           3       0.00      0.00      0.00         0
&lt;BLANKLINE&gt;
   micro avg       1.00      0.67      0.80         3
   macro avg       0.33      0.22      0.27         3
weighted avg       1.00      0.67      0.80         3
&lt;BLANKLINE&gt;
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l02829">2829</a> of file <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html">_classification.py</a>.</p>

<p class="reference">References <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l00069">_check_targets()</a>, and <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l01826">precision_recall_fscore_support()</a>.</p>

</div>
</div>
<a id="a7430b47501eea60d89bf4abec2eef197" name="a7430b47501eea60d89bf4abec2eef197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7430b47501eea60d89bf4abec2eef197">&#9670;&#160;</a></span>cohen_kappa_score()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics._classification.cohen_kappa_score </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>labels</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>weights</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>sample_weight</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute Cohen's kappa: a statistic that measures inter-annotator agreement.

This function computes Cohen's kappa [1]_, a score that expresses the level
of agreement between two annotators on a classification problem. It is
defined as

.. math::
    \kappa = (p_o - p_e) / (1 - p_e)

where :math:`p_o` is the empirical probability of agreement on the label
assigned to any sample (the observed agreement ratio), and :math:`p_e` is
the expected agreement when both annotators assign labels randomly.
:math:`p_e` is estimated using a per-annotator empirical prior over the
class labels [2]_.

Read more in the :ref:`User Guide &lt;cohen_kappa&gt;`.

Parameters
----------
y1 : array-like of shape (n_samples,)
    Labels assigned by the first annotator.

y2 : array-like of shape (n_samples,)
    Labels assigned by the second annotator. The kappa statistic is
    symmetric, so swapping ``y1`` and ``y2`` doesn't change the value.

labels : array-like of shape (n_classes,), default=None
    List of labels to index the matrix. This may be used to select a
    subset of labels. If `None`, all labels that appear at least once in
    ``y1`` or ``y2`` are used. Note that at least one label in `labels` must be
    present in `y1`, even though this function is otherwise agnostic to the order
    of `y1` and `y2`.

weights : {'linear', 'quadratic'}, default=None
    Weighting type to calculate the score. `None` means not weighted;
    "linear" means linear weighting; "quadratic" means quadratic weighting.

sample_weight : array-like of shape (n_samples,), default=None
    Sample weights.

Returns
-------
kappa : float
    The kappa statistic, which is a number between -1 and 1. The maximum
    value means complete agreement; zero or lower means chance agreement.

References
----------
.. [1] :doi:`J. Cohen (1960). "A coefficient of agreement for nominal scales".
       Educational and Psychological Measurement 20(1):37-46.
       &lt;10.1177/001316446002000104&gt;`
.. [2] `R. Artstein and M. Poesio (2008). "Inter-coder agreement for
       computational linguistics". Computational Linguistics 34(4):555-596
       &lt;https://www.mitpressjournals.org/doi/pdf/10.1162/coli.07-034-R2&gt;`_.
.. [3] `Wikipedia entry for the Cohen's kappa
        &lt;https://en.wikipedia.org/wiki/Cohen%27s_kappa&gt;`_.

Examples
--------
&gt;&gt;&gt; from sklearn.metrics import cohen_kappa_score
&gt;&gt;&gt; y1 = ["negative", "positive", "negative", "neutral", "positive"]
&gt;&gt;&gt; y2 = ["negative", "positive", "negative", "neutral", "negative"]
&gt;&gt;&gt; cohen_kappa_score(y1, y2)
0.6875
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l00803">803</a> of file <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html">_classification.py</a>.</p>

</div>
</div>
<a id="a9bdecf060bbdd6ebe26f442d9d3f1382" name="a9bdecf060bbdd6ebe26f442d9d3f1382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bdecf060bbdd6ebe26f442d9d3f1382">&#9670;&#160;</a></span>confusion_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics._classification.confusion_matrix </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y_true</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y_pred</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>labels</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>sample_weight</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>normalize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute confusion matrix to evaluate the accuracy of a classification.

By definition a confusion matrix :math:`C` is such that :math:`C_{i, j}`
is equal to the number of observations known to be in group :math:`i` and
predicted to be in group :math:`j`.

Thus in binary classification, the count of true negatives is
:math:`C_{0,0}`, false negatives is :math:`C_{1,0}`, true positives is
:math:`C_{1,1}` and false positives is :math:`C_{0,1}`.

Read more in the :ref:`User Guide &lt;confusion_matrix&gt;`.

Parameters
----------
y_true : array-like of shape (n_samples,)
    Ground truth (correct) target values.

y_pred : array-like of shape (n_samples,)
    Estimated targets as returned by a classifier.

labels : array-like of shape (n_classes), default=None
    List of labels to index the matrix. This may be used to reorder
    or select a subset of labels.
    If ``None`` is given, those that appear at least once
    in ``y_true`` or ``y_pred`` are used in sorted order.

sample_weight : array-like of shape (n_samples,), default=None
    Sample weights.

    .. versionadded:: 0.18

normalize : {'true', 'pred', 'all'}, default=None
    Normalizes confusion matrix over the true (rows), predicted (columns)
    conditions or all the population. If None, confusion matrix will not be
    normalized.

Returns
-------
C : ndarray of shape (n_classes, n_classes)
    Confusion matrix whose i-th row and j-th
    column entry indicates the number of
    samples with true label being i-th class
    and predicted label being j-th class.

See Also
--------
ConfusionMatrixDisplay.from_estimator : Plot the confusion matrix
    given an estimator, the data, and the label.
ConfusionMatrixDisplay.from_predictions : Plot the confusion matrix
    given the true and predicted labels.
ConfusionMatrixDisplay : Confusion Matrix visualization.

References
----------
.. [1] `Wikipedia entry for the Confusion matrix
       &lt;https://en.wikipedia.org/wiki/Confusion_matrix&gt;`_
       (Wikipedia and other references may use a different
       convention for axes).

Examples
--------
&gt;&gt;&gt; from sklearn.metrics import confusion_matrix
&gt;&gt;&gt; y_true = [2, 0, 2, 2, 0, 1]
&gt;&gt;&gt; y_pred = [0, 0, 2, 2, 0, 2]
&gt;&gt;&gt; confusion_matrix(y_true, y_pred)
array([[2, 0, 0],
       [0, 0, 1],
       [1, 0, 2]])

&gt;&gt;&gt; y_true = ["cat", "ant", "cat", "cat", "ant", "bird"]
&gt;&gt;&gt; y_pred = ["ant", "ant", "cat", "cat", "ant", "cat"]
&gt;&gt;&gt; confusion_matrix(y_true, y_pred, labels=["ant", "bird", "cat"])
array([[2, 0, 0],
       [0, 0, 1],
       [1, 0, 2]])

In the binary case, we can extract true positives, etc. as follows:

&gt;&gt;&gt; tn, fp, fn, tp = confusion_matrix([0, 1, 0, 1], [1, 1, 1, 0]).ravel().tolist()
&gt;&gt;&gt; (tn, fp, fn, tp)
(0, 2, 1, 1)
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l00381">381</a> of file <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html">_classification.py</a>.</p>

<p class="reference">References <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l00069">_check_targets()</a>.</p>

</div>
</div>
<a id="a457f569cc9a5bb6f2172dde936d3be7f" name="a457f569cc9a5bb6f2172dde936d3be7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a457f569cc9a5bb6f2172dde936d3be7f">&#9670;&#160;</a></span>d2_log_loss_score()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics._classification.d2_log_loss_score </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y_true</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y_pred</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>sample_weight</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>labels</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">:math:`D^2` score function, fraction of log loss explained.

Best possible score is 1.0 and it can be negative (because the model can be
arbitrarily worse). A model that always predicts the per-class proportions
of `y_true`, disregarding the input features, gets a D^2 score of 0.0.

Read more in the :ref:`User Guide &lt;d2_score_classification&gt;`.

.. versionadded:: 1.5

Parameters
----------
y_true : array-like or label indicator matrix
    The actuals labels for the n_samples samples.

y_pred : array-like of shape (n_samples, n_classes) or (n_samples,)
    Predicted probabilities, as returned by a classifier's
    predict_proba method. If ``y_pred.shape = (n_samples,)``
    the probabilities provided are assumed to be that of the
    positive class. The labels in ``y_pred`` are assumed to be
    ordered alphabetically, as done by
    :class:`~sklearn.preprocessing.LabelBinarizer`.

sample_weight : array-like of shape (n_samples,), default=None
    Sample weights.

labels : array-like, default=None
    If not provided, labels will be inferred from y_true. If ``labels``
    is ``None`` and ``y_pred`` has shape (n_samples,) the labels are
    assumed to be binary and are inferred from ``y_true``.

Returns
-------
d2 : float or ndarray of floats
    The D^2 score.

Notes
-----
This is not a symmetric function.

Like R^2, D^2 score may be negative (it need not actually be the square of
a quantity D).

This metric is not well-defined for a single sample and will return a NaN
value if n_samples is less than two.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l03638">3638</a> of file <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html">_classification.py</a>.</p>

<p class="reference">References <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l03172">log_loss()</a>.</p>

</div>
</div>
<a id="a5d31c24f718a99decc9441f1e82a7329" name="a5d31c24f718a99decc9441f1e82a7329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d31c24f718a99decc9441f1e82a7329">&#9670;&#160;</a></span>f1_score()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics._classification.f1_score </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y_true</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y_pred</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>labels</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>pos_label</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>average</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;binary&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>sample_weight</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>zero_division</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;warn&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the F1 score, also known as balanced F-score or F-measure.

The F1 score can be interpreted as a harmonic mean of the precision and
recall, where an F1 score reaches its best value at 1 and worst score at 0.
The relative contribution of precision and recall to the F1 score are
equal. The formula for the F1 score is:

.. math::
    \\text{F1} = \\frac{2 * \\text{TP}}{2 * \\text{TP} + \\text{FP} + \\text{FN}}

Where :math:`\\text{TP}` is the number of true positives, :math:`\\text{FN}` is the
number of false negatives, and :math:`\\text{FP}` is the number of false positives.
F1 is by default
calculated as 0.0 when there are no true positives, false negatives, or
false positives.

Support beyond :term:`binary` targets is achieved by treating :term:`multiclass`
and :term:`multilabel` data as a collection of binary problems, one for each
label. For the :term:`binary` case, setting `average='binary'` will return
F1 score for `pos_label`. If `average` is not `'binary'`, `pos_label` is ignored
and F1 score for both classes are computed, then averaged or both returned (when
`average=None`). Similarly, for :term:`multiclass` and :term:`multilabel` targets,
F1 score for all `labels` are either returned or averaged depending on the
`average` parameter. Use `labels` specify the set of labels to calculate F1 score
for.

Read more in the :ref:`User Guide &lt;precision_recall_f_measure_metrics&gt;`.

Parameters
----------
y_true : 1d array-like, or label indicator array / sparse matrix
    Ground truth (correct) target values.

y_pred : 1d array-like, or label indicator array / sparse matrix
    Estimated targets as returned by a classifier.

labels : array-like, default=None
    The set of labels to include when `average != 'binary'`, and their
    order if `average is None`. Labels present in the data can be
    excluded, for example in multiclass classification to exclude a "negative
    class". Labels not present in the data can be included and will be
    "assigned" 0 samples. For multilabel targets, labels are column indices.
    By default, all labels in `y_true` and `y_pred` are used in sorted order.

    .. versionchanged:: 0.17
       Parameter `labels` improved for multiclass problem.

pos_label : int, float, bool or str, default=1
    The class to report if `average='binary'` and the data is binary,
    otherwise this parameter is ignored.
    For multiclass or multilabel targets, set `labels=[pos_label]` and
    `average != 'binary'` to report metrics for one label only.

average : {'micro', 'macro', 'samples', 'weighted', 'binary'} or None, \
        default='binary'
    This parameter is required for multiclass/multilabel targets.
    If ``None``, the metrics for each class are returned. Otherwise, this
    determines the type of averaging performed on the data:

    ``'binary'``:
        Only report results for the class specified by ``pos_label``.
        This is applicable only if targets (``y_{true,pred}``) are binary.
    ``'micro'``:
        Calculate metrics globally by counting the total true positives,
        false negatives and false positives.
    ``'macro'``:
        Calculate metrics for each label, and find their unweighted
        mean.  This does not take label imbalance into account.
    ``'weighted'``:
        Calculate metrics for each label, and find their average weighted
        by support (the number of true instances for each label). This
        alters 'macro' to account for label imbalance; it can result in an
        F-score that is not between precision and recall.
    ``'samples'``:
        Calculate metrics for each instance, and find their average (only
        meaningful for multilabel classification where this differs from
        :func:`accuracy_score`).

sample_weight : array-like of shape (n_samples,), default=None
    Sample weights.

zero_division : {"warn", 0.0, 1.0, np.nan}, default="warn"
    Sets the value to return when there is a zero division, i.e. when all
    predictions and labels are negative.

    Notes:
    - If set to "warn", this acts like 0, but a warning is also raised.
    - If set to `np.nan`, such values will be excluded from the average.

    .. versionadded:: 1.3
       `np.nan` option was added.

Returns
-------
f1_score : float or array of float, shape = [n_unique_labels]
    F1 score of the positive class in binary classification or weighted
    average of the F1 scores of each class for the multiclass task.

See Also
--------
fbeta_score : Compute the F-beta score.
precision_recall_fscore_support : Compute the precision, recall, F-score,
    and support.
jaccard_score : Compute the Jaccard similarity coefficient score.
multilabel_confusion_matrix : Compute a confusion matrix for each class or
    sample.

Notes
-----
When ``true positive + false positive + false negative == 0`` (i.e. a class
is completely absent from both ``y_true`` or ``y_pred``), f-score is
undefined. In such cases, by default f-score will be set to 0.0, and
``UndefinedMetricWarning`` will be raised. This behavior can be modified by
setting the ``zero_division`` parameter.

References
----------
.. [1] `Wikipedia entry for the F1-score
       &lt;https://en.wikipedia.org/wiki/F1_score&gt;`_.

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from sklearn.metrics import f1_score
&gt;&gt;&gt; y_true = [0, 1, 2, 0, 1, 2]
&gt;&gt;&gt; y_pred = [0, 2, 1, 0, 0, 1]
&gt;&gt;&gt; f1_score(y_true, y_pred, average='macro')
0.267
&gt;&gt;&gt; f1_score(y_true, y_pred, average='micro')
0.33
&gt;&gt;&gt; f1_score(y_true, y_pred, average='weighted')
0.267
&gt;&gt;&gt; f1_score(y_true, y_pred, average=None)
array([0.8, 0. , 0. ])

&gt;&gt;&gt; # binary classification
&gt;&gt;&gt; y_true_empty = [0, 0, 0, 0, 0, 0]
&gt;&gt;&gt; y_pred_empty = [0, 0, 0, 0, 0, 0]
&gt;&gt;&gt; f1_score(y_true_empty, y_pred_empty)
0.0...
&gt;&gt;&gt; f1_score(y_true_empty, y_pred_empty, zero_division=1.0)
1.0...
&gt;&gt;&gt; f1_score(y_true_empty, y_pred_empty, zero_division=np.nan)
nan...

&gt;&gt;&gt; # multilabel classification
&gt;&gt;&gt; y_true = [[0, 0, 0], [1, 1, 1], [0, 1, 1]]
&gt;&gt;&gt; y_pred = [[0, 0, 0], [1, 1, 1], [1, 1, 0]]
&gt;&gt;&gt; f1_score(y_true, y_pred, average=None)
array([0.66666667, 1.        , 0.66666667])
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l01304">1304</a> of file <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html">_classification.py</a>.</p>

<p class="reference">References <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l01507">fbeta_score()</a>.</p>

</div>
</div>
<a id="ada551803819b8de72f08d36b10c2775b" name="ada551803819b8de72f08d36b10c2775b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada551803819b8de72f08d36b10c2775b">&#9670;&#160;</a></span>fbeta_score()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics._classification.fbeta_score </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y_true</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y_pred</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>beta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>labels</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>pos_label</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>average</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;binary&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>sample_weight</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>zero_division</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;warn&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the F-beta score.

The F-beta score is the weighted harmonic mean of precision and recall,
reaching its optimal value at 1 and its worst value at 0.

The `beta` parameter represents the ratio of recall importance to
precision importance. `beta &gt; 1` gives more weight to recall, while
`beta &lt; 1` favors precision. For example, `beta = 2` makes recall twice
as important as precision, while `beta = 0.5` does the opposite.
Asymptotically, `beta -&gt; +inf` considers only recall, and `beta -&gt; 0`
only precision.

The formula for F-beta score is:

.. math::

   F_\\beta = \\frac{(1 + \\beta^2) \\text{tp}}
                    {(1 + \\beta^2) \\text{tp} + \\text{fp} + \\beta^2 \\text{fn}}

Where :math:`\\text{tp}` is the number of true positives, :math:`\\text{fp}` is the
number of false positives, and :math:`\\text{fn}` is the number of false negatives.

Support beyond term:`binary` targets is achieved by treating :term:`multiclass`
and :term:`multilabel` data as a collection of binary problems, one for each
label. For the :term:`binary` case, setting `average='binary'` will return
F-beta score for `pos_label`. If `average` is not `'binary'`, `pos_label` is
ignored and F-beta score for both classes are computed, then averaged or both
returned (when `average=None`). Similarly, for :term:`multiclass` and
:term:`multilabel` targets, F-beta score for all `labels` are either returned or
averaged depending on the `average` parameter. Use `labels` specify the set of
labels to calculate F-beta score for.

Read more in the :ref:`User Guide &lt;precision_recall_f_measure_metrics&gt;`.

Parameters
----------
y_true : 1d array-like, or label indicator array / sparse matrix
    Ground truth (correct) target values.

y_pred : 1d array-like, or label indicator array / sparse matrix
    Estimated targets as returned by a classifier.

beta : float
    Determines the weight of recall in the combined score.

labels : array-like, default=None
    The set of labels to include when `average != 'binary'`, and their
    order if `average is None`. Labels present in the data can be
    excluded, for example in multiclass classification to exclude a "negative
    class". Labels not present in the data can be included and will be
    "assigned" 0 samples. For multilabel targets, labels are column indices.
    By default, all labels in `y_true` and `y_pred` are used in sorted order.

    .. versionchanged:: 0.17
       Parameter `labels` improved for multiclass problem.

pos_label : int, float, bool or str, default=1
    The class to report if `average='binary'` and the data is binary,
    otherwise this parameter is ignored.
    For multiclass or multilabel targets, set `labels=[pos_label]` and
    `average != 'binary'` to report metrics for one label only.

average : {'micro', 'macro', 'samples', 'weighted', 'binary'} or None, \
        default='binary'
    This parameter is required for multiclass/multilabel targets.
    If ``None``, the metrics for each class are returned. Otherwise, this
    determines the type of averaging performed on the data:

    ``'binary'``:
        Only report results for the class specified by ``pos_label``.
        This is applicable only if targets (``y_{true,pred}``) are binary.
    ``'micro'``:
        Calculate metrics globally by counting the total true positives,
        false negatives and false positives.
    ``'macro'``:
        Calculate metrics for each label, and find their unweighted
        mean.  This does not take label imbalance into account.
    ``'weighted'``:
        Calculate metrics for each label, and find their average weighted
        by support (the number of true instances for each label). This
        alters 'macro' to account for label imbalance; it can result in an
        F-score that is not between precision and recall.
    ``'samples'``:
        Calculate metrics for each instance, and find their average (only
        meaningful for multilabel classification where this differs from
        :func:`accuracy_score`).

sample_weight : array-like of shape (n_samples,), default=None
    Sample weights.

zero_division : {"warn", 0.0, 1.0, np.nan}, default="warn"
    Sets the value to return when there is a zero division, i.e. when all
    predictions and labels are negative.

    Notes:

    - If set to "warn", this acts like 0, but a warning is also raised.
    - If set to `np.nan`, such values will be excluded from the average.

    .. versionadded:: 1.3
       `np.nan` option was added.

Returns
-------
fbeta_score : float (if average is not None) or array of float, shape =\
    [n_unique_labels]
    F-beta score of the positive class in binary classification or weighted
    average of the F-beta score of each class for the multiclass task.

See Also
--------
precision_recall_fscore_support : Compute the precision, recall, F-score,
    and support.
multilabel_confusion_matrix : Compute a confusion matrix for each class or
    sample.

Notes
-----
When ``true positive + false positive + false negative == 0``, f-score
returns 0.0 and raises ``UndefinedMetricWarning``. This behavior can be
modified by setting ``zero_division``.

F-beta score is not implemented as a named scorer that can be passed to
the `scoring` parameter of cross-validation tools directly: it requires to be
wrapped with :func:`make_scorer` so as to specify the value of `beta`. See
examples for details.

References
----------
.. [1] R. Baeza-Yates and B. Ribeiro-Neto (2011).
       Modern Information Retrieval. Addison Wesley, pp. 327-328.

.. [2] `Wikipedia entry for the F1-score
       &lt;https://en.wikipedia.org/wiki/F1_score&gt;`_.

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from sklearn.metrics import fbeta_score
&gt;&gt;&gt; y_true = [0, 1, 2, 0, 1, 2]
&gt;&gt;&gt; y_pred = [0, 2, 1, 0, 0, 1]
&gt;&gt;&gt; fbeta_score(y_true, y_pred, average='macro', beta=0.5)
0.238
&gt;&gt;&gt; fbeta_score(y_true, y_pred, average='micro', beta=0.5)
0.33
&gt;&gt;&gt; fbeta_score(y_true, y_pred, average='weighted', beta=0.5)
0.238
&gt;&gt;&gt; fbeta_score(y_true, y_pred, average=None, beta=0.5)
array([0.71, 0.        , 0.        ])
&gt;&gt;&gt; y_pred_empty = [0, 0, 0, 0, 0, 0]
&gt;&gt;&gt; fbeta_score(
...     y_true,
...     y_pred_empty,
...     average="macro",
...     zero_division=np.nan,
...     beta=0.5,
... )
0.128

In order to use :func:`fbeta_scorer` as a scorer, a callable
scorer objects needs to be created first with :func:`make_scorer`,
passing the value for the `beta` parameter.

&gt;&gt;&gt; from sklearn.metrics import fbeta_score, make_scorer
&gt;&gt;&gt; ftwo_scorer = make_scorer(fbeta_score, beta=2)
&gt;&gt;&gt; from sklearn.model_selection import GridSearchCV
&gt;&gt;&gt; from sklearn.svm import LinearSVC
&gt;&gt;&gt; grid = GridSearchCV(
...     LinearSVC(dual="auto"),
...     param_grid={'C': [1, 10]},
...     scoring=ftwo_scorer,
...     cv=5
... )
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l01497">1497</a> of file <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html">_classification.py</a>.</p>

<p class="reference">References <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l01826">precision_recall_fscore_support()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l01313">f1_score()</a>.</p>

</div>
</div>
<a id="a1726217c03db123e1bbc0ae220edabe4" name="a1726217c03db123e1bbc0ae220edabe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1726217c03db123e1bbc0ae220edabe4">&#9670;&#160;</a></span>hamming_loss()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics._classification.hamming_loss </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y_true</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y_pred</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>sample_weight</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the average Hamming loss.

The Hamming loss is the fraction of labels that are incorrectly predicted.

Read more in the :ref:`User Guide &lt;hamming_loss&gt;`.

Parameters
----------
y_true : 1d array-like, or label indicator array / sparse matrix
    Ground truth (correct) labels.

y_pred : 1d array-like, or label indicator array / sparse matrix
    Predicted labels, as returned by a classifier.

sample_weight : array-like of shape (n_samples,), default=None
    Sample weights.

    .. versionadded:: 0.18

Returns
-------
loss : float or int
    Return the average Hamming loss between element of ``y_true`` and
    ``y_pred``.

See Also
--------
accuracy_score : Compute the accuracy score. By default, the function will
    return the fraction of correct predictions divided by the total number
    of predictions.
jaccard_score : Compute the Jaccard similarity coefficient score.
zero_one_loss : Compute the Zero-one classification loss. By default, the
    function will return the percentage of imperfectly predicted subsets.

Notes
-----
In multiclass classification, the Hamming loss corresponds to the Hamming
distance between ``y_true`` and ``y_pred`` which is equivalent to the
subset ``zero_one_loss`` function, when `normalize` parameter is set to
True.

In multilabel classification, the Hamming loss is different from the
subset zero-one loss. The zero-one loss considers the entire set of labels
for a given sample incorrect if it does not entirely match the true set of
labels. Hamming loss is more forgiving in that it penalizes only the
individual labels.

The Hamming loss is upperbounded by the subset zero-one loss, when
`normalize` parameter is set to True. It is always between 0 and 1,
lower being better.

References
----------
.. [1] Grigorios Tsoumakas, Ioannis Katakis. Multi-Label Classification:
       An Overview. International Journal of Data Warehousing &amp; Mining,
       3(3), 1-13, July-September 2007.

.. [2] `Wikipedia entry on the Hamming distance
       &lt;https://en.wikipedia.org/wiki/Hamming_distance&gt;`_.

Examples
--------
&gt;&gt;&gt; from sklearn.metrics import hamming_loss
&gt;&gt;&gt; y_pred = [1, 2, 3, 4]
&gt;&gt;&gt; y_true = [2, 2, 3, 4]
&gt;&gt;&gt; hamming_loss(y_true, y_pred)
0.25

In the multilabel case with binary label indicators:

&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; hamming_loss(np.array([[0, 1], [1, 1]]), np.zeros((2, 2)))
0.75
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l03061">3061</a> of file <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html">_classification.py</a>.</p>

<p class="reference">References <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l00069">_check_targets()</a>.</p>

</div>
</div>
<a id="a8b103f5754e2cfae479b2d92e59f53fd" name="a8b103f5754e2cfae479b2d92e59f53fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b103f5754e2cfae479b2d92e59f53fd">&#9670;&#160;</a></span>hinge_loss()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics._classification.hinge_loss </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y_true</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>pred_decision</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>labels</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>sample_weight</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Average hinge loss (non-regularized).

In binary class case, assuming labels in y_true are encoded with +1 and -1,
when a prediction mistake is made, ``margin = y_true * pred_decision`` is
always negative (since the signs disagree), implying ``1 - margin`` is
always greater than 1.  The cumulated hinge loss is therefore an upper
bound of the number of mistakes made by the classifier.

In multiclass case, the function expects that either all the labels are
included in y_true or an optional labels argument is provided which
contains all the labels. The multilabel margin is calculated according
to Crammer-Singer's method. As in the binary case, the cumulated hinge loss
is an upper bound of the number of mistakes made by the classifier.

Read more in the :ref:`User Guide &lt;hinge_loss&gt;`.

Parameters
----------
y_true : array-like of shape (n_samples,)
    True target, consisting of integers of two values. The positive label
    must be greater than the negative label.

pred_decision : array-like of shape (n_samples,) or (n_samples, n_classes)
    Predicted decisions, as output by decision_function (floats).

labels : array-like, default=None
    Contains all the labels for the problem. Used in multiclass hinge loss.

sample_weight : array-like of shape (n_samples,), default=None
    Sample weights.

Returns
-------
loss : float
    Average hinge loss.

References
----------
.. [1] `Wikipedia entry on the Hinge loss
       &lt;https://en.wikipedia.org/wiki/Hinge_loss&gt;`_.

.. [2] Koby Crammer, Yoram Singer. On the Algorithmic
       Implementation of Multiclass Kernel-based Vector
       Machines. Journal of Machine Learning Research 2,
       (2001), 265-292.

.. [3] `L1 AND L2 Regularization for Multiclass Hinge Loss Models
       by Robert C. Moore, John DeNero
       &lt;https://storage.googleapis.com/pub-tools-public-publication-data/pdf/37362.pdf&gt;`_.

Examples
--------
&gt;&gt;&gt; from sklearn import svm
&gt;&gt;&gt; from sklearn.metrics import hinge_loss
&gt;&gt;&gt; X = [[0], [1]]
&gt;&gt;&gt; y = [-1, 1]
&gt;&gt;&gt; est = svm.LinearSVC(random_state=0)
&gt;&gt;&gt; est.fit(X, y)
LinearSVC(random_state=0)
&gt;&gt;&gt; pred_decision = est.decision_function([[-2], [3], [0.5]])
&gt;&gt;&gt; pred_decision
array([-2.18,  2.36,  0.09])
&gt;&gt;&gt; hinge_loss([-1, 1, 1], pred_decision)
0.30

In the multiclass case:

&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; X = np.array([[0], [1], [2], [3]])
&gt;&gt;&gt; Y = np.array([0, 1, 2, 3])
&gt;&gt;&gt; labels = np.array([0, 1, 2, 3])
&gt;&gt;&gt; est = svm.LinearSVC()
&gt;&gt;&gt; est.fit(X, Y)
LinearSVC()
&gt;&gt;&gt; pred_decision = est.decision_function([[-1], [2], [3]])
&gt;&gt;&gt; y_true = [0, 2, 3]
&gt;&gt;&gt; hinge_loss(y_true, pred_decision, labels=labels)
0.56
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l03262">3262</a> of file <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html">_classification.py</a>.</p>

</div>
</div>
<a id="aba21abda11d69893f8ae3727cb64472f" name="aba21abda11d69893f8ae3727cb64472f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba21abda11d69893f8ae3727cb64472f">&#9670;&#160;</a></span>jaccard_score()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics._classification.jaccard_score </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y_true</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y_pred</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>labels</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>pos_label</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>average</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;binary&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>sample_weight</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>zero_division</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;warn&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Jaccard similarity coefficient score.

The Jaccard index [1], or Jaccard similarity coefficient, defined as
the size of the intersection divided by the size of the union of two label
sets, is used to compare set of predicted labels for a sample to the
corresponding set of labels in ``y_true``.

Support beyond term:`binary` targets is achieved by treating :term:`multiclass`
and :term:`multilabel` data as a collection of binary problems, one for each
label. For the :term:`binary` case, setting `average='binary'` will return the
Jaccard similarity coefficient for `pos_label`. If `average` is not `'binary'`,
`pos_label` is ignored and scores for both classes are computed, then averaged or
both returned (when `average=None`). Similarly, for :term:`multiclass` and
:term:`multilabel` targets, scores for all `labels` are either returned or
averaged depending on the `average` parameter. Use `labels` specify the set of
labels to calculate the score for.

Read more in the :ref:`User Guide &lt;jaccard_similarity_score&gt;`.

Parameters
----------
y_true : 1d array-like, or label indicator array / sparse matrix
    Ground truth (correct) labels.

y_pred : 1d array-like, or label indicator array / sparse matrix
    Predicted labels, as returned by a classifier.

labels : array-like of shape (n_classes,), default=None
    The set of labels to include when `average != 'binary'`, and their
    order if `average is None`. Labels present in the data can be
    excluded, for example in multiclass classification to exclude a "negative
    class". Labels not present in the data can be included and will be
    "assigned" 0 samples. For multilabel targets, labels are column indices.
    By default, all labels in `y_true` and `y_pred` are used in sorted order.

pos_label : int, float, bool or str, default=1
    The class to report if `average='binary'` and the data is binary,
    otherwise this parameter is ignored.
    For multiclass or multilabel targets, set `labels=[pos_label]` and
    `average != 'binary'` to report metrics for one label only.

average : {'micro', 'macro', 'samples', 'weighted', \
        'binary'} or None, default='binary'
    If ``None``, the scores for each class are returned. Otherwise, this
    determines the type of averaging performed on the data:

    ``'binary'``:
        Only report results for the class specified by ``pos_label``.
        This is applicable only if targets (``y_{true,pred}``) are binary.
    ``'micro'``:
        Calculate metrics globally by counting the total true positives,
        false negatives and false positives.
    ``'macro'``:
        Calculate metrics for each label, and find their unweighted
        mean.  This does not take label imbalance into account.
    ``'weighted'``:
        Calculate metrics for each label, and find their average, weighted
        by support (the number of true instances for each label). This
        alters 'macro' to account for label imbalance.
    ``'samples'``:
        Calculate metrics for each instance, and find their average (only
        meaningful for multilabel classification).

sample_weight : array-like of shape (n_samples,), default=None
    Sample weights.

zero_division : "warn", {0.0, 1.0}, default="warn"
    Sets the value to return when there is a zero division, i.e. when there
    there are no negative values in predictions and labels. If set to
    "warn", this acts like 0, but a warning is also raised.

    .. versionadded:: 0.24

Returns
-------
score : float or ndarray of shape (n_unique_labels,), dtype=np.float64
    The Jaccard score. When `average` is not `None`, a single scalar is
    returned.

See Also
--------
accuracy_score : Function for calculating the accuracy score.
f1_score : Function for calculating the F1 score.
multilabel_confusion_matrix : Function for computing a confusion matrix\
                              for each class or sample.

Notes
-----
:func:`jaccard_score` may be a poor metric if there are no
positives for some samples or classes. Jaccard is undefined if there are
no true or predicted labels, and our implementation will return a score
of 0 with a warning.

References
----------
.. [1] `Wikipedia entry for the Jaccard index
       &lt;https://en.wikipedia.org/wiki/Jaccard_index&gt;`_.

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from sklearn.metrics import jaccard_score
&gt;&gt;&gt; y_true = np.array([[0, 1, 1],
...                    [1, 1, 0]])
&gt;&gt;&gt; y_pred = np.array([[1, 1, 1],
...                    [1, 0, 0]])

In the binary case:

&gt;&gt;&gt; jaccard_score(y_true[0], y_pred[0])
0.6666

In the 2D comparison case (e.g. image similarity):

&gt;&gt;&gt; jaccard_score(y_true, y_pred, average="micro")
0.6

In the multilabel case:

&gt;&gt;&gt; jaccard_score(y_true, y_pred, average='samples')
0.5833
&gt;&gt;&gt; jaccard_score(y_true, y_pred, average='macro')
0.6666
&gt;&gt;&gt; jaccard_score(y_true, y_pred, average=None)
array([0.5, 0.5, 1. ])

In the multiclass case:

&gt;&gt;&gt; y_pred = [0, 2, 1, 2]
&gt;&gt;&gt; y_true = [0, 1, 2, 2]
&gt;&gt;&gt; jaccard_score(y_true, y_pred, average=None)
array([1. , 0. , 0.33])
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l00919">919</a> of file <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html">_classification.py</a>.</p>

<p class="reference">References <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l01752">_check_set_wise_labels()</a>, <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l01699">_prf_divide()</a>, and <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l00558">multilabel_confusion_matrix()</a>.</p>

</div>
</div>
<a id="a04f7198fff7b380c1a136c9d69c883ef" name="a04f7198fff7b380c1a136c9d69c883ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04f7198fff7b380c1a136c9d69c883ef">&#9670;&#160;</a></span>log_loss()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics._classification.log_loss </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y_true</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y_pred</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>normalize</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d8/d0b/classTrue.html">True</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>sample_weight</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>labels</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Log loss, aka logistic loss or cross-entropy loss.

This is the loss function used in (multinomial) logistic regression
and extensions of it such as neural networks, defined as the negative
log-likelihood of a logistic model that returns ``y_pred`` probabilities
for its training data ``y_true``.
The log loss is only defined for two or more labels.
For a single sample with true label :math:`y \in \{0,1\}` and
a probability estimate :math:`p = \operatorname{Pr}(y = 1)`, the log
loss is:

.. math::
    L_{\log}(y, p) = -(y \log (p) + (1 - y) \log (1 - p))

Read more in the :ref:`User Guide &lt;log_loss&gt;`.

Parameters
----------
y_true : array-like or label indicator matrix
    Ground truth (correct) labels for n_samples samples.

y_pred : array-like of float, shape = (n_samples, n_classes) or (n_samples,)
    Predicted probabilities, as returned by a classifier's
    predict_proba method. If ``y_pred.shape = (n_samples,)``
    the probabilities provided are assumed to be that of the
    positive class. The labels in ``y_pred`` are assumed to be
    ordered alphabetically, as done by
    :class:`~sklearn.preprocessing.LabelBinarizer`.

    `y_pred` values are clipped to `[eps, 1-eps]` where `eps` is the machine
    precision for `y_pred`'s dtype.

normalize : bool, default=True
    If true, return the mean loss per sample.
    Otherwise, return the sum of the per-sample losses.

sample_weight : array-like of shape (n_samples,), default=None
    Sample weights.

labels : array-like, default=None
    If not provided, labels will be inferred from y_true. If ``labels``
    is ``None`` and ``y_pred`` has shape (n_samples,) the labels are
    assumed to be binary and are inferred from ``y_true``.

    .. versionadded:: 0.18

Returns
-------
loss : float
    Log loss, aka logistic loss or cross-entropy loss.

Notes
-----
The logarithm used is the natural logarithm (base-e).

References
----------
C.M. Bishop (2006). Pattern Recognition and Machine Learning. Springer,
p. 209.

Examples
--------
&gt;&gt;&gt; from sklearn.metrics import log_loss
&gt;&gt;&gt; log_loss(["spam", "ham", "ham", "spam"],
...          [[.1, .9], [.9, .1], [.8, .2], [.35, .65]])
0.21616
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l03172">3172</a> of file <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html">_classification.py</a>.</p>

<p class="reference">References <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l00156">_validate_multiclass_probabilistic_prediction()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l03638">d2_log_loss_score()</a>.</p>

</div>
</div>
<a id="a68e73cd770f722164235c466adbf5a0c" name="a68e73cd770f722164235c466adbf5a0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68e73cd770f722164235c466adbf5a0c">&#9670;&#160;</a></span>matthews_corrcoef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics._classification.matthews_corrcoef </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y_true</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y_pred</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>sample_weight</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the Matthews correlation coefficient (MCC).

The Matthews correlation coefficient is used in machine learning as a
measure of the quality of binary and multiclass classifications. It takes
into account true and false positives and negatives and is generally
regarded as a balanced measure which can be used even if the classes are of
very different sizes. The MCC is in essence a correlation coefficient value
between -1 and +1. A coefficient of +1 represents a perfect prediction, 0
an average random prediction and -1 an inverse prediction.  The statistic
is also known as the phi coefficient. [source: Wikipedia]

Binary and multiclass labels are supported.  Only in the binary case does
this relate to information about true and false positives and negatives.
See references below.

Read more in the :ref:`User Guide &lt;matthews_corrcoef&gt;`.

Parameters
----------
y_true : array-like of shape (n_samples,)
    Ground truth (correct) target values.

y_pred : array-like of shape (n_samples,)
    Estimated targets as returned by a classifier.

sample_weight : array-like of shape (n_samples,), default=None
    Sample weights.

    .. versionadded:: 0.18

Returns
-------
mcc : float
    The Matthews correlation coefficient (+1 represents a perfect
    prediction, 0 an average random prediction and -1 and inverse
    prediction).

References
----------
.. [1] :doi:`Baldi, Brunak, Chauvin, Andersen and Nielsen, (2000). Assessing the
   accuracy of prediction algorithms for classification: an overview.
   &lt;10.1093/bioinformatics/16.5.412&gt;`

.. [2] `Wikipedia entry for the Matthews Correlation Coefficient (phi coefficient)
   &lt;https://en.wikipedia.org/wiki/Phi_coefficient&gt;`_.

.. [3] `Gorodkin, (2004). Comparing two K-category assignments by a
    K-category correlation coefficient
    &lt;https://www.sciencedirect.com/science/article/pii/S1476927104000799&gt;`_.

.. [4] `Jurman, Riccadonna, Furlanello, (2012). A Comparison of MCC and CEN
    Error Measures in MultiClass Prediction
    &lt;https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0041882&gt;`_.

Examples
--------
&gt;&gt;&gt; from sklearn.metrics import matthews_corrcoef
&gt;&gt;&gt; y_true = [+1, +1, +1, -1]
&gt;&gt;&gt; y_pred = [+1, -1, +1, +1]
&gt;&gt;&gt; matthews_corrcoef(y_true, y_pred)
-0.33
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l01110">1110</a> of file <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html">_classification.py</a>.</p>

<p class="reference">References <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l00069">_check_targets()</a>.</p>

</div>
</div>
<a id="a441d970c6097ed3b4af7dbb919e53813" name="a441d970c6097ed3b4af7dbb919e53813"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a441d970c6097ed3b4af7dbb919e53813">&#9670;&#160;</a></span>multilabel_confusion_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics._classification.multilabel_confusion_matrix </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y_true</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y_pred</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>sample_weight</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>labels</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>samplewise</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute a confusion matrix for each class or sample.

.. versionadded:: 0.21

Compute class-wise (default) or sample-wise (samplewise=True) multilabel
confusion matrix to evaluate the accuracy of a classification, and output
confusion matrices for each class or sample.

In multilabel confusion matrix :math:`MCM`, the count of true negatives
is :math:`MCM_{:,0,0}`, false negatives is :math:`MCM_{:,1,0}`,
true positives is :math:`MCM_{:,1,1}` and false positives is
:math:`MCM_{:,0,1}`.

Multiclass data will be treated as if binarized under a one-vs-rest
transformation. Returned confusion matrices will be in the order of
sorted unique labels in the union of (y_true, y_pred).

Read more in the :ref:`User Guide &lt;multilabel_confusion_matrix&gt;`.

Parameters
----------
y_true : {array-like, sparse matrix} of shape (n_samples, n_outputs) or \
        (n_samples,)
    Ground truth (correct) target values.

y_pred : {array-like, sparse matrix} of shape (n_samples, n_outputs) or \
        (n_samples,)
    Estimated targets as returned by a classifier.

sample_weight : array-like of shape (n_samples,), default=None
    Sample weights.

labels : array-like of shape (n_classes,), default=None
    A list of classes or column indices to select some (or to force
    inclusion of classes absent from the data).

samplewise : bool, default=False
    In the multilabel case, this calculates a confusion matrix per sample.

Returns
-------
multi_confusion : ndarray of shape (n_outputs, 2, 2)
    A 2x2 confusion matrix corresponding to each output in the input.
    When calculating class-wise multi_confusion (default), then
    n_outputs = n_labels; when calculating sample-wise multi_confusion
    (samplewise=True), n_outputs = n_samples. If ``labels`` is defined,
    the results will be returned in the order specified in ``labels``,
    otherwise the results will be returned in sorted order by default.

See Also
--------
confusion_matrix : Compute confusion matrix to evaluate the accuracy of a
    classifier.

Notes
-----
The `multilabel_confusion_matrix` calculates class-wise or sample-wise
multilabel confusion matrices, and in multiclass tasks, labels are
binarized under a one-vs-rest way; while
:func:`~sklearn.metrics.confusion_matrix` calculates one confusion matrix
for confusion between every two classes.

Examples
--------
Multilabel-indicator case:

&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from sklearn.metrics import multilabel_confusion_matrix
&gt;&gt;&gt; y_true = np.array([[1, 0, 1],
...                    [0, 1, 0]])
&gt;&gt;&gt; y_pred = np.array([[1, 0, 0],
...                    [0, 1, 1]])
&gt;&gt;&gt; multilabel_confusion_matrix(y_true, y_pred)
array([[[1, 0],
        [0, 1]],
&lt;BLANKLINE&gt;
       [[1, 0],
        [0, 1]],
&lt;BLANKLINE&gt;
       [[0, 1],
        [1, 0]]])

Multiclass case:

&gt;&gt;&gt; y_true = ["cat", "ant", "cat", "cat", "ant", "bird"]
&gt;&gt;&gt; y_pred = ["ant", "ant", "cat", "cat", "ant", "cat"]
&gt;&gt;&gt; multilabel_confusion_matrix(y_true, y_pred,
...                             labels=["ant", "bird", "cat"])
array([[[3, 1],
        [0, 2]],
&lt;BLANKLINE&gt;
       [[5, 0],
        [1, 0]],
&lt;BLANKLINE&gt;
       [[2, 1],
        [1, 2]]])
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l00556">556</a> of file <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html">_classification.py</a>.</p>

<p class="reference">References <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l00069">_check_targets()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l00928">jaccard_score()</a>, and <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l01826">precision_recall_fscore_support()</a>.</p>

</div>
</div>
<a id="a15142b0e8df592903125d73338098b62" name="a15142b0e8df592903125d73338098b62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15142b0e8df592903125d73338098b62">&#9670;&#160;</a></span>precision_recall_fscore_support()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics._classification.precision_recall_fscore_support </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y_true</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y_pred</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>beta</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>labels</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>pos_label</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>average</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>warn_for</em></span><span class="paramdefsep"> = </span><span class="paramdefval">(&quot;precision&quot;,&#160;&quot;recall&quot;,&#160;&quot;f-score&quot;)</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>sample_weight</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>zero_division</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;warn&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute precision, recall, F-measure and support for each class.

The precision is the ratio ``tp / (tp + fp)`` where ``tp`` is the number of
true positives and ``fp`` the number of false positives. The precision is
intuitively the ability of the classifier not to label a negative sample as
positive.

The recall is the ratio ``tp / (tp + fn)`` where ``tp`` is the number of
true positives and ``fn`` the number of false negatives. The recall is
intuitively the ability of the classifier to find all the positive samples.

The F-beta score can be interpreted as a weighted harmonic mean of
the precision and recall, where an F-beta score reaches its best
value at 1 and worst score at 0.

The F-beta score weights recall more than precision by a factor of
``beta``. ``beta == 1.0`` means recall and precision are equally important.

The support is the number of occurrences of each class in ``y_true``.

Support beyond term:`binary` targets is achieved by treating :term:`multiclass`
and :term:`multilabel` data as a collection of binary problems, one for each
label. For the :term:`binary` case, setting `average='binary'` will return
metrics for `pos_label`. If `average` is not `'binary'`, `pos_label` is ignored
and metrics for both classes are computed, then averaged or both returned (when
`average=None`). Similarly, for :term:`multiclass` and :term:`multilabel` targets,
metrics for all `labels` are either returned or averaged depending on the `average`
parameter. Use `labels` specify the set of labels to calculate metrics for.

Read more in the :ref:`User Guide &lt;precision_recall_f_measure_metrics&gt;`.

Parameters
----------
y_true : 1d array-like, or label indicator array / sparse matrix
    Ground truth (correct) target values.

y_pred : 1d array-like, or label indicator array / sparse matrix
    Estimated targets as returned by a classifier.

beta : float, default=1.0
    The strength of recall versus precision in the F-score.

labels : array-like, default=None
    The set of labels to include when `average != 'binary'`, and their
    order if `average is None`. Labels present in the data can be
    excluded, for example in multiclass classification to exclude a "negative
    class". Labels not present in the data can be included and will be
    "assigned" 0 samples. For multilabel targets, labels are column indices.
    By default, all labels in `y_true` and `y_pred` are used in sorted order.

    .. versionchanged:: 0.17
       Parameter `labels` improved for multiclass problem.

pos_label : int, float, bool or str, default=1
    The class to report if `average='binary'` and the data is binary,
    otherwise this parameter is ignored.
    For multiclass or multilabel targets, set `labels=[pos_label]` and
    `average != 'binary'` to report metrics for one label only.

average : {'micro', 'macro', 'samples', 'weighted', 'binary'} or None, \
        default='binary'
    This parameter is required for multiclass/multilabel targets.
    If ``None``, the metrics for each class are returned. Otherwise, this
    determines the type of averaging performed on the data:

    ``'binary'``:
        Only report results for the class specified by ``pos_label``.
        This is applicable only if targets (``y_{true,pred}``) are binary.
    ``'micro'``:
        Calculate metrics globally by counting the total true positives,
        false negatives and false positives.
    ``'macro'``:
        Calculate metrics for each label, and find their unweighted
        mean.  This does not take label imbalance into account.
    ``'weighted'``:
        Calculate metrics for each label, and find their average weighted
        by support (the number of true instances for each label). This
        alters 'macro' to account for label imbalance; it can result in an
        F-score that is not between precision and recall.
    ``'samples'``:
        Calculate metrics for each instance, and find their average (only
        meaningful for multilabel classification where this differs from
        :func:`accuracy_score`).

warn_for : list, tuple or set, for internal use
    This determines which warnings will be made in the case that this
    function is being used to return only one of its metrics.

sample_weight : array-like of shape (n_samples,), default=None
    Sample weights.

zero_division : {"warn", 0.0, 1.0, np.nan}, default="warn"
    Sets the value to return when there is a zero division:

    - recall: when there are no positive labels
    - precision: when there are no positive predictions
    - f-score: both

    Notes:

    - If set to "warn", this acts like 0, but a warning is also raised.
    - If set to `np.nan`, such values will be excluded from the average.

    .. versionadded:: 1.3
       `np.nan` option was added.

Returns
-------
precision : float (if average is not None) or array of float, shape =\
    [n_unique_labels]
    Precision score.

recall : float (if average is not None) or array of float, shape =\
    [n_unique_labels]
    Recall score.

fbeta_score : float (if average is not None) or array of float, shape =\
    [n_unique_labels]
    F-beta score.

support : None (if average is not None) or array of int, shape =\
    [n_unique_labels]
    The number of occurrences of each label in ``y_true``.

Notes
-----
When ``true positive + false positive == 0``, precision is undefined.
When ``true positive + false negative == 0``, recall is undefined. When
``true positive + false negative + false positive == 0``, f-score is
undefined. In such cases, by default the metric will be set to 0, and
``UndefinedMetricWarning`` will be raised. This behavior can be modified
with ``zero_division``.

References
----------
.. [1] `Wikipedia entry for the Precision and recall
       &lt;https://en.wikipedia.org/wiki/Precision_and_recall&gt;`_.

.. [2] `Wikipedia entry for the F1-score
       &lt;https://en.wikipedia.org/wiki/F1_score&gt;`_.

.. [3] `Discriminative Methods for Multi-labeled Classification Advances
       in Knowledge Discovery and Data Mining (2004), pp. 22-30 by Shantanu
       Godbole, Sunita Sarawagi
       &lt;http://www.godbole.net/shantanu/pubs/multilabelsvm-pakdd04.pdf&gt;`_.

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from sklearn.metrics import precision_recall_fscore_support
&gt;&gt;&gt; y_true = np.array(['cat', 'dog', 'pig', 'cat', 'dog', 'pig'])
&gt;&gt;&gt; y_pred = np.array(['cat', 'pig', 'dog', 'cat', 'cat', 'dog'])
&gt;&gt;&gt; precision_recall_fscore_support(y_true, y_pred, average='macro')
(0.222, 0.333, 0.267, None)
&gt;&gt;&gt; precision_recall_fscore_support(y_true, y_pred, average='micro')
(0.33, 0.33, 0.33, None)
&gt;&gt;&gt; precision_recall_fscore_support(y_true, y_pred, average='weighted')
(0.222, 0.333, 0.267, None)

It is possible to compute per-label precisions, recalls, F1-scores and
supports instead of averaging:

&gt;&gt;&gt; precision_recall_fscore_support(y_true, y_pred, average=None,
... labels=['pig', 'dog', 'cat'])
(array([0.        , 0.        , 0.66]),
 array([0., 0., 1.]), array([0. , 0. , 0.8]),
 array([2, 2, 2]))
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l01815">1815</a> of file <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html">_classification.py</a>.</p>

<p class="reference">References <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l01752">_check_set_wise_labels()</a>, <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l01699">_prf_divide()</a>, and <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l00558">multilabel_confusion_matrix()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l02839">classification_report()</a>, <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l01507">fbeta_score()</a>, <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l02384">precision_score()</a>, and <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l02565">recall_score()</a>.</p>

</div>
</div>
<a id="aa7da5219ebca6807f6a19706be6f05ba" name="aa7da5219ebca6807f6a19706be6f05ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7da5219ebca6807f6a19706be6f05ba">&#9670;&#160;</a></span>precision_score()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics._classification.precision_score </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y_true</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y_pred</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>labels</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>pos_label</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>average</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;binary&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>sample_weight</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>zero_division</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;warn&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the precision.

The precision is the ratio ``tp / (tp + fp)`` where ``tp`` is the number of
true positives and ``fp`` the number of false positives. The precision is
intuitively the ability of the classifier not to label as positive a sample
that is negative.

The best value is 1 and the worst value is 0.

Support beyond term:`binary` targets is achieved by treating :term:`multiclass`
and :term:`multilabel` data as a collection of binary problems, one for each
label. For the :term:`binary` case, setting `average='binary'` will return
precision for `pos_label`. If `average` is not `'binary'`, `pos_label` is ignored
and precision for both classes are computed, then averaged or both returned (when
`average=None`). Similarly, for :term:`multiclass` and :term:`multilabel` targets,
precision for all `labels` are either returned or averaged depending on the
`average` parameter. Use `labels` specify the set of labels to calculate precision
for.

Read more in the :ref:`User Guide &lt;precision_recall_f_measure_metrics&gt;`.

Parameters
----------
y_true : 1d array-like, or label indicator array / sparse matrix
    Ground truth (correct) target values.

y_pred : 1d array-like, or label indicator array / sparse matrix
    Estimated targets as returned by a classifier.

labels : array-like, default=None
    The set of labels to include when `average != 'binary'`, and their
    order if `average is None`. Labels present in the data can be
    excluded, for example in multiclass classification to exclude a "negative
    class". Labels not present in the data can be included and will be
    "assigned" 0 samples. For multilabel targets, labels are column indices.
    By default, all labels in `y_true` and `y_pred` are used in sorted order.

    .. versionchanged:: 0.17
       Parameter `labels` improved for multiclass problem.

pos_label : int, float, bool or str, default=1
    The class to report if `average='binary'` and the data is binary,
    otherwise this parameter is ignored.
    For multiclass or multilabel targets, set `labels=[pos_label]` and
    `average != 'binary'` to report metrics for one label only.

average : {'micro', 'macro', 'samples', 'weighted', 'binary'} or None, \
        default='binary'
    This parameter is required for multiclass/multilabel targets.
    If ``None``, the metrics for each class are returned. Otherwise, this
    determines the type of averaging performed on the data:

    ``'binary'``:
        Only report results for the class specified by ``pos_label``.
        This is applicable only if targets (``y_{true,pred}``) are binary.
    ``'micro'``:
        Calculate metrics globally by counting the total true positives,
        false negatives and false positives.
    ``'macro'``:
        Calculate metrics for each label, and find their unweighted
        mean.  This does not take label imbalance into account.
    ``'weighted'``:
        Calculate metrics for each label, and find their average weighted
        by support (the number of true instances for each label). This
        alters 'macro' to account for label imbalance; it can result in an
        F-score that is not between precision and recall.
    ``'samples'``:
        Calculate metrics for each instance, and find their average (only
        meaningful for multilabel classification where this differs from
        :func:`accuracy_score`).

sample_weight : array-like of shape (n_samples,), default=None
    Sample weights.

zero_division : {"warn", 0.0, 1.0, np.nan}, default="warn"
    Sets the value to return when there is a zero division.

    Notes:

    - If set to "warn", this acts like 0, but a warning is also raised.
    - If set to `np.nan`, such values will be excluded from the average.

    .. versionadded:: 1.3
       `np.nan` option was added.

Returns
-------
precision : float (if average is not None) or array of float of shape \
            (n_unique_labels,)
    Precision of the positive class in binary classification or weighted
    average of the precision of each class for the multiclass task.

See Also
--------
precision_recall_fscore_support : Compute precision, recall, F-measure and
    support for each class.
recall_score :  Compute the ratio ``tp / (tp + fn)`` where ``tp`` is the
    number of true positives and ``fn`` the number of false negatives.
PrecisionRecallDisplay.from_estimator : Plot precision-recall curve given
    an estimator and some data.
PrecisionRecallDisplay.from_predictions : Plot precision-recall curve given
    binary class predictions.
multilabel_confusion_matrix : Compute a confusion matrix for each class or
    sample.

Notes
-----
When ``true positive + false positive == 0``, precision returns 0 and
raises ``UndefinedMetricWarning``. This behavior can be
modified with ``zero_division``.

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from sklearn.metrics import precision_score
&gt;&gt;&gt; y_true = [0, 1, 2, 0, 1, 2]
&gt;&gt;&gt; y_pred = [0, 2, 1, 0, 0, 1]
&gt;&gt;&gt; precision_score(y_true, y_pred, average='macro')
0.22
&gt;&gt;&gt; precision_score(y_true, y_pred, average='micro')
0.33
&gt;&gt;&gt; precision_score(y_true, y_pred, average='weighted')
0.22
&gt;&gt;&gt; precision_score(y_true, y_pred, average=None)
array([0.66, 0.        , 0.        ])
&gt;&gt;&gt; y_pred = [0, 0, 0, 0, 0, 0]
&gt;&gt;&gt; precision_score(y_true, y_pred, average=None)
array([0.33, 0.        , 0.        ])
&gt;&gt;&gt; precision_score(y_true, y_pred, average=None, zero_division=1)
array([0.33, 1.        , 1.        ])
&gt;&gt;&gt; precision_score(y_true, y_pred, average=None, zero_division=np.nan)
array([0.33,        nan,        nan])

&gt;&gt;&gt; # multilabel classification
&gt;&gt;&gt; y_true = [[0, 0, 0], [1, 1, 1], [0, 1, 1]]
&gt;&gt;&gt; y_pred = [[0, 0, 0], [1, 1, 1], [1, 1, 0]]
&gt;&gt;&gt; precision_score(y_true, y_pred, average=None)
array([0.5, 1. , 1. ])
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l02375">2375</a> of file <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html">_classification.py</a>.</p>

<p class="reference">References <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l01826">precision_recall_fscore_support()</a>.</p>

</div>
</div>
<a id="a5557c71c9e924d3e1d9e3679d1e0e710" name="a5557c71c9e924d3e1d9e3679d1e0e710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5557c71c9e924d3e1d9e3679d1e0e710">&#9670;&#160;</a></span>recall_score()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics._classification.recall_score </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y_true</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y_pred</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>labels</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>pos_label</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>average</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;binary&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>sample_weight</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>zero_division</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;warn&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the recall.

The recall is the ratio ``tp / (tp + fn)`` where ``tp`` is the number of
true positives and ``fn`` the number of false negatives. The recall is
intuitively the ability of the classifier to find all the positive samples.

The best value is 1 and the worst value is 0.

Support beyond term:`binary` targets is achieved by treating :term:`multiclass`
and :term:`multilabel` data as a collection of binary problems, one for each
label. For the :term:`binary` case, setting `average='binary'` will return
recall for `pos_label`. If `average` is not `'binary'`, `pos_label` is ignored
and recall for both classes are computed then averaged or both returned (when
`average=None`). Similarly, for :term:`multiclass` and :term:`multilabel` targets,
recall for all `labels` are either returned or averaged depending on the `average`
parameter. Use `labels` specify the set of labels to calculate recall for.

Read more in the :ref:`User Guide &lt;precision_recall_f_measure_metrics&gt;`.

Parameters
----------
y_true : 1d array-like, or label indicator array / sparse matrix
    Ground truth (correct) target values.

y_pred : 1d array-like, or label indicator array / sparse matrix
    Estimated targets as returned by a classifier.

labels : array-like, default=None
    The set of labels to include when `average != 'binary'`, and their
    order if `average is None`. Labels present in the data can be
    excluded, for example in multiclass classification to exclude a "negative
    class". Labels not present in the data can be included and will be
    "assigned" 0 samples. For multilabel targets, labels are column indices.
    By default, all labels in `y_true` and `y_pred` are used in sorted order.

    .. versionchanged:: 0.17
       Parameter `labels` improved for multiclass problem.

pos_label : int, float, bool or str, default=1
    The class to report if `average='binary'` and the data is binary,
    otherwise this parameter is ignored.
    For multiclass or multilabel targets, set `labels=[pos_label]` and
    `average != 'binary'` to report metrics for one label only.

average : {'micro', 'macro', 'samples', 'weighted', 'binary'} or None, \
        default='binary'
    This parameter is required for multiclass/multilabel targets.
    If ``None``, the metrics for each class are returned. Otherwise, this
    determines the type of averaging performed on the data:

    ``'binary'``:
        Only report results for the class specified by ``pos_label``.
        This is applicable only if targets (``y_{true,pred}``) are binary.
    ``'micro'``:
        Calculate metrics globally by counting the total true positives,
        false negatives and false positives.
    ``'macro'``:
        Calculate metrics for each label, and find their unweighted
        mean.  This does not take label imbalance into account.
    ``'weighted'``:
        Calculate metrics for each label, and find their average weighted
        by support (the number of true instances for each label). This
        alters 'macro' to account for label imbalance; it can result in an
        F-score that is not between precision and recall. Weighted recall
        is equal to accuracy.
    ``'samples'``:
        Calculate metrics for each instance, and find their average (only
        meaningful for multilabel classification where this differs from
        :func:`accuracy_score`).

sample_weight : array-like of shape (n_samples,), default=None
    Sample weights.

zero_division : {"warn", 0.0, 1.0, np.nan}, default="warn"
    Sets the value to return when there is a zero division.

    Notes:

    - If set to "warn", this acts like 0, but a warning is also raised.
    - If set to `np.nan`, such values will be excluded from the average.

    .. versionadded:: 1.3
       `np.nan` option was added.

Returns
-------
recall : float (if average is not None) or array of float of shape \
         (n_unique_labels,)
    Recall of the positive class in binary classification or weighted
    average of the recall of each class for the multiclass task.

See Also
--------
precision_recall_fscore_support : Compute precision, recall, F-measure and
    support for each class.
precision_score : Compute the ratio ``tp / (tp + fp)`` where ``tp`` is the
    number of true positives and ``fp`` the number of false positives.
balanced_accuracy_score : Compute balanced accuracy to deal with imbalanced
    datasets.
multilabel_confusion_matrix : Compute a confusion matrix for each class or
    sample.
PrecisionRecallDisplay.from_estimator : Plot precision-recall curve given
    an estimator and some data.
PrecisionRecallDisplay.from_predictions : Plot precision-recall curve given
    binary class predictions.

Notes
-----
When ``true positive + false negative == 0``, recall returns 0 and raises
``UndefinedMetricWarning``. This behavior can be modified with
``zero_division``.

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from sklearn.metrics import recall_score
&gt;&gt;&gt; y_true = [0, 1, 2, 0, 1, 2]
&gt;&gt;&gt; y_pred = [0, 2, 1, 0, 0, 1]
&gt;&gt;&gt; recall_score(y_true, y_pred, average='macro')
0.33
&gt;&gt;&gt; recall_score(y_true, y_pred, average='micro')
0.33
&gt;&gt;&gt; recall_score(y_true, y_pred, average='weighted')
0.33
&gt;&gt;&gt; recall_score(y_true, y_pred, average=None)
array([1., 0., 0.])
&gt;&gt;&gt; y_true = [0, 0, 0, 0, 0, 0]
&gt;&gt;&gt; recall_score(y_true, y_pred, average=None)
array([0.5, 0. , 0. ])
&gt;&gt;&gt; recall_score(y_true, y_pred, average=None, zero_division=1)
array([0.5, 1. , 1. ])
&gt;&gt;&gt; recall_score(y_true, y_pred, average=None, zero_division=np.nan)
array([0.5, nan, nan])

&gt;&gt;&gt; # multilabel classification
&gt;&gt;&gt; y_true = [[0, 0, 0], [1, 1, 1], [0, 1, 1]]
&gt;&gt;&gt; y_pred = [[0, 0, 0], [1, 1, 1], [1, 1, 0]]
&gt;&gt;&gt; recall_score(y_true, y_pred, average=None)
array([1. , 1. , 0.5])
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l02556">2556</a> of file <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html">_classification.py</a>.</p>

<p class="reference">References <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l01826">precision_recall_fscore_support()</a>.</p>

</div>
</div>
<a id="adf01048251d2b41d3fb5ee881300fc73" name="adf01048251d2b41d3fb5ee881300fc73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf01048251d2b41d3fb5ee881300fc73">&#9670;&#160;</a></span>zero_one_loss()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.metrics._classification.zero_one_loss </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y_true</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y_pred</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>normalize</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d8/d0b/classTrue.html">True</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>sample_weight</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Zero-one classification loss.

If normalize is ``True``, return the fraction of misclassifications
(float), else it returns the number of misclassifications (int). The best
performance is 0.

Read more in the :ref:`User Guide &lt;zero_one_loss&gt;`.

Parameters
----------
y_true : 1d array-like, or label indicator array / sparse matrix
    Ground truth (correct) labels.

y_pred : 1d array-like, or label indicator array / sparse matrix
    Predicted labels, as returned by a classifier.

normalize : bool, default=True
    If ``False``, return the number of misclassifications.
    Otherwise, return the fraction of misclassifications.

sample_weight : array-like of shape (n_samples,), default=None
    Sample weights.

Returns
-------
loss : float or int,
    If ``normalize == True``, return the fraction of misclassifications
    (float), else it returns the number of misclassifications (int).

See Also
--------
accuracy_score : Compute the accuracy score. By default, the function will
    return the fraction of correct predictions divided by the total number
    of predictions.
hamming_loss : Compute the average Hamming loss or Hamming distance between
    two sets of samples.
jaccard_score : Compute the Jaccard similarity coefficient score.

Notes
-----
In multilabel classification, the zero_one_loss function corresponds to
the subset zero-one loss: for each sample, the entire set of labels must be
correctly predicted, otherwise the loss for that sample is equal to one.

Examples
--------
&gt;&gt;&gt; from sklearn.metrics import zero_one_loss
&gt;&gt;&gt; y_pred = [1, 2, 3, 4]
&gt;&gt;&gt; y_true = [2, 2, 3, 4]
&gt;&gt;&gt; zero_one_loss(y_true, y_pred)
0.25
&gt;&gt;&gt; zero_one_loss(y_true, y_pred, normalize=False)
1.0

In the multilabel case with binary label indicators:

&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; zero_one_loss(np.array([[0, 1], [1, 1]]), np.ones((2, 2)))
0.5
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l01209">1209</a> of file <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html">_classification.py</a>.</p>

<p class="reference">References <a class="el" href="../../d9/d6d/metrics_2__classification_8py_source.html#l00296">accuracy_score()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d6/d1d/namespacesklearn.html">sklearn</a></li><li class="navelem"><a class="el" href="../../d0/d06/namespacesklearn_1_1metrics.html">metrics</a></li><li class="navelem"><a class="el" href="../../da/d78/namespacesklearn_1_1metrics_1_1__classification.html">_classification</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
