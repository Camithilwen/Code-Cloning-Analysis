<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Code Cloning Analysis: scipy.linalg._special_matrices Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Code Cloning Analysis
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('da/de7/namespacescipy_1_1linalg_1_1__special__matrices.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">scipy.linalg._special_matrices Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:adbf1d041cdb29a518a9cc4156563d9fb" id="r_adbf1d041cdb29a518a9cc4156563d9fb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adbf1d041cdb29a518a9cc4156563d9fb">tri</a> (N, M=None, k=0, dtype=None)</td></tr>
<tr class="separator:adbf1d041cdb29a518a9cc4156563d9fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9df53d999e3af2182cfee51b697af2" id="r_a5e9df53d999e3af2182cfee51b697af2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e9df53d999e3af2182cfee51b697af2">tril</a> (m, k=0)</td></tr>
<tr class="separator:a5e9df53d999e3af2182cfee51b697af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef9793e4c7a01acf622dbf785e15cc45" id="r_aef9793e4c7a01acf622dbf785e15cc45"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef9793e4c7a01acf622dbf785e15cc45">triu</a> (m, k=0)</td></tr>
<tr class="separator:aef9793e4c7a01acf622dbf785e15cc45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a804e14de09dc0496e3975329dd059e83" id="r_a804e14de09dc0496e3975329dd059e83"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a804e14de09dc0496e3975329dd059e83">toeplitz</a> (c, r=None)</td></tr>
<tr class="separator:a804e14de09dc0496e3975329dd059e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabf57b3b4da0f845cd257df63f01512f" id="r_aabf57b3b4da0f845cd257df63f01512f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aabf57b3b4da0f845cd257df63f01512f">circulant</a> (c)</td></tr>
<tr class="separator:aabf57b3b4da0f845cd257df63f01512f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad74cc1ad8af780ae9c873aaae9c577a6" id="r_ad74cc1ad8af780ae9c873aaae9c577a6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad74cc1ad8af780ae9c873aaae9c577a6">hankel</a> (c, r=None)</td></tr>
<tr class="separator:ad74cc1ad8af780ae9c873aaae9c577a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5bf88c8cf8014413ffbf3f2e86169f8" id="r_aa5bf88c8cf8014413ffbf3f2e86169f8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5bf88c8cf8014413ffbf3f2e86169f8">hadamard</a> (n, dtype=int)</td></tr>
<tr class="separator:aa5bf88c8cf8014413ffbf3f2e86169f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0a31d0a2fb9751f80187a3c496246f0" id="r_ac0a31d0a2fb9751f80187a3c496246f0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0a31d0a2fb9751f80187a3c496246f0">leslie</a> (f, s)</td></tr>
<tr class="separator:ac0a31d0a2fb9751f80187a3c496246f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a873011de8094c873bd302bfe61ea9284" id="r_a873011de8094c873bd302bfe61ea9284"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a873011de8094c873bd302bfe61ea9284">kron</a> (a, b)</td></tr>
<tr class="separator:a873011de8094c873bd302bfe61ea9284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae014151e4a6a5a1fb0d0607d52ac78c2" id="r_ae014151e4a6a5a1fb0d0607d52ac78c2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae014151e4a6a5a1fb0d0607d52ac78c2">block_diag</a> (*arrs)</td></tr>
<tr class="separator:ae014151e4a6a5a1fb0d0607d52ac78c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56554fbd9a385c9283f65d2368fb5fb1" id="r_a56554fbd9a385c9283f65d2368fb5fb1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56554fbd9a385c9283f65d2368fb5fb1">companion</a> (a)</td></tr>
<tr class="separator:a56554fbd9a385c9283f65d2368fb5fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e2a4b3eb8c15fde671fab5cbc3ca325" id="r_a4e2a4b3eb8c15fde671fab5cbc3ca325"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e2a4b3eb8c15fde671fab5cbc3ca325">helmert</a> (n, full=False)</td></tr>
<tr class="separator:a4e2a4b3eb8c15fde671fab5cbc3ca325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f43ed3f392fe5f54db7950ca4cae260" id="r_a6f43ed3f392fe5f54db7950ca4cae260"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f43ed3f392fe5f54db7950ca4cae260">hilbert</a> (n)</td></tr>
<tr class="separator:a6f43ed3f392fe5f54db7950ca4cae260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97248ada231330c917b2d3acbef12d03" id="r_a97248ada231330c917b2d3acbef12d03"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97248ada231330c917b2d3acbef12d03">invhilbert</a> (n, exact=False)</td></tr>
<tr class="separator:a97248ada231330c917b2d3acbef12d03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac723ea273038dbe546e0fe83a0b9ae47" id="r_ac723ea273038dbe546e0fe83a0b9ae47"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac723ea273038dbe546e0fe83a0b9ae47">pascal</a> (n, kind='symmetric', exact=<a class="el" href="../../d8/d0b/classTrue.html">True</a>)</td></tr>
<tr class="separator:ac723ea273038dbe546e0fe83a0b9ae47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada832342bbbbf86f533f48f5030588a" id="r_aada832342bbbbf86f533f48f5030588a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aada832342bbbbf86f533f48f5030588a">invpascal</a> (n, kind='symmetric', exact=<a class="el" href="../../d8/d0b/classTrue.html">True</a>)</td></tr>
<tr class="separator:aada832342bbbbf86f533f48f5030588a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb9a544b2373654620e827cac72cfc18" id="r_acb9a544b2373654620e827cac72cfc18"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb9a544b2373654620e827cac72cfc18">dft</a> (n, scale=None)</td></tr>
<tr class="separator:acb9a544b2373654620e827cac72cfc18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af943019b59847395f467aa5c98213d6f" id="r_af943019b59847395f467aa5c98213d6f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af943019b59847395f467aa5c98213d6f">fiedler</a> (a)</td></tr>
<tr class="separator:af943019b59847395f467aa5c98213d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c98e61199e669c788530b558fae0a2a" id="r_a9c98e61199e669c788530b558fae0a2a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c98e61199e669c788530b558fae0a2a">fiedler_companion</a> (a)</td></tr>
<tr class="separator:a9c98e61199e669c788530b558fae0a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa91257164f7d4cd44eef8c748791d4c2" id="r_aa91257164f7d4cd44eef8c748791d4c2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa91257164f7d4cd44eef8c748791d4c2">convolution_matrix</a> (a, n, mode='full')</td></tr>
<tr class="separator:aa91257164f7d4cd44eef8c748791d4c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ae2e2b6b280d7cad3219d9a6be3e4a1f2" id="r_ae2e2b6b280d7cad3219d9a6be3e4a1f2"><td class="memItemLeft" align="right" valign="top">list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2e2b6b280d7cad3219d9a6be3e4a1f2">__all__</a></td></tr>
<tr class="separator:ae2e2b6b280d7cad3219d9a6be3e4a1f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae014151e4a6a5a1fb0d0607d52ac78c2" name="ae014151e4a6a5a1fb0d0607d52ac78c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae014151e4a6a5a1fb0d0607d52ac78c2">&#9670;&#160;</a></span>block_diag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._special_matrices.block_diag </td>
          <td>(</td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em>arrs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create a block diagonal matrix from provided arrays.

Given the inputs `A`, `B` and `C`, the output will have these
arrays arranged on the diagonal::

    [[A, 0, 0],
     [0, B, 0],
     [0, 0, C]]

Parameters
----------
A, B, C, ... : array_like, up to 2-D
    Input arrays.  A 1-D array or array_like sequence of length `n` is
    treated as a 2-D array with shape ``(1,n)``.

Returns
-------
D : ndarray
    Array with `A`, `B`, `C`, ... on the diagonal. `D` has the
    same dtype as `A`.

Notes
-----
If all the input arrays are square, the output is known as a
block diagonal matrix.

Empty sequences (i.e., array-likes of zero size) will not be ignored.
Noteworthy, both [] and [[]] are treated as matrices with shape ``(1,0)``.

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy.linalg import block_diag
&gt;&gt;&gt; A = [[1, 0],
...      [0, 1]]
&gt;&gt;&gt; B = [[3, 4, 5],
...      [6, 7, 8]]
&gt;&gt;&gt; C = [[7]]
&gt;&gt;&gt; P = np.zeros((2, 0), dtype='int32')
&gt;&gt;&gt; block_diag(A, B, C)
array([[1, 0, 0, 0, 0, 0],
       [0, 1, 0, 0, 0, 0],
       [0, 0, 3, 4, 5, 0],
       [0, 0, 6, 7, 8, 0],
       [0, 0, 0, 0, 0, 7]])
&gt;&gt;&gt; block_diag(A, P, B, C)
array([[1, 0, 0, 0, 0, 0],
       [0, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0],
       [0, 0, 3, 4, 5, 0],
       [0, 0, 6, 7, 8, 0],
       [0, 0, 0, 0, 0, 7]])
&gt;&gt;&gt; block_diag(1.0, [2, 3], [[4, 5], [6, 7]])
array([[ 1.,  0.,  0.,  0.,  0.],
       [ 0.,  2.,  3.,  0.,  0.],
       [ 0.,  0.,  0.,  4.,  5.],
       [ 0.,  0.,  0.,  6.,  7.]])
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d4/dbf/__special__matrices_8py_source.html#l00489">489</a> of file <a class="el" href="../../d4/dbf/__special__matrices_8py_source.html">_special_matrices.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../da/ddc/__decomp__cossin_8py_source.html#l00012">scipy.linalg._decomp_cossin.cossin()</a>, <a class="el" href="../../d3/dd9/__solvers_8py_source.html#l00328">scipy.linalg._solvers.solve_continuous_are()</a>, and <a class="el" href="../../da/da6/test__lapack_8py_source.html#l02402">scipy.linalg.tests.test_lapack.test_pteqr_NAG_f08jgf()</a>.</p>

</div>
</div>
<a id="aabf57b3b4da0f845cd257df63f01512f" name="aabf57b3b4da0f845cd257df63f01512f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabf57b3b4da0f845cd257df63f01512f">&#9670;&#160;</a></span>circulant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._special_matrices.circulant </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Construct a circulant matrix.

Parameters
----------
c : (N,) array_like
    1-D array, the first column of the matrix.

Returns
-------
A : (N, N) ndarray
    A circulant matrix whose first column is `c`.

See Also
--------
toeplitz : Toeplitz matrix
hankel : Hankel matrix
solve_circulant : Solve a circulant system.

Notes
-----
.. versionadded:: 0.8.0

Examples
--------
&gt;&gt;&gt; from scipy.linalg import circulant
&gt;&gt;&gt; circulant([1, 2, 3])
array([[1, 3, 2],
       [2, 1, 3],
       [3, 2, 1]])
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d4/dbf/__special__matrices_8py_source.html#l00221">221</a> of file <a class="el" href="../../d4/dbf/__special__matrices_8py_source.html">_special_matrices.py</a>.</p>

</div>
</div>
<a id="a56554fbd9a385c9283f65d2368fb5fb1" name="a56554fbd9a385c9283f65d2368fb5fb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56554fbd9a385c9283f65d2368fb5fb1">&#9670;&#160;</a></span>companion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._special_matrices.companion </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create a companion matrix.

Create the companion matrix [1]_ associated with the polynomial whose
coefficients are given in `a`.

Parameters
----------
a : (N,) array_like
    1-D array of polynomial coefficients. The length of `a` must be
    at least two, and ``a[0]`` must not be zero.

Returns
-------
c : (N-1, N-1) ndarray
    The first row of `c` is ``-a[1:]/a[0]``, and the first
    sub-diagonal is all ones.  The data-type of the array is the same
    as the data-type of ``1.0*a[0]``.

Raises
------
ValueError
    If any of the following are true: a) ``a.ndim != 1``;
    b) ``a.size &lt; 2``; c) ``a[0] == 0``.

Notes
-----
.. versionadded:: 0.8.0

References
----------
.. [1] R. A. Horn &amp; C. R. Johnson, *Matrix Analysis*.  Cambridge, UK:
    Cambridge University Press, 1999, pp. 146-7.

Examples
--------
&gt;&gt;&gt; from scipy.linalg import companion
&gt;&gt;&gt; companion([1, -10, 31, -30])
array([[ 10., -31.,  30.],
       [  1.,   0.,   0.],
       [  0.,   1.,   0.]])
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d4/dbf/__special__matrices_8py_source.html#l00572">572</a> of file <a class="el" href="../../d4/dbf/__special__matrices_8py_source.html">_special_matrices.py</a>.</p>

</div>
</div>
<a id="aa91257164f7d4cd44eef8c748791d4c2" name="aa91257164f7d4cd44eef8c748791d4c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa91257164f7d4cd44eef8c748791d4c2">&#9670;&#160;</a></span>convolution_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._special_matrices.convolution_matrix </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>mode</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'full'</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Construct a convolution matrix.

Constructs the Toeplitz matrix representing one-dimensional
convolution [1]_.  See the notes below for details.

Parameters
----------
a : (m,) array_like
    The 1-D array to convolve.
n : int
    The number of columns in the resulting matrix.  It gives the length
    of the input to be convolved with `a`.  This is analogous to the
    length of `v` in ``numpy.convolve(a, v)``.
mode : str
    This is analogous to `mode` in ``numpy.convolve(v, a, mode)``.
    It must be one of ('full', 'valid', 'same').
    See below for how `mode` determines the shape of the result.

Returns
-------
A : (k, n) ndarray
    The convolution matrix whose row count `k` depends on `mode`::

        =======  =========================
         mode    k
        =======  =========================
        'full'   m + n -1
        'same'   max(m, n)
        'valid'  max(m, n) - min(m, n) + 1
        =======  =========================

See Also
--------
toeplitz : Toeplitz matrix

Notes
-----
The code::

    A = convolution_matrix(a, n, mode)

creates a Toeplitz matrix `A` such that ``A @ v`` is equivalent to
using ``convolve(a, v, mode)``.  The returned array always has `n`
columns.  The number of rows depends on the specified `mode`, as
explained above.

In the default 'full' mode, the entries of `A` are given by::

    A[i, j] == (a[i-j] if (0 &lt;= (i-j) &lt; m) else 0)

where ``m = len(a)``.  Suppose, for example, the input array is
``[x, y, z]``.  The convolution matrix has the form::

    [x, 0, 0, ..., 0, 0]
    [y, x, 0, ..., 0, 0]
    [z, y, x, ..., 0, 0]
    ...
    [0, 0, 0, ..., x, 0]
    [0, 0, 0, ..., y, x]
    [0, 0, 0, ..., z, y]
    [0, 0, 0, ..., 0, z]

In 'valid' mode, the entries of `A` are given by::

    A[i, j] == (a[i-j+m-1] if (0 &lt;= (i-j+m-1) &lt; m) else 0)

This corresponds to a matrix whose rows are the subset of those from
the 'full' case where all the coefficients in `a` are contained in the
row.  For input ``[x, y, z]``, this array looks like::

    [z, y, x, 0, 0, ..., 0, 0, 0]
    [0, z, y, x, 0, ..., 0, 0, 0]
    [0, 0, z, y, x, ..., 0, 0, 0]
    ...
    [0, 0, 0, 0, 0, ..., x, 0, 0]
    [0, 0, 0, 0, 0, ..., y, x, 0]
    [0, 0, 0, 0, 0, ..., z, y, x]

In the 'same' mode, the entries of `A` are given by::

    d = (m - 1) // 2
    A[i, j] == (a[i-j+d] if (0 &lt;= (i-j+d) &lt; m) else 0)

The typical application of the 'same' mode is when one has a signal of
length `n` (with `n` greater than ``len(a)``), and the desired output
is a filtered signal that is still of length `n`.

For input ``[x, y, z]``, this array looks like::

    [y, x, 0, 0, ..., 0, 0, 0]
    [z, y, x, 0, ..., 0, 0, 0]
    [0, z, y, x, ..., 0, 0, 0]
    [0, 0, z, y, ..., 0, 0, 0]
    ...
    [0, 0, 0, 0, ..., y, x, 0]
    [0, 0, 0, 0, ..., z, y, x]
    [0, 0, 0, 0, ..., 0, z, y]

.. versionadded:: 1.5.0

References
----------
.. [1] "Convolution", https://en.wikipedia.org/wiki/Convolution

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy.linalg import convolution_matrix
&gt;&gt;&gt; A = convolution_matrix([-1, 4, -2], 5, mode='same')
&gt;&gt;&gt; A
array([[ 4, -1,  0,  0,  0],
       [-2,  4, -1,  0,  0],
       [ 0, -2,  4, -1,  0],
       [ 0,  0, -2,  4, -1],
       [ 0,  0,  0, -2,  4]])

Compare multiplication by `A` with the use of `numpy.convolve`.

&gt;&gt;&gt; x = np.array([1, 2, 0, -3, 0.5])
&gt;&gt;&gt; A @ x
array([  2. ,   6. ,  -1. , -12.5,   8. ])

Verify that ``A @ x`` produced the same result as applying the
convolution function.

&gt;&gt;&gt; np.convolve([-1, 4, -2], x, mode='same')
array([  2. ,   6. ,  -1. , -12.5,   8. ])

For comparison to the case ``mode='same'`` shown above, here are the
matrices produced by ``mode='full'`` and ``mode='valid'`` for the
same coefficients and size.

&gt;&gt;&gt; convolution_matrix([-1, 4, -2], 5, mode='full')
array([[-1,  0,  0,  0,  0],
       [ 4, -1,  0,  0,  0],
       [-2,  4, -1,  0,  0],
       [ 0, -2,  4, -1,  0],
       [ 0,  0, -2,  4, -1],
       [ 0,  0,  0, -2,  4],
       [ 0,  0,  0,  0, -2]])

&gt;&gt;&gt; convolution_matrix([-1, 4, -2], 5, mode='valid')
array([[-2,  4, -1,  0,  0],
       [ 0, -2,  4, -1,  0],
       [ 0,  0, -2,  4, -1]])
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d4/dbf/__special__matrices_8py_source.html#l01218">1218</a> of file <a class="el" href="../../d4/dbf/__special__matrices_8py_source.html">_special_matrices.py</a>.</p>

<p class="reference">References <a class="el" href="../../d4/dbf/__special__matrices_8py_source.html#l00158">toeplitz()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dd/d83/test__special__matrices_8py_source.html#l00659">scipy.linalg.tests.test_special_matrices.TestConvolutionMatrix.create_vector()</a>.</p>

</div>
</div>
<a id="acb9a544b2373654620e827cac72cfc18" name="acb9a544b2373654620e827cac72cfc18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb9a544b2373654620e827cac72cfc18">&#9670;&#160;</a></span>dft()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._special_matrices.dft </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>scale</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Discrete Fourier transform matrix.

Create the matrix that computes the discrete Fourier transform of a
sequence [1]_. The nth primitive root of unity used to generate the
matrix is exp(-2*pi*i/n), where i = sqrt(-1).

Parameters
----------
n : int
    Size the matrix to create.
scale : str, optional
    Must be None, 'sqrtn', or 'n'.
    If `scale` is 'sqrtn', the matrix is divided by `sqrt(n)`.
    If `scale` is 'n', the matrix is divided by `n`.
    If `scale` is None (the default), the matrix is not normalized, and the
    return value is simply the Vandermonde matrix of the roots of unity.

Returns
-------
m : (n, n) ndarray
    The DFT matrix.

Notes
-----
When `scale` is None, multiplying a vector by the matrix returned by
`dft` is mathematically equivalent to (but much less efficient than)
the calculation performed by `scipy.fft.fft`.

.. versionadded:: 0.14.0

References
----------
.. [1] "DFT matrix", https://en.wikipedia.org/wiki/DFT_matrix

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy.linalg import dft
&gt;&gt;&gt; np.set_printoptions(precision=2, suppress=True)  # for compact output
&gt;&gt;&gt; m = dft(5)
&gt;&gt;&gt; m
array([[ 1.  +0.j  ,  1.  +0.j  ,  1.  +0.j  ,  1.  +0.j  ,  1.  +0.j  ],
       [ 1.  +0.j  ,  0.31-0.95j, -0.81-0.59j, -0.81+0.59j,  0.31+0.95j],
       [ 1.  +0.j  , -0.81-0.59j,  0.31+0.95j,  0.31-0.95j, -0.81+0.59j],
       [ 1.  +0.j  , -0.81+0.59j,  0.31-0.95j,  0.31+0.95j, -0.81-0.59j],
       [ 1.  +0.j  ,  0.31+0.95j, -0.81+0.59j, -0.81-0.59j,  0.31-0.95j]])
&gt;&gt;&gt; x = np.array([1, 2, 3, 0, 3])
&gt;&gt;&gt; m @ x  # Compute the DFT of x
array([ 9.  +0.j  ,  0.12-0.81j, -2.12+3.44j, -2.12-3.44j,  0.12+0.81j])

Verify that ``m @ x`` is the same as ``fft(x)``.

&gt;&gt;&gt; from scipy.fft import fft
&gt;&gt;&gt; fft(x)     # Same result as m @ x
array([ 9.  +0.j  ,  0.12-0.81j, -2.12+3.44j, -2.12-3.44j,  0.12+0.81j])
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d4/dbf/__special__matrices_8py_source.html#l00992">992</a> of file <a class="el" href="../../d4/dbf/__special__matrices_8py_source.html">_special_matrices.py</a>.</p>

</div>
</div>
<a id="af943019b59847395f467aa5c98213d6f" name="af943019b59847395f467aa5c98213d6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af943019b59847395f467aa5c98213d6f">&#9670;&#160;</a></span>fiedler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._special_matrices.fiedler </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a symmetric Fiedler matrix

Given an sequence of numbers `a`, Fiedler matrices have the structure
``F[i, j] = np.abs(a[i] - a[j])``, and hence zero diagonals and nonnegative
entries. A Fiedler matrix has a dominant positive eigenvalue and other
eigenvalues are negative. Although not valid generally, for certain inputs,
the inverse and the determinant can be derived explicitly as given in [1]_.

Parameters
----------
a : (n,) array_like
    coefficient array

Returns
-------
F : (n, n) ndarray

See Also
--------
circulant, toeplitz

Notes
-----

.. versionadded:: 1.3.0

References
----------
.. [1] J. Todd, "Basic Numerical Mathematics: Vol.2 : Numerical Algebra",
    1977, Birkhauser, :doi:`10.1007/978-3-0348-7286-7`

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy.linalg import det, inv, fiedler
&gt;&gt;&gt; a = [1, 4, 12, 45, 77]
&gt;&gt;&gt; n = len(a)
&gt;&gt;&gt; A = fiedler(a)
&gt;&gt;&gt; A
array([[ 0,  3, 11, 44, 76],
       [ 3,  0,  8, 41, 73],
       [11,  8,  0, 33, 65],
       [44, 41, 33,  0, 32],
       [76, 73, 65, 32,  0]])

The explicit formulas for determinant and inverse seem to hold only for
monotonically increasing/decreasing arrays. Note the tridiagonal structure
and the corners.

&gt;&gt;&gt; Ai = inv(A)
&gt;&gt;&gt; Ai[np.abs(Ai) &lt; 1e-12] = 0.  # cleanup the numerical noise for display
&gt;&gt;&gt; Ai
array([[-0.16008772,  0.16666667,  0.        ,  0.        ,  0.00657895],
       [ 0.16666667, -0.22916667,  0.0625    ,  0.        ,  0.        ],
       [ 0.        ,  0.0625    , -0.07765152,  0.01515152,  0.        ],
       [ 0.        ,  0.        ,  0.01515152, -0.03077652,  0.015625  ],
       [ 0.00657895,  0.        ,  0.        ,  0.015625  , -0.00904605]])
&gt;&gt;&gt; det(A)
15409151.999999998
&gt;&gt;&gt; (-1)**(n-1) * 2**(n-2) * np.diff(a).prod() * (a[-1] - a[0])
15409152
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d4/dbf/__special__matrices_8py_source.html#l01063">1063</a> of file <a class="el" href="../../d4/dbf/__special__matrices_8py_source.html">_special_matrices.py</a>.</p>

</div>
</div>
<a id="a9c98e61199e669c788530b558fae0a2a" name="a9c98e61199e669c788530b558fae0a2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c98e61199e669c788530b558fae0a2a">&#9670;&#160;</a></span>fiedler_companion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._special_matrices.fiedler_companion </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Returns a Fiedler companion matrix

Given a polynomial coefficient array ``a``, this function forms a
pentadiagonal matrix with a special structure whose eigenvalues coincides
with the roots of ``a``.

Parameters
----------
a : (N,) array_like
    1-D array of polynomial coefficients in descending order with a nonzero
    leading coefficient. For ``N &lt; 2``, an empty array is returned.

Returns
-------
c : (N-1, N-1) ndarray
    Resulting companion matrix

See Also
--------
companion

Notes
-----
Similar to `companion` the leading coefficient should be nonzero. In the case
the leading coefficient is not 1, other coefficients are rescaled before
the array generation. To avoid numerical issues, it is best to provide a
monic polynomial.

.. versionadded:: 1.3.0

References
----------
.. [1] M. Fiedler, " A note on companion matrices", Linear Algebra and its
    Applications, 2003, :doi:`10.1016/S0024-3795(03)00548-2`

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy.linalg import fiedler_companion, eigvals
&gt;&gt;&gt; p = np.poly(np.arange(1, 9, 2))  # [1., -16., 86., -176., 105.]
&gt;&gt;&gt; fc = fiedler_companion(p)
&gt;&gt;&gt; fc
array([[  16.,  -86.,    1.,    0.],
       [   1.,    0.,    0.,    0.],
       [   0.,  176.,    0., -105.],
       [   0.,    1.,    0.,    0.]])
&gt;&gt;&gt; eigvals(fc)
array([7.+0.j, 5.+0.j, 3.+0.j, 1.+0.j])
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d4/dbf/__special__matrices_8py_source.html#l01140">1140</a> of file <a class="el" href="../../d4/dbf/__special__matrices_8py_source.html">_special_matrices.py</a>.</p>

</div>
</div>
<a id="aa5bf88c8cf8014413ffbf3f2e86169f8" name="aa5bf88c8cf8014413ffbf3f2e86169f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5bf88c8cf8014413ffbf3f2e86169f8">&#9670;&#160;</a></span>hadamard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._special_matrices.hadamard </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>dtype</em></span><span class="paramdefsep"> = </span><span class="paramdefval">int</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Construct an Hadamard matrix.

Constructs an n-by-n Hadamard matrix, using Sylvester's
construction. `n` must be a power of 2.

Parameters
----------
n : int
    The order of the matrix. `n` must be a power of 2.
dtype : dtype, optional
    The data type of the array to be constructed.

Returns
-------
H : (n, n) ndarray
    The Hadamard matrix.

Notes
-----
.. versionadded:: 0.8.0

Examples
--------
&gt;&gt;&gt; from scipy.linalg import hadamard
&gt;&gt;&gt; hadamard(2, dtype=complex)
array([[ 1.+0.j,  1.+0.j],
       [ 1.+0.j, -1.-0.j]])
&gt;&gt;&gt; hadamard(4)
array([[ 1,  1,  1,  1],
       [ 1, -1,  1, -1],
       [ 1,  1, -1, -1],
       [ 1, -1, -1,  1]])
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d4/dbf/__special__matrices_8py_source.html#l00319">319</a> of file <a class="el" href="../../d4/dbf/__special__matrices_8py_source.html">_special_matrices.py</a>.</p>

</div>
</div>
<a id="ad74cc1ad8af780ae9c873aaae9c577a6" name="ad74cc1ad8af780ae9c873aaae9c577a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad74cc1ad8af780ae9c873aaae9c577a6">&#9670;&#160;</a></span>hankel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._special_matrices.hankel </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>r</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Construct a Hankel matrix.

The Hankel matrix has constant anti-diagonals, with `c` as its
first column and `r` as its last row. If `r` is not given, then
`r = zeros_like(c)` is assumed.

Parameters
----------
c : array_like
    First column of the matrix. Whatever the actual shape of `c`, it
    will be converted to a 1-D array.
r : array_like, optional
    Last row of the matrix. If None, ``r = zeros_like(c)`` is assumed.
    r[0] is ignored; the last row of the returned matrix is
    ``[c[-1], r[1:]]``. Whatever the actual shape of `r`, it will be
    converted to a 1-D array.

Returns
-------
A : (len(c), len(r)) ndarray
    The Hankel matrix. Dtype is the same as ``(c[0] + r[0]).dtype``.

See Also
--------
toeplitz : Toeplitz matrix
circulant : circulant matrix

Examples
--------
&gt;&gt;&gt; from scipy.linalg import hankel
&gt;&gt;&gt; hankel([1, 17, 99])
array([[ 1, 17, 99],
       [17, 99,  0],
       [99,  0,  0]])
&gt;&gt;&gt; hankel([1,2,3,4], [4,7,7,8,9])
array([[1, 2, 3, 4, 7],
       [2, 3, 4, 7, 7],
       [3, 4, 7, 7, 8],
       [4, 7, 7, 8, 9]])
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d4/dbf/__special__matrices_8py_source.html#l00262">262</a> of file <a class="el" href="../../d4/dbf/__special__matrices_8py_source.html">_special_matrices.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d4/dbf/__special__matrices_8py_source.html#l00681">hilbert()</a>.</p>

</div>
</div>
<a id="a4e2a4b3eb8c15fde671fab5cbc3ca325" name="a4e2a4b3eb8c15fde671fab5cbc3ca325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e2a4b3eb8c15fde671fab5cbc3ca325">&#9670;&#160;</a></span>helmert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._special_matrices.helmert </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>full</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create an Helmert matrix of order `n`.

This has applications in statistics, compositional or simplicial analysis,
and in Aitchison geometry.

Parameters
----------
n : int
    The size of the array to create.
full : bool, optional
    If True the (n, n) ndarray will be returned.
    Otherwise the submatrix that does not include the first
    row will be returned.
    Default: False.

Returns
-------
M : ndarray
    The Helmert matrix.
    The shape is (n, n) or (n-1, n) depending on the `full` argument.

Examples
--------
&gt;&gt;&gt; from scipy.linalg import helmert
&gt;&gt;&gt; helmert(5, full=True)
array([[ 0.4472136 ,  0.4472136 ,  0.4472136 ,  0.4472136 ,  0.4472136 ],
       [ 0.70710678, -0.70710678,  0.        ,  0.        ,  0.        ],
       [ 0.40824829,  0.40824829, -0.81649658,  0.        ,  0.        ],
       [ 0.28867513,  0.28867513,  0.28867513, -0.8660254 ,  0.        ],
       [ 0.2236068 ,  0.2236068 ,  0.2236068 ,  0.2236068 , -0.89442719]])
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d4/dbf/__special__matrices_8py_source.html#l00636">636</a> of file <a class="el" href="../../d4/dbf/__special__matrices_8py_source.html">_special_matrices.py</a>.</p>

</div>
</div>
<a id="a6f43ed3f392fe5f54db7950ca4cae260" name="a6f43ed3f392fe5f54db7950ca4cae260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f43ed3f392fe5f54db7950ca4cae260">&#9670;&#160;</a></span>hilbert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._special_matrices.hilbert </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create a Hilbert matrix of order `n`.

Returns the `n` by `n` array with entries `h[i,j] = 1 / (i + j + 1)`.

Parameters
----------
n : int
    The size of the array to create.

Returns
-------
h : (n, n) ndarray
    The Hilbert matrix.

See Also
--------
invhilbert : Compute the inverse of a Hilbert matrix.

Notes
-----
.. versionadded:: 0.10.0

Examples
--------
&gt;&gt;&gt; from scipy.linalg import hilbert
&gt;&gt;&gt; hilbert(3)
array([[ 1.        ,  0.5       ,  0.33333333],
       [ 0.5       ,  0.33333333,  0.25      ],
       [ 0.33333333,  0.25      ,  0.2       ]])
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d4/dbf/__special__matrices_8py_source.html#l00681">681</a> of file <a class="el" href="../../d4/dbf/__special__matrices_8py_source.html">_special_matrices.py</a>.</p>

<p class="reference">References <a class="el" href="../../d4/dbf/__special__matrices_8py_source.html#l00262">hankel()</a>.</p>

</div>
</div>
<a id="a97248ada231330c917b2d3acbef12d03" name="a97248ada231330c917b2d3acbef12d03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97248ada231330c917b2d3acbef12d03">&#9670;&#160;</a></span>invhilbert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._special_matrices.invhilbert </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>exact</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the inverse of the Hilbert matrix of order `n`.

The entries in the inverse of a Hilbert matrix are integers. When `n`
is greater than 14, some entries in the inverse exceed the upper limit
of 64 bit integers. The `exact` argument provides two options for
dealing with these large integers.

Parameters
----------
n : int
    The order of the Hilbert matrix.
exact : bool, optional
    If False, the data type of the array that is returned is np.float64,
    and the array is an approximation of the inverse.
    If True, the array is the exact integer inverse array. To represent
    the exact inverse when n &gt; 14, the returned array is an object array
    of long integers. For n &lt;= 14, the exact inverse is returned as an
    array with data type np.int64.

Returns
-------
invh : (n, n) ndarray
    The data type of the array is np.float64 if `exact` is False.
    If `exact` is True, the data type is either np.int64 (for n &lt;= 14)
    or object (for n &gt; 14). In the latter case, the objects in the
    array will be long integers.

See Also
--------
hilbert : Create a Hilbert matrix.

Notes
-----
.. versionadded:: 0.10.0

Examples
--------
&gt;&gt;&gt; from scipy.linalg import invhilbert
&gt;&gt;&gt; invhilbert(4)
array([[   16.,  -120.,   240.,  -140.],
       [ -120.,  1200., -2700.,  1680.],
       [  240., -2700.,  6480., -4200.],
       [ -140.,  1680., -4200.,  2800.]])
&gt;&gt;&gt; invhilbert(4, exact=True)
array([[   16,  -120,   240,  -140],
       [ -120,  1200, -2700,  1680],
       [  240, -2700,  6480, -4200],
       [ -140,  1680, -4200,  2800]], dtype=int64)
&gt;&gt;&gt; invhilbert(16)[7,7]
4.2475099528537506e+19
&gt;&gt;&gt; invhilbert(16, exact=True)[7,7]
42475099528537378560
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d4/dbf/__special__matrices_8py_source.html#l00719">719</a> of file <a class="el" href="../../d4/dbf/__special__matrices_8py_source.html">_special_matrices.py</a>.</p>

</div>
</div>
<a id="aada832342bbbbf86f533f48f5030588a" name="aada832342bbbbf86f533f48f5030588a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aada832342bbbbf86f533f48f5030588a">&#9670;&#160;</a></span>invpascal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._special_matrices.invpascal </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>kind</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'symmetric'</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>exact</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d8/d0b/classTrue.html">True</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the inverse of the n x n Pascal matrix.

The Pascal matrix is a matrix containing the binomial coefficients as
its elements.

Parameters
----------
n : int
    The size of the matrix to create; that is, the result is an n x n
    matrix.
kind : str, optional
    Must be one of 'symmetric', 'lower', or 'upper'.
    Default is 'symmetric'.
exact : bool, optional
    If `exact` is True, the result is either an array of type
    ``numpy.int64`` (if `n` &lt;= 35) or an object array of Python integers.
    If `exact` is False, the coefficients in the matrix are computed using
    `scipy.special.comb` with `exact=False`. The result will be a floating
    point array, and for large `n`, the values in the array will not be the
    exact coefficients.

Returns
-------
invp : (n, n) ndarray
    The inverse of the Pascal matrix.

See Also
--------
pascal

Notes
-----

.. versionadded:: 0.16.0

References
----------
.. [1] "Pascal matrix", https://en.wikipedia.org/wiki/Pascal_matrix
.. [2] Cohen, A. M., "The inverse of a Pascal matrix", Mathematical
       Gazette, 59(408), pp. 111-112, 1975.

Examples
--------
&gt;&gt;&gt; from scipy.linalg import invpascal, pascal
&gt;&gt;&gt; invp = invpascal(5)
&gt;&gt;&gt; invp
array([[  5, -10,  10,  -5,   1],
       [-10,  30, -35,  19,  -4],
       [ 10, -35,  46, -27,   6],
       [ -5,  19, -27,  17,  -4],
       [  1,  -4,   6,  -4,   1]])

&gt;&gt;&gt; p = pascal(5)
&gt;&gt;&gt; p.dot(invp)
array([[ 1.,  0.,  0.,  0.,  0.],
       [ 0.,  1.,  0.,  0.,  0.],
       [ 0.,  0.,  1.,  0.,  0.],
       [ 0.,  0.,  0.,  1.,  0.],
       [ 0.,  0.,  0.,  0.,  1.]])

An example of the use of `kind` and `exact`:

&gt;&gt;&gt; invpascal(5, kind='lower', exact=False)
array([[ 1., -0.,  0., -0.,  0.],
       [-1.,  1., -0.,  0., -0.],
       [ 1., -2.,  1., -0.,  0.],
       [-1.,  3., -3.,  1., -0.],
       [ 1., -4.,  6., -4.,  1.]])
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d4/dbf/__special__matrices_8py_source.html#l00882">882</a> of file <a class="el" href="../../d4/dbf/__special__matrices_8py_source.html">_special_matrices.py</a>.</p>

<p class="reference">References <a class="el" href="../../d4/dbf/__special__matrices_8py_source.html#l00796">pascal()</a>, and <a class="el" href="../../d4/dbf/__special__matrices_8py_source.html#l00158">toeplitz()</a>.</p>

</div>
</div>
<a id="a873011de8094c873bd302bfe61ea9284" name="a873011de8094c873bd302bfe61ea9284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a873011de8094c873bd302bfe61ea9284">&#9670;&#160;</a></span>kron()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._special_matrices.kron </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Kronecker product.

The result is the block matrix::

    a[0,0]*b    a[0,1]*b  ... a[0,-1]*b
    a[1,0]*b    a[1,1]*b  ... a[1,-1]*b
    ...
    a[-1,0]*b   a[-1,1]*b ... a[-1,-1]*b

Parameters
----------
a : (M, N) ndarray
    Input array
b : (P, Q) ndarray
    Input array

Returns
-------
A : (M*P, N*Q) ndarray
    Kronecker product of `a` and `b`.

Examples
--------
&gt;&gt;&gt; from numpy import array
&gt;&gt;&gt; from scipy.linalg import kron
&gt;&gt;&gt; kron(array([[1,2],[3,4]]), array([[1,1,1]]))
array([[1, 1, 1, 2, 2, 2],
       [3, 3, 3, 4, 4, 4]])
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d4/dbf/__special__matrices_8py_source.html#l00448">448</a> of file <a class="el" href="../../d4/dbf/__special__matrices_8py_source.html">_special_matrices.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d3/dd9/__solvers_8py_source.html#l00206">scipy.linalg._solvers._solve_discrete_lyapunov_direct()</a>.</p>

</div>
</div>
<a id="ac0a31d0a2fb9751f80187a3c496246f0" name="ac0a31d0a2fb9751f80187a3c496246f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0a31d0a2fb9751f80187a3c496246f0">&#9670;&#160;</a></span>leslie()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._special_matrices.leslie </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create a Leslie matrix.

Given the length n array of fecundity coefficients `f` and the length
n-1 array of survival coefficients `s`, return the associated Leslie
matrix.

Parameters
----------
f : (N,) array_like
    The "fecundity" coefficients.
s : (N-1,) array_like
    The "survival" coefficients, has to be 1-D.  The length of `s`
    must be one less than the length of `f`, and it must be at least 1.

Returns
-------
L : (N, N) ndarray
    The array is zero except for the first row,
    which is `f`, and the first sub-diagonal, which is `s`.
    The data-type of the array will be the data-type of ``f[0]+s[0]``.

Notes
-----
.. versionadded:: 0.8.0

The Leslie matrix is used to model discrete-time, age-structured
population growth [1]_ [2]_. In a population with `n` age classes, two sets
of parameters define a Leslie matrix: the `n` "fecundity coefficients",
which give the number of offspring per-capita produced by each age
class, and the `n` - 1 "survival coefficients", which give the
per-capita survival rate of each age class.

References
----------
.. [1] P. H. Leslie, On the use of matrices in certain population
       mathematics, Biometrika, Vol. 33, No. 3, 183--212 (Nov. 1945)
.. [2] P. H. Leslie, Some further notes on the use of matrices in
       population mathematics, Biometrika, Vol. 35, No. 3/4, 213--245
       (Dec. 1948)

Examples
--------
&gt;&gt;&gt; from scipy.linalg import leslie
&gt;&gt;&gt; leslie([0.1, 2.0, 1.0, 0.1], [0.2, 0.8, 0.7])
array([[ 0.1,  2. ,  1. ,  0.1],
       [ 0.2,  0. ,  0. ,  0. ],
       [ 0. ,  0.8,  0. ,  0. ],
       [ 0. ,  0. ,  0.7,  0. ]])
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d4/dbf/__special__matrices_8py_source.html#l00376">376</a> of file <a class="el" href="../../d4/dbf/__special__matrices_8py_source.html">_special_matrices.py</a>.</p>

</div>
</div>
<a id="ac723ea273038dbe546e0fe83a0b9ae47" name="ac723ea273038dbe546e0fe83a0b9ae47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac723ea273038dbe546e0fe83a0b9ae47">&#9670;&#160;</a></span>pascal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._special_matrices.pascal </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>kind</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'symmetric'</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>exact</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d8/d0b/classTrue.html">True</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the n x n Pascal matrix.

The Pascal matrix is a matrix containing the binomial coefficients as
its elements.

Parameters
----------
n : int
    The size of the matrix to create; that is, the result is an n x n
    matrix.
kind : str, optional
    Must be one of 'symmetric', 'lower', or 'upper'.
    Default is 'symmetric'.
exact : bool, optional
    If `exact` is True, the result is either an array of type
    numpy.uint64 (if n &lt; 35) or an object array of Python long integers.
    If `exact` is False, the coefficients in the matrix are computed using
    `scipy.special.comb` with `exact=False`. The result will be a floating
    point array, and the values in the array will not be the exact
    coefficients, but this version is much faster than `exact=True`.

Returns
-------
p : (n, n) ndarray
    The Pascal matrix.

See Also
--------
invpascal

Notes
-----
See https://en.wikipedia.org/wiki/Pascal_matrix for more information
about Pascal matrices.

.. versionadded:: 0.11.0

Examples
--------
&gt;&gt;&gt; from scipy.linalg import pascal
&gt;&gt;&gt; pascal(4)
array([[ 1,  1,  1,  1],
       [ 1,  2,  3,  4],
       [ 1,  3,  6, 10],
       [ 1,  4, 10, 20]], dtype=uint64)
&gt;&gt;&gt; pascal(4, kind='lower')
array([[1, 0, 0, 0],
       [1, 1, 0, 0],
       [1, 2, 1, 0],
       [1, 3, 3, 1]], dtype=uint64)
&gt;&gt;&gt; pascal(50)[-1, -1]
25477612258980856902730428600
&gt;&gt;&gt; from scipy.special import comb
&gt;&gt;&gt; comb(98, 49, exact=True)
25477612258980856902730428600
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d4/dbf/__special__matrices_8py_source.html#l00796">796</a> of file <a class="el" href="../../d4/dbf/__special__matrices_8py_source.html">_special_matrices.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d4/dbf/__special__matrices_8py_source.html#l00882">invpascal()</a>.</p>

</div>
</div>
<a id="a804e14de09dc0496e3975329dd059e83" name="a804e14de09dc0496e3975329dd059e83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a804e14de09dc0496e3975329dd059e83">&#9670;&#160;</a></span>toeplitz()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._special_matrices.toeplitz </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>r</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Construct a Toeplitz matrix.

The Toeplitz matrix has constant diagonals, with c as its first column
and r as its first row. If r is not given, ``r == conjugate(c)`` is
assumed.

Parameters
----------
c : array_like
    First column of the matrix.  Whatever the actual shape of `c`, it
    will be converted to a 1-D array.
r : array_like, optional
    First row of the matrix. If None, ``r = conjugate(c)`` is assumed;
    in this case, if c[0] is real, the result is a Hermitian matrix.
    r[0] is ignored; the first row of the returned matrix is
    ``[c[0], r[1:]]``.  Whatever the actual shape of `r`, it will be
    converted to a 1-D array.

Returns
-------
A : (len(c), len(r)) ndarray
    The Toeplitz matrix. Dtype is the same as ``(c[0] + r[0]).dtype``.

See Also
--------
circulant : circulant matrix
hankel : Hankel matrix
solve_toeplitz : Solve a Toeplitz system.

Notes
-----
The behavior when `c` or `r` is a scalar, or when `c` is complex and
`r` is None, was changed in version 0.8.0. The behavior in previous
versions was undocumented and is no longer supported.

Examples
--------
&gt;&gt;&gt; from scipy.linalg import toeplitz
&gt;&gt;&gt; toeplitz([1,2,3], [1,4,5,6])
array([[1, 4, 5, 6],
       [2, 1, 4, 5],
       [3, 2, 1, 4]])
&gt;&gt;&gt; toeplitz([1.0, 2+3j, 4-1j])
array([[ 1.+0.j,  2.-3.j,  4.+1.j],
       [ 2.+3.j,  1.+0.j,  2.-3.j],
       [ 4.-1.j,  2.+3.j,  1.+0.j]])
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d4/dbf/__special__matrices_8py_source.html#l00158">158</a> of file <a class="el" href="../../d4/dbf/__special__matrices_8py_source.html">_special_matrices.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d4/dbf/__special__matrices_8py_source.html#l01218">convolution_matrix()</a>, <a class="el" href="../../d4/dbf/__special__matrices_8py_source.html#l00882">invpascal()</a>, and <a class="el" href="../../dd/d83/test__special__matrices_8py_source.html#l00140">scipy.linalg.tests.test_special_matrices.TestToeplitz.test_scalar_00()</a>.</p>

</div>
</div>
<a id="adbf1d041cdb29a518a9cc4156563d9fb" name="adbf1d041cdb29a518a9cc4156563d9fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbf1d041cdb29a518a9cc4156563d9fb">&#9670;&#160;</a></span>tri()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._special_matrices.tri </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>N</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>M</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>k</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>dtype</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">.. deprecated:: 1.11.0
    `tri` is deprecated in favour of `numpy.tri` and will be removed in
    SciPy 1.13.0.    

Construct (N, M) matrix filled with ones at and below the kth diagonal.

The matrix has A[i,j] == 1 for j &lt;= i + k

Parameters
----------
N : int
    The size of the first dimension of the matrix.
M : int or None, optional
    The size of the second dimension of the matrix. If `M` is None,
    `M = N` is assumed.
k : int, optional
    Number of subdiagonal below which matrix is filled with ones.
    `k` = 0 is the main diagonal, `k` &lt; 0 subdiagonal and `k` &gt; 0
    superdiagonal.
dtype : dtype, optional
    Data type of the matrix.

Returns
-------
tri : (N, M) ndarray
    Tri matrix.

Examples
--------
&gt;&gt;&gt; from scipy.linalg import tri
&gt;&gt;&gt; tri(3, 5, 2, dtype=int)
array([[1, 1, 1, 0, 0],
       [1, 1, 1, 1, 0],
       [1, 1, 1, 1, 1]])
&gt;&gt;&gt; tri(3, 5, -1, dtype=int)
array([[0, 0, 0, 0, 0],
       [1, 0, 0, 0, 0],
       [1, 1, 0, 0, 0]])
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d4/dbf/__special__matrices_8py_source.html#l00022">22</a> of file <a class="el" href="../../d4/dbf/__special__matrices_8py_source.html">_special_matrices.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d4/dbf/__special__matrices_8py_source.html#l00083">tril()</a>, and <a class="el" href="../../d4/dbf/__special__matrices_8py_source.html#l00120">triu()</a>.</p>

</div>
</div>
<a id="a5e9df53d999e3af2182cfee51b697af2" name="a5e9df53d999e3af2182cfee51b697af2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e9df53d999e3af2182cfee51b697af2">&#9670;&#160;</a></span>tril()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._special_matrices.tril </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>k</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">.. deprecated:: 1.11.0
    `tril` is deprecated in favour of `numpy.tril` and will be removed in
    SciPy 1.13.0.

Make a copy of a matrix with elements above the kth diagonal zeroed.

Parameters
----------
m : array_like
    Matrix whose elements to return
k : int, optional
    Diagonal above which to zero elements.
    `k` == 0 is the main diagonal, `k` &lt; 0 subdiagonal and
    `k` &gt; 0 superdiagonal.

Returns
-------
tril : ndarray
    Return is the same shape and type as `m`.

Examples
--------
&gt;&gt;&gt; from scipy.linalg import tril
&gt;&gt;&gt; tril([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)
array([[ 0,  0,  0],
       [ 4,  0,  0],
       [ 7,  8,  0],
       [10, 11, 12]])
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d4/dbf/__special__matrices_8py_source.html#l00083">83</a> of file <a class="el" href="../../d4/dbf/__special__matrices_8py_source.html">_special_matrices.py</a>.</p>

<p class="reference">References <a class="el" href="../../d4/dbf/__special__matrices_8py_source.html#l00022">tri()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dc/dc1/__decomp__ldl_8py_source.html#l00242">scipy.linalg._decomp_ldl._ldl_get_d_and_l()</a>, <a class="el" href="../../da/da6/test__lapack_8py_source.html#l01423">scipy.linalg.tests.test_lapack.test_syconv()</a>, <a class="el" href="../../da/da6/test__lapack_8py_source.html#l01201">scipy.linalg.tests.test_lapack.test_tfttr_trttf()</a>, and <a class="el" href="../../da/da6/test__lapack_8py_source.html#l01259">scipy.linalg.tests.test_lapack.test_tpttr_trttp()</a>.</p>

</div>
</div>
<a id="aef9793e4c7a01acf622dbf785e15cc45" name="aef9793e4c7a01acf622dbf785e15cc45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef9793e4c7a01acf622dbf785e15cc45">&#9670;&#160;</a></span>triu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._special_matrices.triu </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>k</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">.. deprecated:: 1.11.0
    `tril` is deprecated in favour of `numpy.triu` and will be removed in
    SciPy 1.13.0.

Make a copy of a matrix with elements below the kth diagonal zeroed.

Parameters
----------
m : array_like
    Matrix whose elements to return
k : int, optional
    Diagonal below which to zero elements.
    `k` == 0 is the main diagonal, `k` &lt; 0 subdiagonal and
    `k` &gt; 0 superdiagonal.

Returns
-------
triu : ndarray
    Return matrix with zeroed elements below the kth diagonal and has
    same shape and type as `m`.

Examples
--------
&gt;&gt;&gt; from scipy.linalg import triu
&gt;&gt;&gt; triu([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)
array([[ 1,  2,  3],
       [ 4,  5,  6],
       [ 0,  8,  9],
       [ 0,  0, 12]])
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d4/dbf/__special__matrices_8py_source.html#l00120">120</a> of file <a class="el" href="../../d4/dbf/__special__matrices_8py_source.html">_special_matrices.py</a>.</p>

<p class="reference">References <a class="el" href="../../d4/dbf/__special__matrices_8py_source.html#l00022">tri()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dc/dc1/__decomp__ldl_8py_source.html#l00242">scipy.linalg._decomp_ldl._ldl_get_d_and_l()</a>, <a class="el" href="../../d6/d8b/linalg_2__matfuncs_8py_source.html#l00634">scipy.linalg._matfuncs.funm()</a>, <a class="el" href="../../da/da6/test__lapack_8py_source.html#l01143">scipy.linalg.tests.test_lapack.test_ormrz_unmrz()</a>, <a class="el" href="../../da/da6/test__lapack_8py_source.html#l01327">scipy.linalg.tests.test_lapack.test_pftri()</a>, <a class="el" href="../../da/da6/test__lapack_8py_source.html#l01396">scipy.linalg.tests.test_lapack.test_sfrk_hfrk()</a>, <a class="el" href="../../da/da6/test__lapack_8py_source.html#l01423">scipy.linalg.tests.test_lapack.test_syconv()</a>, <a class="el" href="../../da/da6/test__lapack_8py_source.html#l01102">scipy.linalg.tests.test_lapack.test_tfsm()</a>, <a class="el" href="../../da/da6/test__lapack_8py_source.html#l01201">scipy.linalg.tests.test_lapack.test_tfttr_trttf()</a>, <a class="el" href="../../da/da6/test__lapack_8py_source.html#l01259">scipy.linalg.tests.test_lapack.test_tpttr_trttp()</a>, and <a class="el" href="../../da/da6/test__lapack_8py_source.html#l01068">scipy.linalg.tests.test_lapack.test_tzrzf()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ae2e2b6b280d7cad3219d9a6be3e4a1f2" name="ae2e2b6b280d7cad3219d9a6be3e4a1f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2e2b6b280d7cad3219d9a6be3e4a1f2">&#9670;&#160;</a></span>__all__</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">list scipy.linalg._special_matrices.__all__</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  [<span class="stringliteral">&#39;tri&#39;</span>, <span class="stringliteral">&#39;tril&#39;</span>, <span class="stringliteral">&#39;triu&#39;</span>, <span class="stringliteral">&#39;toeplitz&#39;</span>, <span class="stringliteral">&#39;circulant&#39;</span>, <span class="stringliteral">&#39;hankel&#39;</span>,</div>
<div class="line"><span class="lineno">    2</span>           <span class="stringliteral">&#39;hadamard&#39;</span>, <span class="stringliteral">&#39;leslie&#39;</span>, <span class="stringliteral">&#39;kron&#39;</span>, <span class="stringliteral">&#39;block_diag&#39;</span>, <span class="stringliteral">&#39;companion&#39;</span>,</div>
<div class="line"><span class="lineno">    3</span>           <span class="stringliteral">&#39;helmert&#39;</span>, <span class="stringliteral">&#39;hilbert&#39;</span>, <span class="stringliteral">&#39;invhilbert&#39;</span>, <span class="stringliteral">&#39;pascal&#39;</span>, <span class="stringliteral">&#39;invpascal&#39;</span>, <span class="stringliteral">&#39;dft&#39;</span>,</div>
<div class="line"><span class="lineno">    4</span>           <span class="stringliteral">&#39;fiedler&#39;</span>, <span class="stringliteral">&#39;fiedler_companion&#39;</span>, <span class="stringliteral">&#39;convolution_matrix&#39;</span>]</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="../../d4/dbf/__special__matrices_8py_source.html#l00007">7</a> of file <a class="el" href="../../d4/dbf/__special__matrices_8py_source.html">_special_matrices.py</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../db/d0f/namespacescipy.html">scipy</a></li><li class="navelem"><a class="el" href="../../dd/dd4/namespacescipy_1_1linalg.html">linalg</a></li><li class="navelem"><a class="el" href="../../da/de7/namespacescipy_1_1linalg_1_1__special__matrices.html">_special_matrices</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
