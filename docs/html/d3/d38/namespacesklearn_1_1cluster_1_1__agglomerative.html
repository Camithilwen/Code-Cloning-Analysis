<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Code Cloning Analysis: sklearn.cluster._agglomerative Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Code Cloning Analysis
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d3/d38/namespacesklearn_1_1cluster_1_1__agglomerative.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">sklearn.cluster._agglomerative Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfe/classsklearn_1_1cluster_1_1__agglomerative_1_1AgglomerativeClustering.html">AgglomerativeClustering</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d6e/classsklearn_1_1cluster_1_1__agglomerative_1_1FeatureAgglomeration.html">FeatureAgglomeration</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0b13ca3962b9ec0e5bcb2be861306e2e" id="r_a0b13ca3962b9ec0e5bcb2be861306e2e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b13ca3962b9ec0e5bcb2be861306e2e">_fix_connectivity</a> (X, connectivity, affinity)</td></tr>
<tr class="memdesc:a0b13ca3962b9ec0e5bcb2be861306e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">For non fully-connected graphs.  <br /></td></tr>
<tr class="separator:a0b13ca3962b9ec0e5bcb2be861306e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad65876a4f74782f89c454de63e0f4310" id="r_ad65876a4f74782f89c454de63e0f4310"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad65876a4f74782f89c454de63e0f4310">_single_linkage_tree</a> (connectivity, n_samples, n_nodes, n_clusters, n_connected_components, return_distance)</td></tr>
<tr class="separator:ad65876a4f74782f89c454de63e0f4310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb2df287905ff22850b785d38d08f6c8" id="r_acb2df287905ff22850b785d38d08f6c8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb2df287905ff22850b785d38d08f6c8">ward_tree</a> (X, *, connectivity=None, n_clusters=None, return_distance=False)</td></tr>
<tr class="memdesc:acb2df287905ff22850b785d38d08f6c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hierarchical tree building functions.  <br /></td></tr>
<tr class="separator:acb2df287905ff22850b785d38d08f6c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38921d78a1744f9449ba29ce8bfd0e49" id="r_a38921d78a1744f9449ba29ce8bfd0e49"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38921d78a1744f9449ba29ce8bfd0e49">linkage_tree</a> (X, connectivity=None, n_clusters=None, linkage=&quot;complete&quot;, affinity=&quot;euclidean&quot;, return_distance=False)</td></tr>
<tr class="separator:a38921d78a1744f9449ba29ce8bfd0e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74bd194f2944183b66e9cb9fd7d025b6" id="r_a74bd194f2944183b66e9cb9fd7d025b6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74bd194f2944183b66e9cb9fd7d025b6">_complete_linkage</a> (*args, **kwargs)</td></tr>
<tr class="separator:a74bd194f2944183b66e9cb9fd7d025b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae673b271cfd3a443e0adf8d540112875" id="r_ae673b271cfd3a443e0adf8d540112875"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae673b271cfd3a443e0adf8d540112875">_average_linkage</a> (*args, **kwargs)</td></tr>
<tr class="separator:ae673b271cfd3a443e0adf8d540112875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac529c06cbb70f05802322a9dbd3a7769" id="r_ac529c06cbb70f05802322a9dbd3a7769"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac529c06cbb70f05802322a9dbd3a7769">_single_linkage</a> (*args, **kwargs)</td></tr>
<tr class="separator:ac529c06cbb70f05802322a9dbd3a7769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4100f38e807bc25c3d687cd064e8468" id="r_aa4100f38e807bc25c3d687cd064e8468"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4100f38e807bc25c3d687cd064e8468">_hc_cut</a> (n_clusters, children, n_leaves)</td></tr>
<tr class="memdesc:aa4100f38e807bc25c3d687cd064e8468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functions for cutting hierarchical clustering tree.  <br /></td></tr>
<tr class="separator:aa4100f38e807bc25c3d687cd064e8468"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a2b1947c000f96fb6a39bbaafc58697aa" id="r_a2b1947c000f96fb6a39bbaafc58697aa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b1947c000f96fb6a39bbaafc58697aa">_TREE_BUILDERS</a></td></tr>
<tr class="separator:a2b1947c000f96fb6a39bbaafc58697aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Hierarchical Agglomerative Clustering

These routines perform some hierarchical agglomerative clustering of some
input data.
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="ae673b271cfd3a443e0adf8d540112875" name="ae673b271cfd3a443e0adf8d540112875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae673b271cfd3a443e0adf8d540112875">&#9670;&#160;</a></span>_average_linkage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.cluster._agglomerative._average_linkage </td>
          <td>(</td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**</td>          <td class="paramname"><span class="paramname"><em>kwargs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d6/d1d/__agglomerative_8py_source.html#l00708">708</a> of file <a class="el" href="../../d6/d1d/__agglomerative_8py_source.html">_agglomerative.py</a>.</p>

</div>
</div>
<a id="a74bd194f2944183b66e9cb9fd7d025b6" name="a74bd194f2944183b66e9cb9fd7d025b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74bd194f2944183b66e9cb9fd7d025b6">&#9670;&#160;</a></span>_complete_linkage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.cluster._agglomerative._complete_linkage </td>
          <td>(</td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**</td>          <td class="paramname"><span class="paramname"><em>kwargs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d6/d1d/__agglomerative_8py_source.html#l00703">703</a> of file <a class="el" href="../../d6/d1d/__agglomerative_8py_source.html">_agglomerative.py</a>.</p>

</div>
</div>
<a id="a0b13ca3962b9ec0e5bcb2be861306e2e" name="a0b13ca3962b9ec0e5bcb2be861306e2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b13ca3962b9ec0e5bcb2be861306e2e">&#9670;&#160;</a></span>_fix_connectivity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.cluster._agglomerative._fix_connectivity </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>connectivity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>affinity</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For non fully-connected graphs. </p>
<pre class="fragment">Fixes the connectivity matrix.

The different steps are:

- copies it
- makes it symmetric
- converts it to LIL if necessary
- completes it if necessary.

Parameters
----------
X : array-like of shape (n_samples, n_features)
    Feature matrix representing `n_samples` samples to be clustered.

connectivity : sparse matrix, default=None
    Connectivity matrix. Defines for each sample the neighboring samples
    following a given structure of the data. The matrix is assumed to
    be symmetric and only the upper triangular half is used.
    Default is `None`, i.e, the Ward algorithm is unstructured.

affinity : {"euclidean", "precomputed"}, default="euclidean"
    Which affinity to use. At the moment `precomputed` and
    ``euclidean`` are supported. `euclidean` uses the
    negative squared Euclidean distance between points.

Returns
-------
connectivity : sparse matrix
    The fixed connectivity matrix.

n_connected_components : int
    The number of connected components in the graph.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d6/d1d/__agglomerative_8py_source.html#l00046">46</a> of file <a class="el" href="../../d6/d1d/__agglomerative_8py_source.html">_agglomerative.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d6/d1d/__agglomerative_8py_source.html#l00433">linkage_tree()</a>, and <a class="el" href="../../d6/d1d/__agglomerative_8py_source.html#l00191">ward_tree()</a>.</p>

</div>
</div>
<a id="aa4100f38e807bc25c3d687cd064e8468" name="aa4100f38e807bc25c3d687cd064e8468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4100f38e807bc25c3d687cd064e8468">&#9670;&#160;</a></span>_hc_cut()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.cluster._agglomerative._hc_cut </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n_clusters</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>children</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n_leaves</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Functions for cutting hierarchical clustering tree. </p>
<pre class="fragment">Function cutting the ward tree for a given number of clusters.

Parameters
----------
n_clusters : int or ndarray
    The number of clusters to form.

children : ndarray of shape (n_nodes-1, 2)
    The children of each non-leaf node. Values less than `n_samples`
    correspond to leaves of the tree which are the original samples.
    A node `i` greater than or equal to `n_samples` is a non-leaf
    node and has children `children_[i - n_samples]`. Alternatively
    at the i-th iteration, children[i][0] and children[i][1]
    are merged to form node `n_samples + i`.

n_leaves : int
    Number of leaves of the tree.

Returns
-------
labels : array [n_samples]
    Cluster labels for each point.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d6/d1d/__agglomerative_8py_source.html#l00729">729</a> of file <a class="el" href="../../d6/d1d/__agglomerative_8py_source.html">_agglomerative.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d6/d1d/__agglomerative_8py_source.html#l00993">sklearn.cluster._agglomerative.AgglomerativeClustering._fit()</a>.</p>

</div>
</div>
<a id="ac529c06cbb70f05802322a9dbd3a7769" name="ac529c06cbb70f05802322a9dbd3a7769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac529c06cbb70f05802322a9dbd3a7769">&#9670;&#160;</a></span>_single_linkage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.cluster._agglomerative._single_linkage </td>
          <td>(</td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**</td>          <td class="paramname"><span class="paramname"><em>kwargs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d6/d1d/__agglomerative_8py_source.html#l00713">713</a> of file <a class="el" href="../../d6/d1d/__agglomerative_8py_source.html">_agglomerative.py</a>.</p>

</div>
</div>
<a id="ad65876a4f74782f89c454de63e0f4310" name="ad65876a4f74782f89c454de63e0f4310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad65876a4f74782f89c454de63e0f4310">&#9670;&#160;</a></span>_single_linkage_tree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.cluster._agglomerative._single_linkage_tree </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>connectivity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n_samples</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n_nodes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n_clusters</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n_connected_components</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>return_distance</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Perform single linkage clustering on sparse data via the minimum
spanning tree from scipy.sparse.csgraph, then using union-find to label.
The parent array is then generated by walking through the tree.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d6/d1d/__agglomerative_8py_source.html#l00122">122</a> of file <a class="el" href="../../d6/d1d/__agglomerative_8py_source.html">_agglomerative.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d6/d1d/__agglomerative_8py_source.html#l00433">linkage_tree()</a>.</p>

</div>
</div>
<a id="a38921d78a1744f9449ba29ce8bfd0e49" name="a38921d78a1744f9449ba29ce8bfd0e49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38921d78a1744f9449ba29ce8bfd0e49">&#9670;&#160;</a></span>linkage_tree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.cluster._agglomerative.linkage_tree </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>connectivity</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n_clusters</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>linkage</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;complete&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>affinity</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;euclidean&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>return_distance</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Linkage agglomerative clustering based on a Feature matrix.

The inertia matrix uses a Heapq-based representation.

This is the structured version, that takes into account some topological
structure between samples.

Read more in the :ref:`User Guide &lt;hierarchical_clustering&gt;`.

Parameters
----------
X : array-like of shape (n_samples, n_features)
    Feature matrix representing `n_samples` samples to be clustered.

connectivity : sparse matrix, default=None
    Connectivity matrix. Defines for each sample the neighboring samples
    following a given structure of the data. The matrix is assumed to
    be symmetric and only the upper triangular half is used.
    Default is `None`, i.e, the Ward algorithm is unstructured.

n_clusters : int, default=None
    Stop early the construction of the tree at `n_clusters`. This is
    useful to decrease computation time if the number of clusters is
    not small compared to the number of samples. In this case, the
    complete tree is not computed, thus the 'children' output is of
    limited use, and the 'parents' output should rather be used.
    This option is valid only when specifying a connectivity matrix.

linkage : {"average", "complete", "single"}, default="complete"
    Which linkage criteria to use. The linkage criterion determines which
    distance to use between sets of observation.
        - "average" uses the average of the distances of each observation of
          the two sets.
        - "complete" or maximum linkage uses the maximum distances between
          all observations of the two sets.
        - "single" uses the minimum of the distances between all
          observations of the two sets.

affinity : str or callable, default='euclidean'
    Which metric to use. Can be 'euclidean', 'manhattan', or any
    distance known to paired distance (see metric.pairwise).

return_distance : bool, default=False
    Whether or not to return the distances between the clusters.

Returns
-------
children : ndarray of shape (n_nodes-1, 2)
    The children of each non-leaf node. Values less than `n_samples`
    correspond to leaves of the tree which are the original samples.
    A node `i` greater than or equal to `n_samples` is a non-leaf
    node and has children `children_[i - n_samples]`. Alternatively
    at the i-th iteration, children[i][0] and children[i][1]
    are merged to form node `n_samples + i`.

n_connected_components : int
    The number of connected components in the graph.

n_leaves : int
    The number of leaves in the tree.

parents : ndarray of shape (n_nodes, ) or None
    The parent of each node. Only returned when a connectivity matrix
    is specified, elsewhere 'None' is returned.

distances : ndarray of shape (n_nodes-1,)
    Returned when `return_distance` is set to `True`.

    distances[i] refers to the distance between children[i][0] and
    children[i][1] when they are merged.

See Also
--------
ward_tree : Hierarchical clustering with ward linkage.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d6/d1d/__agglomerative_8py_source.html#l00426">426</a> of file <a class="el" href="../../d6/d1d/__agglomerative_8py_source.html">_agglomerative.py</a>.</p>

<p class="reference">References <a class="el" href="../../d6/d1d/__agglomerative_8py_source.html#l00046">_fix_connectivity()</a>, <a class="el" href="../../d6/d1d/__agglomerative_8py_source.html#l00129">_single_linkage_tree()</a>, and <a class="el" href="../../d6/d1d/__agglomerative_8py_source.html#l00433">linkage_tree()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d6/d1d/__agglomerative_8py_source.html#l00433">linkage_tree()</a>.</p>

</div>
</div>
<a id="acb2df287905ff22850b785d38d08f6c8" name="acb2df287905ff22850b785d38d08f6c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb2df287905ff22850b785d38d08f6c8">&#9670;&#160;</a></span>ward_tree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.cluster._agglomerative.ward_tree </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>connectivity</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n_clusters</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>return_distance</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hierarchical tree building functions. </p>
<pre class="fragment">Ward clustering based on a Feature matrix.

Recursively merges the pair of clusters that minimally increases
within-cluster variance.

The inertia matrix uses a Heapq-based representation.

This is the structured version, that takes into account some topological
structure between samples.

Read more in the :ref:`User Guide &lt;hierarchical_clustering&gt;`.

Parameters
----------
X : array-like of shape (n_samples, n_features)
    Feature matrix representing `n_samples` samples to be clustered.

connectivity : {array-like, sparse matrix}, default=None
    Connectivity matrix. Defines for each sample the neighboring samples
    following a given structure of the data. The matrix is assumed to
    be symmetric and only the upper triangular half is used.
    Default is None, i.e, the Ward algorithm is unstructured.

n_clusters : int, default=None
    `n_clusters` should be less than `n_samples`.  Stop early the
    construction of the tree at `n_clusters.` This is useful to decrease
    computation time if the number of clusters is not small compared to the
    number of samples. In this case, the complete tree is not computed, thus
    the 'children' output is of limited use, and the 'parents' output should
    rather be used. This option is valid only when specifying a connectivity
    matrix.

return_distance : bool, default=False
    If `True`, return the distance between the clusters.

Returns
-------
children : ndarray of shape (n_nodes-1, 2)
    The children of each non-leaf node. Values less than `n_samples`
    correspond to leaves of the tree which are the original samples.
    A node `i` greater than or equal to `n_samples` is a non-leaf
    node and has children `children_[i - n_samples]`. Alternatively
    at the i-th iteration, children[i][0] and children[i][1]
    are merged to form node `n_samples + i`.

n_connected_components : int
    The number of connected components in the graph.

n_leaves : int
    The number of leaves in the tree.

parents : ndarray of shape (n_nodes,) or None
    The parent of each node. Only returned when a connectivity matrix
    is specified, elsewhere 'None' is returned.

distances : ndarray of shape (n_nodes-1,)
    Only returned if `return_distance` is set to `True` (for compatibility).
    The distances between the centers of the nodes. `distances[i]`
    corresponds to a weighted Euclidean distance between
    the nodes `children[i, 1]` and `children[i, 2]`. If the nodes refer to
    leaves of the tree, then `distances[i]` is their unweighted Euclidean
    distance. Distances are updated in the following way
    (from scipy.hierarchy.linkage):

    The new entry :math:`d(u,v)` is computed as follows,

    .. math::

       d(u,v) = \\sqrt{\\frac{|v|+|s|}
                           {T}d(v,s)^2
                    + \\frac{|v|+|t|}
                           {T}d(v,t)^2
                    - \\frac{|v|}
                           {T}d(s,t)^2}

    where :math:`u` is the newly joined cluster consisting of
    clusters :math:`s` and :math:`t`, :math:`v` is an unused
    cluster in the forest, :math:`T=|v|+|s|+|t|`, and
    :math:`|*|` is the cardinality of its argument. This is also
    known as the incremental algorithm.

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from sklearn.cluster import ward_tree
&gt;&gt;&gt; X = np.array([[1, 2], [1, 4], [1, 0],
...               [4, 2], [4, 4], [4, 0]])
&gt;&gt;&gt; children, n_connected_components, n_leaves, parents = ward_tree(X)
&gt;&gt;&gt; children
array([[0, 1],
       [3, 5],
       [2, 6],
       [4, 7],
       [8, 9]])
&gt;&gt;&gt; n_connected_components
1
&gt;&gt;&gt; n_leaves
6
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d6/d1d/__agglomerative_8py_source.html#l00191">191</a> of file <a class="el" href="../../d6/d1d/__agglomerative_8py_source.html">_agglomerative.py</a>.</p>

<p class="reference">References <a class="el" href="../../d6/d1d/__agglomerative_8py_source.html#l00046">_fix_connectivity()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a2b1947c000f96fb6a39bbaafc58697aa" name="a2b1947c000f96fb6a39bbaafc58697aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b1947c000f96fb6a39bbaafc58697aa">&#9670;&#160;</a></span>_TREE_BUILDERS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.cluster._agglomerative._TREE_BUILDERS</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  dict(</div>
<div class="line"><span class="lineno">    2</span>    ward=ward_tree,</div>
<div class="line"><span class="lineno">    3</span>    complete=_complete_linkage,</div>
<div class="line"><span class="lineno">    4</span>    average=_average_linkage,</div>
<div class="line"><span class="lineno">    5</span>    single=_single_linkage,</div>
<div class="line"><span class="lineno">    6</span>)</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="../../d6/d1d/__agglomerative_8py_source.html#l00718">718</a> of file <a class="el" href="../../d6/d1d/__agglomerative_8py_source.html">_agglomerative.py</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d6/d1d/namespacesklearn.html">sklearn</a></li><li class="navelem"><a class="el" href="../../d8/d01/namespacesklearn_1_1cluster.html">cluster</a></li><li class="navelem"><a class="el" href="../../d3/d38/namespacesklearn_1_1cluster_1_1__agglomerative.html">_agglomerative</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
