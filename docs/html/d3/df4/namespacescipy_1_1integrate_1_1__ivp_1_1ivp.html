<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Code Cloning Analysis: scipy.integrate._ivp.ivp Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Code Cloning Analysis
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d3/df4/namespacescipy_1_1integrate_1_1__ivp_1_1ivp.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">scipy.integrate._ivp.ivp Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d45/classscipy_1_1integrate_1_1__ivp_1_1ivp_1_1OdeResult.html">OdeResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2bd524e6874fbf3d7eb6197e22f391f7" id="r_a2bd524e6874fbf3d7eb6197e22f391f7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2bd524e6874fbf3d7eb6197e22f391f7">prepare_events</a> (events)</td></tr>
<tr class="separator:a2bd524e6874fbf3d7eb6197e22f391f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69a224cb82ae44c7221aec878313de6" id="r_af69a224cb82ae44c7221aec878313de6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af69a224cb82ae44c7221aec878313de6">solve_event_equation</a> (event, sol, t_old, t)</td></tr>
<tr class="separator:af69a224cb82ae44c7221aec878313de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e233bb8153b216ec17cdda179d98da2" id="r_a2e233bb8153b216ec17cdda179d98da2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e233bb8153b216ec17cdda179d98da2">handle_events</a> (sol, events, active_events, is_terminal, t_old, t)</td></tr>
<tr class="separator:a2e233bb8153b216ec17cdda179d98da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb40a6f493108b392e598070ec378dc" id="r_aedb40a6f493108b392e598070ec378dc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aedb40a6f493108b392e598070ec378dc">find_active_events</a> (g, g_new, direction)</td></tr>
<tr class="separator:aedb40a6f493108b392e598070ec378dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f365255db6d7cf4fcfeebdcc68ec11e" id="r_a2f365255db6d7cf4fcfeebdcc68ec11e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f365255db6d7cf4fcfeebdcc68ec11e">solve_ivp</a> (fun, t_span, y0, method='<a class="el" href="../../d4/d77/classscipy_1_1integrate_1_1__ivp_1_1rk_1_1RK45.html">RK45</a>', t_eval=None, dense_output=False, events=None, vectorized=False, args=None, **options)</td></tr>
<tr class="separator:a2f365255db6d7cf4fcfeebdcc68ec11e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a80440f90e45322aa39e237b7055ce687" id="r_a80440f90e45322aa39e237b7055ce687"><td class="memItemLeft" align="right" valign="top">dict&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80440f90e45322aa39e237b7055ce687">METHODS</a></td></tr>
<tr class="separator:a80440f90e45322aa39e237b7055ce687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1fea86006b69f5100e628e463bff7a2" id="r_ae1fea86006b69f5100e628e463bff7a2"><td class="memItemLeft" align="right" valign="top">dict&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1fea86006b69f5100e628e463bff7a2">MESSAGES</a></td></tr>
<tr class="separator:ae1fea86006b69f5100e628e463bff7a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="aedb40a6f493108b392e598070ec378dc" name="aedb40a6f493108b392e598070ec378dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedb40a6f493108b392e598070ec378dc">&#9670;&#160;</a></span>find_active_events()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.integrate._ivp.ivp.find_active_events </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>g_new</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>direction</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find which event occurred during an integration step.

Parameters
----------
g, g_new : array_like, shape (n_events,)
    Values of event functions at a current and next points.
direction : ndarray, shape (n_events,)
    Event "direction" according to the definition in `solve_ivp`.

Returns
-------
active_events : ndarray
    Indices of events which occurred during the step.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d9/d73/ivp_8py_source.html#l00130">130</a> of file <a class="el" href="../../d9/d73/ivp_8py_source.html">ivp.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d9/d73/ivp_8py_source.html#l00157">solve_ivp()</a>.</p>

</div>
</div>
<a id="a2e233bb8153b216ec17cdda179d98da2" name="a2e233bb8153b216ec17cdda179d98da2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e233bb8153b216ec17cdda179d98da2">&#9670;&#160;</a></span>handle_events()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.integrate._ivp.ivp.handle_events </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>sol</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>events</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>active_events</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>is_terminal</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>t_old</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Helper function to handle events.

Parameters
----------
sol : DenseOutput
    Function ``sol(t)`` which evaluates an ODE solution between `t_old`
    and  `t`.
events : list of callables, length n_events
    Event functions with signatures ``event(t, y)``.
active_events : ndarray
    Indices of events which occurred.
is_terminal : ndarray, shape (n_events,)
    Which events are terminal.
t_old, t : float
    Previous and new values of time.

Returns
-------
root_indices : ndarray
    Indices of events which take zero between `t_old` and `t` and before
    a possible termination.
roots : ndarray
    Values of t at which events occurred.
terminate : bool
    Whether a terminal event occurred.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d9/d73/ivp_8py_source.html#l00081">81</a> of file <a class="el" href="../../d9/d73/ivp_8py_source.html">ivp.py</a>.</p>

<p class="reference">References <a class="el" href="../../d9/d73/ivp_8py_source.html#l00053">solve_event_equation()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d9/d73/ivp_8py_source.html#l00157">solve_ivp()</a>.</p>

</div>
</div>
<a id="a2bd524e6874fbf3d7eb6197e22f391f7" name="a2bd524e6874fbf3d7eb6197e22f391f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bd524e6874fbf3d7eb6197e22f391f7">&#9670;&#160;</a></span>prepare_events()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.integrate._ivp.ivp.prepare_events </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>events</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Standardize event functions and extract is_terminal and direction.</pre> 
<p class="definition">Definition at line <a class="el" href="../../d9/d73/ivp_8py_source.html#l00028">28</a> of file <a class="el" href="../../d9/d73/ivp_8py_source.html">ivp.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d9/d73/ivp_8py_source.html#l00157">solve_ivp()</a>.</p>

</div>
</div>
<a id="af69a224cb82ae44c7221aec878313de6" name="af69a224cb82ae44c7221aec878313de6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af69a224cb82ae44c7221aec878313de6">&#9670;&#160;</a></span>solve_event_equation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.integrate._ivp.ivp.solve_event_equation </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>event</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>sol</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>t_old</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solve an equation corresponding to an ODE event.

The equation is ``event(t, y(t)) = 0``, here ``y(t)`` is known from an
ODE solver using some sort of interpolation. It is solved by
`scipy.optimize.brentq` with xtol=atol=4*EPS.

Parameters
----------
event : callable
    Function ``event(t, y)``.
sol : callable
    Function ``sol(t)`` which evaluates an ODE solution between `t_old`
    and  `t`.
t_old, t : float
    Previous and new values of time. They will be used as a bracketing
    interval.

Returns
-------
root : float
    Found solution.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d9/d73/ivp_8py_source.html#l00053">53</a> of file <a class="el" href="../../d9/d73/ivp_8py_source.html">ivp.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d9/d73/ivp_8py_source.html#l00081">handle_events()</a>.</p>

</div>
</div>
<a id="a2f365255db6d7cf4fcfeebdcc68ec11e" name="a2f365255db6d7cf4fcfeebdcc68ec11e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f365255db6d7cf4fcfeebdcc68ec11e">&#9670;&#160;</a></span>solve_ivp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.integrate._ivp.ivp.solve_ivp </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>fun</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>t_span</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>method</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'<a class="el" href="../../d4/d77/classscipy_1_1integrate_1_1__ivp_1_1rk_1_1RK45.html">RK45</a>'</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>t_eval</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>dense_output</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>events</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>vectorized</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>args</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solve an initial value problem for a system of ODEs.

This function numerically integrates a system of ordinary differential
equations given an initial value::

    dy / dt = f(t, y)
    y(t0) = y0

Here t is a 1-D independent variable (time), y(t) is an
N-D vector-valued function (state), and an N-D
vector-valued function f(t, y) determines the differential equations.
The goal is to find y(t) approximately satisfying the differential
equations, given an initial value y(t0)=y0.

Some of the solvers support integration in the complex domain, but note
that for stiff ODE solvers, the right-hand side must be
complex-differentiable (satisfy Cauchy-Riemann equations [11]_).
To solve a problem in the complex domain, pass y0 with a complex data type.
Another option always available is to rewrite your problem for real and
imaginary parts separately.

Parameters
----------
fun : callable
    Right-hand side of the system: the time derivative of the state ``y``
    at time ``t``. The calling signature is ``fun(t, y)``, where ``t`` is a
    scalar and ``y`` is an ndarray with ``len(y) = len(y0)``. ``fun`` must
    return an array of the same shape as ``y``. See `vectorized` for more
    information.
t_span : 2-member sequence
    Interval of integration (t0, tf). The solver starts with t=t0 and
    integrates until it reaches t=tf. Both t0 and tf must be floats
    or values interpretable by the float conversion function.
y0 : array_like, shape (n,)
    Initial state. For problems in the complex domain, pass `y0` with a
    complex data type (even if the initial value is purely real).
method : string or `OdeSolver`, optional
    Integration method to use:

        * 'RK45' (default): Explicit Runge-Kutta method of order 5(4) [1]_.
          The error is controlled assuming accuracy of the fourth-order
          method, but steps are taken using the fifth-order accurate
          formula (local extrapolation is done). A quartic interpolation
          polynomial is used for the dense output [2]_. Can be applied in
          the complex domain.
        * 'RK23': Explicit Runge-Kutta method of order 3(2) [3]_. The error
          is controlled assuming accuracy of the second-order method, but
          steps are taken using the third-order accurate formula (local
          extrapolation is done). A cubic Hermite polynomial is used for the
          dense output. Can be applied in the complex domain.
        * 'DOP853': Explicit Runge-Kutta method of order 8 [13]_.
          Python implementation of the "DOP853" algorithm originally
          written in Fortran [14]_. A 7-th order interpolation polynomial
          accurate to 7-th order is used for the dense output.
          Can be applied in the complex domain.
        * 'Radau': Implicit Runge-Kutta method of the Radau IIA family of
          order 5 [4]_. The error is controlled with a third-order accurate
          embedded formula. A cubic polynomial which satisfies the
          collocation conditions is used for the dense output.
        * 'BDF': Implicit multi-step variable-order (1 to 5) method based
          on a backward differentiation formula for the derivative
          approximation [5]_. The implementation follows the one described
          in [6]_. A quasi-constant step scheme is used and accuracy is
          enhanced using the NDF modification. Can be applied in the
          complex domain.
        * 'LSODA': Adams/BDF method with automatic stiffness detection and
          switching [7]_, [8]_. This is a wrapper of the Fortran solver
          from ODEPACK.

    Explicit Runge-Kutta methods ('RK23', 'RK45', 'DOP853') should be used
    for non-stiff problems and implicit methods ('Radau', 'BDF') for
    stiff problems [9]_. Among Runge-Kutta methods, 'DOP853' is recommended
    for solving with high precision (low values of `rtol` and `atol`).

    If not sure, first try to run 'RK45'. If it makes unusually many
    iterations, diverges, or fails, your problem is likely to be stiff and
    you should use 'Radau' or 'BDF'. 'LSODA' can also be a good universal
    choice, but it might be somewhat less convenient to work with as it
    wraps old Fortran code.

    You can also pass an arbitrary class derived from `OdeSolver` which
    implements the solver.
t_eval : array_like or None, optional
    Times at which to store the computed solution, must be sorted and lie
    within `t_span`. If None (default), use points selected by the solver.
dense_output : bool, optional
    Whether to compute a continuous solution. Default is False.
events : callable, or list of callables, optional
    Events to track. If None (default), no events will be tracked.
    Each event occurs at the zeros of a continuous function of time and
    state. Each function must have the signature ``event(t, y)`` and return
    a float. The solver will find an accurate value of `t` at which
    ``event(t, y(t)) = 0`` using a root-finding algorithm. By default, all
    zeros will be found. The solver looks for a sign change over each step,
    so if multiple zero crossings occur within one step, events may be
    missed. Additionally each `event` function might have the following
    attributes:

        terminal: bool, optional
            Whether to terminate integration if this event occurs.
            Implicitly False if not assigned.
        direction: float, optional
            Direction of a zero crossing. If `direction` is positive,
            `event` will only trigger when going from negative to positive,
            and vice versa if `direction` is negative. If 0, then either
            direction will trigger event. Implicitly 0 if not assigned.

    You can assign attributes like ``event.terminal = True`` to any
    function in Python.
vectorized : bool, optional
    Whether `fun` can be called in a vectorized fashion. Default is False.

    If ``vectorized`` is False, `fun` will always be called with ``y`` of
    shape ``(n,)``, where ``n = len(y0)``.

    If ``vectorized`` is True, `fun` may be called with ``y`` of shape
    ``(n, k)``, where ``k`` is an integer. In this case, `fun` must behave
    such that ``fun(t, y)[:, i] == fun(t, y[:, i])`` (i.e. each column of
    the returned array is the time derivative of the state corresponding
    with a column of ``y``).

    Setting ``vectorized=True`` allows for faster finite difference
    approximation of the Jacobian by methods 'Radau' and 'BDF', but
    will result in slower execution for other methods and for 'Radau' and
    'BDF' in some circumstances (e.g. small ``len(y0)``).
args : tuple, optional
    Additional arguments to pass to the user-defined functions.  If given,
    the additional arguments are passed to all user-defined functions.
    So if, for example, `fun` has the signature ``fun(t, y, a, b, c)``,
    then `jac` (if given) and any event functions must have the same
    signature, and `args` must be a tuple of length 3.
**options
    Options passed to a chosen solver. All options available for already
    implemented solvers are listed below.
first_step : float or None, optional
    Initial step size. Default is `None` which means that the algorithm
    should choose.
max_step : float, optional
    Maximum allowed step size. Default is np.inf, i.e., the step size is not
    bounded and determined solely by the solver.
rtol, atol : float or array_like, optional
    Relative and absolute tolerances. The solver keeps the local error
    estimates less than ``atol + rtol * abs(y)``. Here `rtol` controls a
    relative accuracy (number of correct digits), while `atol` controls
    absolute accuracy (number of correct decimal places). To achieve the
    desired `rtol`, set `atol` to be smaller than the smallest value that
    can be expected from ``rtol * abs(y)`` so that `rtol` dominates the
    allowable error. If `atol` is larger than ``rtol * abs(y)`` the
    number of correct digits is not guaranteed. Conversely, to achieve the
    desired `atol` set `rtol` such that ``rtol * abs(y)`` is always smaller
    than `atol`. If components of y have different scales, it might be
    beneficial to set different `atol` values for different components by
    passing array_like with shape (n,) for `atol`. Default values are
    1e-3 for `rtol` and 1e-6 for `atol`.
jac : array_like, sparse_matrix, callable or None, optional
    Jacobian matrix of the right-hand side of the system with respect
    to y, required by the 'Radau', 'BDF' and 'LSODA' method. The
    Jacobian matrix has shape (n, n) and its element (i, j) is equal to
    ``d f_i / d y_j``.  There are three ways to define the Jacobian:

        * If array_like or sparse_matrix, the Jacobian is assumed to
          be constant. Not supported by 'LSODA'.
        * If callable, the Jacobian is assumed to depend on both
          t and y; it will be called as ``jac(t, y)``, as necessary.
          For 'Radau' and 'BDF' methods, the return value might be a
          sparse matrix.
        * If None (default), the Jacobian will be approximated by
          finite differences.

    It is generally recommended to provide the Jacobian rather than
    relying on a finite-difference approximation.
jac_sparsity : array_like, sparse matrix or None, optional
    Defines a sparsity structure of the Jacobian matrix for a finite-
    difference approximation. Its shape must be (n, n). This argument
    is ignored if `jac` is not `None`. If the Jacobian has only few
    non-zero elements in *each* row, providing the sparsity structure
    will greatly speed up the computations [10]_. A zero entry means that
    a corresponding element in the Jacobian is always zero. If None
    (default), the Jacobian is assumed to be dense.
    Not supported by 'LSODA', see `lband` and `uband` instead.
lband, uband : int or None, optional
    Parameters defining the bandwidth of the Jacobian for the 'LSODA'
    method, i.e., ``jac[i, j] != 0 only for i - lband &lt;= j &lt;= i + uband``.
    Default is None. Setting these requires your jac routine to return the
    Jacobian in the packed format: the returned array must have ``n``
    columns and ``uband + lband + 1`` rows in which Jacobian diagonals are
    written. Specifically ``jac_packed[uband + i - j , j] = jac[i, j]``.
    The same format is used in `scipy.linalg.solve_banded` (check for an
    illustration).  These parameters can be also used with ``jac=None`` to
    reduce the number of Jacobian elements estimated by finite differences.
min_step : float, optional
    The minimum allowed step size for 'LSODA' method.
    By default `min_step` is zero.

Returns
-------
Bunch object with the following fields defined:
t : ndarray, shape (n_points,)
    Time points.
y : ndarray, shape (n, n_points)
    Values of the solution at `t`.
sol : `OdeSolution` or None
    Found solution as `OdeSolution` instance; None if `dense_output` was
    set to False.
t_events : list of ndarray or None
    Contains for each event type a list of arrays at which an event of
    that type event was detected. None if `events` was None.
y_events : list of ndarray or None
    For each value of `t_events`, the corresponding value of the solution.
    None if `events` was None.
nfev : int
    Number of evaluations of the right-hand side.
njev : int
    Number of evaluations of the Jacobian.
nlu : int
    Number of LU decompositions.
status : int
    Reason for algorithm termination:

        * -1: Integration step failed.
        *  0: The solver successfully reached the end of `tspan`.
        *  1: A termination event occurred.

message : string
    Human-readable description of the termination reason.
success : bool
    True if the solver reached the interval end or a termination event
    occurred (``status &gt;= 0``).

References
----------
.. [1] J. R. Dormand, P. J. Prince, "A family of embedded Runge-Kutta
       formulae", Journal of Computational and Applied Mathematics, Vol. 6,
       No. 1, pp. 19-26, 1980.
.. [2] L. W. Shampine, "Some Practical Runge-Kutta Formulas", Mathematics
       of Computation,, Vol. 46, No. 173, pp. 135-150, 1986.
.. [3] P. Bogacki, L.F. Shampine, "A 3(2) Pair of Runge-Kutta Formulas",
       Appl. Math. Lett. Vol. 2, No. 4. pp. 321-325, 1989.
.. [4] E. Hairer, G. Wanner, "Solving Ordinary Differential Equations II:
       Stiff and Differential-Algebraic Problems", Sec. IV.8.
.. [5] `Backward Differentiation Formula
        &lt;https://en.wikipedia.org/wiki/Backward_differentiation_formula&gt;`_
        on Wikipedia.
.. [6] L. F. Shampine, M. W. Reichelt, "THE MATLAB ODE SUITE", SIAM J. SCI.
       COMPUTE., Vol. 18, No. 1, pp. 1-22, January 1997.
.. [7] A. C. Hindmarsh, "ODEPACK, A Systematized Collection of ODE
       Solvers," IMACS Transactions on Scientific Computation, Vol 1.,
       pp. 55-64, 1983.
.. [8] L. Petzold, "Automatic selection of methods for solving stiff and
       nonstiff systems of ordinary differential equations", SIAM Journal
       on Scientific and Statistical Computing, Vol. 4, No. 1, pp. 136-148,
       1983.
.. [9] `Stiff equation &lt;https://en.wikipedia.org/wiki/Stiff_equation&gt;`_ on
       Wikipedia.
.. [10] A. Curtis, M. J. D. Powell, and J. Reid, "On the estimation of
        sparse Jacobian matrices", Journal of the Institute of Mathematics
        and its Applications, 13, pp. 117-120, 1974.
.. [11] `Cauchy-Riemann equations
         &lt;https://en.wikipedia.org/wiki/Cauchy-Riemann_equations&gt;`_ on
         Wikipedia.
.. [12] `Lotka-Volterra equations
        &lt;https://en.wikipedia.org/wiki/Lotka%E2%80%93Volterra_equations&gt;`_
        on Wikipedia.
.. [13] E. Hairer, S. P. Norsett G. Wanner, "Solving Ordinary Differential
        Equations I: Nonstiff Problems", Sec. II.
.. [14] `Page with original Fortran code of DOP853
        &lt;http://www.unige.ch/~hairer/software.html&gt;`_.

Examples
--------
Basic exponential decay showing automatically chosen time points.

&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy.integrate import solve_ivp
&gt;&gt;&gt; def exponential_decay(t, y): return -0.5 * y
&gt;&gt;&gt; sol = solve_ivp(exponential_decay, [0, 10], [2, 4, 8])
&gt;&gt;&gt; print(sol.t)
[ 0.          0.11487653  1.26364188  3.06061781  4.81611105  6.57445806
  8.33328988 10.        ]
&gt;&gt;&gt; print(sol.y)
[[2.         1.88836035 1.06327177 0.43319312 0.18017253 0.07483045
  0.03107158 0.01350781]
 [4.         3.7767207  2.12654355 0.86638624 0.36034507 0.14966091
  0.06214316 0.02701561]
 [8.         7.5534414  4.25308709 1.73277247 0.72069014 0.29932181
  0.12428631 0.05403123]]

Specifying points where the solution is desired.

&gt;&gt;&gt; sol = solve_ivp(exponential_decay, [0, 10], [2, 4, 8],
...                 t_eval=[0, 1, 2, 4, 10])
&gt;&gt;&gt; print(sol.t)
[ 0  1  2  4 10]
&gt;&gt;&gt; print(sol.y)
[[2.         1.21305369 0.73534021 0.27066736 0.01350938]
 [4.         2.42610739 1.47068043 0.54133472 0.02701876]
 [8.         4.85221478 2.94136085 1.08266944 0.05403753]]

Cannon fired upward with terminal event upon impact. The ``terminal`` and
``direction`` fields of an event are applied by monkey patching a function.
Here ``y[0]`` is position and ``y[1]`` is velocity. The projectile starts
at position 0 with velocity +10. Note that the integration never reaches
t=100 because the event is terminal.

&gt;&gt;&gt; def upward_cannon(t, y): return [y[1], -0.5]
&gt;&gt;&gt; def hit_ground(t, y): return y[0]
&gt;&gt;&gt; hit_ground.terminal = True
&gt;&gt;&gt; hit_ground.direction = -1
&gt;&gt;&gt; sol = solve_ivp(upward_cannon, [0, 100], [0, 10], events=hit_ground)
&gt;&gt;&gt; print(sol.t_events)
[array([40.])]
&gt;&gt;&gt; print(sol.t)
[0.00000000e+00 9.99900010e-05 1.09989001e-03 1.10988901e-02
 1.11088891e-01 1.11098890e+00 1.11099890e+01 4.00000000e+01]

Use `dense_output` and `events` to find position, which is 100, at the apex
of the cannonball's trajectory. Apex is not defined as terminal, so both
apex and hit_ground are found. There is no information at t=20, so the sol
attribute is used to evaluate the solution. The sol attribute is returned
by setting ``dense_output=True``. Alternatively, the `y_events` attribute
can be used to access the solution at the time of the event.

&gt;&gt;&gt; def apex(t, y): return y[1]
&gt;&gt;&gt; sol = solve_ivp(upward_cannon, [0, 100], [0, 10],
...                 events=(hit_ground, apex), dense_output=True)
&gt;&gt;&gt; print(sol.t_events)
[array([40.]), array([20.])]
&gt;&gt;&gt; print(sol.t)
[0.00000000e+00 9.99900010e-05 1.09989001e-03 1.10988901e-02
 1.11088891e-01 1.11098890e+00 1.11099890e+01 4.00000000e+01]
&gt;&gt;&gt; print(sol.sol(sol.t_events[1][0]))
[100.   0.]
&gt;&gt;&gt; print(sol.y_events)
[array([[-5.68434189e-14, -1.00000000e+01]]), array([[1.00000000e+02, 1.77635684e-15]])]

As an example of a system with additional parameters, we'll implement
the Lotka-Volterra equations [12]_.

&gt;&gt;&gt; def lotkavolterra(t, z, a, b, c, d):
...     x, y = z
...     return [a*x - b*x*y, -c*y + d*x*y]
...

We pass in the parameter values a=1.5, b=1, c=3 and d=1 with the `args`
argument.

&gt;&gt;&gt; sol = solve_ivp(lotkavolterra, [0, 15], [10, 5], args=(1.5, 1, 3, 1),
...                 dense_output=True)

Compute a dense solution and plot it.

&gt;&gt;&gt; t = np.linspace(0, 15, 300)
&gt;&gt;&gt; z = sol.sol(t)
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; plt.plot(t, z.T)
&gt;&gt;&gt; plt.xlabel('t')
&gt;&gt;&gt; plt.legend(['x', 'y'], shadow=True)
&gt;&gt;&gt; plt.title('Lotka-Volterra System')
&gt;&gt;&gt; plt.show()
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d9/d73/ivp_8py_source.html#l00156">156</a> of file <a class="el" href="../../d9/d73/ivp_8py_source.html">ivp.py</a>.</p>

<p class="reference">References <a class="el" href="../../d9/d73/ivp_8py_source.html#l00130">find_active_events()</a>, <a class="el" href="../../d9/d73/ivp_8py_source.html#l00081">handle_events()</a>, and <a class="el" href="../../d9/d73/ivp_8py_source.html#l00028">prepare_events()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ae1fea86006b69f5100e628e463bff7a2" name="ae1fea86006b69f5100e628e463bff7a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1fea86006b69f5100e628e463bff7a2">&#9670;&#160;</a></span>MESSAGES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dict scipy.integrate._ivp.ivp.MESSAGES</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  {0: <span class="stringliteral">&quot;The solver successfully reached the end of the integration interval.&quot;</span>,</div>
<div class="line"><span class="lineno">    2</span>            1: <span class="stringliteral">&quot;A termination event occurred.&quot;</span>}</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="../../d9/d73/ivp_8py_source.html#l00020">20</a> of file <a class="el" href="../../d9/d73/ivp_8py_source.html">ivp.py</a>.</p>

</div>
</div>
<a id="a80440f90e45322aa39e237b7055ce687" name="a80440f90e45322aa39e237b7055ce687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80440f90e45322aa39e237b7055ce687">&#9670;&#160;</a></span>METHODS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dict scipy.integrate._ivp.ivp.METHODS</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  {<span class="stringliteral">&#39;RK23&#39;</span>: RK23,</div>
<div class="line"><span class="lineno">    2</span>           <span class="stringliteral">&#39;RK45&#39;</span>: RK45,</div>
<div class="line"><span class="lineno">    3</span>           <span class="stringliteral">&#39;DOP853&#39;</span>: DOP853,</div>
<div class="line"><span class="lineno">    4</span>           <span class="stringliteral">&#39;Radau&#39;</span>: Radau,</div>
<div class="line"><span class="lineno">    5</span>           <span class="stringliteral">&#39;BDF&#39;</span>: BDF,</div>
<div class="line"><span class="lineno">    6</span>           <span class="stringliteral">&#39;LSODA&#39;</span>: LSODA}</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="../../d9/d73/ivp_8py_source.html#l00012">12</a> of file <a class="el" href="../../d9/d73/ivp_8py_source.html">ivp.py</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../db/d0f/namespacescipy.html">scipy</a></li><li class="navelem"><a class="el" href="../../d1/da1/namespacescipy_1_1integrate.html">integrate</a></li><li class="navelem"><a class="el" href="../../d5/d6a/namespacescipy_1_1integrate_1_1__ivp.html">_ivp</a></li><li class="navelem"><a class="el" href="../../d3/df4/namespacescipy_1_1integrate_1_1__ivp_1_1ivp.html">ivp</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
