<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Code Cloning Analysis: scipy.signal._spectral_py Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Code Cloning Analysis
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('dc/de6/namespacescipy_1_1signal_1_1__spectral__py.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">scipy.signal._spectral_py Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a04de21aa2a099fd07b3a8079f68af846" id="r_a04de21aa2a099fd07b3a8079f68af846"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04de21aa2a099fd07b3a8079f68af846">lombscargle</a> (x, y, <a class="el" href="../../d3/df8/namespacescipy_1_1signal_1_1__filter__design.html#a9575c4eb7f36f5e534309051f96a8bb7">freqs</a>, precenter=False, <a class="el" href="../../d3/df8/namespacescipy_1_1signal_1_1__filter__design.html#a403f599e6854656425d2a6c393be2504">normalize</a>=False)</td></tr>
<tr class="separator:a04de21aa2a099fd07b3a8079f68af846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ef921c6ed4361b59839b02dad2f958e" id="r_a1ef921c6ed4361b59839b02dad2f958e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ef921c6ed4361b59839b02dad2f958e">periodogram</a> (x, fs=1.0, window='boxcar', nfft=None, <a class="el" href="../../d8/d0f/namespacescipy_1_1signal_1_1__signaltools.html#ac2d71cde110198d9f3fb485301d42aa7">detrend</a>='constant', return_onesided=<a class="el" href="../../d8/d0b/classTrue.html">True</a>, scaling='density', axis=-1)</td></tr>
<tr class="separator:a1ef921c6ed4361b59839b02dad2f958e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad045f3f43aa8846446af595a5b66bfd7" id="r_ad045f3f43aa8846446af595a5b66bfd7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad045f3f43aa8846446af595a5b66bfd7">welch</a> (x, fs=1.0, window='hann', nperseg=None, noverlap=None, nfft=None, <a class="el" href="../../d8/d0f/namespacescipy_1_1signal_1_1__signaltools.html#ac2d71cde110198d9f3fb485301d42aa7">detrend</a>='constant', return_onesided=<a class="el" href="../../d8/d0b/classTrue.html">True</a>, scaling='density', axis=-1, average='mean')</td></tr>
<tr class="separator:ad045f3f43aa8846446af595a5b66bfd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b32e812473c8c8b467b5539edf825b" id="r_ab0b32e812473c8c8b467b5539edf825b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0b32e812473c8c8b467b5539edf825b">csd</a> (x, y, fs=1.0, window='hann', nperseg=None, noverlap=None, nfft=None, <a class="el" href="../../d8/d0f/namespacescipy_1_1signal_1_1__signaltools.html#ac2d71cde110198d9f3fb485301d42aa7">detrend</a>='constant', return_onesided=<a class="el" href="../../d8/d0b/classTrue.html">True</a>, scaling='density', axis=-1, average='mean')</td></tr>
<tr class="separator:ab0b32e812473c8c8b467b5539edf825b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aca9fb32af690767509d2a98b0d211f" id="r_a4aca9fb32af690767509d2a98b0d211f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4aca9fb32af690767509d2a98b0d211f">spectrogram</a> (x, fs=1.0, window=('tukey',.25), nperseg=None, noverlap=None, nfft=None, <a class="el" href="../../d8/d0f/namespacescipy_1_1signal_1_1__signaltools.html#ac2d71cde110198d9f3fb485301d42aa7">detrend</a>='constant', return_onesided=<a class="el" href="../../d8/d0b/classTrue.html">True</a>, scaling='density', axis=-1, mode='psd')</td></tr>
<tr class="separator:a4aca9fb32af690767509d2a98b0d211f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f9eee97f27719960a111d57f4ddb9a" id="r_a31f9eee97f27719960a111d57f4ddb9a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31f9eee97f27719960a111d57f4ddb9a">check_COLA</a> (window, nperseg, noverlap, tol=1e-10)</td></tr>
<tr class="separator:a31f9eee97f27719960a111d57f4ddb9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c94a26fc7ac4ef34316519b1d52e49" id="r_a13c94a26fc7ac4ef34316519b1d52e49"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13c94a26fc7ac4ef34316519b1d52e49">check_NOLA</a> (window, nperseg, noverlap, tol=1e-10)</td></tr>
<tr class="separator:a13c94a26fc7ac4ef34316519b1d52e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0eee5a94f5128e159f80bbf7be61d2f" id="r_ad0eee5a94f5128e159f80bbf7be61d2f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0eee5a94f5128e159f80bbf7be61d2f">stft</a> (x, fs=1.0, window='hann', nperseg=256, noverlap=None, nfft=None, <a class="el" href="../../d8/d0f/namespacescipy_1_1signal_1_1__signaltools.html#ac2d71cde110198d9f3fb485301d42aa7">detrend</a>=False, return_onesided=<a class="el" href="../../d8/d0b/classTrue.html">True</a>, boundary='zeros', padded=<a class="el" href="../../d8/d0b/classTrue.html">True</a>, axis=-1, scaling='spectrum')</td></tr>
<tr class="separator:ad0eee5a94f5128e159f80bbf7be61d2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19b39dcdf416fb9d891d16cdeb8633f4" id="r_a19b39dcdf416fb9d891d16cdeb8633f4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19b39dcdf416fb9d891d16cdeb8633f4">istft</a> (Zxx, fs=1.0, window='hann', nperseg=None, noverlap=None, nfft=None, input_onesided=<a class="el" href="../../d8/d0b/classTrue.html">True</a>, boundary=<a class="el" href="../../d8/d0b/classTrue.html">True</a>, time_axis=-1, freq_axis=-2, scaling='spectrum')</td></tr>
<tr class="separator:a19b39dcdf416fb9d891d16cdeb8633f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f334cd2cbf48712f19204fa6e62d68" id="r_a24f334cd2cbf48712f19204fa6e62d68"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24f334cd2cbf48712f19204fa6e62d68">coherence</a> (x, y, fs=1.0, window='hann', nperseg=None, noverlap=None, nfft=None, <a class="el" href="../../d8/d0f/namespacescipy_1_1signal_1_1__signaltools.html#ac2d71cde110198d9f3fb485301d42aa7">detrend</a>='constant', axis=-1)</td></tr>
<tr class="separator:a24f334cd2cbf48712f19204fa6e62d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0d45d15e0d240790fe33574479be2b" id="r_a2f0d45d15e0d240790fe33574479be2b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f0d45d15e0d240790fe33574479be2b">_spectral_helper</a> (x, y, fs=1.0, window='hann', nperseg=None, noverlap=None, nfft=None, <a class="el" href="../../d8/d0f/namespacescipy_1_1signal_1_1__signaltools.html#ac2d71cde110198d9f3fb485301d42aa7">detrend</a>='constant', return_onesided=<a class="el" href="../../d8/d0b/classTrue.html">True</a>, scaling='density', axis=-1, mode='psd', boundary=None, padded=False)</td></tr>
<tr class="separator:a2f0d45d15e0d240790fe33574479be2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab42777904c2943e2e8c7a62d0c3a639f" id="r_ab42777904c2943e2e8c7a62d0c3a639f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab42777904c2943e2e8c7a62d0c3a639f">_fft_helper</a> (x, win, detrend_func, nperseg, noverlap, nfft, sides)</td></tr>
<tr class="separator:ab42777904c2943e2e8c7a62d0c3a639f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac82dde67c5d61334ca7d9c078be6a6ce" id="r_ac82dde67c5d61334ca7d9c078be6a6ce"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac82dde67c5d61334ca7d9c078be6a6ce">_triage_segments</a> (window, nperseg, input_length)</td></tr>
<tr class="separator:ac82dde67c5d61334ca7d9c078be6a6ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f182108e5535b53bc8adf0394c51548" id="r_a4f182108e5535b53bc8adf0394c51548"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f182108e5535b53bc8adf0394c51548">_median_bias</a> (n)</td></tr>
<tr class="separator:a4f182108e5535b53bc8adf0394c51548"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a45048c1f404bbbdb60ba197c50636b4e" id="r_a45048c1f404bbbdb60ba197c50636b4e"><td class="memItemLeft" align="right" valign="top">list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45048c1f404bbbdb60ba197c50636b4e">__all__</a></td></tr>
<tr class="separator:a45048c1f404bbbdb60ba197c50636b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Tools for spectral analysis.
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="ab42777904c2943e2e8c7a62d0c3a639f" name="ab42777904c2943e2e8c7a62d0c3a639f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab42777904c2943e2e8c7a62d0c3a639f">&#9670;&#160;</a></span>_fft_helper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._spectral_py._fft_helper </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>win</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>detrend_func</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>nperseg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>noverlap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>nfft</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>sides</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Calculate windowed FFT, for internal use by
`scipy.signal._spectral_helper`.

This is a helper function that does the main FFT calculation for
`_spectral helper`. All input validation is performed there, and the
data axis is assumed to be the last axis of x. It is not designed to
be called externally. The windows are not averaged over; the result
from each window is returned.

Returns
-------
result : ndarray
    Array of FFT data

Notes
-----
Adapted from matplotlib.mlab

.. versionadded:: 0.16.0
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d1/dc6/__spectral__py_8py_source.html#l01928">1928</a> of file <a class="el" href="../../d1/dc6/__spectral__py_8py_source.html">_spectral_py.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d1/dc6/__spectral__py_8py_source.html#l01637">_spectral_helper()</a>.</p>

</div>
</div>
<a id="a4f182108e5535b53bc8adf0394c51548" name="a4f182108e5535b53bc8adf0394c51548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f182108e5535b53bc8adf0394c51548">&#9670;&#160;</a></span>_median_bias()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._spectral_py._median_bias </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Returns the bias of the median of a set of periodograms relative to
the mean.

See Appendix B from [1]_ for details.

Parameters
----------
n : int
    Numbers of periodograms being averaged.

Returns
-------
bias : float
    Calculated bias.

References
----------
.. [1] B. Allen, W.G. Anderson, P.R. Brady, D.A. Brown, J.D.E. Creighton.
       "FINDCHIRP: an algorithm for detection of gravitational waves from
       inspiraling compact binaries", Physical Review D 85, 2012,
       :arxiv:`gr-qc/0509116`
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d1/dc6/__spectral__py_8py_source.html#l02037">2037</a> of file <a class="el" href="../../d1/dc6/__spectral__py_8py_source.html">_spectral_py.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d1/dc6/__spectral__py_8py_source.html#l00465">csd()</a>.</p>

</div>
</div>
<a id="a2f0d45d15e0d240790fe33574479be2b" name="a2f0d45d15e0d240790fe33574479be2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f0d45d15e0d240790fe33574479be2b">&#9670;&#160;</a></span>_spectral_helper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._spectral_py._spectral_helper </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>fs</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>window</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'hann'</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>nperseg</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>noverlap</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>nfft</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>detrend</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'constant'</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>return_onesided</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d8/d0b/classTrue.html">True</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>scaling</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'density'</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>axis</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>mode</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'psd'</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>boundary</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>padded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Calculate various forms of windowed FFTs for PSD, CSD, etc.

This is a helper function that implements the commonality between
the stft, psd, csd, and spectrogram functions. It is not designed to
be called externally. The windows are not averaged over; the result
from each window is returned.

Parameters
----------
x : array_like
    Array or sequence containing the data to be analyzed.
y : array_like
    Array or sequence containing the data to be analyzed. If this is
    the same object in memory as `x` (i.e. ``_spectral_helper(x,
    x, ...)``), the extra computations are spared.
fs : float, optional
    Sampling frequency of the time series. Defaults to 1.0.
window : str or tuple or array_like, optional
    Desired window to use. If `window` is a string or tuple, it is
    passed to `get_window` to generate the window values, which are
    DFT-even by default. See `get_window` for a list of windows and
    required parameters. If `window` is array_like it will be used
    directly as the window and its length must be nperseg. Defaults
    to a Hann window.
nperseg : int, optional
    Length of each segment. Defaults to None, but if window is str or
    tuple, is set to 256, and if window is array_like, is set to the
    length of the window.
noverlap : int, optional
    Number of points to overlap between segments. If `None`,
    ``noverlap = nperseg // 2``. Defaults to `None`.
nfft : int, optional
    Length of the FFT used, if a zero padded FFT is desired. If
    `None`, the FFT length is `nperseg`. Defaults to `None`.
detrend : str or function or `False`, optional
    Specifies how to detrend each segment. If `detrend` is a
    string, it is passed as the `type` argument to the `detrend`
    function. If it is a function, it takes a segment and returns a
    detrended segment. If `detrend` is `False`, no detrending is
    done. Defaults to 'constant'.
return_onesided : bool, optional
    If `True`, return a one-sided spectrum for real data. If
    `False` return a two-sided spectrum. Defaults to `True`, but for
    complex data, a two-sided spectrum is always returned.
scaling : { 'density', 'spectrum' }, optional
    Selects between computing the cross spectral density ('density')
    where `Pxy` has units of V**2/Hz and computing the cross
    spectrum ('spectrum') where `Pxy` has units of V**2, if `x`
    and `y` are measured in V and `fs` is measured in Hz.
    Defaults to 'density'
axis : int, optional
    Axis along which the FFTs are computed; the default is over the
    last axis (i.e. ``axis=-1``).
mode: str {'psd', 'stft'}, optional
    Defines what kind of return values are expected. Defaults to
    'psd'.
boundary : str or None, optional
    Specifies whether the input signal is extended at both ends, and
    how to generate the new values, in order to center the first
    windowed segment on the first input point. This has the benefit
    of enabling reconstruction of the first input point when the
    employed window function starts at zero. Valid options are
    ``['even', 'odd', 'constant', 'zeros', None]``. Defaults to
    `None`.
padded : bool, optional
    Specifies whether the input signal is zero-padded at the end to
    make the signal fit exactly into an integer number of window
    segments, so that all of the signal is included in the output.
    Defaults to `False`. Padding occurs after boundary extension, if
    `boundary` is not `None`, and `padded` is `True`.

Returns
-------
freqs : ndarray
    Array of sample frequencies.
t : ndarray
    Array of times corresponding to each data segment
result : ndarray
    Array of output data, contents dependent on *mode* kwarg.

Notes
-----
Adapted from matplotlib.mlab

.. versionadded:: 0.16.0
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d1/dc6/__spectral__py_8py_source.html#l01634">1634</a> of file <a class="el" href="../../d1/dc6/__spectral__py_8py_source.html">_spectral_py.py</a>.</p>

<p class="reference">References <a class="el" href="../../d1/dc6/__spectral__py_8py_source.html#l01928">_fft_helper()</a>, <a class="el" href="../../d1/dc6/__spectral__py_8py_source.html#l01978">_triage_segments()</a>, and <a class="el" href="../../d3/d5d/__signaltools_8py_source.html#l03510">scipy.signal._signaltools.detrend()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d1/dc6/__spectral__py_8py_source.html#l00465">csd()</a>, <a class="el" href="../../d1/dc6/__spectral__py_8py_source.html#l00619">spectrogram()</a>, and <a class="el" href="../../d1/dc6/__spectral__py_8py_source.html#l01040">stft()</a>.</p>

</div>
</div>
<a id="ac82dde67c5d61334ca7d9c078be6a6ce" name="ac82dde67c5d61334ca7d9c078be6a6ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac82dde67c5d61334ca7d9c078be6a6ce">&#9670;&#160;</a></span>_triage_segments()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._spectral_py._triage_segments </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>window</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>nperseg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>input_length</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Parses window and nperseg arguments for spectrogram and _spectral_helper.
This is a helper function, not meant to be called externally.

Parameters
----------
window : string, tuple, or ndarray
    If window is specified by a string or tuple and nperseg is not
    specified, nperseg is set to the default of 256 and returns a window of
    that length.
    If instead the window is array_like and nperseg is not specified, then
    nperseg is set to the length of the window. A ValueError is raised if
    the user supplies both an array_like window and a value for nperseg but
    nperseg does not equal the length of the window.

nperseg : int
    Length of each segment

input_length: int
    Length of input signal, i.e. x.shape[-1]. Used to test for errors.

Returns
-------
win : ndarray
    window. If function was called with string or tuple than this will hold
    the actual array used as a window.

nperseg : int
    Length of each segment. If window is str or tuple, nperseg is set to
    256. If window is array_like, nperseg is set to the length of the
    window.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d1/dc6/__spectral__py_8py_source.html#l01978">1978</a> of file <a class="el" href="../../d1/dc6/__spectral__py_8py_source.html">_spectral_py.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d1/dc6/__spectral__py_8py_source.html#l01637">_spectral_helper()</a>, and <a class="el" href="../../d1/dc6/__spectral__py_8py_source.html#l00619">spectrogram()</a>.</p>

</div>
</div>
<a id="a31f9eee97f27719960a111d57f4ddb9a" name="a31f9eee97f27719960a111d57f4ddb9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31f9eee97f27719960a111d57f4ddb9a">&#9670;&#160;</a></span>check_COLA()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._spectral_py.check_COLA </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>window</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>nperseg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>noverlap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>tol</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1e-10</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Check whether the Constant OverLap Add (COLA) constraint is met.

Parameters
----------
window : str or tuple or array_like
Desired window to use. If `window` is a string or tuple, it is
passed to `get_window` to generate the window values, which are
DFT-even by default. See `get_window` for a list of windows and
required parameters. If `window` is array_like it will be used
directly as the window and its length must be nperseg.
nperseg : int
Length of each segment.
noverlap : int
Number of points to overlap between segments.
tol : float, optional
The allowed variance of a bin's weighted sum from the median bin
sum.

Returns
-------
verdict : bool
`True` if chosen combination satisfies COLA within `tol`,
`False` otherwise

See Also
--------
check_NOLA: Check whether the Nonzero Overlap Add (NOLA) constraint is met
stft: Short Time Fourier Transform
istft: Inverse Short Time Fourier Transform

Notes
-----
In order to enable inversion of an STFT via the inverse STFT in
`istft`, it is sufficient that the signal windowing obeys the constraint of
"Constant OverLap Add" (COLA). This ensures that every point in the input
data is equally weighted, thereby avoiding aliasing and allowing full
reconstruction.

Some examples of windows that satisfy COLA:
- Rectangular window at overlap of 0, 1/2, 2/3, 3/4, ...
- Bartlett window at overlap of 1/2, 3/4, 5/6, ...
- Hann window at 1/2, 2/3, 3/4, ...
- Any Blackman family window at 2/3 overlap
- Any window with ``noverlap = nperseg-1``

A very comprehensive list of other windows may be found in [2]_,
wherein the COLA condition is satisfied when the "Amplitude
Flatness" is unity.

.. versionadded:: 0.19.0

References
----------
.. [1] Julius O. Smith III, "Spectral Audio Signal Processing", W3K
   Publishing, 2011,ISBN 978-0-9745607-3-1.
.. [2] G. Heinzel, A. Ruediger and R. Schilling, "Spectrum and
   spectral density estimation by the Discrete Fourier transform
   (DFT), including a comprehensive list of window functions and
   some new at-top windows", 2002,
   http://hdl.handle.net/11858/00-001M-0000-0013-557A-5

Examples
--------
&gt;&gt;&gt; from scipy import signal

Confirm COLA condition for rectangular window of 75% (3/4) overlap:

&gt;&gt;&gt; signal.check_COLA(signal.windows.boxcar(100), 100, 75)
True

COLA is not true for 25% (1/4) overlap, though:

&gt;&gt;&gt; signal.check_COLA(signal.windows.boxcar(100), 100, 25)
False

"Symmetrical" Hann window (for filter design) is not COLA:

&gt;&gt;&gt; signal.check_COLA(signal.windows.hann(120, sym=True), 120, 60)
False

"Periodic" or "DFT-even" Hann window (for FFT analysis) is COLA for
overlap of 1/2, 2/3, 3/4, etc.:

&gt;&gt;&gt; signal.check_COLA(signal.windows.hann(120, sym=False), 120, 60)
True

&gt;&gt;&gt; signal.check_COLA(signal.windows.hann(120, sym=False), 120, 80)
True

&gt;&gt;&gt; signal.check_COLA(signal.windows.hann(120, sym=False), 120, 90)
True
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d1/dc6/__spectral__py_8py_source.html#l00789">789</a> of file <a class="el" href="../../d1/dc6/__spectral__py_8py_source.html">_spectral_py.py</a>.</p>

</div>
</div>
<a id="a13c94a26fc7ac4ef34316519b1d52e49" name="a13c94a26fc7ac4ef34316519b1d52e49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13c94a26fc7ac4ef34316519b1d52e49">&#9670;&#160;</a></span>check_NOLA()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._spectral_py.check_NOLA </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>window</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>nperseg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>noverlap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>tol</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1e-10</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Check whether the Nonzero Overlap Add (NOLA) constraint is met.

Parameters
----------
window : str or tuple or array_like
Desired window to use. If `window` is a string or tuple, it is
passed to `get_window` to generate the window values, which are
DFT-even by default. See `get_window` for a list of windows and
required parameters. If `window` is array_like it will be used
directly as the window and its length must be nperseg.
nperseg : int
Length of each segment.
noverlap : int
Number of points to overlap between segments.
tol : float, optional
The allowed variance of a bin's weighted sum from the median bin
sum.

Returns
-------
verdict : bool
`True` if chosen combination satisfies the NOLA constraint within
`tol`, `False` otherwise

See Also
--------
check_COLA: Check whether the Constant OverLap Add (COLA) constraint is met
stft: Short Time Fourier Transform
istft: Inverse Short Time Fourier Transform

Notes
-----
In order to enable inversion of an STFT via the inverse STFT in
`istft`, the signal windowing must obey the constraint of "nonzero
overlap add" (NOLA):

.. math:: \sum_{t}w^{2}[n-tH] \ne 0

for all :math:`n`, where :math:`w` is the window function, :math:`t` is the
frame index, and :math:`H` is the hop size (:math:`H` = `nperseg` -
`noverlap`).

This ensures that the normalization factors in the denominator of the
overlap-add inversion equation are not zero. Only very pathological windows
will fail the NOLA constraint.

.. versionadded:: 1.2.0

References
----------
.. [1] Julius O. Smith III, "Spectral Audio Signal Processing", W3K
   Publishing, 2011,ISBN 978-0-9745607-3-1.
.. [2] G. Heinzel, A. Ruediger and R. Schilling, "Spectrum and
   spectral density estimation by the Discrete Fourier transform
   (DFT), including a comprehensive list of window functions and
   some new at-top windows", 2002,
   http://hdl.handle.net/11858/00-001M-0000-0013-557A-5

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy import signal

Confirm NOLA condition for rectangular window of 75% (3/4) overlap:

&gt;&gt;&gt; signal.check_NOLA(signal.windows.boxcar(100), 100, 75)
True

NOLA is also true for 25% (1/4) overlap:

&gt;&gt;&gt; signal.check_NOLA(signal.windows.boxcar(100), 100, 25)
True

"Symmetrical" Hann window (for filter design) is also NOLA:

&gt;&gt;&gt; signal.check_NOLA(signal.windows.hann(120, sym=True), 120, 60)
True

As long as there is overlap, it takes quite a pathological window to fail
NOLA:

&gt;&gt;&gt; w = np.ones(64, dtype="float")
&gt;&gt;&gt; w[::2] = 0
&gt;&gt;&gt; signal.check_NOLA(w, 64, 32)
False

If there is not enough overlap, a window with zeros at the ends will not
work:

&gt;&gt;&gt; signal.check_NOLA(signal.windows.hann(64), 64, 0)
False
&gt;&gt;&gt; signal.check_NOLA(signal.windows.hann(64), 64, 1)
False
&gt;&gt;&gt; signal.check_NOLA(signal.windows.hann(64), 64, 2)
True
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d1/dc6/__spectral__py_8py_source.html#l00911">911</a> of file <a class="el" href="../../d1/dc6/__spectral__py_8py_source.html">_spectral_py.py</a>.</p>

</div>
</div>
<a id="a24f334cd2cbf48712f19204fa6e62d68" name="a24f334cd2cbf48712f19204fa6e62d68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24f334cd2cbf48712f19204fa6e62d68">&#9670;&#160;</a></span>coherence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._spectral_py.coherence </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>fs</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>window</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'hann'</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>nperseg</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>noverlap</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>nfft</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>detrend</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'constant'</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>axis</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Estimate the magnitude squared coherence estimate, Cxy, of
discrete-time signals X and Y using Welch's method.

``Cxy = abs(Pxy)**2/(Pxx*Pyy)``, where `Pxx` and `Pyy` are power
spectral density estimates of X and Y, and `Pxy` is the cross
spectral density estimate of X and Y.

Parameters
----------
x : array_like
    Time series of measurement values
y : array_like
    Time series of measurement values
fs : float, optional
    Sampling frequency of the `x` and `y` time series. Defaults
    to 1.0.
window : str or tuple or array_like, optional
    Desired window to use. If `window` is a string or tuple, it is
    passed to `get_window` to generate the window values, which are
    DFT-even by default. See `get_window` for a list of windows and
    required parameters. If `window` is array_like it will be used
    directly as the window and its length must be nperseg. Defaults
    to a Hann window.
nperseg : int, optional
    Length of each segment. Defaults to None, but if window is str or
    tuple, is set to 256, and if window is array_like, is set to the
    length of the window.
noverlap: int, optional
    Number of points to overlap between segments. If `None`,
    ``noverlap = nperseg // 2``. Defaults to `None`.
nfft : int, optional
    Length of the FFT used, if a zero padded FFT is desired. If
    `None`, the FFT length is `nperseg`. Defaults to `None`.
detrend : str or function or `False`, optional
    Specifies how to detrend each segment. If `detrend` is a
    string, it is passed as the `type` argument to the `detrend`
    function. If it is a function, it takes a segment and returns a
    detrended segment. If `detrend` is `False`, no detrending is
    done. Defaults to 'constant'.
axis : int, optional
    Axis along which the coherence is computed for both inputs; the
    default is over the last axis (i.e. ``axis=-1``).

Returns
-------
f : ndarray
    Array of sample frequencies.
Cxy : ndarray
    Magnitude squared coherence of x and y.

See Also
--------
periodogram: Simple, optionally modified periodogram
lombscargle: Lomb-Scargle periodogram for unevenly sampled data
welch: Power spectral density by Welch's method.
csd: Cross spectral density by Welch's method.

Notes
-----
An appropriate amount of overlap will depend on the choice of window
and on your requirements. For the default Hann window an overlap of
50% is a reasonable trade off between accurately estimating the
signal power, while not over counting any of the data. Narrower
windows may require a larger overlap.

.. versionadded:: 0.16.0

References
----------
.. [1] P. Welch, "The use of the fast Fourier transform for the
       estimation of power spectra: A method based on time averaging
       over short, modified periodograms", IEEE Trans. Audio
       Electroacoust. vol. 15, pp. 70-73, 1967.
.. [2] Stoica, Petre, and Randolph Moses, "Spectral Analysis of
       Signals" Prentice Hall, 2005

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; rng = np.random.default_rng()

Generate two test signals with some common features.

&gt;&gt;&gt; fs = 10e3
&gt;&gt;&gt; N = 1e5
&gt;&gt;&gt; amp = 20
&gt;&gt;&gt; freq = 1234.0
&gt;&gt;&gt; noise_power = 0.001 * fs / 2
&gt;&gt;&gt; time = np.arange(N) / fs
&gt;&gt;&gt; b, a = signal.butter(2, 0.25, 'low')
&gt;&gt;&gt; x = rng.normal(scale=np.sqrt(noise_power), size=time.shape)
&gt;&gt;&gt; y = signal.lfilter(b, a, x)
&gt;&gt;&gt; x += amp*np.sin(2*np.pi*freq*time)
&gt;&gt;&gt; y += rng.normal(scale=0.1*np.sqrt(noise_power), size=time.shape)

Compute and plot the coherence.

&gt;&gt;&gt; f, Cxy = signal.coherence(x, y, fs, nperseg=1024)
&gt;&gt;&gt; plt.semilogy(f, Cxy)
&gt;&gt;&gt; plt.xlabel('frequency [Hz]')
&gt;&gt;&gt; plt.ylabel('Coherence')
&gt;&gt;&gt; plt.show()
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d1/dc6/__spectral__py_8py_source.html#l01512">1512</a> of file <a class="el" href="../../d1/dc6/__spectral__py_8py_source.html">_spectral_py.py</a>.</p>

<p class="reference">References <a class="el" href="../../d1/dc6/__spectral__py_8py_source.html#l00465">csd()</a>, and <a class="el" href="../../d1/dc6/__spectral__py_8py_source.html#l00299">welch()</a>.</p>

</div>
</div>
<a id="ab0b32e812473c8c8b467b5539edf825b" name="ab0b32e812473c8c8b467b5539edf825b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0b32e812473c8c8b467b5539edf825b">&#9670;&#160;</a></span>csd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._spectral_py.csd </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>fs</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>window</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'hann'</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>nperseg</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>noverlap</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>nfft</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>detrend</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'constant'</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>return_onesided</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d8/d0b/classTrue.html">True</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>scaling</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'density'</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>axis</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>average</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'mean'</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Estimate the cross power spectral density, Pxy, using Welch's method.

Parameters
----------
x : array_like
Time series of measurement values
y : array_like
Time series of measurement values
fs : float, optional
Sampling frequency of the `x` and `y` time series. Defaults
to 1.0.
window : str or tuple or array_like, optional
Desired window to use. If `window` is a string or tuple, it is
passed to `get_window` to generate the window values, which are
DFT-even by default. See `get_window` for a list of windows and
required parameters. If `window` is array_like it will be used
directly as the window and its length must be nperseg. Defaults
to a Hann window.
nperseg : int, optional
Length of each segment. Defaults to None, but if window is str or
tuple, is set to 256, and if window is array_like, is set to the
length of the window.
noverlap: int, optional
Number of points to overlap between segments. If `None`,
``noverlap = nperseg // 2``. Defaults to `None`.
nfft : int, optional
Length of the FFT used, if a zero padded FFT is desired. If
`None`, the FFT length is `nperseg`. Defaults to `None`.
detrend : str or function or `False`, optional
Specifies how to detrend each segment. If `detrend` is a
string, it is passed as the `type` argument to the `detrend`
function. If it is a function, it takes a segment and returns a
detrended segment. If `detrend` is `False`, no detrending is
done. Defaults to 'constant'.
return_onesided : bool, optional
If `True`, return a one-sided spectrum for real data. If
`False` return a two-sided spectrum. Defaults to `True`, but for
complex data, a two-sided spectrum is always returned.
scaling : { 'density', 'spectrum' }, optional
Selects between computing the cross spectral density ('density')
where `Pxy` has units of V**2/Hz and computing the cross spectrum
('spectrum') where `Pxy` has units of V**2, if `x` and `y` are
measured in V and `fs` is measured in Hz. Defaults to 'density'
axis : int, optional
Axis along which the CSD is computed for both inputs; the
default is over the last axis (i.e. ``axis=-1``).
average : { 'mean', 'median' }, optional
Method to use when averaging periodograms. If the spectrum is
complex, the average is computed separately for the real and
imaginary parts. Defaults to 'mean'.

.. versionadded:: 1.2.0

Returns
-------
f : ndarray
Array of sample frequencies.
Pxy : ndarray
Cross spectral density or cross power spectrum of x,y.

See Also
--------
periodogram: Simple, optionally modified periodogram
lombscargle: Lomb-Scargle periodogram for unevenly sampled data
welch: Power spectral density by Welch's method. [Equivalent to
csd(x,x)]
coherence: Magnitude squared coherence by Welch's method.

Notes
-----
By convention, Pxy is computed with the conjugate FFT of X
multiplied by the FFT of Y.

If the input series differ in length, the shorter series will be
zero-padded to match.

An appropriate amount of overlap will depend on the choice of window
and on your requirements. For the default Hann window an overlap of
50% is a reasonable trade off between accurately estimating the
signal power, while not over counting any of the data. Narrower
windows may require a larger overlap.

.. versionadded:: 0.16.0

References
----------
.. [1] P. Welch, "The use of the fast Fourier transform for the
estimation of power spectra: A method based on time averaging
over short, modified periodograms", IEEE Trans. Audio
Electroacoust. vol. 15, pp. 70-73, 1967.
.. [2] Rabiner, Lawrence R., and B. Gold. "Theory and Application of
Digital Signal Processing" Prentice-Hall, pp. 414-419, 1975

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; rng = np.random.default_rng()

Generate two test signals with some common features.

&gt;&gt;&gt; fs = 10e3
&gt;&gt;&gt; N = 1e5
&gt;&gt;&gt; amp = 20
&gt;&gt;&gt; freq = 1234.0
&gt;&gt;&gt; noise_power = 0.001 * fs / 2
&gt;&gt;&gt; time = np.arange(N) / fs
&gt;&gt;&gt; b, a = signal.butter(2, 0.25, 'low')
&gt;&gt;&gt; x = rng.normal(scale=np.sqrt(noise_power), size=time.shape)
&gt;&gt;&gt; y = signal.lfilter(b, a, x)
&gt;&gt;&gt; x += amp*np.sin(2*np.pi*freq*time)
&gt;&gt;&gt; y += rng.normal(scale=0.1*np.sqrt(noise_power), size=time.shape)

Compute and plot the magnitude of the cross spectral density.

&gt;&gt;&gt; f, Pxy = signal.csd(x, y, fs, nperseg=1024)
&gt;&gt;&gt; plt.semilogy(f, np.abs(Pxy))
&gt;&gt;&gt; plt.xlabel('frequency [Hz]')
&gt;&gt;&gt; plt.ylabel('CSD [V**2/Hz]')
&gt;&gt;&gt; plt.show()
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d1/dc6/__spectral__py_8py_source.html#l00463">463</a> of file <a class="el" href="../../d1/dc6/__spectral__py_8py_source.html">_spectral_py.py</a>.</p>

<p class="reference">References <a class="el" href="../../d1/dc6/__spectral__py_8py_source.html#l02037">_median_bias()</a>, and <a class="el" href="../../d1/dc6/__spectral__py_8py_source.html#l01637">_spectral_helper()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d1/dc6/__spectral__py_8py_source.html#l01513">coherence()</a>, and <a class="el" href="../../d1/dc6/__spectral__py_8py_source.html#l00299">welch()</a>.</p>

</div>
</div>
<a id="a19b39dcdf416fb9d891d16cdeb8633f4" name="a19b39dcdf416fb9d891d16cdeb8633f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19b39dcdf416fb9d891d16cdeb8633f4">&#9670;&#160;</a></span>istft()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._spectral_py.istft </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>Zxx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>fs</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>window</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'hann'</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>nperseg</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>noverlap</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>nfft</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>input_onesided</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d8/d0b/classTrue.html">True</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>boundary</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d8/d0b/classTrue.html">True</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>time_axis</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>freq_axis</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-2</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>scaling</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'spectrum'</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Perform the inverse Short Time Fourier transform (iSTFT).

Parameters
----------
Zxx : array_like
STFT of the signal to be reconstructed. If a purely real array
is passed, it will be cast to a complex data type.
fs : float, optional
Sampling frequency of the time series. Defaults to 1.0.
window : str or tuple or array_like, optional
Desired window to use. If `window` is a string or tuple, it is
passed to `get_window` to generate the window values, which are
DFT-even by default. See `get_window` for a list of windows and
required parameters. If `window` is array_like it will be used
directly as the window and its length must be nperseg. Defaults
to a Hann window. Must match the window used to generate the
STFT for faithful inversion.
nperseg : int, optional
Number of data points corresponding to each STFT segment. This
parameter must be specified if the number of data points per
segment is odd, or if the STFT was padded via ``nfft &gt;
nperseg``. If `None`, the value depends on the shape of
`Zxx` and `input_onesided`. If `input_onesided` is `True`,
``nperseg=2*(Zxx.shape[freq_axis] - 1)``. Otherwise,
``nperseg=Zxx.shape[freq_axis]``. Defaults to `None`.
noverlap : int, optional
Number of points to overlap between segments. If `None`, half
of the segment length. Defaults to `None`. When specified, the
COLA constraint must be met (see Notes below), and should match
the parameter used to generate the STFT. Defaults to `None`.
nfft : int, optional
Number of FFT points corresponding to each STFT segment. This
parameter must be specified if the STFT was padded via ``nfft &gt;
nperseg``. If `None`, the default values are the same as for
`nperseg`, detailed above, with one exception: if
`input_onesided` is True and
``nperseg==2*Zxx.shape[freq_axis] - 1``, `nfft` also takes on
that value. This case allows the proper inversion of an
odd-length unpadded STFT using ``nfft=None``. Defaults to
`None`.
input_onesided : bool, optional
If `True`, interpret the input array as one-sided FFTs, such
as is returned by `stft` with ``return_onesided=True`` and
`numpy.fft.rfft`. If `False`, interpret the input as a a
two-sided FFT. Defaults to `True`.
boundary : bool, optional
Specifies whether the input signal was extended at its
boundaries by supplying a non-`None` ``boundary`` argument to
`stft`. Defaults to `True`.
time_axis : int, optional
Where the time segments of the STFT is located; the default is
the last axis (i.e. ``axis=-1``).
freq_axis : int, optional
Where the frequency axis of the STFT is located; the default is
the penultimate axis (i.e. ``axis=-2``).
scaling: {'spectrum', 'psd'}
The default 'spectrum' scaling allows each frequency line of `Zxx` to
be interpreted as a magnitude spectrum. The 'psd' option scales each
line to a power spectral density - it allows to calculate the signal's
energy by numerically integrating over ``abs(Zxx)**2``.

Returns
-------
t : ndarray
Array of output data times.
x : ndarray
iSTFT of `Zxx`.

See Also
--------
stft: Short Time Fourier Transform
check_COLA: Check whether the Constant OverLap Add (COLA) constraint
        is met
check_NOLA: Check whether the Nonzero Overlap Add (NOLA) constraint is met

Notes
-----
In order to enable inversion of an STFT via the inverse STFT with
`istft`, the signal windowing must obey the constraint of "nonzero
overlap add" (NOLA):

.. math:: \sum_{t}w^{2}[n-tH] \ne 0

This ensures that the normalization factors that appear in the denominator
of the overlap-add reconstruction equation

.. math:: x[n]=\frac{\sum_{t}x_{t}[n]w[n-tH]}{\sum_{t}w^{2}[n-tH]}

are not zero. The NOLA constraint can be checked with the `check_NOLA`
function.

An STFT which has been modified (via masking or otherwise) is not
guaranteed to correspond to a exactly realizible signal. This
function implements the iSTFT via the least-squares estimation
algorithm detailed in [2]_, which produces a signal that minimizes
the mean squared error between the STFT of the returned signal and
the modified STFT.

.. versionadded:: 0.19.0

References
----------
.. [1] Oppenheim, Alan V., Ronald W. Schafer, John R. Buck
   "Discrete-Time Signal Processing", Prentice Hall, 1999.
.. [2] Daniel W. Griffin, Jae S. Lim "Signal Estimation from
   Modified Short-Time Fourier Transform", IEEE 1984,
   10.1109/TASSP.1984.1164317

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; rng = np.random.default_rng()

Generate a test signal, a 2 Vrms sine wave at 50Hz corrupted by
0.001 V**2/Hz of white noise sampled at 1024 Hz.

&gt;&gt;&gt; fs = 1024
&gt;&gt;&gt; N = 10*fs
&gt;&gt;&gt; nperseg = 512
&gt;&gt;&gt; amp = 2 * np.sqrt(2)
&gt;&gt;&gt; noise_power = 0.001 * fs / 2
&gt;&gt;&gt; time = np.arange(N) / float(fs)
&gt;&gt;&gt; carrier = amp * np.sin(2*np.pi*50*time)
&gt;&gt;&gt; noise = rng.normal(scale=np.sqrt(noise_power),
...                    size=time.shape)
&gt;&gt;&gt; x = carrier + noise

Compute the STFT, and plot its magnitude

&gt;&gt;&gt; f, t, Zxx = signal.stft(x, fs=fs, nperseg=nperseg)
&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; plt.pcolormesh(t, f, np.abs(Zxx), vmin=0, vmax=amp, shading='gouraud')
&gt;&gt;&gt; plt.ylim([f[1], f[-1]])
&gt;&gt;&gt; plt.title('STFT Magnitude')
&gt;&gt;&gt; plt.ylabel('Frequency [Hz]')
&gt;&gt;&gt; plt.xlabel('Time [sec]')
&gt;&gt;&gt; plt.yscale('log')
&gt;&gt;&gt; plt.show()

Zero the components that are 10% or less of the carrier magnitude,
then convert back to a time series via inverse STFT

&gt;&gt;&gt; Zxx = np.where(np.abs(Zxx) &gt;= amp/10, Zxx, 0)
&gt;&gt;&gt; _, xrec = signal.istft(Zxx, fs)

Compare the cleaned signal with the original and true carrier signals.

&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; plt.plot(time, x, time, xrec, time, carrier)
&gt;&gt;&gt; plt.xlim([2, 2.1])
&gt;&gt;&gt; plt.xlabel('Time [sec]')
&gt;&gt;&gt; plt.ylabel('Signal')
&gt;&gt;&gt; plt.legend(['Carrier + Noise', 'Filtered via STFT', 'True Carrier'])
&gt;&gt;&gt; plt.show()

Note that the cleaned signal does not start as abruptly as the original,
since some of the coefficients of the transient were also removed:

&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; plt.plot(time, x, time, xrec, time, carrier)
&gt;&gt;&gt; plt.xlim([0, 0.1])
&gt;&gt;&gt; plt.xlabel('Time [sec]')
&gt;&gt;&gt; plt.ylabel('Signal')
&gt;&gt;&gt; plt.legend(['Carrier + Noise', 'Filtered via STFT', 'True Carrier'])
&gt;&gt;&gt; plt.show()
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d1/dc6/__spectral__py_8py_source.html#l01220">1220</a> of file <a class="el" href="../../d1/dc6/__spectral__py_8py_source.html">_spectral_py.py</a>.</p>

</div>
</div>
<a id="a04de21aa2a099fd07b3a8079f68af846" name="a04de21aa2a099fd07b3a8079f68af846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04de21aa2a099fd07b3a8079f68af846">&#9670;&#160;</a></span>lombscargle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._spectral_py.lombscargle </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>freqs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>precenter</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>normalize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">lombscargle(x, y, freqs)

Computes the Lomb-Scargle periodogram.

The Lomb-Scargle periodogram was developed by Lomb [1]_ and further
extended by Scargle [2]_ to find, and test the significance of weak
periodic signals with uneven temporal sampling.

When *normalize* is False (default) the computed periodogram
is unnormalized, it takes the value ``(A**2) * N/4`` for a harmonic
signal with amplitude A for sufficiently large N.

When *normalize* is True the computed periodogram is normalized by
the residuals of the data around a constant reference model (at zero).

Input arrays should be 1-D and will be cast to float64.

Parameters
----------
x : array_like
    Sample times.
y : array_like
    Measurement values.
freqs : array_like
    Angular frequencies for output periodogram.
precenter : bool, optional
    Pre-center measurement values by subtracting the mean.
normalize : bool, optional
    Compute normalized periodogram.

Returns
-------
pgram : array_like
    Lomb-Scargle periodogram.

Raises
------
ValueError
    If the input arrays `x` and `y` do not have the same shape.

See Also
--------
istft: Inverse Short Time Fourier Transform
check_COLA: Check whether the Constant OverLap Add (COLA) constraint is met
welch: Power spectral density by Welch's method
spectrogram: Spectrogram by Welch's method
csd: Cross spectral density by Welch's method

Notes
-----
This subroutine calculates the periodogram using a slightly
modified algorithm due to Townsend [3]_ which allows the
periodogram to be calculated using only a single pass through
the input arrays for each frequency.

The algorithm running time scales roughly as O(x * freqs) or O(N^2)
for a large number of samples and frequencies.

References
----------
.. [1] N.R. Lomb "Least-squares frequency analysis of unequally spaced
       data", Astrophysics and Space Science, vol 39, pp. 447-462, 1976

.. [2] J.D. Scargle "Studies in astronomical time series analysis. II -
       Statistical aspects of spectral analysis of unevenly spaced data",
       The Astrophysical Journal, vol 263, pp. 835-853, 1982

.. [3] R.H.D. Townsend, "Fast calculation of the Lomb-Scargle
       periodogram using graphics processing units.", The Astrophysical
       Journal Supplement Series, vol 191, pp. 247-253, 2010

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; rng = np.random.default_rng()

First define some input parameters for the signal:

&gt;&gt;&gt; A = 2.
&gt;&gt;&gt; w0 = 1.  # rad/sec
&gt;&gt;&gt; nin = 150
&gt;&gt;&gt; nout = 100000

Randomly generate sample times:

&gt;&gt;&gt; x = rng.uniform(0, 10*np.pi, nin)

Plot a sine wave for the selected times:

&gt;&gt;&gt; y = A * np.cos(w0*x)

Define the array of frequencies for which to compute the periodogram:

&gt;&gt;&gt; w = np.linspace(0.01, 10, nout)

Calculate Lomb-Scargle periodogram:

&gt;&gt;&gt; import scipy.signal as signal
&gt;&gt;&gt; pgram = signal.lombscargle(x, y, w, normalize=True)

Now make a plot of the input data:

&gt;&gt;&gt; fig, (ax_t, ax_w) = plt.subplots(2, 1, constrained_layout=True)
&gt;&gt;&gt; ax_t.plot(x, y, 'b+')
&gt;&gt;&gt; ax_t.set_xlabel('Time [s]')

Then plot the normalized periodogram:

&gt;&gt;&gt; ax_w.plot(w, pgram)
&gt;&gt;&gt; ax_w.set_xlabel('Angular frequency [rad/s]')
&gt;&gt;&gt; ax_w.set_ylabel('Normalized amplitude')
&gt;&gt;&gt; plt.show()
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d1/dc6/__spectral__py_8py_source.html#l00017">17</a> of file <a class="el" href="../../d1/dc6/__spectral__py_8py_source.html">_spectral_py.py</a>.</p>

</div>
</div>
<a id="a1ef921c6ed4361b59839b02dad2f958e" name="a1ef921c6ed4361b59839b02dad2f958e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ef921c6ed4361b59839b02dad2f958e">&#9670;&#160;</a></span>periodogram()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._spectral_py.periodogram </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>fs</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>window</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'boxcar'</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>nfft</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>detrend</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'constant'</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>return_onesided</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d8/d0b/classTrue.html">True</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>scaling</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'density'</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>axis</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Estimate power spectral density using a periodogram.

Parameters
----------
x : array_like
    Time series of measurement values
fs : float, optional
    Sampling frequency of the `x` time series. Defaults to 1.0.
window : str or tuple or array_like, optional
    Desired window to use. If `window` is a string or tuple, it is
    passed to `get_window` to generate the window values, which are
    DFT-even by default. See `get_window` for a list of windows and
    required parameters. If `window` is array_like it will be used
    directly as the window and its length must be equal to the length
    of the axis over which the periodogram is computed. Defaults
    to 'boxcar'.
nfft : int, optional
    Length of the FFT used. If `None` the length of `x` will be
    used.
detrend : str or function or `False`, optional
    Specifies how to detrend each segment. If `detrend` is a
    string, it is passed as the `type` argument to the `detrend`
    function. If it is a function, it takes a segment and returns a
    detrended segment. If `detrend` is `False`, no detrending is
    done. Defaults to 'constant'.
return_onesided : bool, optional
    If `True`, return a one-sided spectrum for real data. If
    `False` return a two-sided spectrum. Defaults to `True`, but for
    complex data, a two-sided spectrum is always returned.
scaling : { 'density', 'spectrum' }, optional
    Selects between computing the power spectral density ('density')
    where `Pxx` has units of V**2/Hz and computing the power
    spectrum ('spectrum') where `Pxx` has units of V**2, if `x`
    is measured in V and `fs` is measured in Hz. Defaults to
    'density'
axis : int, optional
    Axis along which the periodogram is computed; the default is
    over the last axis (i.e. ``axis=-1``).

Returns
-------
f : ndarray
    Array of sample frequencies.
Pxx : ndarray
    Power spectral density or power spectrum of `x`.

See Also
--------
welch: Estimate power spectral density using Welch's method
lombscargle: Lomb-Scargle periodogram for unevenly sampled data

Notes
-----
.. versionadded:: 0.12.0

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; rng = np.random.default_rng()

Generate a test signal, a 2 Vrms sine wave at 1234 Hz, corrupted by
0.001 V**2/Hz of white noise sampled at 10 kHz.

&gt;&gt;&gt; fs = 10e3
&gt;&gt;&gt; N = 1e5
&gt;&gt;&gt; amp = 2*np.sqrt(2)
&gt;&gt;&gt; freq = 1234.0
&gt;&gt;&gt; noise_power = 0.001 * fs / 2
&gt;&gt;&gt; time = np.arange(N) / fs
&gt;&gt;&gt; x = amp*np.sin(2*np.pi*freq*time)
&gt;&gt;&gt; x += rng.normal(scale=np.sqrt(noise_power), size=time.shape)

Compute and plot the power spectral density.

&gt;&gt;&gt; f, Pxx_den = signal.periodogram(x, fs)
&gt;&gt;&gt; plt.semilogy(f, Pxx_den)
&gt;&gt;&gt; plt.ylim([1e-7, 1e2])
&gt;&gt;&gt; plt.xlabel('frequency [Hz]')
&gt;&gt;&gt; plt.ylabel('PSD [V**2/Hz]')
&gt;&gt;&gt; plt.show()

If we average the last half of the spectral density, to exclude the
peak, we can recover the noise power on the signal.

&gt;&gt;&gt; np.mean(Pxx_den[25000:])
0.000985320699252543

Now compute and plot the power spectrum.

&gt;&gt;&gt; f, Pxx_spec = signal.periodogram(x, fs, 'flattop', scaling='spectrum')
&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; plt.semilogy(f, np.sqrt(Pxx_spec))
&gt;&gt;&gt; plt.ylim([1e-4, 1e1])
&gt;&gt;&gt; plt.xlabel('frequency [Hz]')
&gt;&gt;&gt; plt.ylabel('Linear spectrum [V RMS]')
&gt;&gt;&gt; plt.show()

The peak height in the power spectrum is an estimate of the RMS
amplitude.

&gt;&gt;&gt; np.sqrt(Pxx_spec.max())
2.0077340678640727
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d1/dc6/__spectral__py_8py_source.html#l00157">157</a> of file <a class="el" href="../../d1/dc6/__spectral__py_8py_source.html">_spectral_py.py</a>.</p>

<p class="reference">References <a class="el" href="../../d1/dc6/__spectral__py_8py_source.html#l00299">welch()</a>.</p>

</div>
</div>
<a id="a4aca9fb32af690767509d2a98b0d211f" name="a4aca9fb32af690767509d2a98b0d211f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aca9fb32af690767509d2a98b0d211f">&#9670;&#160;</a></span>spectrogram()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._spectral_py.spectrogram </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>fs</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>window</em></span><span class="paramdefsep"> = </span><span class="paramdefval">('tukey',&#160;.25)</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>nperseg</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>noverlap</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>nfft</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>detrend</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'constant'</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>return_onesided</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d8/d0b/classTrue.html">True</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>scaling</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'density'</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>axis</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>mode</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'psd'</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute a spectrogram with consecutive Fourier transforms.

Spectrograms can be used as a way of visualizing the change of a
nonstationary signal's frequency content over time.

Parameters
----------
x : array_like
    Time series of measurement values
fs : float, optional
    Sampling frequency of the `x` time series. Defaults to 1.0.
window : str or tuple or array_like, optional
    Desired window to use. If `window` is a string or tuple, it is
    passed to `get_window` to generate the window values, which are
    DFT-even by default. See `get_window` for a list of windows and
    required parameters. If `window` is array_like it will be used
    directly as the window and its length must be nperseg.
    Defaults to a Tukey window with shape parameter of 0.25.
nperseg : int, optional
    Length of each segment. Defaults to None, but if window is str or
    tuple, is set to 256, and if window is array_like, is set to the
    length of the window.
noverlap : int, optional
    Number of points to overlap between segments. If `None`,
    ``noverlap = nperseg // 8``. Defaults to `None`.
nfft : int, optional
    Length of the FFT used, if a zero padded FFT is desired. If
    `None`, the FFT length is `nperseg`. Defaults to `None`.
detrend : str or function or `False`, optional
    Specifies how to detrend each segment. If `detrend` is a
    string, it is passed as the `type` argument to the `detrend`
    function. If it is a function, it takes a segment and returns a
    detrended segment. If `detrend` is `False`, no detrending is
    done. Defaults to 'constant'.
return_onesided : bool, optional
    If `True`, return a one-sided spectrum for real data. If
    `False` return a two-sided spectrum. Defaults to `True`, but for
    complex data, a two-sided spectrum is always returned.
scaling : { 'density', 'spectrum' }, optional
    Selects between computing the power spectral density ('density')
    where `Sxx` has units of V**2/Hz and computing the power
    spectrum ('spectrum') where `Sxx` has units of V**2, if `x`
    is measured in V and `fs` is measured in Hz. Defaults to
    'density'.
axis : int, optional
    Axis along which the spectrogram is computed; the default is over
    the last axis (i.e. ``axis=-1``).
mode : str, optional
    Defines what kind of return values are expected. Options are
    ['psd', 'complex', 'magnitude', 'angle', 'phase']. 'complex' is
    equivalent to the output of `stft` with no padding or boundary
    extension. 'magnitude' returns the absolute magnitude of the
    STFT. 'angle' and 'phase' return the complex angle of the STFT,
    with and without unwrapping, respectively.

Returns
-------
f : ndarray
    Array of sample frequencies.
t : ndarray
    Array of segment times.
Sxx : ndarray
    Spectrogram of x. By default, the last axis of Sxx corresponds
    to the segment times.

See Also
--------
periodogram: Simple, optionally modified periodogram
lombscargle: Lomb-Scargle periodogram for unevenly sampled data
welch: Power spectral density by Welch's method.
csd: Cross spectral density by Welch's method.

Notes
-----
An appropriate amount of overlap will depend on the choice of window
and on your requirements. In contrast to welch's method, where the
entire data stream is averaged over, one may wish to use a smaller
overlap (or perhaps none at all) when computing a spectrogram, to
maintain some statistical independence between individual segments.
It is for this reason that the default window is a Tukey window with
1/8th of a window's length overlap at each end.

.. versionadded:: 0.16.0

References
----------
.. [1] Oppenheim, Alan V., Ronald W. Schafer, John R. Buck
       "Discrete-Time Signal Processing", Prentice Hall, 1999.

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; from scipy.fft import fftshift
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; rng = np.random.default_rng()

Generate a test signal, a 2 Vrms sine wave whose frequency is slowly
modulated around 3kHz, corrupted by white noise of exponentially
decreasing magnitude sampled at 10 kHz.

&gt;&gt;&gt; fs = 10e3
&gt;&gt;&gt; N = 1e5
&gt;&gt;&gt; amp = 2 * np.sqrt(2)
&gt;&gt;&gt; noise_power = 0.01 * fs / 2
&gt;&gt;&gt; time = np.arange(N) / float(fs)
&gt;&gt;&gt; mod = 500*np.cos(2*np.pi*0.25*time)
&gt;&gt;&gt; carrier = amp * np.sin(2*np.pi*3e3*time + mod)
&gt;&gt;&gt; noise = rng.normal(scale=np.sqrt(noise_power), size=time.shape)
&gt;&gt;&gt; noise *= np.exp(-time/5)
&gt;&gt;&gt; x = carrier + noise

Compute and plot the spectrogram.

&gt;&gt;&gt; f, t, Sxx = signal.spectrogram(x, fs)
&gt;&gt;&gt; plt.pcolormesh(t, f, Sxx, shading='gouraud')
&gt;&gt;&gt; plt.ylabel('Frequency [Hz]')
&gt;&gt;&gt; plt.xlabel('Time [sec]')
&gt;&gt;&gt; plt.show()

Note, if using output that is not one sided, then use the following:

&gt;&gt;&gt; f, t, Sxx = signal.spectrogram(x, fs, return_onesided=False)
&gt;&gt;&gt; plt.pcolormesh(t, fftshift(f), fftshift(Sxx, axes=0), shading='gouraud')
&gt;&gt;&gt; plt.ylabel('Frequency [Hz]')
&gt;&gt;&gt; plt.xlabel('Time [sec]')
&gt;&gt;&gt; plt.show()
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d1/dc6/__spectral__py_8py_source.html#l00617">617</a> of file <a class="el" href="../../d1/dc6/__spectral__py_8py_source.html">_spectral_py.py</a>.</p>

<p class="reference">References <a class="el" href="../../d1/dc6/__spectral__py_8py_source.html#l01637">_spectral_helper()</a>, and <a class="el" href="../../d1/dc6/__spectral__py_8py_source.html#l01978">_triage_segments()</a>.</p>

</div>
</div>
<a id="ad0eee5a94f5128e159f80bbf7be61d2f" name="ad0eee5a94f5128e159f80bbf7be61d2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0eee5a94f5128e159f80bbf7be61d2f">&#9670;&#160;</a></span>stft()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._spectral_py.stft </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>fs</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>window</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'hann'</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>nperseg</em></span><span class="paramdefsep"> = </span><span class="paramdefval">256</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>noverlap</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>nfft</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>detrend</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>return_onesided</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d8/d0b/classTrue.html">True</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>boundary</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'zeros'</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>padded</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d8/d0b/classTrue.html">True</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>axis</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>scaling</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'spectrum'</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the Short Time Fourier Transform (STFT).

STFTs can be used as a way of quantifying the change of a
nonstationary signal's frequency and phase content over time.

Parameters
----------
x : array_like
Time series of measurement values
fs : float, optional
Sampling frequency of the `x` time series. Defaults to 1.0.
window : str or tuple or array_like, optional
Desired window to use. If `window` is a string or tuple, it is
passed to `get_window` to generate the window values, which are
DFT-even by default. See `get_window` for a list of windows and
required parameters. If `window` is array_like it will be used
directly as the window and its length must be nperseg. Defaults
to a Hann window.
nperseg : int, optional
Length of each segment. Defaults to 256.
noverlap : int, optional
Number of points to overlap between segments. If `None`,
``noverlap = nperseg // 2``. Defaults to `None`. When
specified, the COLA constraint must be met (see Notes below).
nfft : int, optional
Length of the FFT used, if a zero padded FFT is desired. If
`None`, the FFT length is `nperseg`. Defaults to `None`.
detrend : str or function or `False`, optional
Specifies how to detrend each segment. If `detrend` is a
string, it is passed as the `type` argument to the `detrend`
function. If it is a function, it takes a segment and returns a
detrended segment. If `detrend` is `False`, no detrending is
done. Defaults to `False`.
return_onesided : bool, optional
If `True`, return a one-sided spectrum for real data. If
`False` return a two-sided spectrum. Defaults to `True`, but for
complex data, a two-sided spectrum is always returned.
boundary : str or None, optional
Specifies whether the input signal is extended at both ends, and
how to generate the new values, in order to center the first
windowed segment on the first input point. This has the benefit
of enabling reconstruction of the first input point when the
employed window function starts at zero. Valid options are
``['even', 'odd', 'constant', 'zeros', None]``. Defaults to
'zeros', for zero padding extension. I.e. ``[1, 2, 3, 4]`` is
extended to ``[0, 1, 2, 3, 4, 0]`` for ``nperseg=3``.
padded : bool, optional
Specifies whether the input signal is zero-padded at the end to
make the signal fit exactly into an integer number of window
segments, so that all of the signal is included in the output.
Defaults to `True`. Padding occurs after boundary extension, if
`boundary` is not `None`, and `padded` is `True`, as is the
default.
axis : int, optional
Axis along which the STFT is computed; the default is over the
last axis (i.e. ``axis=-1``).
scaling: {'spectrum', 'psd'}
The default 'spectrum' scaling allows each frequency line of `Zxx` to
be interpreted as a magnitude spectrum. The 'psd' option scales each
line to a power spectral density - it allows to calculate the signal's
energy by numerically integrating over ``abs(Zxx)**2``.

.. versionadded:: 1.9.0

Returns
-------
f : ndarray
Array of sample frequencies.
t : ndarray
Array of segment times.
Zxx : ndarray
STFT of `x`. By default, the last axis of `Zxx` corresponds
to the segment times.

See Also
--------
istft: Inverse Short Time Fourier Transform
check_COLA: Check whether the Constant OverLap Add (COLA) constraint
        is met
check_NOLA: Check whether the Nonzero Overlap Add (NOLA) constraint is met
welch: Power spectral density by Welch's method.
spectrogram: Spectrogram by Welch's method.
csd: Cross spectral density by Welch's method.
lombscargle: Lomb-Scargle periodogram for unevenly sampled data

Notes
-----
In order to enable inversion of an STFT via the inverse STFT in
`istft`, the signal windowing must obey the constraint of "Nonzero
OverLap Add" (NOLA), and the input signal must have complete
windowing coverage (i.e. ``(x.shape[axis] - nperseg) %
(nperseg-noverlap) == 0``). The `padded` argument may be used to
accomplish this.

Given a time-domain signal :math:`x[n]`, a window :math:`w[n]`, and a hop
size :math:`H` = `nperseg - noverlap`, the windowed frame at time index
:math:`t` is given by

.. math:: x_{t}[n]=x[n]w[n-tH]

The overlap-add (OLA) reconstruction equation is given by

.. math:: x[n]=\frac{\sum_{t}x_{t}[n]w[n-tH]}{\sum_{t}w^{2}[n-tH]}

The NOLA constraint ensures that every normalization term that appears
in the denomimator of the OLA reconstruction equation is nonzero. Whether a
choice of `window`, `nperseg`, and `noverlap` satisfy this constraint can
be tested with `check_NOLA`.

.. versionadded:: 0.19.0

References
----------
.. [1] Oppenheim, Alan V., Ronald W. Schafer, John R. Buck
   "Discrete-Time Signal Processing", Prentice Hall, 1999.
.. [2] Daniel W. Griffin, Jae S. Lim "Signal Estimation from
   Modified Short-Time Fourier Transform", IEEE 1984,
   10.1109/TASSP.1984.1164317

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; rng = np.random.default_rng()

Generate a test signal, a 2 Vrms sine wave whose frequency is slowly
modulated around 3kHz, corrupted by white noise of exponentially
decreasing magnitude sampled at 10 kHz.

&gt;&gt;&gt; fs = 10e3
&gt;&gt;&gt; N = 1e5
&gt;&gt;&gt; amp = 2 * np.sqrt(2)
&gt;&gt;&gt; noise_power = 0.01 * fs / 2
&gt;&gt;&gt; time = np.arange(N) / float(fs)
&gt;&gt;&gt; mod = 500*np.cos(2*np.pi*0.25*time)
&gt;&gt;&gt; carrier = amp * np.sin(2*np.pi*3e3*time + mod)
&gt;&gt;&gt; noise = rng.normal(scale=np.sqrt(noise_power),
...                    size=time.shape)
&gt;&gt;&gt; noise *= np.exp(-time/5)
&gt;&gt;&gt; x = carrier + noise

Compute and plot the STFT's magnitude.

&gt;&gt;&gt; f, t, Zxx = signal.stft(x, fs, nperseg=1000)
&gt;&gt;&gt; plt.pcolormesh(t, f, np.abs(Zxx), vmin=0, vmax=amp, shading='gouraud')
&gt;&gt;&gt; plt.title('STFT Magnitude')
&gt;&gt;&gt; plt.ylabel('Frequency [Hz]')
&gt;&gt;&gt; plt.xlabel('Time [sec]')
&gt;&gt;&gt; plt.show()

Compare the energy of the signal `x` with the energy of its STFT:

&gt;&gt;&gt; E_x = sum(x**2) / fs  # Energy of x
&gt;&gt;&gt; # Calculate a two-sided STFT with PSD scaling:
&gt;&gt;&gt; f, t, Zxx = signal.stft(x, fs, nperseg=1000, return_onesided=False,
...                         scaling='psd')
&gt;&gt;&gt; # Integrate numerically over abs(Zxx)**2:
&gt;&gt;&gt; df, dt = f[1] - f[0], t[1] - t[0]
&gt;&gt;&gt; E_Zxx = sum(np.sum(Zxx.real**2 + Zxx.imag**2, axis=0) * df) * dt
&gt;&gt;&gt; # The energy is the same, but the numerical errors are quite large:
&gt;&gt;&gt; np.isclose(E_x, E_Zxx, rtol=1e-2)
True
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d1/dc6/__spectral__py_8py_source.html#l01038">1038</a> of file <a class="el" href="../../d1/dc6/__spectral__py_8py_source.html">_spectral_py.py</a>.</p>

<p class="reference">References <a class="el" href="../../d1/dc6/__spectral__py_8py_source.html#l01637">_spectral_helper()</a>.</p>

</div>
</div>
<a id="ad045f3f43aa8846446af595a5b66bfd7" name="ad045f3f43aa8846446af595a5b66bfd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad045f3f43aa8846446af595a5b66bfd7">&#9670;&#160;</a></span>welch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._spectral_py.welch </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>fs</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>window</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'hann'</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>nperseg</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>noverlap</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>nfft</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>detrend</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'constant'</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>return_onesided</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d8/d0b/classTrue.html">True</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>scaling</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'density'</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>axis</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>average</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'mean'</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Estimate power spectral density using Welch's method.

Welch's method [1]_ computes an estimate of the power spectral
density by dividing the data into overlapping segments, computing a
modified periodogram for each segment and averaging the
periodograms.

Parameters
----------
x : array_like
Time series of measurement values
fs : float, optional
Sampling frequency of the `x` time series. Defaults to 1.0.
window : str or tuple or array_like, optional
Desired window to use. If `window` is a string or tuple, it is
passed to `get_window` to generate the window values, which are
DFT-even by default. See `get_window` for a list of windows and
required parameters. If `window` is array_like it will be used
directly as the window and its length must be nperseg. Defaults
to a Hann window.
nperseg : int, optional
Length of each segment. Defaults to None, but if window is str or
tuple, is set to 256, and if window is array_like, is set to the
length of the window.
noverlap : int, optional
Number of points to overlap between segments. If `None`,
``noverlap = nperseg // 2``. Defaults to `None`.
nfft : int, optional
Length of the FFT used, if a zero padded FFT is desired. If
`None`, the FFT length is `nperseg`. Defaults to `None`.
detrend : str or function or `False`, optional
Specifies how to detrend each segment. If `detrend` is a
string, it is passed as the `type` argument to the `detrend`
function. If it is a function, it takes a segment and returns a
detrended segment. If `detrend` is `False`, no detrending is
done. Defaults to 'constant'.
return_onesided : bool, optional
If `True`, return a one-sided spectrum for real data. If
`False` return a two-sided spectrum. Defaults to `True`, but for
complex data, a two-sided spectrum is always returned.
scaling : { 'density', 'spectrum' }, optional
Selects between computing the power spectral density ('density')
where `Pxx` has units of V**2/Hz and computing the power
spectrum ('spectrum') where `Pxx` has units of V**2, if `x`
is measured in V and `fs` is measured in Hz. Defaults to
'density'
axis : int, optional
Axis along which the periodogram is computed; the default is
over the last axis (i.e. ``axis=-1``).
average : { 'mean', 'median' }, optional
Method to use when averaging periodograms. Defaults to 'mean'.

.. versionadded:: 1.2.0

Returns
-------
f : ndarray
Array of sample frequencies.
Pxx : ndarray
Power spectral density or power spectrum of x.

See Also
--------
periodogram: Simple, optionally modified periodogram
lombscargle: Lomb-Scargle periodogram for unevenly sampled data

Notes
-----
An appropriate amount of overlap will depend on the choice of window
and on your requirements. For the default Hann window an overlap of
50% is a reasonable trade off between accurately estimating the
signal power, while not over counting any of the data. Narrower
windows may require a larger overlap.

If `noverlap` is 0, this method is equivalent to Bartlett's method
[2]_.

.. versionadded:: 0.12.0

References
----------
.. [1] P. Welch, "The use of the fast Fourier transform for the
estimation of power spectra: A method based on time averaging
over short, modified periodograms", IEEE Trans. Audio
Electroacoust. vol. 15, pp. 70-73, 1967.
.. [2] M.S. Bartlett, "Periodogram Analysis and Continuous Spectra",
Biometrika, vol. 37, pp. 1-16, 1950.

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; rng = np.random.default_rng()

Generate a test signal, a 2 Vrms sine wave at 1234 Hz, corrupted by
0.001 V**2/Hz of white noise sampled at 10 kHz.

&gt;&gt;&gt; fs = 10e3
&gt;&gt;&gt; N = 1e5
&gt;&gt;&gt; amp = 2*np.sqrt(2)
&gt;&gt;&gt; freq = 1234.0
&gt;&gt;&gt; noise_power = 0.001 * fs / 2
&gt;&gt;&gt; time = np.arange(N) / fs
&gt;&gt;&gt; x = amp*np.sin(2*np.pi*freq*time)
&gt;&gt;&gt; x += rng.normal(scale=np.sqrt(noise_power), size=time.shape)

Compute and plot the power spectral density.

&gt;&gt;&gt; f, Pxx_den = signal.welch(x, fs, nperseg=1024)
&gt;&gt;&gt; plt.semilogy(f, Pxx_den)
&gt;&gt;&gt; plt.ylim([0.5e-3, 1])
&gt;&gt;&gt; plt.xlabel('frequency [Hz]')
&gt;&gt;&gt; plt.ylabel('PSD [V**2/Hz]')
&gt;&gt;&gt; plt.show()

If we average the last half of the spectral density, to exclude the
peak, we can recover the noise power on the signal.

&gt;&gt;&gt; np.mean(Pxx_den[256:])
0.0009924865443739191

Now compute and plot the power spectrum.

&gt;&gt;&gt; f, Pxx_spec = signal.welch(x, fs, 'flattop', 1024, scaling='spectrum')
&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; plt.semilogy(f, np.sqrt(Pxx_spec))
&gt;&gt;&gt; plt.xlabel('frequency [Hz]')
&gt;&gt;&gt; plt.ylabel('Linear spectrum [V RMS]')
&gt;&gt;&gt; plt.show()

The peak height in the power spectrum is an estimate of the RMS
amplitude.

&gt;&gt;&gt; np.sqrt(Pxx_spec.max())
2.0077340678640727

If we now introduce a discontinuity in the signal, by increasing the
amplitude of a small portion of the signal by 50, we can see the
corruption of the mean average power spectral density, but using a
median average better estimates the normal behaviour.

&gt;&gt;&gt; x[int(N//2):int(N//2)+10] *= 50.
&gt;&gt;&gt; f, Pxx_den = signal.welch(x, fs, nperseg=1024)
&gt;&gt;&gt; f_med, Pxx_den_med = signal.welch(x, fs, nperseg=1024, average='median')
&gt;&gt;&gt; plt.semilogy(f, Pxx_den, label='mean')
&gt;&gt;&gt; plt.semilogy(f_med, Pxx_den_med, label='median')
&gt;&gt;&gt; plt.ylim([0.5e-3, 1])
&gt;&gt;&gt; plt.xlabel('frequency [Hz]')
&gt;&gt;&gt; plt.ylabel('PSD [V**2/Hz]')
&gt;&gt;&gt; plt.legend()
&gt;&gt;&gt; plt.show()
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d1/dc6/__spectral__py_8py_source.html#l00297">297</a> of file <a class="el" href="../../d1/dc6/__spectral__py_8py_source.html">_spectral_py.py</a>.</p>

<p class="reference">References <a class="el" href="../../d1/dc6/__spectral__py_8py_source.html#l00465">csd()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d1/dc6/__spectral__py_8py_source.html#l01513">coherence()</a>, and <a class="el" href="../../d1/dc6/__spectral__py_8py_source.html#l00158">periodogram()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a45048c1f404bbbdb60ba197c50636b4e" name="a45048c1f404bbbdb60ba197c50636b4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45048c1f404bbbdb60ba197c50636b4e">&#9670;&#160;</a></span>__all__</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">list scipy.signal._spectral_py.__all__</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  [<span class="stringliteral">&#39;periodogram&#39;</span>, <span class="stringliteral">&#39;welch&#39;</span>, <span class="stringliteral">&#39;lombscargle&#39;</span>, <span class="stringliteral">&#39;csd&#39;</span>, <span class="stringliteral">&#39;coherence&#39;</span>,</div>
<div class="line"><span class="lineno">    2</span>           <span class="stringliteral">&#39;spectrogram&#39;</span>, <span class="stringliteral">&#39;stft&#39;</span>, <span class="stringliteral">&#39;istft&#39;</span>, <span class="stringliteral">&#39;check_COLA&#39;</span>, <span class="stringliteral">&#39;check_NOLA&#39;</span>]</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="../../d1/dc6/__spectral__py_8py_source.html#l00013">13</a> of file <a class="el" href="../../d1/dc6/__spectral__py_8py_source.html">_spectral_py.py</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../db/d0f/namespacescipy.html">scipy</a></li><li class="navelem"><a class="el" href="../../dd/d63/namespacescipy_1_1signal.html">signal</a></li><li class="navelem"><a class="el" href="../../dc/de6/namespacescipy_1_1signal_1_1__spectral__py.html">_spectral_py</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
