<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Code Cloning Analysis: scipy.linalg._solvers Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Code Cloning Analysis
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('de/d53/namespacescipy_1_1linalg_1_1__solvers.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">scipy.linalg._solvers Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3998015d397914b80c35bc7d05d51a87" id="r_a3998015d397914b80c35bc7d05d51a87"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3998015d397914b80c35bc7d05d51a87">solve_sylvester</a> (a, b, q)</td></tr>
<tr class="separator:a3998015d397914b80c35bc7d05d51a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7c0774545127a1e4f46eb3fac815dc9" id="r_ad7c0774545127a1e4f46eb3fac815dc9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad7c0774545127a1e4f46eb3fac815dc9">solve_continuous_lyapunov</a> (a, q)</td></tr>
<tr class="separator:ad7c0774545127a1e4f46eb3fac815dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b508c50219bea8dff25c55223ef298" id="r_ad5b508c50219bea8dff25c55223ef298"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5b508c50219bea8dff25c55223ef298">_solve_discrete_lyapunov_direct</a> (a, q)</td></tr>
<tr class="separator:ad5b508c50219bea8dff25c55223ef298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f4f41f8966738e4a985320a2c25553" id="r_aa8f4f41f8966738e4a985320a2c25553"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8f4f41f8966738e4a985320a2c25553">_solve_discrete_lyapunov_bilinear</a> (a, q)</td></tr>
<tr class="separator:aa8f4f41f8966738e4a985320a2c25553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69e3106f77513c66be82cc205a378763" id="r_a69e3106f77513c66be82cc205a378763"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69e3106f77513c66be82cc205a378763">solve_discrete_lyapunov</a> (a, q, method=None)</td></tr>
<tr class="separator:a69e3106f77513c66be82cc205a378763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6dc294d2a4d07e61a77477c8107bc00" id="r_ae6dc294d2a4d07e61a77477c8107bc00"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6dc294d2a4d07e61a77477c8107bc00">solve_continuous_are</a> (a, b, q, r, e=None, s=None, balanced=<a class="el" href="../../d8/d0b/classTrue.html">True</a>)</td></tr>
<tr class="separator:ae6dc294d2a4d07e61a77477c8107bc00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add5d1844118d8a79aae4a71660894ab8" id="r_add5d1844118d8a79aae4a71660894ab8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add5d1844118d8a79aae4a71660894ab8">solve_discrete_are</a> (a, b, q, r, e=None, s=None, balanced=<a class="el" href="../../d8/d0b/classTrue.html">True</a>)</td></tr>
<tr class="separator:add5d1844118d8a79aae4a71660894ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6825788563b9a2e2b62176d2c46b06c" id="r_aa6825788563b9a2e2b62176d2c46b06c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6825788563b9a2e2b62176d2c46b06c">_are_validate_args</a> (a, b, q, r, e, s, eq_type='care')</td></tr>
<tr class="separator:aa6825788563b9a2e2b62176d2c46b06c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ae47545360ff6e70df51361aee24589d3" id="r_ae47545360ff6e70df51361aee24589d3"><td class="memItemLeft" align="right" valign="top">list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae47545360ff6e70df51361aee24589d3">__all__</a></td></tr>
<tr class="separator:ae47545360ff6e70df51361aee24589d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae887ddd4ca47310dc4cc334f1e07d9ca" id="r_ae887ddd4ca47310dc4cc334f1e07d9ca"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae887ddd4ca47310dc4cc334f1e07d9ca">solve_lyapunov</a> = <a class="el" href="#ad7c0774545127a1e4f46eb3fac815dc9">solve_continuous_lyapunov</a></td></tr>
<tr class="separator:ae887ddd4ca47310dc4cc334f1e07d9ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Matrix equation solver routines</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="aa6825788563b9a2e2b62176d2c46b06c" name="aa6825788563b9a2e2b62176d2c46b06c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6825788563b9a2e2b62176d2c46b06c">&#9670;&#160;</a></span>_are_validate_args()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._solvers._are_validate_args </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>eq_type</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'care'</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">A helper function to validate the arguments supplied to the
Riccati equation solvers. Any discrepancy found in the input
matrices leads to a ``ValueError`` exception.

Essentially, it performs:

    - a check whether the input is free of NaN and Infs
    - a pass for the data through ``numpy.atleast_2d()``
    - squareness check of the relevant arrays
    - shape consistency check of the arrays
    - singularity check of the relevant arrays
    - symmetricity check of the relevant matrices
    - a check whether the regular or the generalized version is asked.

This function is used by ``solve_continuous_are`` and
``solve_discrete_are``.

Parameters
----------
a, b, q, r, e, s : array_like
    Input data
eq_type : str
    Accepted arguments are 'care' and 'dare'.

Returns
-------
a, b, q, r, e, s : ndarray
    Regularized input data
m, n : int
    shape of the problem
r_or_c : type
    Data type of the problem, returns float or complex
gen_or_not : bool
    Type of the equation, True for generalized and False for regular ARE.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d3/dd9/__solvers_8py_source.html#l00742">742</a> of file <a class="el" href="../../d3/dd9/__solvers_8py_source.html">_solvers.py</a>.</p>

<p class="reference">References <a class="el" href="../../d9/d46/__decomp__svd_8py_source.html#l00014">scipy.linalg._decomp_svd.svd()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d3/dd9/__solvers_8py_source.html#l00328">solve_continuous_are()</a>, and <a class="el" href="../../d3/dd9/__solvers_8py_source.html#l00533">solve_discrete_are()</a>.</p>

</div>
</div>
<a id="aa8f4f41f8966738e4a985320a2c25553" name="aa8f4f41f8966738e4a985320a2c25553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8f4f41f8966738e4a985320a2c25553">&#9670;&#160;</a></span>_solve_discrete_lyapunov_bilinear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._solvers._solve_discrete_lyapunov_bilinear </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>q</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Solves the discrete Lyapunov equation using a bilinear transformation.

This function is called by the `solve_discrete_lyapunov` function with
`method=bilinear`. It is not supposed to be called directly.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d3/dd9/__solvers_8py_source.html#l00221">221</a> of file <a class="el" href="../../d3/dd9/__solvers_8py_source.html">_solvers.py</a>.</p>

<p class="reference">References <a class="el" href="../../d6/dda/linalg_2__basic_8py_source.html#l00903">scipy.linalg._basic.inv()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d3/dd9/__solvers_8py_source.html#l00236">solve_discrete_lyapunov()</a>.</p>

</div>
</div>
<a id="ad5b508c50219bea8dff25c55223ef298" name="ad5b508c50219bea8dff25c55223ef298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5b508c50219bea8dff25c55223ef298">&#9670;&#160;</a></span>_solve_discrete_lyapunov_direct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._solvers._solve_discrete_lyapunov_direct </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>q</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Solves the discrete Lyapunov equation directly.

This function is called by the `solve_discrete_lyapunov` function with
`method=direct`. It is not supposed to be called directly.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d3/dd9/__solvers_8py_source.html#l00206">206</a> of file <a class="el" href="../../d3/dd9/__solvers_8py_source.html">_solvers.py</a>.</p>

<p class="reference">References <a class="el" href="../../d4/dbf/__special__matrices_8py_source.html#l00448">scipy.linalg._special_matrices.kron()</a>, and <a class="el" href="../../d6/dda/linalg_2__basic_8py_source.html#l00054">scipy.linalg._basic.solve()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d3/dd9/__solvers_8py_source.html#l00236">solve_discrete_lyapunov()</a>.</p>

</div>
</div>
<a id="ae6dc294d2a4d07e61a77477c8107bc00" name="ae6dc294d2a4d07e61a77477c8107bc00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6dc294d2a4d07e61a77477c8107bc00">&#9670;&#160;</a></span>solve_continuous_are()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._solvers.solve_continuous_are </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>e</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>s</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>balanced</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d8/d0b/classTrue.html">True</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solves the continuous-time algebraic Riccati equation (CARE).

The CARE is defined as

.. math::

  X A + A^H X - X B R^{-1} B^H X + Q = 0

The limitations for a solution to exist are :

* All eigenvalues of :math:`A` on the right half plane, should be
  controllable.

* The associated hamiltonian pencil (See Notes), should have
  eigenvalues sufficiently away from the imaginary axis.

Moreover, if ``e`` or ``s`` is not precisely ``None``, then the
generalized version of CARE

.. math::

  E^HXA + A^HXE - (E^HXB + S) R^{-1} (B^HXE + S^H) + Q = 0

is solved. When omitted, ``e`` is assumed to be the identity and ``s``
is assumed to be the zero matrix with sizes compatible with ``a`` and
``b``, respectively.

Parameters
----------
a : (M, M) array_like
Square matrix
b : (M, N) array_like
Input
q : (M, M) array_like
Input
r : (N, N) array_like
Nonsingular square matrix
e : (M, M) array_like, optional
Nonsingular square matrix
s : (M, N) array_like, optional
Input
balanced : bool, optional
The boolean that indicates whether a balancing step is performed
on the data. The default is set to True.

Returns
-------
x : (M, M) ndarray
Solution to the continuous-time algebraic Riccati equation.

Raises
------
LinAlgError
For cases where the stable subspace of the pencil could not be
isolated. See Notes section and the references for details.

See Also
--------
solve_discrete_are : Solves the discrete-time algebraic Riccati equation

Notes
-----
The equation is solved by forming the extended hamiltonian matrix pencil,
as described in [1]_, :math:`H - \lambda J` given by the block matrices ::

[ A    0    B ]             [ E   0    0 ]
[-Q  -A^H  -S ] - \lambda * [ 0  E^H   0 ]
[ S^H B^H   R ]             [ 0   0    0 ]

and using a QZ decomposition method.

In this algorithm, the fail conditions are linked to the symmetry
of the product :math:`U_2 U_1^{-1}` and condition number of
:math:`U_1`. Here, :math:`U` is the 2m-by-m matrix that holds the
eigenvectors spanning the stable subspace with 2-m rows and partitioned
into two m-row matrices. See [1]_ and [2]_ for more details.

In order to improve the QZ decomposition accuracy, the pencil goes
through a balancing step where the sum of absolute values of
:math:`H` and :math:`J` entries (after removing the diagonal entries of
the sum) is balanced following the recipe given in [3]_.

.. versionadded:: 0.11.0

References
----------
.. [1]  P. van Dooren , "A Generalized Eigenvalue Approach For Solving
Riccati Equations.", SIAM Journal on Scientific and Statistical
Computing, Vol.2(2), :doi:`10.1137/0902010`

.. [2] A.J. Laub, "A Schur Method for Solving Algebraic Riccati
Equations.", Massachusetts Institute of Technology. Laboratory for
Information and Decision Systems. LIDS-R ; 859. Available online :
http://hdl.handle.net/1721.1/1301

.. [3] P. Benner, "Symplectic Balancing of Hamiltonian Matrices", 2001,
SIAM J. Sci. Comput., 2001, Vol.22(5), :doi:`10.1137/S1064827500367993`

Examples
--------
Given `a`, `b`, `q`, and `r` solve for `x`:

&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy import linalg
&gt;&gt;&gt; a = np.array([[4, 3], [-4.5, -3.5]])
&gt;&gt;&gt; b = np.array([[1], [-1]])
&gt;&gt;&gt; q = np.array([[9, 6], [6, 4.]])
&gt;&gt;&gt; r = 1
&gt;&gt;&gt; x = linalg.solve_continuous_are(a, b, q, r)
&gt;&gt;&gt; x
array([[ 21.72792206,  14.48528137],
   [ 14.48528137,   9.65685425]])
&gt;&gt;&gt; np.allclose(a.T.dot(x) + x.dot(a)-x.dot(b).dot(b.T).dot(x), -q)
True
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d3/dd9/__solvers_8py_source.html#l00328">328</a> of file <a class="el" href="../../d3/dd9/__solvers_8py_source.html">_solvers.py</a>.</p>

<p class="reference">References <a class="el" href="../../d3/dd9/__solvers_8py_source.html#l00742">_are_validate_args()</a>, <a class="el" href="../../d4/dbf/__special__matrices_8py_source.html#l00489">scipy.linalg._special_matrices.block_diag()</a>, <a class="el" href="../../d7/d02/__decomp__lu_8py_source.html#l00160">scipy.linalg._decomp_lu.lu()</a>, <a class="el" href="../../d6/dda/linalg_2__basic_8py_source.html#l01561">scipy.linalg._basic.matrix_balance()</a>, <a class="el" href="../../d4/dd4/__decomp__qz_8py_source.html#l00321">scipy.linalg._decomp_qz.ordqz()</a>, <a class="el" href="../../d6/da4/__decomp__qr_8py_source.html#l00027">scipy.linalg._decomp_qr.qr()</a>, and <a class="el" href="../../d6/dda/linalg_2__basic_8py_source.html#l00266">scipy.linalg._basic.solve_triangular()</a>.</p>

</div>
</div>
<a id="ad7c0774545127a1e4f46eb3fac815dc9" name="ad7c0774545127a1e4f46eb3fac815dc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7c0774545127a1e4f46eb3fac815dc9">&#9670;&#160;</a></span>solve_continuous_lyapunov()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._solvers.solve_continuous_lyapunov </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>q</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solves the continuous Lyapunov equation :math:`AX + XA^H = Q`.

Uses the Bartels-Stewart algorithm to find :math:`X`.

Parameters
----------
a : array_like
    A square matrix

q : array_like
    Right-hand side square matrix

Returns
-------
x : ndarray
    Solution to the continuous Lyapunov equation

See Also
--------
solve_discrete_lyapunov : computes the solution to the discrete-time
    Lyapunov equation
solve_sylvester : computes the solution to the Sylvester equation

Notes
-----
The continuous Lyapunov equation is a special form of the Sylvester
equation, hence this solver relies on LAPACK routine ?TRSYL.

.. versionadded:: 0.11.0

Examples
--------
Given `a` and `q` solve for `x`:

&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy import linalg
&gt;&gt;&gt; a = np.array([[-3, -2, 0], [-1, -1, 0], [0, -5, -1]])
&gt;&gt;&gt; b = np.array([2, 4, -1])
&gt;&gt;&gt; q = np.eye(3)
&gt;&gt;&gt; x = linalg.solve_continuous_lyapunov(a, q)
&gt;&gt;&gt; x
array([[ -0.75  ,   0.875 ,  -3.75  ],
       [  0.875 ,  -1.375 ,   5.3125],
       [ -3.75  ,   5.3125, -27.0625]])
&gt;&gt;&gt; np.allclose(a.dot(x) + x.dot(a.T), q)
True
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d3/dd9/__solvers_8py_source.html#l00109">109</a> of file <a class="el" href="../../d3/dd9/__solvers_8py_source.html">_solvers.py</a>.</p>

<p class="reference">References <a class="el" href="../../d0/d0c/lapack_8py_source.html#l00882">scipy.linalg.lapack.get_lapack_funcs()</a>, and <a class="el" href="../../df/df8/__decomp__schur_8py_source.html#l00018">scipy.linalg._decomp_schur.schur()</a>.</p>

</div>
</div>
<a id="add5d1844118d8a79aae4a71660894ab8" name="add5d1844118d8a79aae4a71660894ab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add5d1844118d8a79aae4a71660894ab8">&#9670;&#160;</a></span>solve_discrete_are()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._solvers.solve_discrete_are </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>e</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>s</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>balanced</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d8/d0b/classTrue.html">True</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solves the discrete-time algebraic Riccati equation (DARE).

The DARE is defined as

.. math::

A^HXA - X - (A^HXB) (R + B^HXB)^{-1} (B^HXA) + Q = 0

The limitations for a solution to exist are :

* All eigenvalues of :math:`A` outside the unit disc, should be
controllable.

* The associated symplectic pencil (See Notes), should have
eigenvalues sufficiently away from the unit circle.

Moreover, if ``e`` and ``s`` are not both precisely ``None``, then the
generalized version of DARE

.. math::

A^HXA - E^HXE - (A^HXB+S) (R+B^HXB)^{-1} (B^HXA+S^H) + Q = 0

is solved. When omitted, ``e`` is assumed to be the identity and ``s``
is assumed to be the zero matrix.

Parameters
----------
a : (M, M) array_like
Square matrix
b : (M, N) array_like
Input
q : (M, M) array_like
Input
r : (N, N) array_like
Square matrix
e : (M, M) array_like, optional
Nonsingular square matrix
s : (M, N) array_like, optional
Input
balanced : bool
The boolean that indicates whether a balancing step is performed
on the data. The default is set to True.

Returns
-------
x : (M, M) ndarray
Solution to the discrete algebraic Riccati equation.

Raises
------
LinAlgError
For cases where the stable subspace of the pencil could not be
isolated. See Notes section and the references for details.

See Also
--------
solve_continuous_are : Solves the continuous algebraic Riccati equation

Notes
-----
The equation is solved by forming the extended symplectic matrix pencil,
as described in [1]_, :math:`H - \lambda J` given by the block matrices ::

[  A   0   B ]             [ E   0   B ]
[ -Q  E^H -S ] - \lambda * [ 0  A^H  0 ]
[ S^H  0   R ]             [ 0 -B^H  0 ]

and using a QZ decomposition method.

In this algorithm, the fail conditions are linked to the symmetry
of the product :math:`U_2 U_1^{-1}` and condition number of
:math:`U_1`. Here, :math:`U` is the 2m-by-m matrix that holds the
eigenvectors spanning the stable subspace with 2-m rows and partitioned
into two m-row matrices. See [1]_ and [2]_ for more details.

In order to improve the QZ decomposition accuracy, the pencil goes
through a balancing step where the sum of absolute values of
:math:`H` and :math:`J` rows/cols (after removing the diagonal entries)
is balanced following the recipe given in [3]_. If the data has small
numerical noise, balancing may amplify their effects and some clean up
is required.

.. versionadded:: 0.11.0

References
----------
.. [1]  P. van Dooren , "A Generalized Eigenvalue Approach For Solving
Riccati Equations.", SIAM Journal on Scientific and Statistical
Computing, Vol.2(2), :doi:`10.1137/0902010`

.. [2] A.J. Laub, "A Schur Method for Solving Algebraic Riccati
Equations.", Massachusetts Institute of Technology. Laboratory for
Information and Decision Systems. LIDS-R ; 859. Available online :
http://hdl.handle.net/1721.1/1301

.. [3] P. Benner, "Symplectic Balancing of Hamiltonian Matrices", 2001,
SIAM J. Sci. Comput., 2001, Vol.22(5), :doi:`10.1137/S1064827500367993`

Examples
--------
Given `a`, `b`, `q`, and `r` solve for `x`:

&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy import linalg as la
&gt;&gt;&gt; a = np.array([[0, 1], [0, -1]])
&gt;&gt;&gt; b = np.array([[1, 0], [2, 1]])
&gt;&gt;&gt; q = np.array([[-4, -4], [-4, 7]])
&gt;&gt;&gt; r = np.array([[9, 3], [3, 1]])
&gt;&gt;&gt; x = la.solve_discrete_are(a, b, q, r)
&gt;&gt;&gt; x
array([[-4., -4.],
[-4.,  7.]])
&gt;&gt;&gt; R = la.solve(r + b.T.dot(x).dot(b), b.T.dot(x).dot(a))
&gt;&gt;&gt; np.allclose(a.T.dot(x).dot(a) - x - a.T.dot(x).dot(b).dot(R), -q)
True
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d3/dd9/__solvers_8py_source.html#l00533">533</a> of file <a class="el" href="../../d3/dd9/__solvers_8py_source.html">_solvers.py</a>.</p>

<p class="reference">References <a class="el" href="../../d3/dd9/__solvers_8py_source.html#l00742">_are_validate_args()</a>, <a class="el" href="../../d7/d02/__decomp__lu_8py_source.html#l00160">scipy.linalg._decomp_lu.lu()</a>, <a class="el" href="../../d6/dda/linalg_2__basic_8py_source.html#l01561">scipy.linalg._basic.matrix_balance()</a>, <a class="el" href="../../d4/dd4/__decomp__qz_8py_source.html#l00321">scipy.linalg._decomp_qz.ordqz()</a>, <a class="el" href="../../d6/da4/__decomp__qr_8py_source.html#l00027">scipy.linalg._decomp_qr.qr()</a>, and <a class="el" href="../../d6/dda/linalg_2__basic_8py_source.html#l00266">scipy.linalg._basic.solve_triangular()</a>.</p>

</div>
</div>
<a id="a69e3106f77513c66be82cc205a378763" name="a69e3106f77513c66be82cc205a378763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69e3106f77513c66be82cc205a378763">&#9670;&#160;</a></span>solve_discrete_lyapunov()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._solvers.solve_discrete_lyapunov </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>method</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solves the discrete Lyapunov equation :math:`AXA^H - X + Q = 0`.

Parameters
----------
a, q : (M, M) array_like
    Square matrices corresponding to A and Q in the equation
    above respectively. Must have the same shape.

method : {'direct', 'bilinear'}, optional
    Type of solver.

    If not given, chosen to be ``direct`` if ``M`` is less than 10 and
    ``bilinear`` otherwise.

Returns
-------
x : ndarray
    Solution to the discrete Lyapunov equation

See Also
--------
solve_continuous_lyapunov : computes the solution to the continuous-time
    Lyapunov equation

Notes
-----
This section describes the available solvers that can be selected by the
'method' parameter. The default method is *direct* if ``M`` is less than 10
and ``bilinear`` otherwise.

Method *direct* uses a direct analytical solution to the discrete Lyapunov
equation. The algorithm is given in, for example, [1]_. However, it requires
the linear solution of a system with dimension :math:`M^2` so that
performance degrades rapidly for even moderately sized matrices.

Method *bilinear* uses a bilinear transformation to convert the discrete
Lyapunov equation to a continuous Lyapunov equation :math:`(BX+XB'=-C)`
where :math:`B=(A-I)(A+I)^{-1}` and
:math:`C=2(A' + I)^{-1} Q (A + I)^{-1}`. The continuous equation can be
efficiently solved since it is a special case of a Sylvester equation.
The transformation algorithm is from Popov (1964) as described in [2]_.

.. versionadded:: 0.11.0

References
----------
.. [1] Hamilton, James D. Time Series Analysis, Princeton: Princeton
   University Press, 1994.  265.  Print.
   http://doc1.lbfl.li/aca/FLMF037168.pdf
.. [2] Gajic, Z., and M.T.J. Qureshi. 2008.
   Lyapunov Matrix Equation in System Stability and Control.
   Dover Books on Engineering Series. Dover Publications.

Examples
--------
Given `a` and `q` solve for `x`:

&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy import linalg
&gt;&gt;&gt; a = np.array([[0.2, 0.5],[0.7, -0.9]])
&gt;&gt;&gt; q = np.eye(2)
&gt;&gt;&gt; x = linalg.solve_discrete_lyapunov(a, q)
&gt;&gt;&gt; x
array([[ 0.70872893,  1.43518822],
       [ 1.43518822, -2.4266315 ]])
&gt;&gt;&gt; np.allclose(a.dot(x).dot(a.T)-x, -q)
True
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d3/dd9/__solvers_8py_source.html#l00236">236</a> of file <a class="el" href="../../d3/dd9/__solvers_8py_source.html">_solvers.py</a>.</p>

<p class="reference">References <a class="el" href="../../d3/dd9/__solvers_8py_source.html#l00221">_solve_discrete_lyapunov_bilinear()</a>, and <a class="el" href="../../d3/dd9/__solvers_8py_source.html#l00206">_solve_discrete_lyapunov_direct()</a>.</p>

</div>
</div>
<a id="a3998015d397914b80c35bc7d05d51a87" name="a3998015d397914b80c35bc7d05d51a87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3998015d397914b80c35bc7d05d51a87">&#9670;&#160;</a></span>solve_sylvester()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._solvers.solve_sylvester </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>q</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Computes a solution (X) to the Sylvester equation :math:`AX + XB = Q`.

Parameters
----------
a : (M, M) array_like
    Leading matrix of the Sylvester equation
b : (N, N) array_like
    Trailing matrix of the Sylvester equation
q : (M, N) array_like
    Right-hand side

Returns
-------
x : (M, N) ndarray
    The solution to the Sylvester equation.

Raises
------
LinAlgError
    If solution was not found

Notes
-----
Computes a solution to the Sylvester matrix equation via the Bartels-
Stewart algorithm. The A and B matrices first undergo Schur
decompositions. The resulting matrices are used to construct an
alternative Sylvester equation (``RY + YS^T = F``) where the R and S
matrices are in quasi-triangular form (or, when R, S or F are complex,
triangular form). The simplified equation is then solved using
``*TRSYL`` from LAPACK directly.

.. versionadded:: 0.11.0

Examples
--------
Given `a`, `b`, and `q` solve for `x`:

&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy import linalg
&gt;&gt;&gt; a = np.array([[-3, -2, 0], [-1, -1, 3], [3, -5, -1]])
&gt;&gt;&gt; b = np.array([[1]])
&gt;&gt;&gt; q = np.array([[1],[2],[3]])
&gt;&gt;&gt; x = linalg.solve_sylvester(a, b, q)
&gt;&gt;&gt; x
array([[ 0.0625],
       [-0.5625],
       [ 0.6875]])
&gt;&gt;&gt; np.allclose(a.dot(x) + x.dot(b), q)
True
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d3/dd9/__solvers_8py_source.html#l00030">30</a> of file <a class="el" href="../../d3/dd9/__solvers_8py_source.html">_solvers.py</a>.</p>

<p class="reference">References <a class="el" href="../../d0/d0c/lapack_8py_source.html#l00882">scipy.linalg.lapack.get_lapack_funcs()</a>, and <a class="el" href="../../df/df8/__decomp__schur_8py_source.html#l00018">scipy.linalg._decomp_schur.schur()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ae47545360ff6e70df51361aee24589d3" name="ae47545360ff6e70df51361aee24589d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae47545360ff6e70df51361aee24589d3">&#9670;&#160;</a></span>__all__</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">list scipy.linalg._solvers.__all__</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  [<span class="stringliteral">&#39;solve_sylvester&#39;</span>,</div>
<div class="line"><span class="lineno">    2</span>           <span class="stringliteral">&#39;solve_continuous_lyapunov&#39;</span>, <span class="stringliteral">&#39;solve_discrete_lyapunov&#39;</span>,</div>
<div class="line"><span class="lineno">    3</span>           <span class="stringliteral">&#39;solve_lyapunov&#39;</span>,</div>
<div class="line"><span class="lineno">    4</span>           <span class="stringliteral">&#39;solve_continuous_are&#39;</span>, <span class="stringliteral">&#39;solve_discrete_are&#39;</span>]</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="../../d3/dd9/__solvers_8py_source.html#l00024">24</a> of file <a class="el" href="../../d3/dd9/__solvers_8py_source.html">_solvers.py</a>.</p>

</div>
</div>
<a id="ae887ddd4ca47310dc4cc334f1e07d9ca" name="ae887ddd4ca47310dc4cc334f1e07d9ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae887ddd4ca47310dc4cc334f1e07d9ca">&#9670;&#160;</a></span>solve_lyapunov</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.linalg._solvers.solve_lyapunov = <a class="el" href="#ad7c0774545127a1e4f46eb3fac815dc9">solve_continuous_lyapunov</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d3/dd9/__solvers_8py_source.html#l00203">203</a> of file <a class="el" href="../../d3/dd9/__solvers_8py_source.html">_solvers.py</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../db/d0f/namespacescipy.html">scipy</a></li><li class="navelem"><a class="el" href="../../dd/dd4/namespacescipy_1_1linalg.html">linalg</a></li><li class="navelem"><a class="el" href="../../de/d53/namespacescipy_1_1linalg_1_1__solvers.html">_solvers</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
