<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Code Cloning Analysis: scipy.integrate._bvp Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Code Cloning Analysis
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d7/de8/namespacescipy_1_1integrate_1_1__bvp.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">scipy.integrate._bvp Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/db4/classscipy_1_1integrate_1_1__bvp_1_1BVPResult.html">BVPResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a7e1d215a615a92553cf69d99c957daf1" id="r_a7e1d215a615a92553cf69d99c957daf1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e1d215a615a92553cf69d99c957daf1">estimate_fun_jac</a> (fun, x, y, p, f0=None)</td></tr>
<tr class="separator:a7e1d215a615a92553cf69d99c957daf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c9bd5fbc41d0665e0326c9bd5fccfb" id="r_a45c9bd5fbc41d0665e0326c9bd5fccfb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45c9bd5fbc41d0665e0326c9bd5fccfb">estimate_bc_jac</a> (bc, ya, yb, p, bc0=None)</td></tr>
<tr class="separator:a45c9bd5fbc41d0665e0326c9bd5fccfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6bbeda8eaef8fdac0da58fa78f6f198" id="r_af6bbeda8eaef8fdac0da58fa78f6f198"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6bbeda8eaef8fdac0da58fa78f6f198">compute_jac_indices</a> (n, m, k)</td></tr>
<tr class="separator:af6bbeda8eaef8fdac0da58fa78f6f198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2ee109a1b89b59380bc4d9aa0b57ba" id="r_a1d2ee109a1b89b59380bc4d9aa0b57ba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d2ee109a1b89b59380bc4d9aa0b57ba">stacked_matmul</a> (a, b)</td></tr>
<tr class="separator:a1d2ee109a1b89b59380bc4d9aa0b57ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1154189ea728f879fa1a50bf962f5628" id="r_a1154189ea728f879fa1a50bf962f5628"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1154189ea728f879fa1a50bf962f5628">construct_global_jac</a> (n, m, k, i_jac, j_jac, h, df_dy, df_dy_middle, df_dp, df_dp_middle, dbc_dya, dbc_dyb, dbc_dp)</td></tr>
<tr class="separator:a1154189ea728f879fa1a50bf962f5628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10253dea50687b4fa2f6c452de6f749a" id="r_a10253dea50687b4fa2f6c452de6f749a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10253dea50687b4fa2f6c452de6f749a">collocation_fun</a> (fun, y, p, x, h)</td></tr>
<tr class="separator:a10253dea50687b4fa2f6c452de6f749a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e5192bec9ee862fea0740740b0b180a" id="r_a3e5192bec9ee862fea0740740b0b180a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e5192bec9ee862fea0740740b0b180a">prepare_sys</a> (n, m, k, fun, bc, fun_jac, bc_jac, x, h)</td></tr>
<tr class="separator:a3e5192bec9ee862fea0740740b0b180a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b44b4b962bed36f279bfe9307fe6eb3" id="r_a9b44b4b962bed36f279bfe9307fe6eb3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b44b4b962bed36f279bfe9307fe6eb3">solve_newton</a> (n, m, h, col_fun, bc, jac, y, p, B, bvp_tol, bc_tol)</td></tr>
<tr class="separator:a9b44b4b962bed36f279bfe9307fe6eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91b30c7b4693fb5d60b6005793ae834a" id="r_a91b30c7b4693fb5d60b6005793ae834a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91b30c7b4693fb5d60b6005793ae834a">print_iteration_header</a> ()</td></tr>
<tr class="separator:a91b30c7b4693fb5d60b6005793ae834a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56031b469e5609df5d8dd39bd8f5509c" id="r_a56031b469e5609df5d8dd39bd8f5509c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56031b469e5609df5d8dd39bd8f5509c">print_iteration_progress</a> (iteration, residual, bc_residual, total_nodes, nodes_added)</td></tr>
<tr class="separator:a56031b469e5609df5d8dd39bd8f5509c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af426b824c4dbc0de39b9942652a8904e" id="r_af426b824c4dbc0de39b9942652a8904e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af426b824c4dbc0de39b9942652a8904e">estimate_rms_residuals</a> (fun, sol, x, h, p, r_middle, f_middle)</td></tr>
<tr class="separator:af426b824c4dbc0de39b9942652a8904e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52008364a7339728115c99023d524c26" id="r_a52008364a7339728115c99023d524c26"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52008364a7339728115c99023d524c26">create_spline</a> (y, yp, x, h)</td></tr>
<tr class="separator:a52008364a7339728115c99023d524c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b2734b62ef488e502e42e0aa66a9946" id="r_a9b2734b62ef488e502e42e0aa66a9946"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b2734b62ef488e502e42e0aa66a9946">modify_mesh</a> (x, insert_1, insert_2)</td></tr>
<tr class="separator:a9b2734b62ef488e502e42e0aa66a9946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab326bbe47e4328938c2cf9b65c6d5dc3" id="r_ab326bbe47e4328938c2cf9b65c6d5dc3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab326bbe47e4328938c2cf9b65c6d5dc3">wrap_functions</a> (fun, bc, fun_jac, bc_jac, k, a, S, D, dtype)</td></tr>
<tr class="separator:ab326bbe47e4328938c2cf9b65c6d5dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d9e00cd7b244fb96fd92ff8510b1a6" id="r_ac7d9e00cd7b244fb96fd92ff8510b1a6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7d9e00cd7b244fb96fd92ff8510b1a6">solve_bvp</a> (fun, bc, x, y, p=None, S=None, fun_jac=None, bc_jac=None, tol=1e-3, max_nodes=1000, verbose=0, bc_tol=None)</td></tr>
<tr class="separator:ac7d9e00cd7b244fb96fd92ff8510b1a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ad99dbe0f4c37ff34045848221ac5174e" id="r_ad99dbe0f4c37ff34045848221ac5174e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad99dbe0f4c37ff34045848221ac5174e">EPS</a> = np.finfo(float).eps</td></tr>
<tr class="separator:ad99dbe0f4c37ff34045848221ac5174e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e0abd96fce877bfa6f1ba4fc0774515" id="r_a9e0abd96fce877bfa6f1ba4fc0774515"><td class="memItemLeft" align="right" valign="top">dict&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e0abd96fce877bfa6f1ba4fc0774515">TERMINATION_MESSAGES</a></td></tr>
<tr class="separator:a9e0abd96fce877bfa6f1ba4fc0774515"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Boundary value problem solver.</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a10253dea50687b4fa2f6c452de6f749a" name="a10253dea50687b4fa2f6c452de6f749a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10253dea50687b4fa2f6c452de6f749a">&#9670;&#160;</a></span>collocation_fun()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.integrate._bvp.collocation_fun </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>fun</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>h</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Evaluate collocation residuals.

This function lies in the core of the method. The solution is sought
as a cubic C1 continuous spline with derivatives matching the ODE rhs
at given nodes `x`. Collocation conditions are formed from the equality
of the spline derivatives and rhs of the ODE system in the middle points
between nodes.

Such method is classified to Lobbato IIIA family in ODE literature.
Refer to [1]_ for the formula and some discussion.

Returns
-------
col_res : ndarray, shape (n, m - 1)
    Collocation residuals at the middle points of the mesh intervals.
y_middle : ndarray, shape (n, m - 1)
    Values of the cubic spline evaluated at the middle points of the mesh
    intervals.
f : ndarray, shape (n, m)
    RHS of the ODE system evaluated at the mesh nodes.
f_middle : ndarray, shape (n, m - 1)
    RHS of the ODE system evaluated at the middle points of the mesh
    intervals (and using `y_middle`).

References
----------
.. [1] J. Kierzenka, L. F. Shampine, "A BVP Solver Based on Residual
       Control and the Maltab PSE", ACM Trans. Math. Softw., Vol. 27,
       Number 3, pp. 299-316, 2001.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../dc/d3b/__bvp_8py_source.html#l00276">276</a> of file <a class="el" href="../../dc/d3b/__bvp_8py_source.html">_bvp.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dc/d3b/__bvp_8py_source.html#l00317">prepare_sys()</a>, and <a class="el" href="../../dc/d3b/__bvp_8py_source.html#l00711">solve_bvp()</a>.</p>

</div>
</div>
<a id="af6bbeda8eaef8fdac0da58fa78f6f198" name="af6bbeda8eaef8fdac0da58fa78f6f198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6bbeda8eaef8fdac0da58fa78f6f198">&#9670;&#160;</a></span>compute_jac_indices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.integrate._bvp.compute_jac_indices </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>k</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute indices for the collocation system Jacobian construction.

See `construct_global_jac` for the explanation.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../dc/d3b/__bvp_8py_source.html#l00117">117</a> of file <a class="el" href="../../dc/d3b/__bvp_8py_source.html">_bvp.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dc/d3b/__bvp_8py_source.html#l00317">prepare_sys()</a>.</p>

</div>
</div>
<a id="a1154189ea728f879fa1a50bf962f5628" name="a1154189ea728f879fa1a50bf962f5628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1154189ea728f879fa1a50bf962f5628">&#9670;&#160;</a></span>construct_global_jac()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.integrate._bvp.construct_global_jac </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>i_jac</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>j_jac</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>h</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>df_dy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>df_dy_middle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>df_dp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>df_dp_middle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>dbc_dya</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>dbc_dyb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>dbc_dp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Construct the Jacobian of the collocation system.

There are n * m + k functions: m - 1 collocations residuals, each
containing n components, followed by n + k boundary condition residuals.

There are n * m + k variables: m vectors of y, each containing n
components, followed by k values of vector p.

For example, let m = 4, n = 2 and k = 1, then the Jacobian will have
the following sparsity structure:

    1 1 2 2 0 0 0 0  5
    1 1 2 2 0 0 0 0  5
    0 0 1 1 2 2 0 0  5
    0 0 1 1 2 2 0 0  5
    0 0 0 0 1 1 2 2  5
    0 0 0 0 1 1 2 2  5

    3 3 0 0 0 0 4 4  6
    3 3 0 0 0 0 4 4  6
    3 3 0 0 0 0 4 4  6

Zeros denote identically zero values, other values denote different kinds
of blocks in the matrix (see below). The blank row indicates the separation
of collocation residuals from boundary conditions. And the blank column
indicates the separation of y values from p values.

Refer to [1]_  (p. 306) for the formula of n x n blocks for derivatives
of collocation residuals with respect to y.

Parameters
----------
n : int
    Number of equations in the ODE system.
m : int
    Number of nodes in the mesh.
k : int
    Number of the unknown parameters.
i_jac, j_jac : ndarray
    Row and column indices returned by `compute_jac_indices`. They
    represent different blocks in the Jacobian matrix in the following
    order (see the scheme above):

        * 1: m - 1 diagonal n x n blocks for the collocation residuals.
        * 2: m - 1 off-diagonal n x n blocks for the collocation residuals.
        * 3 : (n + k) x n block for the dependency of the boundary
          conditions on ya.
        * 4: (n + k) x n block for the dependency of the boundary
          conditions on yb.
        * 5: (m - 1) * n x k block for the dependency of the collocation
          residuals on p.
        * 6: (n + k) x k block for the dependency of the boundary
          conditions on p.

df_dy : ndarray, shape (n, n, m)
    Jacobian of f with respect to y computed at the mesh nodes.
df_dy_middle : ndarray, shape (n, n, m - 1)
    Jacobian of f with respect to y computed at the middle between the
    mesh nodes.
df_dp : ndarray with shape (n, k, m) or None
    Jacobian of f with respect to p computed at the mesh nodes.
df_dp_middle : ndarray with shape (n, k, m - 1) or None
    Jacobian of f with respect to p computed at the middle between the
    mesh nodes.
dbc_dya, dbc_dyb : ndarray, shape (n, n)
    Jacobian of bc with respect to ya and yb.
dbc_dp : ndarray with shape (n, k) or None
    Jacobian of bc with respect to p.

Returns
-------
J : csc_matrix, shape (n * m + k, n * m + k)
    Jacobian of the collocation system in a sparse form.

References
----------
.. [1] J. Kierzenka, L. F. Shampine, "A BVP Solver Based on Residual
   Control and the Maltab PSE", ACM Trans. Math. Softw., Vol. 27,
   Number 3, pp. 299-316, 2001.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../dc/d3b/__bvp_8py_source.html#l00158">158</a> of file <a class="el" href="../../dc/d3b/__bvp_8py_source.html">_bvp.py</a>.</p>

<p class="reference">References <a class="el" href="../../dc/d3b/__bvp_8py_source.html#l00143">stacked_matmul()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dc/d3b/__bvp_8py_source.html#l00317">prepare_sys()</a>.</p>

</div>
</div>
<a id="a52008364a7339728115c99023d524c26" name="a52008364a7339728115c99023d524c26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52008364a7339728115c99023d524c26">&#9670;&#160;</a></span>create_spline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.integrate._bvp.create_spline </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>yp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>h</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create a cubic spline given values and derivatives.

Formulas for the coefficients are taken from interpolate.CubicSpline.

Returns
-------
sol : PPoly
    Constructed spline as a PPoly instance.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../dc/d3b/__bvp_8py_source.html#l00577">577</a> of file <a class="el" href="../../dc/d3b/__bvp_8py_source.html">_bvp.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dc/d3b/__bvp_8py_source.html#l00711">solve_bvp()</a>.</p>

</div>
</div>
<a id="a45c9bd5fbc41d0665e0326c9bd5fccfb" name="a45c9bd5fbc41d0665e0326c9bd5fccfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45c9bd5fbc41d0665e0326c9bd5fccfb">&#9670;&#160;</a></span>estimate_bc_jac()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.integrate._bvp.estimate_bc_jac </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>bc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>ya</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>yb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>bc0</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Estimate derivatives of boundary conditions with forward differences.

Returns
-------
dbc_dya : ndarray, shape (n + k, n)
    Derivatives with respect to ya. An element (i, j) corresponds to
    d bc_i / d ya_j.
dbc_dyb : ndarray, shape (n + k, n)
    Derivatives with respect to yb. An element (i, j) corresponds to
    d bc_i / d ya_j.
dbc_dp : ndarray with shape (n + k, k) or None
    Derivatives with respect to p. An element (i, j) corresponds to
    d bc_i / d p_j. If `p` is empty, None is returned.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../dc/d3b/__bvp_8py_source.html#l00058">58</a> of file <a class="el" href="../../dc/d3b/__bvp_8py_source.html">_bvp.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dc/d3b/__bvp_8py_source.html#l00317">prepare_sys()</a>.</p>

</div>
</div>
<a id="a7e1d215a615a92553cf69d99c957daf1" name="a7e1d215a615a92553cf69d99c957daf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e1d215a615a92553cf69d99c957daf1">&#9670;&#160;</a></span>estimate_fun_jac()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.integrate._bvp.estimate_fun_jac </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>fun</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>f0</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Estimate derivatives of an ODE system rhs with forward differences.

Returns
-------
df_dy : ndarray, shape (n, n, m)
    Derivatives with respect to y. An element (i, j, q) corresponds to
    d f_i(x_q, y_q) / d (y_q)_j.
df_dp : ndarray with shape (n, k, m) or None
    Derivatives with respect to p. An element (i, j, q) corresponds to
    d f_i(x_q, y_q, p) / d p_j. If `p` is empty, None is returned.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../dc/d3b/__bvp_8py_source.html#l00015">15</a> of file <a class="el" href="../../dc/d3b/__bvp_8py_source.html">_bvp.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dc/d3b/__bvp_8py_source.html#l00317">prepare_sys()</a>.</p>

</div>
</div>
<a id="af426b824c4dbc0de39b9942652a8904e" name="af426b824c4dbc0de39b9942652a8904e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af426b824c4dbc0de39b9942652a8904e">&#9670;&#160;</a></span>estimate_rms_residuals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.integrate._bvp.estimate_rms_residuals </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>fun</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>sol</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>h</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>r_middle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>f_middle</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Estimate rms values of collocation residuals using Lobatto quadrature.

The residuals are defined as the difference between the derivatives of
our solution and rhs of the ODE system. We use relative residuals, i.e.,
normalized by 1 + np.abs(f). RMS values are computed as sqrt from the
normalized integrals of the squared relative residuals over each interval.
Integrals are estimated using 5-point Lobatto quadrature [1]_, we use the
fact that residuals at the mesh nodes are identically zero.

In [2] they don't normalize integrals by interval lengths, which gives
a higher rate of convergence of the residuals by the factor of h**0.5.
I chose to do such normalization for an ease of interpretation of return
values as RMS estimates.

Returns
-------
rms_res : ndarray, shape (m - 1,)
    Estimated rms values of the relative residuals over each interval.

References
----------
.. [1] http://mathworld.wolfram.com/LobattoQuadrature.html
.. [2] J. Kierzenka, L. F. Shampine, "A BVP Solver Based on Residual
   Control and the Maltab PSE", ACM Trans. Math. Softw., Vol. 27,
   Number 3, pp. 299-316, 2001.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../dc/d3b/__bvp_8py_source.html#l00526">526</a> of file <a class="el" href="../../dc/d3b/__bvp_8py_source.html">_bvp.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dc/d3b/__bvp_8py_source.html#l00711">solve_bvp()</a>.</p>

</div>
</div>
<a id="a9b2734b62ef488e502e42e0aa66a9946" name="a9b2734b62ef488e502e42e0aa66a9946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b2734b62ef488e502e42e0aa66a9946">&#9670;&#160;</a></span>modify_mesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.integrate._bvp.modify_mesh </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>insert_1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>insert_2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Insert nodes into a mesh.

Nodes removal logic is not established, its impact on the solver is
presumably negligible. So, only insertion is done in this function.

Parameters
----------
x : ndarray, shape (m,)
    Mesh nodes.
insert_1 : ndarray
    Intervals to each insert 1 new node in the middle.
insert_2 : ndarray
    Intervals to each insert 2 new nodes, such that divide an interval
    into 3 equal parts.

Returns
-------
x_new : ndarray
    New mesh nodes.

Notes
-----
`insert_1` and `insert_2` should not have common values.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../dc/d3b/__bvp_8py_source.html#l00602">602</a> of file <a class="el" href="../../dc/d3b/__bvp_8py_source.html">_bvp.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dc/d3b/__bvp_8py_source.html#l00711">solve_bvp()</a>.</p>

</div>
</div>
<a id="a3e5192bec9ee862fea0740740b0b180a" name="a3e5192bec9ee862fea0740740b0b180a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e5192bec9ee862fea0740740b0b180a">&#9670;&#160;</a></span>prepare_sys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.integrate._bvp.prepare_sys </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>fun</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>bc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>fun_jac</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>bc_jac</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>h</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create the function and the Jacobian for the collocation system.</pre> 
<p class="definition">Definition at line <a class="el" href="../../dc/d3b/__bvp_8py_source.html#l00317">317</a> of file <a class="el" href="../../dc/d3b/__bvp_8py_source.html">_bvp.py</a>.</p>

<p class="reference">References <a class="el" href="../../dc/d3b/__bvp_8py_source.html#l00276">collocation_fun()</a>, <a class="el" href="../../dc/d3b/__bvp_8py_source.html#l00117">compute_jac_indices()</a>, <a class="el" href="../../dc/d3b/__bvp_8py_source.html#l00159">construct_global_jac()</a>, <a class="el" href="../../dc/d3b/__bvp_8py_source.html#l00058">estimate_bc_jac()</a>, and <a class="el" href="../../dc/d3b/__bvp_8py_source.html#l00015">estimate_fun_jac()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dc/d3b/__bvp_8py_source.html#l00711">solve_bvp()</a>.</p>

</div>
</div>
<a id="a91b30c7b4693fb5d60b6005793ae834a" name="a91b30c7b4693fb5d60b6005793ae834a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91b30c7b4693fb5d60b6005793ae834a">&#9670;&#160;</a></span>print_iteration_header()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.integrate._bvp.print_iteration_header </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../dc/d3b/__bvp_8py_source.html#l00502">502</a> of file <a class="el" href="../../dc/d3b/__bvp_8py_source.html">_bvp.py</a>.</p>

</div>
</div>
<a id="a56031b469e5609df5d8dd39bd8f5509c" name="a56031b469e5609df5d8dd39bd8f5509c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56031b469e5609df5d8dd39bd8f5509c">&#9670;&#160;</a></span>print_iteration_progress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.integrate._bvp.print_iteration_progress </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>iteration</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>residual</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>bc_residual</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>total_nodes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>nodes_added</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../dc/d3b/__bvp_8py_source.html#l00508">508</a> of file <a class="el" href="../../dc/d3b/__bvp_8py_source.html">_bvp.py</a>.</p>

</div>
</div>
<a id="ac7d9e00cd7b244fb96fd92ff8510b1a6" name="ac7d9e00cd7b244fb96fd92ff8510b1a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7d9e00cd7b244fb96fd92ff8510b1a6">&#9670;&#160;</a></span>solve_bvp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.integrate._bvp.solve_bvp </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>fun</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>bc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>p</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>S</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>fun_jac</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>bc_jac</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>tol</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1e-3</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>max_nodes</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1000</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>verbose</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>bc_tol</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solve a boundary value problem for a system of ODEs.

This function numerically solves a first order system of ODEs subject to
two-point boundary conditions::

    dy / dx = f(x, y, p) + S * y / (x - a), a &lt;= x &lt;= b
    bc(y(a), y(b), p) = 0

Here x is a 1-D independent variable, y(x) is an N-D
vector-valued function and p is a k-D vector of unknown
parameters which is to be found along with y(x). For the problem to be
determined, there must be n + k boundary conditions, i.e., bc must be an
(n + k)-D function.

The last singular term on the right-hand side of the system is optional.
It is defined by an n-by-n matrix S, such that the solution must satisfy
S y(a) = 0. This condition will be forced during iterations, so it must not
contradict boundary conditions. See [2]_ for the explanation how this term
is handled when solving BVPs numerically.

Problems in a complex domain can be solved as well. In this case, y and p
are considered to be complex, and f and bc are assumed to be complex-valued
functions, but x stays real. Note that f and bc must be complex
differentiable (satisfy Cauchy-Riemann equations [4]_), otherwise you
should rewrite your problem for real and imaginary parts separately. To
solve a problem in a complex domain, pass an initial guess for y with a
complex data type (see below).

Parameters
----------
fun : callable
    Right-hand side of the system. The calling signature is ``fun(x, y)``,
    or ``fun(x, y, p)`` if parameters are present. All arguments are
    ndarray: ``x`` with shape (m,), ``y`` with shape (n, m), meaning that
    ``y[:, i]`` corresponds to ``x[i]``, and ``p`` with shape (k,). The
    return value must be an array with shape (n, m) and with the same
    layout as ``y``.
bc : callable
    Function evaluating residuals of the boundary conditions. The calling
    signature is ``bc(ya, yb)``, or ``bc(ya, yb, p)`` if parameters are
    present. All arguments are ndarray: ``ya`` and ``yb`` with shape (n,),
    and ``p`` with shape (k,). The return value must be an array with
    shape (n + k,).
x : array_like, shape (m,)
    Initial mesh. Must be a strictly increasing sequence of real numbers
    with ``x[0]=a`` and ``x[-1]=b``.
y : array_like, shape (n, m)
    Initial guess for the function values at the mesh nodes, ith column
    corresponds to ``x[i]``. For problems in a complex domain pass `y`
    with a complex data type (even if the initial guess is purely real).
p : array_like with shape (k,) or None, optional
    Initial guess for the unknown parameters. If None (default), it is
    assumed that the problem doesn't depend on any parameters.
S : array_like with shape (n, n) or None
    Matrix defining the singular term. If None (default), the problem is
    solved without the singular term.
fun_jac : callable or None, optional
    Function computing derivatives of f with respect to y and p. The
    calling signature is ``fun_jac(x, y)``, or ``fun_jac(x, y, p)`` if
    parameters are present. The return must contain 1 or 2 elements in the
    following order:

        * df_dy : array_like with shape (n, n, m), where an element
          (i, j, q) equals to d f_i(x_q, y_q, p) / d (y_q)_j.
        * df_dp : array_like with shape (n, k, m), where an element
          (i, j, q) equals to d f_i(x_q, y_q, p) / d p_j.

    Here q numbers nodes at which x and y are defined, whereas i and j
    number vector components. If the problem is solved without unknown
    parameters, df_dp should not be returned.

    If `fun_jac` is None (default), the derivatives will be estimated
    by the forward finite differences.
bc_jac : callable or None, optional
    Function computing derivatives of bc with respect to ya, yb, and p.
    The calling signature is ``bc_jac(ya, yb)``, or ``bc_jac(ya, yb, p)``
    if parameters are present. The return must contain 2 or 3 elements in
    the following order:

        * dbc_dya : array_like with shape (n, n), where an element (i, j)
          equals to d bc_i(ya, yb, p) / d ya_j.
        * dbc_dyb : array_like with shape (n, n), where an element (i, j)
          equals to d bc_i(ya, yb, p) / d yb_j.
        * dbc_dp : array_like with shape (n, k), where an element (i, j)
          equals to d bc_i(ya, yb, p) / d p_j.

    If the problem is solved without unknown parameters, dbc_dp should not
    be returned.

    If `bc_jac` is None (default), the derivatives will be estimated by
    the forward finite differences.
tol : float, optional
    Desired tolerance of the solution. If we define ``r = y' - f(x, y)``,
    where y is the found solution, then the solver tries to achieve on each
    mesh interval ``norm(r / (1 + abs(f)) &lt; tol``, where ``norm`` is
    estimated in a root mean squared sense (using a numerical quadrature
    formula). Default is 1e-3.
max_nodes : int, optional
    Maximum allowed number of the mesh nodes. If exceeded, the algorithm
    terminates. Default is 1000.
verbose : {0, 1, 2}, optional
    Level of algorithm's verbosity:

        * 0 (default) : work silently.
        * 1 : display a termination report.
        * 2 : display progress during iterations.
bc_tol : float, optional
    Desired absolute tolerance for the boundary condition residuals: `bc`
    value should satisfy ``abs(bc) &lt; bc_tol`` component-wise.
    Equals to `tol` by default. Up to 10 iterations are allowed to achieve this
    tolerance.

Returns
-------
Bunch object with the following fields defined:
sol : PPoly
    Found solution for y as `scipy.interpolate.PPoly` instance, a C1
    continuous cubic spline.
p : ndarray or None, shape (k,)
    Found parameters. None, if the parameters were not present in the
    problem.
x : ndarray, shape (m,)
    Nodes of the final mesh.
y : ndarray, shape (n, m)
    Solution values at the mesh nodes.
yp : ndarray, shape (n, m)
    Solution derivatives at the mesh nodes.
rms_residuals : ndarray, shape (m - 1,)
    RMS values of the relative residuals over each mesh interval (see the
    description of `tol` parameter).
niter : int
    Number of completed iterations.
status : int
    Reason for algorithm termination:

        * 0: The algorithm converged to the desired accuracy.
        * 1: The maximum number of mesh nodes is exceeded.
        * 2: A singular Jacobian encountered when solving the collocation
          system.

message : string
    Verbal description of the termination reason.
success : bool
    True if the algorithm converged to the desired accuracy (``status=0``).

Notes
-----
This function implements a 4th order collocation algorithm with the
control of residuals similar to [1]_. A collocation system is solved
by a damped Newton method with an affine-invariant criterion function as
described in [3]_.

Note that in [1]_  integral residuals are defined without normalization
by interval lengths. So, their definition is different by a multiplier of
h**0.5 (h is an interval length) from the definition used here.

.. versionadded:: 0.18.0

References
----------
.. [1] J. Kierzenka, L. F. Shampine, "A BVP Solver Based on Residual
       Control and the Maltab PSE", ACM Trans. Math. Softw., Vol. 27,
       Number 3, pp. 299-316, 2001.
.. [2] L.F. Shampine, P. H. Muir and H. Xu, "A User-Friendly Fortran BVP
       Solver".
.. [3] U. Ascher, R. Mattheij and R. Russell "Numerical Solution of
       Boundary Value Problems for Ordinary Differential Equations".
.. [4] `Cauchy-Riemann equations
        &lt;https://en.wikipedia.org/wiki/Cauchy-Riemann_equations&gt;`_ on
        Wikipedia.

Examples
--------
In the first example, we solve Bratu's problem::

    y'' + k * exp(y) = 0
    y(0) = y(1) = 0

for k = 1.

We rewrite the equation as a first-order system and implement its
right-hand side evaluation::

    y1' = y2
    y2' = -exp(y1)

&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; def fun(x, y):
...     return np.vstack((y[1], -np.exp(y[0])))

Implement evaluation of the boundary condition residuals:

&gt;&gt;&gt; def bc(ya, yb):
...     return np.array([ya[0], yb[0]])

Define the initial mesh with 5 nodes:

&gt;&gt;&gt; x = np.linspace(0, 1, 5)

This problem is known to have two solutions. To obtain both of them, we
use two different initial guesses for y. We denote them by subscripts
a and b.

&gt;&gt;&gt; y_a = np.zeros((2, x.size))
&gt;&gt;&gt; y_b = np.zeros((2, x.size))
&gt;&gt;&gt; y_b[0] = 3

Now we are ready to run the solver.

&gt;&gt;&gt; from scipy.integrate import solve_bvp
&gt;&gt;&gt; res_a = solve_bvp(fun, bc, x, y_a)
&gt;&gt;&gt; res_b = solve_bvp(fun, bc, x, y_b)

Let's plot the two found solutions. We take an advantage of having the
solution in a spline form to produce a smooth plot.

&gt;&gt;&gt; x_plot = np.linspace(0, 1, 100)
&gt;&gt;&gt; y_plot_a = res_a.sol(x_plot)[0]
&gt;&gt;&gt; y_plot_b = res_b.sol(x_plot)[0]
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; plt.plot(x_plot, y_plot_a, label='y_a')
&gt;&gt;&gt; plt.plot(x_plot, y_plot_b, label='y_b')
&gt;&gt;&gt; plt.legend()
&gt;&gt;&gt; plt.xlabel("x")
&gt;&gt;&gt; plt.ylabel("y")
&gt;&gt;&gt; plt.show()

We see that the two solutions have similar shape, but differ in scale
significantly.

In the second example, we solve a simple Sturm-Liouville problem::

    y'' + k**2 * y = 0
    y(0) = y(1) = 0

It is known that a non-trivial solution y = A * sin(k * x) is possible for
k = pi * n, where n is an integer. To establish the normalization constant
A = 1 we add a boundary condition::

    y'(0) = k

Again, we rewrite our equation as a first-order system and implement its
right-hand side evaluation::

    y1' = y2
    y2' = -k**2 * y1

&gt;&gt;&gt; def fun(x, y, p):
...     k = p[0]
...     return np.vstack((y[1], -k**2 * y[0]))

Note that parameters p are passed as a vector (with one element in our
case).

Implement the boundary conditions:

&gt;&gt;&gt; def bc(ya, yb, p):
...     k = p[0]
...     return np.array([ya[0], yb[0], ya[1] - k])

Set up the initial mesh and guess for y. We aim to find the solution for
k = 2 * pi, to achieve that we set values of y to approximately follow
sin(2 * pi * x):

&gt;&gt;&gt; x = np.linspace(0, 1, 5)
&gt;&gt;&gt; y = np.zeros((2, x.size))
&gt;&gt;&gt; y[0, 1] = 1
&gt;&gt;&gt; y[0, 3] = -1

Run the solver with 6 as an initial guess for k.

&gt;&gt;&gt; sol = solve_bvp(fun, bc, x, y, p=[6])

We see that the found k is approximately correct:

&gt;&gt;&gt; sol.p[0]
6.28329460046

And, finally, plot the solution to see the anticipated sinusoid:

&gt;&gt;&gt; x_plot = np.linspace(0, 1, 100)
&gt;&gt;&gt; y_plot = sol.sol(x_plot)[0]
&gt;&gt;&gt; plt.plot(x_plot, y_plot)
&gt;&gt;&gt; plt.xlabel("x")
&gt;&gt;&gt; plt.ylabel("y")
&gt;&gt;&gt; plt.show()
</pre> 
<p class="definition">Definition at line <a class="el" href="../../dc/d3b/__bvp_8py_source.html#l00710">710</a> of file <a class="el" href="../../dc/d3b/__bvp_8py_source.html">_bvp.py</a>.</p>

<p class="reference">References <a class="el" href="../../dc/d3b/__bvp_8py_source.html#l00276">collocation_fun()</a>, <a class="el" href="../../dc/d3b/__bvp_8py_source.html#l00577">create_spline()</a>, <a class="el" href="../../dc/d3b/__bvp_8py_source.html#l00526">estimate_rms_residuals()</a>, <a class="el" href="../../dc/d3b/__bvp_8py_source.html#l00602">modify_mesh()</a>, <a class="el" href="../../dc/d3b/__bvp_8py_source.html#l00317">prepare_sys()</a>, <a class="el" href="../../dc/d3b/__bvp_8py_source.html#l00347">solve_newton()</a>, and <a class="el" href="../../dc/d3b/__bvp_8py_source.html#l00637">wrap_functions()</a>.</p>

</div>
</div>
<a id="a9b44b4b962bed36f279bfe9307fe6eb3" name="a9b44b4b962bed36f279bfe9307fe6eb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b44b4b962bed36f279bfe9307fe6eb3">&#9670;&#160;</a></span>solve_newton()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.integrate._bvp.solve_newton </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>h</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>col_fun</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>bc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>jac</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>bvp_tol</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>bc_tol</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Solve the nonlinear collocation system by a Newton method.

This is a simple Newton method with a backtracking line search. As
advised in [1]_, an affine-invariant criterion function F = ||J^-1 r||^2
is used, where J is the Jacobian matrix at the current iteration and r is
the vector or collocation residuals (values of the system lhs).

The method alters between full Newton iterations and the fixed-Jacobian
iterations based

There are other tricks proposed in [1]_, but they are not used as they
don't seem to improve anything significantly, and even break the
convergence on some test problems I tried.

All important parameters of the algorithm are defined inside the function.

Parameters
----------
n : int
    Number of equations in the ODE system.
m : int
    Number of nodes in the mesh.
h : ndarray, shape (m-1,)
    Mesh intervals.
col_fun : callable
    Function computing collocation residuals.
bc : callable
    Function computing boundary condition residuals.
jac : callable
    Function computing the Jacobian of the whole system (including
    collocation and boundary condition residuals). It is supposed to
    return csc_matrix.
y : ndarray, shape (n, m)
    Initial guess for the function values at the mesh nodes.
p : ndarray, shape (k,)
    Initial guess for the unknown parameters.
B : ndarray with shape (n, n) or None
    Matrix to force the S y(a) = 0 condition for a problems with the
    singular term. If None, the singular term is assumed to be absent.
bvp_tol : float
    Tolerance to which we want to solve a BVP.
bc_tol : float
    Tolerance to which we want to satisfy the boundary conditions.

Returns
-------
y : ndarray, shape (n, m)
    Final iterate for the function values at the mesh nodes.
p : ndarray, shape (k,)
    Final iterate for the unknown parameters.
singular : bool
    True, if the LU decomposition failed because Jacobian turned out
    to be singular.

References
----------
.. [1]  U. Ascher, R. Mattheij and R. Russell "Numerical Solution of
   Boundary Value Problems for Ordinary Differential Equations"
</pre> 
<p class="definition">Definition at line <a class="el" href="../../dc/d3b/__bvp_8py_source.html#l00347">347</a> of file <a class="el" href="../../dc/d3b/__bvp_8py_source.html">_bvp.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dc/d3b/__bvp_8py_source.html#l00711">solve_bvp()</a>.</p>

</div>
</div>
<a id="a1d2ee109a1b89b59380bc4d9aa0b57ba" name="a1d2ee109a1b89b59380bc4d9aa0b57ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d2ee109a1b89b59380bc4d9aa0b57ba">&#9670;&#160;</a></span>stacked_matmul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.integrate._bvp.stacked_matmul </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Stacked matrix multiply: out[i,:,:] = np.dot(a[i,:,:], b[i,:,:]).

Empirical optimization. Use outer Python loop and BLAS for large
matrices, otherwise use a single einsum call.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../dc/d3b/__bvp_8py_source.html#l00143">143</a> of file <a class="el" href="../../dc/d3b/__bvp_8py_source.html">_bvp.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dc/d3b/__bvp_8py_source.html#l00159">construct_global_jac()</a>.</p>

</div>
</div>
<a id="ab326bbe47e4328938c2cf9b65c6d5dc3" name="ab326bbe47e4328938c2cf9b65c6d5dc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab326bbe47e4328938c2cf9b65c6d5dc3">&#9670;&#160;</a></span>wrap_functions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.integrate._bvp.wrap_functions </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>fun</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>bc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>fun_jac</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>bc_jac</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>S</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>D</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>dtype</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Wrap functions for unified usage in the solver.</pre> 
<p class="definition">Definition at line <a class="el" href="../../dc/d3b/__bvp_8py_source.html#l00637">637</a> of file <a class="el" href="../../dc/d3b/__bvp_8py_source.html">_bvp.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dc/d3b/__bvp_8py_source.html#l00711">solve_bvp()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ad99dbe0f4c37ff34045848221ac5174e" name="ad99dbe0f4c37ff34045848221ac5174e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad99dbe0f4c37ff34045848221ac5174e">&#9670;&#160;</a></span>EPS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.integrate._bvp.EPS = np.finfo(float).eps</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../dc/d3b/__bvp_8py_source.html#l00012">12</a> of file <a class="el" href="../../dc/d3b/__bvp_8py_source.html">_bvp.py</a>.</p>

</div>
</div>
<a id="a9e0abd96fce877bfa6f1ba4fc0774515" name="a9e0abd96fce877bfa6f1ba4fc0774515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e0abd96fce877bfa6f1ba4fc0774515">&#9670;&#160;</a></span>TERMINATION_MESSAGES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dict scipy.integrate._bvp.TERMINATION_MESSAGES</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  {</div>
<div class="line"><span class="lineno">    2</span>    0: <span class="stringliteral">&quot;The algorithm converged to the desired accuracy.&quot;</span>,</div>
<div class="line"><span class="lineno">    3</span>    1: <span class="stringliteral">&quot;The maximum number of mesh nodes is exceeded.&quot;</span>,</div>
<div class="line"><span class="lineno">    4</span>    2: <span class="stringliteral">&quot;A singular Jacobian encountered when solving the collocation system.&quot;</span>,</div>
<div class="line"><span class="lineno">    5</span>    3: <span class="stringliteral">&quot;The solver was unable to satisfy boundary conditions tolerance on iteration 10.&quot;</span></div>
<div class="line"><span class="lineno">    6</span>}</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="../../dc/d3b/__bvp_8py_source.html#l00518">518</a> of file <a class="el" href="../../dc/d3b/__bvp_8py_source.html">_bvp.py</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../db/d0f/namespacescipy.html">scipy</a></li><li class="navelem"><a class="el" href="../../d1/da1/namespacescipy_1_1integrate.html">integrate</a></li><li class="navelem"><a class="el" href="../../d7/de8/namespacescipy_1_1integrate_1_1__bvp.html">_bvp</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
