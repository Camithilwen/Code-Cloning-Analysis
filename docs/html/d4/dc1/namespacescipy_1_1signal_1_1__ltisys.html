<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Code Cloning Analysis: scipy.signal._ltisys Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Code Cloning Analysis
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d4/dc1/namespacescipy_1_1signal_1_1__ltisys.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">scipy.signal._ltisys Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d94/classscipy_1_1signal_1_1__ltisys_1_1Bunch.html">Bunch</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dd6/classscipy_1_1signal_1_1__ltisys_1_1dlti.html">dlti</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d32/classscipy_1_1signal_1_1__ltisys_1_1LinearTimeInvariant.html">LinearTimeInvariant</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d6e/classscipy_1_1signal_1_1__ltisys_1_1lti.html">lti</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d40/classscipy_1_1signal_1_1__ltisys_1_1StateSpace.html">StateSpace</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d69/classscipy_1_1signal_1_1__ltisys_1_1StateSpaceContinuous.html">StateSpaceContinuous</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/db3/classscipy_1_1signal_1_1__ltisys_1_1StateSpaceDiscrete.html">StateSpaceDiscrete</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d13/classscipy_1_1signal_1_1__ltisys_1_1TransferFunction.html">TransferFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d20/classscipy_1_1signal_1_1__ltisys_1_1TransferFunctionContinuous.html">TransferFunctionContinuous</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dbc/classscipy_1_1signal_1_1__ltisys_1_1TransferFunctionDiscrete.html">TransferFunctionDiscrete</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/daf/classscipy_1_1signal_1_1__ltisys_1_1ZerosPolesGain.html">ZerosPolesGain</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dfd/classscipy_1_1signal_1_1__ltisys_1_1ZerosPolesGainContinuous.html">ZerosPolesGainContinuous</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d8a/classscipy_1_1signal_1_1__ltisys_1_1ZerosPolesGainDiscrete.html">ZerosPolesGainDiscrete</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a73239b2f2cfaa982c8db857756f6c6e8" id="r_a73239b2f2cfaa982c8db857756f6c6e8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a73239b2f2cfaa982c8db857756f6c6e8">_atleast_2d_or_none</a> (arg)</td></tr>
<tr class="separator:a73239b2f2cfaa982c8db857756f6c6e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43193c10de2bb05be9d1c60fbcf2f764" id="r_a43193c10de2bb05be9d1c60fbcf2f764"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43193c10de2bb05be9d1c60fbcf2f764">lsim2</a> (system, U=None, T=None, X0=None, **kwargs)</td></tr>
<tr class="separator:a43193c10de2bb05be9d1c60fbcf2f764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5c6bfaa9b8432b53aab337c9687edf" id="r_ade5c6bfaa9b8432b53aab337c9687edf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade5c6bfaa9b8432b53aab337c9687edf">_cast_to_array_dtype</a> (in1, in2)</td></tr>
<tr class="separator:ade5c6bfaa9b8432b53aab337c9687edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad81706d4397767b146b651c5cebc2fd2" id="r_ad81706d4397767b146b651c5cebc2fd2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad81706d4397767b146b651c5cebc2fd2">lsim</a> (system, U, T, X0=None, interp=<a class="el" href="../../d8/d0b/classTrue.html">True</a>)</td></tr>
<tr class="separator:ad81706d4397767b146b651c5cebc2fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4a16b8d04be9ec49f5fbe645706801" id="r_a4e4a16b8d04be9ec49f5fbe645706801"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e4a16b8d04be9ec49f5fbe645706801">_default_response_times</a> (A, n)</td></tr>
<tr class="separator:a4e4a16b8d04be9ec49f5fbe645706801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e8d379f94d78becbd5dd16b97734ec" id="r_a09e8d379f94d78becbd5dd16b97734ec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09e8d379f94d78becbd5dd16b97734ec">impulse</a> (system, X0=None, T=None, N=None)</td></tr>
<tr class="separator:a09e8d379f94d78becbd5dd16b97734ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae26f9ff8dfac66c8fb42c282fb27d9da" id="r_ae26f9ff8dfac66c8fb42c282fb27d9da"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae26f9ff8dfac66c8fb42c282fb27d9da">impulse2</a> (system, X0=None, T=None, N=None, **kwargs)</td></tr>
<tr class="separator:ae26f9ff8dfac66c8fb42c282fb27d9da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a531d2c4ab049182357f13971cf8e58e5" id="r_a531d2c4ab049182357f13971cf8e58e5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a531d2c4ab049182357f13971cf8e58e5">step</a> (system, X0=None, T=None, N=None)</td></tr>
<tr class="separator:a531d2c4ab049182357f13971cf8e58e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d583450772b85b02f687c6b097ebe7" id="r_a14d583450772b85b02f687c6b097ebe7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14d583450772b85b02f687c6b097ebe7">step2</a> (system, X0=None, T=None, N=None, **kwargs)</td></tr>
<tr class="separator:a14d583450772b85b02f687c6b097ebe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeafb6cd1c8d5ee1b0b0c411ff0e0c5a4" id="r_aeafb6cd1c8d5ee1b0b0c411ff0e0c5a4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeafb6cd1c8d5ee1b0b0c411ff0e0c5a4">bode</a> (system, w=None, n=100)</td></tr>
<tr class="separator:aeafb6cd1c8d5ee1b0b0c411ff0e0c5a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5224b7e7920b072f5a40d9776f9687f5" id="r_a5224b7e7920b072f5a40d9776f9687f5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5224b7e7920b072f5a40d9776f9687f5">freqresp</a> (system, w=None, n=10000)</td></tr>
<tr class="separator:a5224b7e7920b072f5a40d9776f9687f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af808660cbb91d4fbdda9047943da7eb8" id="r_af808660cbb91d4fbdda9047943da7eb8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af808660cbb91d4fbdda9047943da7eb8">_valid_inputs</a> (A, B, poles, method, rtol, maxiter)</td></tr>
<tr class="separator:af808660cbb91d4fbdda9047943da7eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c186b25c05f27e99b1a79ee1e4221c" id="r_af2c186b25c05f27e99b1a79ee1e4221c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2c186b25c05f27e99b1a79ee1e4221c">_order_complex_poles</a> (poles)</td></tr>
<tr class="separator:af2c186b25c05f27e99b1a79ee1e4221c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe429b12ac7b4287bb921166424a371" id="r_a8fe429b12ac7b4287bb921166424a371"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8fe429b12ac7b4287bb921166424a371">_KNV0</a> (B, ker_pole, transfer_matrix, j, poles)</td></tr>
<tr class="separator:a8fe429b12ac7b4287bb921166424a371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4288e056f809dfaa360e79ec95fe64" id="r_a1f4288e056f809dfaa360e79ec95fe64"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f4288e056f809dfaa360e79ec95fe64">_YT_real</a> (ker_pole, Q, transfer_matrix, i, j)</td></tr>
<tr class="separator:a1f4288e056f809dfaa360e79ec95fe64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e40ad626e73edc303306365d185c6c" id="r_a35e40ad626e73edc303306365d185c6c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a35e40ad626e73edc303306365d185c6c">_YT_complex</a> (ker_pole, Q, transfer_matrix, i, j)</td></tr>
<tr class="separator:a35e40ad626e73edc303306365d185c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af62d2ed2235dc24c84e2605cc275157e" id="r_af62d2ed2235dc24c84e2605cc275157e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af62d2ed2235dc24c84e2605cc275157e">_YT_loop</a> (ker_pole, transfer_matrix, poles, B, maxiter, rtol)</td></tr>
<tr class="separator:af62d2ed2235dc24c84e2605cc275157e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9acb1db2b4f17e1560fd36bfd84e8a04" id="r_a9acb1db2b4f17e1560fd36bfd84e8a04"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9acb1db2b4f17e1560fd36bfd84e8a04">_KNV0_loop</a> (ker_pole, transfer_matrix, poles, B, maxiter, rtol)</td></tr>
<tr class="separator:a9acb1db2b4f17e1560fd36bfd84e8a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028e75567f2c624a3c1434b630817736" id="r_a028e75567f2c624a3c1434b630817736"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a028e75567f2c624a3c1434b630817736">place_poles</a> (A, B, poles, method=&quot;YT&quot;, rtol=1e-3, maxiter=30)</td></tr>
<tr class="separator:a028e75567f2c624a3c1434b630817736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aab993a41192c63bde62a840751cdd9" id="r_a5aab993a41192c63bde62a840751cdd9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5aab993a41192c63bde62a840751cdd9">dlsim</a> (system, u, t=None, x0=None)</td></tr>
<tr class="separator:a5aab993a41192c63bde62a840751cdd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7232a366e580be2067d3bc8340c639f2" id="r_a7232a366e580be2067d3bc8340c639f2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7232a366e580be2067d3bc8340c639f2">dimpulse</a> (system, x0=None, t=None, n=None)</td></tr>
<tr class="separator:a7232a366e580be2067d3bc8340c639f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1106cc5e8301c0883b141e59dbf53cf8" id="r_a1106cc5e8301c0883b141e59dbf53cf8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1106cc5e8301c0883b141e59dbf53cf8">dstep</a> (system, x0=None, t=None, n=None)</td></tr>
<tr class="separator:a1106cc5e8301c0883b141e59dbf53cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc2d5055e90d297dbde688307acaa5b" id="r_aafc2d5055e90d297dbde688307acaa5b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aafc2d5055e90d297dbde688307acaa5b">dfreqresp</a> (system, w=None, n=10000, whole=False)</td></tr>
<tr class="separator:aafc2d5055e90d297dbde688307acaa5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a008bf6e9a51183d42a73d86718cb879c" id="r_a008bf6e9a51183d42a73d86718cb879c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a008bf6e9a51183d42a73d86718cb879c">dbode</a> (system, w=None, n=100)</td></tr>
<tr class="separator:a008bf6e9a51183d42a73d86718cb879c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a1db78c7dddd07b5f30441a32780d5ced" id="r_a1db78c7dddd07b5f30441a32780d5ced"><td class="memItemLeft" align="right" valign="top">list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1db78c7dddd07b5f30441a32780d5ced">__all__</a></td></tr>
<tr class="separator:a1db78c7dddd07b5f30441a32780d5ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">ltisys -- a collection of classes and functions for modeling linear
time invariant systems.
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a73239b2f2cfaa982c8db857756f6c6e8" name="a73239b2f2cfaa982c8db857756f6c6e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73239b2f2cfaa982c8db857756f6c6e8">&#9670;&#160;</a></span>_atleast_2d_or_none()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._ltisys._atleast_2d_or_none </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l01223">1223</a> of file <a class="el" href="../../dc/dd0/__ltisys_8py_source.html">_ltisys.py</a>.</p>

</div>
</div>
<a id="ade5c6bfaa9b8432b53aab337c9687edf" name="ade5c6bfaa9b8432b53aab337c9687edf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade5c6bfaa9b8432b53aab337c9687edf">&#9670;&#160;</a></span>_cast_to_array_dtype()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._ltisys._cast_to_array_dtype </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>in1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>in2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Cast array to dtype of other array, while avoiding ComplexWarning.

Those can be raised when casting complex to real.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l01959">1959</a> of file <a class="el" href="../../dc/dd0/__ltisys_8py_source.html">_ltisys.py</a>.</p>

</div>
</div>
<a id="a4e4a16b8d04be9ec49f5fbe645706801" name="a4e4a16b8d04be9ec49f5fbe645706801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e4a16b8d04be9ec49f5fbe645706801">&#9670;&#160;</a></span>_default_response_times()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._ltisys._default_response_times </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Compute a reasonable set of time samples for the response time.

This function is used by `impulse`, `impulse2`, `step` and `step2`
to compute the response time when the `T` argument to the function
is None.

Parameters
----------
A : array_like
    The system matrix, which is square.
n : int
    The number of time samples to generate.

Returns
-------
t : ndarray
    The 1-D array of length `n` of time samples at which the response
    is to be computed.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l02188">2188</a> of file <a class="el" href="../../dc/dd0/__ltisys_8py_source.html">_ltisys.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l02220">impulse()</a>, <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l02290">impulse2()</a>, <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l02400">step()</a>, and <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l02467">step2()</a>.</p>

</div>
</div>
<a id="a8fe429b12ac7b4287bb921166424a371" name="a8fe429b12ac7b4287bb921166424a371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fe429b12ac7b4287bb921166424a371">&#9670;&#160;</a></span>_KNV0()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._ltisys._KNV0 </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>ker_pole</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>transfer_matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>j</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>poles</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Algorithm "KNV0" Kautsky et Al. Robust pole
assignment in linear state feedback, Int journal of Control
1985, vol 41 p 1129-&gt;1155
https://la.epfl.ch/files/content/sites/la/files/
    users/105941/public/KautskyNicholsDooren
</pre> 
<p class="definition">Definition at line <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l02795">2795</a> of file <a class="el" href="../../dc/dd0/__ltisys_8py_source.html">_ltisys.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l03081">_KNV0_loop()</a>, and <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l02958">_YT_loop()</a>.</p>

</div>
</div>
<a id="a9acb1db2b4f17e1560fd36bfd84e8a04" name="a9acb1db2b4f17e1560fd36bfd84e8a04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9acb1db2b4f17e1560fd36bfd84e8a04">&#9670;&#160;</a></span>_KNV0_loop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._ltisys._KNV0_loop </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>ker_pole</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>transfer_matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>poles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>maxiter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>rtol</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Loop over all poles one by one and apply KNV method 0 algorithm
</pre> 
<p class="definition">Definition at line <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l03081">3081</a> of file <a class="el" href="../../dc/dd0/__ltisys_8py_source.html">_ltisys.py</a>.</p>

<p class="reference">References <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l02795">_KNV0()</a>.</p>

</div>
</div>
<a id="af2c186b25c05f27e99b1a79ee1e4221c" name="af2c186b25c05f27e99b1a79ee1e4221c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2c186b25c05f27e99b1a79ee1e4221c">&#9670;&#160;</a></span>_order_complex_poles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._ltisys._order_complex_poles </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>poles</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Check we have complex conjugates pairs and reorder P according to YT, ie
real_poles, complex_i, conjugate complex_i, ....
The lexicographic sort on the complex poles is added to help the user to
compare sets of poles.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l02775">2775</a> of file <a class="el" href="../../dc/dd0/__ltisys_8py_source.html">_ltisys.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l02724">_valid_inputs()</a>, and <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l03107">place_poles()</a>.</p>

</div>
</div>
<a id="af808660cbb91d4fbdda9047943da7eb8" name="af808660cbb91d4fbdda9047943da7eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af808660cbb91d4fbdda9047943da7eb8">&#9670;&#160;</a></span>_valid_inputs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._ltisys._valid_inputs </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>poles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>method</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>rtol</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>maxiter</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Check the poles come in complex conjugage pairs
Check shapes of A, B and poles are compatible.
Check the method chosen is compatible with provided poles
Return update method to use and ordered poles
</pre> 
<p class="definition">Definition at line <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l02724">2724</a> of file <a class="el" href="../../dc/dd0/__ltisys_8py_source.html">_ltisys.py</a>.</p>

<p class="reference">References <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l02775">_order_complex_poles()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l03107">place_poles()</a>.</p>

</div>
</div>
<a id="a35e40ad626e73edc303306365d185c6c" name="a35e40ad626e73edc303306365d185c6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35e40ad626e73edc303306365d185c6c">&#9670;&#160;</a></span>_YT_complex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._ltisys._YT_complex </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>ker_pole</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>Q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>transfer_matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>j</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Applies algorithm from YT section 6.2 page 20 related to complex pairs
</pre> 
<p class="definition">Definition at line <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l02907">2907</a> of file <a class="el" href="../../dc/dd0/__ltisys_8py_source.html">_ltisys.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l02958">_YT_loop()</a>.</p>

</div>
</div>
<a id="af62d2ed2235dc24c84e2605cc275157e" name="af62d2ed2235dc24c84e2605cc275157e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af62d2ed2235dc24c84e2605cc275157e">&#9670;&#160;</a></span>_YT_loop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._ltisys._YT_loop </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>ker_pole</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>transfer_matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>poles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>maxiter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>rtol</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Algorithm "YT" Tits, Yang. Globally Convergent
Algorithms for Robust Pole Assignment by State Feedback
https://hdl.handle.net/1903/5598
The poles P have to be sorted accordingly to section 6.2 page 20
</pre> 
<p class="definition">Definition at line <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l02958">2958</a> of file <a class="el" href="../../dc/dd0/__ltisys_8py_source.html">_ltisys.py</a>.</p>

<p class="reference">References <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l02795">_KNV0()</a>, <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l02907">_YT_complex()</a>, and <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l02842">_YT_real()</a>.</p>

</div>
</div>
<a id="a1f4288e056f809dfaa360e79ec95fe64" name="a1f4288e056f809dfaa360e79ec95fe64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f4288e056f809dfaa360e79ec95fe64">&#9670;&#160;</a></span>_YT_real()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._ltisys._YT_real </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>ker_pole</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>Q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>transfer_matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>j</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Applies algorithm from YT section 6.1 page 19 related to real pairs
</pre> 
<p class="definition">Definition at line <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l02842">2842</a> of file <a class="el" href="../../dc/dd0/__ltisys_8py_source.html">_ltisys.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l02958">_YT_loop()</a>.</p>

</div>
</div>
<a id="aeafb6cd1c8d5ee1b0b0c411ff0e0c5a4" name="aeafb6cd1c8d5ee1b0b0c411ff0e0c5a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeafb6cd1c8d5ee1b0b0c411ff0e0c5a4">&#9670;&#160;</a></span>bode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._ltisys.bode </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>system</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>w</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n</em></span><span class="paramdefsep"> = </span><span class="paramdefval">100</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate Bode magnitude and phase data of a continuous-time system.

Parameters
----------
system : an instance of the LTI class or a tuple describing the system.
    The following gives the number of elements in the tuple and
    the interpretation:

        * 1 (instance of `lti`)
        * 2 (num, den)
        * 3 (zeros, poles, gain)
        * 4 (A, B, C, D)

w : array_like, optional
    Array of frequencies (in rad/s). Magnitude and phase data is calculated
    for every value in this array. If not given a reasonable set will be
    calculated.
n : int, optional
    Number of frequency points to compute if `w` is not given. The `n`
    frequencies are logarithmically spaced in an interval chosen to
    include the influence of the poles and zeros of the system.

Returns
-------
w : 1D ndarray
    Frequency array [rad/s]
mag : 1D ndarray
    Magnitude array [dB]
phase : 1D ndarray
    Phase array [deg]

Notes
-----
If (num, den) is passed in for ``system``, coefficients for both the
numerator and denominator should be specified in descending exponent
order (e.g. ``s^2 + 3s + 5`` would be represented as ``[1, 3, 5]``).

.. versionadded:: 0.11.0

Examples
--------
&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; sys = signal.TransferFunction([1], [1, 1])
&gt;&gt;&gt; w, mag, phase = signal.bode(sys)

&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; plt.semilogx(w, mag)    # Bode magnitude plot
&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; plt.semilogx(w, phase)  # Bode phase plot
&gt;&gt;&gt; plt.show()
</pre> 
<p class="definition">Definition at line <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l02568">2568</a> of file <a class="el" href="../../dc/dd0/__ltisys_8py_source.html">_ltisys.py</a>.</p>

<p class="reference">References <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l02632">freqresp()</a>.</p>

</div>
</div>
<a id="a008bf6e9a51183d42a73d86718cb879c" name="a008bf6e9a51183d42a73d86718cb879c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a008bf6e9a51183d42a73d86718cb879c">&#9670;&#160;</a></span>dbode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._ltisys.dbode </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>system</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>w</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n</em></span><span class="paramdefsep"> = </span><span class="paramdefval">100</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate Bode magnitude and phase data of a discrete-time system.

Parameters
----------
system : an instance of the LTI class or a tuple describing the system.
The following gives the number of elements in the tuple and
the interpretation:

    * 1 (instance of `dlti`)
    * 2 (num, den, dt)
    * 3 (zeros, poles, gain, dt)
    * 4 (A, B, C, D, dt)

w : array_like, optional
Array of frequencies (in radians/sample). Magnitude and phase data is
calculated for every value in this array. If not given a reasonable
set will be calculated.
n : int, optional
Number of frequency points to compute if `w` is not given. The `n`
frequencies are logarithmically spaced in an interval chosen to
include the influence of the poles and zeros of the system.

Returns
-------
w : 1D ndarray
Frequency array [rad/time_unit]
mag : 1D ndarray
Magnitude array [dB]
phase : 1D ndarray
Phase array [deg]

Notes
-----
If (num, den) is passed in for ``system``, coefficients for both the
numerator and denominator should be specified in descending exponent
order (e.g. ``z^2 + 3z + 5`` would be represented as ``[1, 3, 5]``).

.. versionadded:: 0.18.0

Examples
--------
&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt

Construct the transfer function :math:`H(z) = \frac{1}{z^2 + 2z + 3}` with
a sampling time of 0.05 seconds:

&gt;&gt;&gt; sys = signal.TransferFunction([1], [1, 2, 3], dt=0.05)

Equivalent: sys.bode()

&gt;&gt;&gt; w, mag, phase = signal.dbode(sys)

&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; plt.semilogx(w, mag)    # Bode magnitude plot
&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; plt.semilogx(w, phase)  # Bode phase plot
&gt;&gt;&gt; plt.show()
</pre> 
<p class="definition">Definition at line <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l03848">3848</a> of file <a class="el" href="../../dc/dd0/__ltisys_8py_source.html">_ltisys.py</a>.</p>

<p class="reference">References <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l03748">dfreqresp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l00450">scipy.signal._ltisys.dlti.bode()</a>.</p>

</div>
</div>
<a id="aafc2d5055e90d297dbde688307acaa5b" name="aafc2d5055e90d297dbde688307acaa5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafc2d5055e90d297dbde688307acaa5b">&#9670;&#160;</a></span>dfreqresp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._ltisys.dfreqresp </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>system</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>w</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n</em></span><span class="paramdefsep"> = </span><span class="paramdefval">10000</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>whole</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate the frequency response of a discrete-time system.

Parameters
----------
system : an instance of the `dlti` class or a tuple describing the system.
    The following gives the number of elements in the tuple and
    the interpretation:

        * 1 (instance of `dlti`)
        * 2 (numerator, denominator, dt)
        * 3 (zeros, poles, gain, dt)
        * 4 (A, B, C, D, dt)

w : array_like, optional
    Array of frequencies (in radians/sample). Magnitude and phase data is
    calculated for every value in this array. If not given a reasonable
    set will be calculated.
n : int, optional
    Number of frequency points to compute if `w` is not given. The `n`
    frequencies are logarithmically spaced in an interval chosen to
    include the influence of the poles and zeros of the system.
whole : bool, optional
    Normally, if 'w' is not given, frequencies are computed from 0 to the
    Nyquist frequency, pi radians/sample (upper-half of unit-circle). If
    `whole` is True, compute frequencies from 0 to 2*pi radians/sample.

Returns
-------
w : 1D ndarray
    Frequency array [radians/sample]
H : 1D ndarray
    Array of complex magnitude values

Notes
-----
If (num, den) is passed in for ``system``, coefficients for both the
numerator and denominator should be specified in descending exponent
order (e.g. ``z^2 + 3z + 5`` would be represented as ``[1, 3, 5]``).

.. versionadded:: 0.18.0

Examples
--------
Generating the Nyquist plot of a transfer function

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt

Construct the transfer function
:math:`H(z) = \frac{1}{z^2 + 2z + 3}` with a sampling time of 0.05
seconds:

&gt;&gt;&gt; sys = signal.TransferFunction([1], [1, 2, 3], dt=0.05)

&gt;&gt;&gt; w, H = signal.dfreqresp(sys)

&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; plt.plot(H.real, H.imag, "b")
&gt;&gt;&gt; plt.plot(H.real, -H.imag, "r")
&gt;&gt;&gt; plt.show()
</pre> 
<p class="definition">Definition at line <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l03748">3748</a> of file <a class="el" href="../../dc/dd0/__ltisys_8py_source.html">_ltisys.py</a>.</p>

<p class="reference">References <a class="el" href="../../d7/d4f/__filter__design_8py_source.html#l00277">scipy.signal._filter_design.freqz()</a>, and <a class="el" href="../../d7/d4f/__filter__design_8py_source.html#l00491">scipy.signal._filter_design.freqz_zpk()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l03848">dbode()</a>, and <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l00480">scipy.signal._ltisys.dlti.freqresp()</a>.</p>

</div>
</div>
<a id="a7232a366e580be2067d3bc8340c639f2" name="a7232a366e580be2067d3bc8340c639f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7232a366e580be2067d3bc8340c639f2">&#9670;&#160;</a></span>dimpulse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._ltisys.dimpulse </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>system</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>x0</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>t</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Impulse response of discrete-time system.

Parameters
----------
system : tuple of array_like or instance of `dlti`
    A tuple describing the system.
    The following gives the number of elements in the tuple and
    the interpretation:

        * 1: (instance of `dlti`)
        * 3: (num, den, dt)
        * 4: (zeros, poles, gain, dt)
        * 5: (A, B, C, D, dt)

x0 : array_like, optional
    Initial state-vector.  Defaults to zero.
t : array_like, optional
    Time points.  Computed if not given.
n : int, optional
    The number of time points to compute (if `t` is not given).

Returns
-------
tout : ndarray
    Time values for the output, as a 1-D array.
yout : tuple of ndarray
    Impulse response of system.  Each element of the tuple represents
    the output of the system based on an impulse in each input.

See Also
--------
impulse, dstep, dlsim, cont2discrete

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; butter = signal.dlti(*signal.butter(3, 0.5))
&gt;&gt;&gt; t, y = signal.dimpulse(butter, n=25)
&gt;&gt;&gt; plt.step(t, np.squeeze(y))
&gt;&gt;&gt; plt.grid()
&gt;&gt;&gt; plt.xlabel('n [samples]')
&gt;&gt;&gt; plt.ylabel('Amplitude')
</pre> 
<p class="definition">Definition at line <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l03575">3575</a> of file <a class="el" href="../../dc/dd0/__ltisys_8py_source.html">_ltisys.py</a>.</p>

<p class="reference">References <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l03458">dlsim()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l00429">scipy.signal._ltisys.dlti.impulse()</a>.</p>

</div>
</div>
<a id="a5aab993a41192c63bde62a840751cdd9" name="a5aab993a41192c63bde62a840751cdd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aab993a41192c63bde62a840751cdd9">&#9670;&#160;</a></span>dlsim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._ltisys.dlsim </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>system</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>t</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>x0</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Simulate output of a discrete-time linear system.

Parameters
----------
system : tuple of array_like or instance of `dlti`
    A tuple describing the system.
    The following gives the number of elements in the tuple and
    the interpretation:

        * 1: (instance of `dlti`)
        * 3: (num, den, dt)
        * 4: (zeros, poles, gain, dt)
        * 5: (A, B, C, D, dt)

u : array_like
    An input array describing the input at each time `t` (interpolation is
    assumed between given times).  If there are multiple inputs, then each
    column of the rank-2 array represents an input.
t : array_like, optional
    The time steps at which the input is defined.  If `t` is given, it
    must be the same length as `u`, and the final value in `t` determines
    the number of steps returned in the output.
x0 : array_like, optional
    The initial conditions on the state vector (zero by default).

Returns
-------
tout : ndarray
    Time values for the output, as a 1-D array.
yout : ndarray
    System response, as a 1-D array.
xout : ndarray, optional
    Time-evolution of the state-vector.  Only generated if the input is a
    `StateSpace` system.

See Also
--------
lsim, dstep, dimpulse, cont2discrete

Examples
--------
A simple integrator transfer function with a discrete time step of 1.0
could be implemented as:

&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; tf = ([1.0,], [1.0, -1.0], 1.0)
&gt;&gt;&gt; t_in = [0.0, 1.0, 2.0, 3.0]
&gt;&gt;&gt; u = np.asarray([0.0, 0.0, 1.0, 1.0])
&gt;&gt;&gt; t_out, y = signal.dlsim(tf, u, t=t_in)
&gt;&gt;&gt; y.T
array([[ 0.,  0.,  0.,  1.]])
</pre> 
<p class="definition">Definition at line <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l03458">3458</a> of file <a class="el" href="../../dc/dd0/__ltisys_8py_source.html">_ltisys.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l03575">dimpulse()</a>, <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l03662">dstep()</a>, <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l00443">scipy.signal._ltisys.dlti.output()</a>, and <a class="el" href="../../dd/de5/test__cont2discrete_8py_source.html#l00276">scipy.signal.tests.test_cont2discrete.TestC2D.test_discrete_approx()</a>.</p>

</div>
</div>
<a id="a1106cc5e8301c0883b141e59dbf53cf8" name="a1106cc5e8301c0883b141e59dbf53cf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1106cc5e8301c0883b141e59dbf53cf8">&#9670;&#160;</a></span>dstep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._ltisys.dstep </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>system</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>x0</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>t</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Step response of discrete-time system.

Parameters
----------
system : tuple of array_like
    A tuple describing the system.
    The following gives the number of elements in the tuple and
    the interpretation:

        * 1: (instance of `dlti`)
        * 3: (num, den, dt)
        * 4: (zeros, poles, gain, dt)
        * 5: (A, B, C, D, dt)

x0 : array_like, optional
    Initial state-vector.  Defaults to zero.
t : array_like, optional
    Time points.  Computed if not given.
n : int, optional
    The number of time points to compute (if `t` is not given).

Returns
-------
tout : ndarray
    Output time points, as a 1-D array.
yout : tuple of ndarray
    Step response of system.  Each element of the tuple represents
    the output of the system based on a step response to each input.

See Also
--------
step, dimpulse, dlsim, cont2discrete

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; butter = signal.dlti(*signal.butter(3, 0.5))
&gt;&gt;&gt; t, y = signal.dstep(butter, n=25)
&gt;&gt;&gt; plt.step(t, np.squeeze(y))
&gt;&gt;&gt; plt.grid()
&gt;&gt;&gt; plt.xlabel('n [samples]')
&gt;&gt;&gt; plt.ylabel('Amplitude')
</pre> 
<p class="definition">Definition at line <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l03662">3662</a> of file <a class="el" href="../../dc/dd0/__ltisys_8py_source.html">_ltisys.py</a>.</p>

<p class="reference">References <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l03458">dlsim()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l00436">scipy.signal._ltisys.dlti.step()</a>.</p>

</div>
</div>
<a id="a5224b7e7920b072f5a40d9776f9687f5" name="a5224b7e7920b072f5a40d9776f9687f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5224b7e7920b072f5a40d9776f9687f5">&#9670;&#160;</a></span>freqresp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._ltisys.freqresp </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>system</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>w</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n</em></span><span class="paramdefsep"> = </span><span class="paramdefval">10000</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate the frequency response of a continuous-time system.

Parameters
----------
system : an instance of the `lti` class or a tuple describing the system.
    The following gives the number of elements in the tuple and
    the interpretation:

        * 1 (instance of `lti`)
        * 2 (num, den)
        * 3 (zeros, poles, gain)
        * 4 (A, B, C, D)

w : array_like, optional
    Array of frequencies (in rad/s). Magnitude and phase data is
    calculated for every value in this array. If not given, a reasonable
    set will be calculated.
n : int, optional
    Number of frequency points to compute if `w` is not given. The `n`
    frequencies are logarithmically spaced in an interval chosen to
    include the influence of the poles and zeros of the system.

Returns
-------
w : 1D ndarray
    Frequency array [rad/s]
H : 1D ndarray
    Array of complex magnitude values

Notes
-----
If (num, den) is passed in for ``system``, coefficients for both the
numerator and denominator should be specified in descending exponent
order (e.g. ``s^2 + 3s + 5`` would be represented as ``[1, 3, 5]``).

Examples
--------
Generating the Nyquist plot of a transfer function

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt

Construct the transfer function :math:`H(s) = \frac{5}{(s-1)^3}`:

&gt;&gt;&gt; s1 = signal.ZerosPolesGain([], [1, 1, 1], [5])

&gt;&gt;&gt; w, H = signal.freqresp(s1)

&gt;&gt;&gt; plt.figure()
&gt;&gt;&gt; plt.plot(H.real, H.imag, "b")
&gt;&gt;&gt; plt.plot(H.real, -H.imag, "r")
&gt;&gt;&gt; plt.show()
</pre> 
<p class="definition">Definition at line <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l02632">2632</a> of file <a class="el" href="../../dc/dd0/__ltisys_8py_source.html">_ltisys.py</a>.</p>

<p class="reference">References <a class="el" href="../../d7/d4f/__filter__design_8py_source.html#l00119">scipy.signal._filter_design.freqs()</a>, and <a class="el" href="../../d7/d4f/__filter__design_8py_source.html#l00196">scipy.signal._filter_design.freqs_zpk()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l02568">bode()</a>.</p>

</div>
</div>
<a id="a09e8d379f94d78becbd5dd16b97734ec" name="a09e8d379f94d78becbd5dd16b97734ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09e8d379f94d78becbd5dd16b97734ec">&#9670;&#160;</a></span>impulse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._ltisys.impulse </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>system</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>X0</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>T</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>N</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Impulse response of continuous-time system.

Parameters
----------
system : an instance of the LTI class or a tuple of array_like
    describing the system.
    The following gives the number of elements in the tuple and
    the interpretation:

        * 1 (instance of `lti`)
        * 2 (num, den)
        * 3 (zeros, poles, gain)
        * 4 (A, B, C, D)

X0 : array_like, optional
    Initial state-vector.  Defaults to zero.
T : array_like, optional
    Time points.  Computed if not given.
N : int, optional
    The number of time points to compute (if `T` is not given).

Returns
-------
T : ndarray
    A 1-D array of time points.
yout : ndarray
    A 1-D array containing the impulse response of the system (except for
    singularities at zero).

Notes
-----
If (num, den) is passed in for ``system``, coefficients for both the
numerator and denominator should be specified in descending exponent
order (e.g. ``s^2 + 3s + 5`` would be represented as ``[1, 3, 5]``).

Examples
--------
Compute the impulse response of a second order system with a repeated
root: ``x''(t) + 2*x'(t) + x(t) = u(t)``

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; system = ([1.0], [1.0, 2.0, 1.0])
&gt;&gt;&gt; t, y = signal.impulse(system)
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; plt.plot(t, y)
</pre> 
<p class="definition">Definition at line <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l02220">2220</a> of file <a class="el" href="../../dc/dd0/__ltisys_8py_source.html">_ltisys.py</a>.</p>

<p class="reference">References <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l02188">_default_response_times()</a>, and <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l01973">lsim()</a>.</p>

</div>
</div>
<a id="ae26f9ff8dfac66c8fb42c282fb27d9da" name="ae26f9ff8dfac66c8fb42c282fb27d9da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae26f9ff8dfac66c8fb42c282fb27d9da">&#9670;&#160;</a></span>impulse2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._ltisys.impulse2 </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>system</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>X0</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>T</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>N</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**</td>          <td class="paramname"><span class="paramname"><em>kwargs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Impulse response of a single-input, continuous-time linear system.

.. deprecated:: 1.11.0
    Function `impulse2` is deprecated in favor of the faster `impulse`
    function. `impulse2` will be removed in SciPy 1.13.

Parameters
----------
system : an instance of the LTI class or a tuple of array_like
    describing the system.
    The following gives the number of elements in the tuple and
    the interpretation:

        * 1 (instance of `lti`)
        * 2 (num, den)
        * 3 (zeros, poles, gain)
        * 4 (A, B, C, D)

X0 : 1-D array_like, optional
    The initial condition of the state vector.  Default: 0 (the
    zero vector).
T : 1-D array_like, optional
    The time steps at which the input is defined and at which the
    output is desired.  If `T` is not given, the function will
    generate a set of time samples automatically.
N : int, optional
    Number of time points to compute.  Default: 100.
kwargs : various types
    Additional keyword arguments are passed on to the function
    `scipy.signal.lsim2`, which in turn passes them on to
    `scipy.integrate.odeint`; see the latter's documentation for
    information about these arguments.

Returns
-------
T : ndarray
    The time values for the output.
yout : ndarray
    The output response of the system.

See Also
--------
impulse, lsim2, scipy.integrate.odeint

Notes
-----
The solution is generated by calling `scipy.signal.lsim2`, which uses
the differential equation solver `scipy.integrate.odeint`.

As `impulse2` is now deprecated, users are advised to switch to the faster
and more accurate `impulse` function. Keyword arguments for
`scipy.integrate.odeint` are not supported in `impulse`, but not needed in
general.

If (num, den) is passed in for ``system``, coefficients for both the
numerator and denominator should be specified in descending exponent
order (e.g. ``s^2 + 3s + 5`` would be represented as ``[1, 3, 5]``).

.. versionadded:: 0.8.0

Examples
--------
Compute the impulse response of a second order system with a repeated
root: ``x''(t) + 2*x'(t) + x(t) = u(t)``

&gt;&gt;&gt; from scipy import signal

&gt;&gt;&gt; system = ([1.0], [1.0, 2.0, 1.0])

&gt;&gt;&gt; t, y = signal.impulse2(system)
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; plt.plot(t, y)
</pre> 
<p class="definition">Definition at line <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l02290">2290</a> of file <a class="el" href="../../dc/dd0/__ltisys_8py_source.html">_ltisys.py</a>.</p>

<p class="reference">References <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l02188">_default_response_times()</a>, and <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l01768">lsim2()</a>.</p>

</div>
</div>
<a id="ad81706d4397767b146b651c5cebc2fd2" name="ad81706d4397767b146b651c5cebc2fd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad81706d4397767b146b651c5cebc2fd2">&#9670;&#160;</a></span>lsim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._ltisys.lsim </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>system</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>U</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>T</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>X0</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>interp</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d8/d0b/classTrue.html">True</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Simulate output of a continuous-time linear system.

Parameters
----------
system : an instance of the LTI class or a tuple describing the system.
    The following gives the number of elements in the tuple and
    the interpretation:

    * 1: (instance of `lti`)
    * 2: (num, den)
    * 3: (zeros, poles, gain)
    * 4: (A, B, C, D)

U : array_like
    An input array describing the input at each time `T`
    (interpolation is assumed between given times).  If there are
    multiple inputs, then each column of the rank-2 array
    represents an input.  If U = 0 or None, a zero input is used.
T : array_like
    The time steps at which the input is defined and at which the
    output is desired.  Must be nonnegative, increasing, and equally spaced.
X0 : array_like, optional
    The initial conditions on the state vector (zero by default).
interp : bool, optional
    Whether to use linear (True, the default) or zero-order-hold (False)
    interpolation for the input array.

Returns
-------
T : 1D ndarray
    Time values for the output.
yout : 1D ndarray
    System response.
xout : ndarray
    Time evolution of the state vector.

Notes
-----
If (num, den) is passed in for ``system``, coefficients for both the
numerator and denominator should be specified in descending exponent
order (e.g. ``s^2 + 3s + 5`` would be represented as ``[1, 3, 5]``).

Examples
--------
We'll use `lsim` to simulate an analog Bessel filter applied to
a signal.

&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy.signal import bessel, lsim
&gt;&gt;&gt; import matplotlib.pyplot as plt

Create a low-pass Bessel filter with a cutoff of 12 Hz.

&gt;&gt;&gt; b, a = bessel(N=5, Wn=2*np.pi*12, btype='lowpass', analog=True)

Generate data to which the filter is applied.

&gt;&gt;&gt; t = np.linspace(0, 1.25, 500, endpoint=False)

The input signal is the sum of three sinusoidal curves, with
frequencies 4 Hz, 40 Hz, and 80 Hz.  The filter should mostly
eliminate the 40 Hz and 80 Hz components, leaving just the 4 Hz signal.

&gt;&gt;&gt; u = (np.cos(2*np.pi*4*t) + 0.6*np.sin(2*np.pi*40*t) +
...      0.5*np.cos(2*np.pi*80*t))

Simulate the filter with `lsim`.

&gt;&gt;&gt; tout, yout, xout = lsim((b, a), U=u, T=t)

Plot the result.

&gt;&gt;&gt; plt.plot(t, u, 'r', alpha=0.5, linewidth=1, label='input')
&gt;&gt;&gt; plt.plot(tout, yout, 'k', linewidth=1.5, label='output')
&gt;&gt;&gt; plt.legend(loc='best', shadow=True, framealpha=1)
&gt;&gt;&gt; plt.grid(alpha=0.3)
&gt;&gt;&gt; plt.xlabel('t')
&gt;&gt;&gt; plt.show()

In a second example, we simulate a double integrator ``y'' = u``, with
a constant input ``u = 1``.  We'll use the state space representation
of the integrator.

&gt;&gt;&gt; from scipy.signal import lti
&gt;&gt;&gt; A = np.array([[0.0, 1.0], [0.0, 0.0]])
&gt;&gt;&gt; B = np.array([[0.0], [1.0]])
&gt;&gt;&gt; C = np.array([[1.0, 0.0]])
&gt;&gt;&gt; D = 0.0
&gt;&gt;&gt; system = lti(A, B, C, D)

`t` and `u` define the time and input signal for the system to
be simulated.

&gt;&gt;&gt; t = np.linspace(0, 5, num=50)
&gt;&gt;&gt; u = np.ones_like(t)

Compute the simulation, and then plot `y`.  As expected, the plot shows
the curve ``y = 0.5*t**2``.

&gt;&gt;&gt; tout, y, x = lsim(system, u, t)
&gt;&gt;&gt; plt.plot(t, y)
&gt;&gt;&gt; plt.grid(alpha=0.3)
&gt;&gt;&gt; plt.xlabel('t')
&gt;&gt;&gt; plt.show()
</pre> 
<p class="definition">Definition at line <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l01973">1973</a> of file <a class="el" href="../../dc/dd0/__ltisys_8py_source.html">_ltisys.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l02220">impulse()</a>, <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l00247">scipy.signal._ltisys.lti.output()</a>, <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l02400">step()</a>, and <a class="el" href="../../dd/de5/test__cont2discrete_8py_source.html#l00276">scipy.signal.tests.test_cont2discrete.TestC2D.test_discrete_approx()</a>.</p>

</div>
</div>
<a id="a43193c10de2bb05be9d1c60fbcf2f764" name="a43193c10de2bb05be9d1c60fbcf2f764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43193c10de2bb05be9d1c60fbcf2f764">&#9670;&#160;</a></span>lsim2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._ltisys.lsim2 </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>system</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>U</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>T</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>X0</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**</td>          <td class="paramname"><span class="paramname"><em>kwargs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Simulate output of a continuous-time linear system, by using
the ODE solver `scipy.integrate.odeint`.

.. deprecated:: 1.11.0
    Function `lsim2` is deprecated in favor of the faster `lsim` function.
    `lsim2` will be removed in SciPy 1.13.

Parameters
----------
system : an instance of the `lti` class or a tuple describing the system.
    The following gives the number of elements in the tuple and
    the interpretation:

    * 1: (instance of `lti`)
    * 2: (num, den)
    * 3: (zeros, poles, gain)
    * 4: (A, B, C, D)

U : array_like (1D or 2D), optional
    An input array describing the input at each time T.  Linear
    interpolation is used between given times.  If there are
    multiple inputs, then each column of the rank-2 array
    represents an input.  If U is not given, the input is assumed
    to be zero.
T : array_like (1D or 2D), optional
    The time steps at which the input is defined and at which the
    output is desired.  The default is 101 evenly spaced points on
    the interval [0,10.0].
X0 : array_like (1D), optional
    The initial condition of the state vector.  If `X0` is not
    given, the initial conditions are assumed to be 0.
kwargs : dict
    Additional keyword arguments are passed on to the function
    `odeint`.  See the notes below for more details.

Returns
-------
T : 1D ndarray
    The time values for the output.
yout : ndarray
    The response of the system.
xout : ndarray
    The time-evolution of the state-vector.

See Also
--------
lsim

Notes
-----
This function uses `scipy.integrate.odeint` to solve the system's
differential equations.  Additional keyword arguments given to `lsim2`
are passed on to `scipy.integrate.odeint`.  See the documentation
for `scipy.integrate.odeint` for the full list of arguments.

As `lsim2` is now deprecated, users are advised to switch to the faster
and more accurate `lsim` function. Keyword arguments for
`scipy.integrate.odeint` are not supported in `lsim`, but not needed in
general.

If (num, den) is passed in for ``system``, coefficients for both the
numerator and denominator should be specified in descending exponent
order (e.g. ``s^2 + 3s + 5`` would be represented as ``[1, 3, 5]``).

Examples
--------
We'll use `lsim2` to simulate an analog Bessel filter applied to
a signal.

&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy.signal import bessel, lsim2
&gt;&gt;&gt; import matplotlib.pyplot as plt

Create a low-pass Bessel filter with a cutoff of 12 Hz.

&gt;&gt;&gt; b, a = bessel(N=5, Wn=2*np.pi*12, btype='lowpass', analog=True)

Generate data to which the filter is applied.

&gt;&gt;&gt; t = np.linspace(0, 1.25, 500, endpoint=False)

The input signal is the sum of three sinusoidal curves, with
frequencies 4 Hz, 40 Hz, and 80 Hz.  The filter should mostly
eliminate the 40 Hz and 80 Hz components, leaving just the 4 Hz signal.

&gt;&gt;&gt; u = (np.cos(2*np.pi*4*t) + 0.6*np.sin(2*np.pi*40*t) +
...      0.5*np.cos(2*np.pi*80*t))

Simulate the filter with `lsim2`.

&gt;&gt;&gt; tout, yout, xout = lsim2((b, a), U=u, T=t)

Plot the result.

&gt;&gt;&gt; plt.plot(t, u, 'r', alpha=0.5, linewidth=1, label='input')
&gt;&gt;&gt; plt.plot(tout, yout, 'k', linewidth=1.5, label='output')
&gt;&gt;&gt; plt.legend(loc='best', shadow=True, framealpha=1)
&gt;&gt;&gt; plt.grid(alpha=0.3)
&gt;&gt;&gt; plt.xlabel('t')
&gt;&gt;&gt; plt.show()

In a second example, we simulate a double integrator ``y'' = u``, with
a constant input ``u = 1``.  We'll use the state space representation
of the integrator.

&gt;&gt;&gt; from scipy.signal import lti
&gt;&gt;&gt; A = np.array([[0, 1], [0, 0]])
&gt;&gt;&gt; B = np.array([[0], [1]])
&gt;&gt;&gt; C = np.array([[1, 0]])
&gt;&gt;&gt; D = 0
&gt;&gt;&gt; system = lti(A, B, C, D)

`t` and `u` define the time and input signal for the system to
be simulated.

&gt;&gt;&gt; t = np.linspace(0, 5, num=50)
&gt;&gt;&gt; u = np.ones_like(t)

Compute the simulation, and then plot `y`.  As expected, the plot shows
the curve ``y = 0.5*t**2``.

&gt;&gt;&gt; tout, y, x = lsim2(system, u, t)
&gt;&gt;&gt; plt.plot(t, y)
&gt;&gt;&gt; plt.grid(alpha=0.3)
&gt;&gt;&gt; plt.xlabel('t')
&gt;&gt;&gt; plt.show()
</pre> 
<p class="definition">Definition at line <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l01768">1768</a> of file <a class="el" href="../../dc/dd0/__ltisys_8py_source.html">_ltisys.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l02290">impulse2()</a>, and <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l02467">step2()</a>.</p>

</div>
</div>
<a id="a028e75567f2c624a3c1434b630817736" name="a028e75567f2c624a3c1434b630817736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a028e75567f2c624a3c1434b630817736">&#9670;&#160;</a></span>place_poles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._ltisys.place_poles </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>poles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>method</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;YT&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>rtol</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1e-3</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>maxiter</em></span><span class="paramdefsep"> = </span><span class="paramdefval">30</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute K such that eigenvalues (A - dot(B, K))=poles.

K is the gain matrix such as the plant described by the linear system
``AX+BU`` will have its closed-loop poles, i.e the eigenvalues ``A - B*K``,
as close as possible to those asked for in poles.

SISO, MISO and MIMO systems are supported.

Parameters
----------
A, B : ndarray
    State-space representation of linear system ``AX + BU``.
poles : array_like
    Desired real poles and/or complex conjugates poles.
    Complex poles are only supported with ``method="YT"`` (default).
method: {'YT', 'KNV0'}, optional
    Which method to choose to find the gain matrix K. One of:

        - 'YT': Yang Tits
        - 'KNV0': Kautsky, Nichols, Van Dooren update method 0

    See References and Notes for details on the algorithms.
rtol: float, optional
    After each iteration the determinant of the eigenvectors of
    ``A - B*K`` is compared to its previous value, when the relative
    error between these two values becomes lower than `rtol` the algorithm
    stops.  Default is 1e-3.
maxiter: int, optional
    Maximum number of iterations to compute the gain matrix.
    Default is 30.

Returns
-------
full_state_feedback : Bunch object
    full_state_feedback is composed of:
        gain_matrix : 1-D ndarray
            The closed loop matrix K such as the eigenvalues of ``A-BK``
            are as close as possible to the requested poles.
        computed_poles : 1-D ndarray
            The poles corresponding to ``A-BK`` sorted as first the real
            poles in increasing order, then the complex congugates in
            lexicographic order.
        requested_poles : 1-D ndarray
            The poles the algorithm was asked to place sorted as above,
            they may differ from what was achieved.
        X : 2-D ndarray
            The transfer matrix such as ``X * diag(poles) = (A - B*K)*X``
            (see Notes)
        rtol : float
            The relative tolerance achieved on ``det(X)`` (see Notes).
            `rtol` will be NaN if it is possible to solve the system
            ``diag(poles) = (A - B*K)``, or 0 when the optimization
            algorithms can't do anything i.e when ``B.shape[1] == 1``.
        nb_iter : int
            The number of iterations performed before converging.
            `nb_iter` will be NaN if it is possible to solve the system
            ``diag(poles) = (A - B*K)``, or 0 when the optimization
            algorithms can't do anything i.e when ``B.shape[1] == 1``.

Notes
-----
The Tits and Yang (YT), [2]_ paper is an update of the original Kautsky et
al. (KNV) paper [1]_.  KNV relies on rank-1 updates to find the transfer
matrix X such that ``X * diag(poles) = (A - B*K)*X``, whereas YT uses
rank-2 updates. This yields on average more robust solutions (see [2]_
pp 21-22), furthermore the YT algorithm supports complex poles whereas KNV
does not in its original version.  Only update method 0 proposed by KNV has
been implemented here, hence the name ``'KNV0'``.

KNV extended to complex poles is used in Matlab's ``place`` function, YT is
distributed under a non-free licence by Slicot under the name ``robpole``.
It is unclear and undocumented how KNV0 has been extended to complex poles
(Tits and Yang claim on page 14 of their paper that their method can not be
used to extend KNV to complex poles), therefore only YT supports them in
this implementation.

As the solution to the problem of pole placement is not unique for MIMO
systems, both methods start with a tentative transfer matrix which is
altered in various way to increase its determinant.  Both methods have been
proven to converge to a stable solution, however depending on the way the
initial transfer matrix is chosen they will converge to different
solutions and therefore there is absolutely no guarantee that using
``'KNV0'`` will yield results similar to Matlab's or any other
implementation of these algorithms.

Using the default method ``'YT'`` should be fine in most cases; ``'KNV0'``
is only provided because it is needed by ``'YT'`` in some specific cases.
Furthermore ``'YT'`` gives on average more robust results than ``'KNV0'``
when ``abs(det(X))`` is used as a robustness indicator.

[2]_ is available as a technical report on the following URL:
https://hdl.handle.net/1903/5598

References
----------
.. [1] J. Kautsky, N.K. Nichols and P. van Dooren, "Robust pole assignment
       in linear state feedback", International Journal of Control, Vol. 41
       pp. 1129-1155, 1985.
.. [2] A.L. Tits and Y. Yang, "Globally convergent algorithms for robust
       pole assignment by state feedback", IEEE Transactions on Automatic
       Control, Vol. 41, pp. 1432-1452, 1996.

Examples
--------
A simple example demonstrating real pole placement using both KNV and YT
algorithms.  This is example number 1 from section 4 of the reference KNV
publication ([1]_):

&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; A = np.array([[ 1.380,  -0.2077,  6.715, -5.676  ],
...               [-0.5814, -4.290,   0,      0.6750 ],
...               [ 1.067,   4.273,  -6.654,  5.893  ],
...               [ 0.0480,  4.273,   1.343, -2.104  ]])
&gt;&gt;&gt; B = np.array([[ 0,      5.679 ],
...               [ 1.136,  1.136 ],
...               [ 0,      0,    ],
...               [-3.146,  0     ]])
&gt;&gt;&gt; P = np.array([-0.2, -0.5, -5.0566, -8.6659])

Now compute K with KNV method 0, with the default YT method and with the YT
method while forcing 100 iterations of the algorithm and print some results
after each call.

&gt;&gt;&gt; fsf1 = signal.place_poles(A, B, P, method='KNV0')
&gt;&gt;&gt; fsf1.gain_matrix
array([[ 0.20071427, -0.96665799,  0.24066128, -0.10279785],
       [ 0.50587268,  0.57779091,  0.51795763, -0.41991442]])

&gt;&gt;&gt; fsf2 = signal.place_poles(A, B, P)  # uses YT method
&gt;&gt;&gt; fsf2.computed_poles
array([-8.6659, -5.0566, -0.5   , -0.2   ])

&gt;&gt;&gt; fsf3 = signal.place_poles(A, B, P, rtol=-1, maxiter=100)
&gt;&gt;&gt; fsf3.X
array([[ 0.52072442+0.j, -0.08409372+0.j, -0.56847937+0.j,  0.74823657+0.j],
       [-0.04977751+0.j, -0.80872954+0.j,  0.13566234+0.j, -0.29322906+0.j],
       [-0.82266932+0.j, -0.19168026+0.j, -0.56348322+0.j, -0.43815060+0.j],
       [ 0.22267347+0.j,  0.54967577+0.j, -0.58387806+0.j, -0.40271926+0.j]])

The absolute value of the determinant of X is a good indicator to check the
robustness of the results, both ``'KNV0'`` and ``'YT'`` aim at maximizing
it.  Below a comparison of the robustness of the results above:

&gt;&gt;&gt; abs(np.linalg.det(fsf1.X)) &lt; abs(np.linalg.det(fsf2.X))
True
&gt;&gt;&gt; abs(np.linalg.det(fsf2.X)) &lt; abs(np.linalg.det(fsf3.X))
True

Now a simple example for complex poles:

&gt;&gt;&gt; A = np.array([[ 0,  7/3.,  0,   0   ],
...               [ 0,   0,    0,  7/9. ],
...               [ 0,   0,    0,   0   ],
...               [ 0,   0,    0,   0   ]])
&gt;&gt;&gt; B = np.array([[ 0,  0 ],
...               [ 0,  0 ],
...               [ 1,  0 ],
...               [ 0,  1 ]])
&gt;&gt;&gt; P = np.array([-3, -1, -2-1j, -2+1j]) / 3.
&gt;&gt;&gt; fsf = signal.place_poles(A, B, P, method='YT')

We can plot the desired and computed poles in the complex plane:

&gt;&gt;&gt; t = np.linspace(0, 2*np.pi, 401)
&gt;&gt;&gt; plt.plot(np.cos(t), np.sin(t), 'k--')  # unit circle
&gt;&gt;&gt; plt.plot(fsf.requested_poles.real, fsf.requested_poles.imag,
...          'wo', label='Desired')
&gt;&gt;&gt; plt.plot(fsf.computed_poles.real, fsf.computed_poles.imag, 'bx',
...          label='Placed')
&gt;&gt;&gt; plt.grid()
&gt;&gt;&gt; plt.axis('image')
&gt;&gt;&gt; plt.axis([-1.1, 1.1, -1.1, 1.1])
&gt;&gt;&gt; plt.legend(bbox_to_anchor=(1.05, 1), loc=2, numpoints=1)
</pre> 
<p class="definition">Definition at line <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l03107">3107</a> of file <a class="el" href="../../dc/dd0/__ltisys_8py_source.html">_ltisys.py</a>.</p>

<p class="reference">References <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l02775">_order_complex_poles()</a>, and <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l02724">_valid_inputs()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d9/dc9/test__ltisys_8py_source.html#l00041">scipy.signal.tests.test_ltisys.TestPlacePoles._check()</a>.</p>

</div>
</div>
<a id="a531d2c4ab049182357f13971cf8e58e5" name="a531d2c4ab049182357f13971cf8e58e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a531d2c4ab049182357f13971cf8e58e5">&#9670;&#160;</a></span>step()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._ltisys.step </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>system</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>X0</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>T</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>N</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Step response of continuous-time system.

Parameters
----------
system : an instance of the LTI class or a tuple of array_like
    describing the system.
    The following gives the number of elements in the tuple and
    the interpretation:

        * 1 (instance of `lti`)
        * 2 (num, den)
        * 3 (zeros, poles, gain)
        * 4 (A, B, C, D)

X0 : array_like, optional
    Initial state-vector (default is zero).
T : array_like, optional
    Time points (computed if not given).
N : int, optional
    Number of time points to compute if `T` is not given.

Returns
-------
T : 1D ndarray
    Output time points.
yout : 1D ndarray
    Step response of system.


Notes
-----
If (num, den) is passed in for ``system``, coefficients for both the
numerator and denominator should be specified in descending exponent
order (e.g. ``s^2 + 3s + 5`` would be represented as ``[1, 3, 5]``).

Examples
--------
&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; lti = signal.lti([1.0], [1.0, 1.0])
&gt;&gt;&gt; t, y = signal.step(lti)
&gt;&gt;&gt; plt.plot(t, y)
&gt;&gt;&gt; plt.xlabel('Time [s]')
&gt;&gt;&gt; plt.ylabel('Amplitude')
&gt;&gt;&gt; plt.title('Step response for 1. Order Lowpass')
&gt;&gt;&gt; plt.grid()
</pre> 
<p class="definition">Definition at line <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l02400">2400</a> of file <a class="el" href="../../dc/dd0/__ltisys_8py_source.html">_ltisys.py</a>.</p>

<p class="reference">References <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l02188">_default_response_times()</a>, and <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l01973">lsim()</a>.</p>

</div>
</div>
<a id="a14d583450772b85b02f687c6b097ebe7" name="a14d583450772b85b02f687c6b097ebe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14d583450772b85b02f687c6b097ebe7">&#9670;&#160;</a></span>step2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._ltisys.step2 </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>system</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>X0</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>T</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>N</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**</td>          <td class="paramname"><span class="paramname"><em>kwargs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Step response of continuous-time system.

This function is functionally the same as `scipy.signal.step`, but
it uses the function `scipy.signal.lsim2` to compute the step
response.

.. deprecated:: 1.11.0
    Function `step2` is deprecated in favor of the faster `step` function.
    `step2` will be removed in SciPy 1.13.

Parameters
----------
system : an instance of the LTI class or a tuple of array_like
    describing the system.
    The following gives the number of elements in the tuple and
    the interpretation:

        * 1 (instance of `lti`)
        * 2 (num, den)
        * 3 (zeros, poles, gain)
        * 4 (A, B, C, D)

X0 : array_like, optional
    Initial state-vector (default is zero).
T : array_like, optional
    Time points (computed if not given).
N : int, optional
    Number of time points to compute if `T` is not given.
kwargs : various types
    Additional keyword arguments are passed on the function
    `scipy.signal.lsim2`, which in turn passes them on to
    `scipy.integrate.odeint`.  See the documentation for
    `scipy.integrate.odeint` for information about these arguments.

Returns
-------
T : 1D ndarray
    Output time points.
yout : 1D ndarray
    Step response of system.

See Also
--------
scipy.signal.step

Notes
-----
As `step2` is now deprecated, users are advised to switch to the faster
and more accurate `step` function. Keyword arguments for
`scipy.integrate.odeint` are not supported in `step`, but not needed in
general.

If (num, den) is passed in for ``system``, coefficients for both the
numerator and denominator should be specified in descending exponent
order (e.g. ``s^2 + 3s + 5`` would be represented as ``[1, 3, 5]``).

.. versionadded:: 0.8.0

Examples
--------
&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; lti = signal.lti([1.0], [1.0, 1.0])
&gt;&gt;&gt; t, y = signal.step2(lti)

&gt;&gt;&gt; plt.plot(t, y)
&gt;&gt;&gt; plt.xlabel('Time [s]')
&gt;&gt;&gt; plt.ylabel('Amplitude')
&gt;&gt;&gt; plt.title('Step response for 1. Order Lowpass')
&gt;&gt;&gt; plt.grid()
</pre> 
<p class="definition">Definition at line <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l02467">2467</a> of file <a class="el" href="../../dc/dd0/__ltisys_8py_source.html">_ltisys.py</a>.</p>

<p class="reference">References <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l02188">_default_response_times()</a>, and <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l01768">lsim2()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a1db78c7dddd07b5f30441a32780d5ced" name="a1db78c7dddd07b5f30441a32780d5ced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1db78c7dddd07b5f30441a32780d5ced">&#9670;&#160;</a></span>__all__</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">list scipy.signal._ltisys.__all__</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  [<span class="stringliteral">&#39;lti&#39;</span>, <span class="stringliteral">&#39;dlti&#39;</span>, <span class="stringliteral">&#39;TransferFunction&#39;</span>, <span class="stringliteral">&#39;ZerosPolesGain&#39;</span>, <span class="stringliteral">&#39;StateSpace&#39;</span>,</div>
<div class="line"><span class="lineno">    2</span>           <span class="stringliteral">&#39;lsim&#39;</span>, <span class="stringliteral">&#39;lsim2&#39;</span>, <span class="stringliteral">&#39;impulse&#39;</span>, <span class="stringliteral">&#39;impulse2&#39;</span>, <span class="stringliteral">&#39;step&#39;</span>, <span class="stringliteral">&#39;step2&#39;</span>, <span class="stringliteral">&#39;bode&#39;</span>,</div>
<div class="line"><span class="lineno">    3</span>           <span class="stringliteral">&#39;freqresp&#39;</span>, <span class="stringliteral">&#39;place_poles&#39;</span>, <span class="stringliteral">&#39;dlsim&#39;</span>, <span class="stringliteral">&#39;dstep&#39;</span>, <span class="stringliteral">&#39;dimpulse&#39;</span>,</div>
<div class="line"><span class="lineno">    4</span>           <span class="stringliteral">&#39;dfreqresp&#39;</span>, <span class="stringliteral">&#39;dbode&#39;</span>]</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="../../dc/dd0/__ltisys_8py_source.html#l00042">42</a> of file <a class="el" href="../../dc/dd0/__ltisys_8py_source.html">_ltisys.py</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../db/d0f/namespacescipy.html">scipy</a></li><li class="navelem"><a class="el" href="../../dd/d63/namespacescipy_1_1signal.html">signal</a></li><li class="navelem"><a class="el" href="../../d4/dc1/namespacescipy_1_1signal_1_1__ltisys.html">_ltisys</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
