<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Code Cloning Analysis: sklearn.cluster._spectral Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Code Cloning Analysis
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d4/d1f/namespacesklearn_1_1cluster_1_1__spectral.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">sklearn.cluster._spectral Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d39/classsklearn_1_1cluster_1_1__spectral_1_1SpectralClustering.html">SpectralClustering</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a29792a5e5b87373c1a30aec97aeef847" id="r_a29792a5e5b87373c1a30aec97aeef847"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a29792a5e5b87373c1a30aec97aeef847">cluster_qr</a> (vectors)</td></tr>
<tr class="separator:a29792a5e5b87373c1a30aec97aeef847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d39bb04deba6ff73a7876d738e394a" id="r_ab7d39bb04deba6ff73a7876d738e394a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7d39bb04deba6ff73a7876d738e394a">discretize</a> (vectors, *, copy=<a class="el" href="../../d8/d0b/classTrue.html">True</a>, max_svd_restarts=30, n_iter_max=20, random_state=None)</td></tr>
<tr class="separator:ab7d39bb04deba6ff73a7876d738e394a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a6207e4b3d57e9422f5bf88c71fc2c" id="r_a72a6207e4b3d57e9422f5bf88c71fc2c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72a6207e4b3d57e9422f5bf88c71fc2c">spectral_clustering</a> (affinity, *, n_clusters=8, n_components=None, eigen_solver=None, random_state=None, n_init=10, eigen_tol=&quot;auto&quot;, assign_labels=&quot;kmeans&quot;, verbose=False)</td></tr>
<tr class="separator:a72a6207e4b3d57e9422f5bf88c71fc2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Algorithms for spectral clustering</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a29792a5e5b87373c1a30aec97aeef847" name="a29792a5e5b87373c1a30aec97aeef847"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29792a5e5b87373c1a30aec97aeef847">&#9670;&#160;</a></span>cluster_qr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.cluster._spectral.cluster_qr </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>vectors</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find the discrete partition closest to the eigenvector embedding.

    This implementation was proposed in [1]_.

.. versionadded:: 1.1

    Parameters
    ----------
    vectors : array-like, shape: (n_samples, n_clusters)
        The embedding space of the samples.

    Returns
    -------
    labels : array of integers, shape: n_samples
        The cluster labels of vectors.

    References
    ----------
    .. [1] :doi:`Simple, direct, and efficient multi-way spectral clustering, 2019
        Anil Damle, Victor Minden, Lexing Ying
        &lt;10.1093/imaiai/iay008&gt;`
</pre> 
<p class="definition">Definition at line <a class="el" href="../../dd/d61/sklearn_2cluster_2__spectral_8py_source.html#l00023">23</a> of file <a class="el" href="../../dd/d61/sklearn_2cluster_2__spectral_8py_source.html">_spectral.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dd/d61/sklearn_2cluster_2__spectral_8py_source.html#l00672">sklearn.cluster._spectral.SpectralClustering.fit()</a>.</p>

</div>
</div>
<a id="ab7d39bb04deba6ff73a7876d738e394a" name="ab7d39bb04deba6ff73a7876d738e394a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7d39bb04deba6ff73a7876d738e394a">&#9670;&#160;</a></span>discretize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.cluster._spectral.discretize </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>vectors</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>copy</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d8/d0b/classTrue.html">True</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>max_svd_restarts</em></span><span class="paramdefsep"> = </span><span class="paramdefval">30</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n_iter_max</em></span><span class="paramdefsep"> = </span><span class="paramdefval">20</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>random_state</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Search for a partition matrix which is closest to the eigenvector embedding.

This implementation was proposed in [1]_.

Parameters
----------
vectors : array-like of shape (n_samples, n_clusters)
    The embedding space of the samples.

copy : bool, default=True
    Whether to copy vectors, or perform in-place normalization.

max_svd_restarts : int, default=30
    Maximum number of attempts to restart SVD if convergence fails

n_iter_max : int, default=30
    Maximum number of iterations to attempt in rotation and partition
    matrix search if machine precision convergence is not reached

random_state : int, RandomState instance, default=None
    Determines random number generation for rotation matrix initialization.
    Use an int to make the randomness deterministic.
    See :term:`Glossary &lt;random_state&gt;`.

Returns
-------
labels : array of integers, shape: n_samples
    The labels of the clusters.

References
----------

.. [1] `Multiclass spectral clustering, 2003
       Stella X. Yu, Jianbo Shi
       &lt;https://people.eecs.berkeley.edu/~jordan/courses/281B-spring04/readings/yu-shi.pdf&gt;`_

Notes
-----

The eigenvector embedding is used to iteratively search for the
closest discrete partition.  First, the eigenvector embedding is
normalized to the space of partition matrices. An optimal discrete
partition matrix closest to this normalized embedding multiplied by
an initial rotation is calculated.  Fixing this discrete partition
matrix, an optimal rotation matrix is calculated.  These two
calculations are performed until convergence.  The discrete partition
matrix is returned as the clustering solution.  Used in spectral
clustering, this method tends to be faster and more robust to random
initialization than k-means.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../dd/d61/sklearn_2cluster_2__spectral_8py_source.html#l00055">55</a> of file <a class="el" href="../../dd/d61/sklearn_2cluster_2__spectral_8py_source.html">_spectral.py</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dd/d61/sklearn_2cluster_2__spectral_8py_source.html#l00672">sklearn.cluster._spectral.SpectralClustering.fit()</a>.</p>

</div>
</div>
<a id="a72a6207e4b3d57e9422f5bf88c71fc2c" name="a72a6207e4b3d57e9422f5bf88c71fc2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72a6207e4b3d57e9422f5bf88c71fc2c">&#9670;&#160;</a></span>spectral_clustering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.cluster._spectral.spectral_clustering </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>affinity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n_clusters</em></span><span class="paramdefsep"> = </span><span class="paramdefval">8</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n_components</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>eigen_solver</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>random_state</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n_init</em></span><span class="paramdefsep"> = </span><span class="paramdefval">10</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>eigen_tol</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;auto&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>assign_labels</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;kmeans&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>verbose</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Apply clustering to a projection of the normalized Laplacian.

In practice Spectral Clustering is very useful when the structure of
the individual clusters is highly non-convex or more generally when
a measure of the center and spread of the cluster is not a suitable
description of the complete cluster. For instance, when clusters are
nested circles on the 2D plane.

If affinity is the adjacency matrix of a graph, this method can be
used to find normalized graph cuts [1]_, [2]_.

Read more in the :ref:`User Guide &lt;spectral_clustering&gt;`.

Parameters
----------
affinity : {array-like, sparse matrix} of shape (n_samples, n_samples)
    The affinity matrix describing the relationship of the samples to
    embed. **Must be symmetric**.

    Possible examples:
      - adjacency matrix of a graph,
      - heat kernel of the pairwise distance matrix of the samples,
      - symmetric k-nearest neighbours connectivity matrix of the samples.

n_clusters : int, default=None
    Number of clusters to extract.

n_components : int, default=n_clusters
    Number of eigenvectors to use for the spectral embedding.

eigen_solver : {None, 'arpack', 'lobpcg', or 'amg'}
    The eigenvalue decomposition method. If None then ``'arpack'`` is used.
    See [4]_ for more details regarding ``'lobpcg'``.
    Eigensolver ``'amg'`` runs ``'lobpcg'`` with optional
    Algebraic MultiGrid preconditioning and requires pyamg to be installed.
    It can be faster on very large sparse problems [6]_ and [7]_.

random_state : int, RandomState instance, default=None
    A pseudo random number generator used for the initialization
    of the lobpcg eigenvectors decomposition when `eigen_solver ==
    'amg'`, and for the K-Means initialization. Use an int to make
    the results deterministic across calls (See
    :term:`Glossary &lt;random_state&gt;`).

    .. note::
        When using `eigen_solver == 'amg'`,
        it is necessary to also fix the global numpy seed with
        `np.random.seed(int)` to get deterministic results. See
        https://github.com/pyamg/pyamg/issues/139 for further
        information.

n_init : int, default=10
    Number of time the k-means algorithm will be run with different
    centroid seeds. The final results will be the best output of n_init
    consecutive runs in terms of inertia. Only used if
    ``assign_labels='kmeans'``.

eigen_tol : float, default="auto"
    Stopping criterion for eigendecomposition of the Laplacian matrix.
    If `eigen_tol="auto"` then the passed tolerance will depend on the
    `eigen_solver`:

    - If `eigen_solver="arpack"`, then `eigen_tol=0.0`;
    - If `eigen_solver="lobpcg"` or `eigen_solver="amg"`, then
      `eigen_tol=None` which configures the underlying `lobpcg` solver to
      automatically resolve the value according to their heuristics. See,
      :func:`scipy.sparse.linalg.lobpcg` for details.

    Note that when using `eigen_solver="lobpcg"` or `eigen_solver="amg"`
    values of `tol&lt;1e-5` may lead to convergence issues and should be
    avoided.

    .. versionadded:: 1.2
       Added 'auto' option.

assign_labels : {'kmeans', 'discretize', 'cluster_qr'}, default='kmeans'
    The strategy to use to assign labels in the embedding
    space.  There are three ways to assign labels after the Laplacian
    embedding.  k-means can be applied and is a popular choice. But it can
    also be sensitive to initialization. Discretization is another
    approach which is less sensitive to random initialization [3]_.
    The cluster_qr method [5]_ directly extracts clusters from eigenvectors
    in spectral clustering. In contrast to k-means and discretization, cluster_qr
    has no tuning parameters and is not an iterative method, yet may outperform
    k-means and discretization in terms of both quality and speed. For a detailed
    comparison of clustering strategies, refer to the following example:
    :ref:`sphx_glr_auto_examples_cluster_plot_coin_segmentation.py`.

    .. versionchanged:: 1.1
       Added new labeling method 'cluster_qr'.

verbose : bool, default=False
    Verbosity mode.

    .. versionadded:: 0.24

Returns
-------
labels : array of integers, shape: n_samples
    The labels of the clusters.

Notes
-----
The graph should contain only one connected component, elsewhere
the results make little sense.

This algorithm solves the normalized cut for `k=2`: it is a
normalized spectral clustering.

References
----------

.. [1] :doi:`Normalized cuts and image segmentation, 2000
       Jianbo Shi, Jitendra Malik
       &lt;10.1109/34.868688&gt;`

.. [2] :doi:`A Tutorial on Spectral Clustering, 2007
       Ulrike von Luxburg
       &lt;10.1007/s11222-007-9033-z&gt;`

.. [3] `Multiclass spectral clustering, 2003
       Stella X. Yu, Jianbo Shi
       &lt;https://people.eecs.berkeley.edu/~jordan/courses/281B-spring04/readings/yu-shi.pdf&gt;`_

.. [4] :doi:`Toward the Optimal Preconditioned Eigensolver:
       Locally Optimal Block Preconditioned Conjugate Gradient Method, 2001
       A. V. Knyazev
       SIAM Journal on Scientific Computing 23, no. 2, pp. 517-541.
       &lt;10.1137/S1064827500366124&gt;`

.. [5] :doi:`Simple, direct, and efficient multi-way spectral clustering, 2019
       Anil Damle, Victor Minden, Lexing Ying
       &lt;10.1093/imaiai/iay008&gt;`

.. [6] :doi:`Multiscale Spectral Image Segmentation Multiscale preconditioning
       for computing eigenvalues of graph Laplacians in image segmentation, 2006
       Andrew Knyazev
       &lt;10.13140/RG.2.2.35280.02565&gt;`

.. [7] :doi:`Preconditioned spectral clustering for stochastic block partition
       streaming graph challenge (Preliminary version at arXiv.)
       David Zhuzhunashvili, Andrew Knyazev
       &lt;10.1109/HPEC.2017.8091045&gt;`

Examples
--------
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from sklearn.metrics.pairwise import pairwise_kernels
&gt;&gt;&gt; from sklearn.cluster import spectral_clustering
&gt;&gt;&gt; X = np.array([[1, 1], [2, 1], [1, 0],
...               [4, 7], [3, 5], [3, 6]])
&gt;&gt;&gt; affinity = pairwise_kernels(X, metric='rbf')
&gt;&gt;&gt; spectral_clustering(
...     affinity=affinity, n_clusters=2, assign_labels="discretize", random_state=0
... )
array([1, 1, 1, 0, 0, 0])
</pre> 
<p class="definition">Definition at line <a class="el" href="../../dd/d61/sklearn_2cluster_2__spectral_8py_source.html#l00194">194</a> of file <a class="el" href="../../dd/d61/sklearn_2cluster_2__spectral_8py_source.html">_spectral.py</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d6/d1d/namespacesklearn.html">sklearn</a></li><li class="navelem"><a class="el" href="../../d8/d01/namespacesklearn_1_1cluster.html">cluster</a></li><li class="navelem"><a class="el" href="../../d4/d1f/namespacesklearn_1_1cluster_1_1__spectral.html">_spectral</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
